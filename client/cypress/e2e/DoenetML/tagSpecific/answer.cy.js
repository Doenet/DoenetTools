import { cesc, cesc2 } from "../../../../src/_utils/url";

describe("Answer Tag Tests", function () {
  beforeEach(() => {
    cy.clearIndexedDB();
    cy.visit("/src/Tools/cypressTest/");
  });

  it("answer sugar from one string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer>x+y</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");

      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");

      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });

      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer sugar from one macro", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <math name="xy" hide>x+y</math>
  <p><answer>$xy</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");

      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      // wrap to change value of cesc('#\\/sr1')
      cy.window().then(async (win) => {
        cy.log("Test value displayed in browser");
        // cy.get(mathinputAnchor).should('have.value', 'x+y');
        cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
        cy.get(cesc("#\\/cr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x+y");
          });

        cy.get(cesc("#\\/sr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x+y");
          });
        cy.get(cesc("#\\/ca1")).should("have.text", "1");

        cy.log("Test internal values");
        cy.window().then(async (win) => {
          let stateVariables = await win.returnAllStateVariables1();
          expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
          expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
            [["+", "x", "y"]],
          );
          expect(
            stateVariables["/_answer1"].stateValues.submittedResponses,
          ).eqls([["+", "x", "y"]]);
          expect(stateVariables[mathinputName].stateValues.value).eqls([
            "+",
            "x",
            "y",
          ]);
          // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
        });

        cy.log("Enter wrong answer");
        cy.get(mathinputAnchor)
          .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
          .blur();

        cy.log("Test value displayed in browser");
        // cy.get(mathinputAnchor).should('have.value', 'x');
        cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
        cy.get(cesc("#\\/cr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x");
          });
        cy.get(cesc("#\\/sr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x+y");
          });
        cy.get(cesc("#\\/ca1")).should("have.text", "1");

        cy.log("Test internal values");
        cy.window().then(async (win) => {
          let stateVariables = await win.returnAllStateVariables1();
          expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
          expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
            ["x"],
          );
          expect(
            stateVariables["/_answer1"].stateValues.submittedResponses,
          ).eqls([["+", "x", "y"]]);
          expect(stateVariables[mathinputName].stateValues.value).eqls("x");
          // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
        });

        cy.log("Submit answer");
        cy.get(mathinputSubmitAnchor).click();

        cy.log("Test value displayed in browser");
        // cy.get(mathinputAnchor).should('have.value', 'x');
        cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
        cy.get(cesc("#\\/cr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x");
          });
        cy.get(cesc("#\\/sr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x");
          });
        cy.get(cesc("#\\/ca1")).should("have.text", "0");

        cy.log("Test internal values");
        cy.window().then(async (win) => {
          let stateVariables = await win.returnAllStateVariables1();
          expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
          expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
            ["x"],
          );
          expect(
            stateVariables["/_answer1"].stateValues.submittedResponses,
          ).eqls(["x"]);
          expect(stateVariables[mathinputName].stateValues.value).eqls("x");
          // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
        });
      });
    });
  });

  it("answer sugar from one math", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><math>x+y</math></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");

      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      // wrap to change value of cesc('#\\/sr1')
      cy.window().then(async (win) => {
        cy.log("Test value displayed in browser");
        // cy.get(mathinputAnchor).should('have.value', 'x+y');
        cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
        cy.get(cesc("#\\/cr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x+y");
          });

        cy.get(cesc("#\\/sr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x+y");
          });
        cy.get(cesc("#\\/ca1")).should("have.text", "1");

        cy.log("Test internal values");
        cy.window().then(async (win) => {
          let stateVariables = await win.returnAllStateVariables1();
          expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
          expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
            [["+", "x", "y"]],
          );
          expect(
            stateVariables["/_answer1"].stateValues.submittedResponses,
          ).eqls([["+", "x", "y"]]);
          expect(stateVariables[mathinputName].stateValues.value).eqls([
            "+",
            "x",
            "y",
          ]);
          // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
        });

        cy.log("Enter wrong answer");
        cy.get(mathinputAnchor)
          .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
          .blur();

        cy.log("Test value displayed in browser");
        // cy.get(mathinputAnchor).should('have.value', 'x');
        cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
        cy.get(cesc("#\\/cr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x");
          });
        cy.get(cesc("#\\/sr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x+y");
          });
        cy.get(cesc("#\\/ca1")).should("have.text", "1");

        cy.log("Test internal values");
        cy.window().then(async (win) => {
          let stateVariables = await win.returnAllStateVariables1();
          expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
          expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
            ["x"],
          );
          expect(
            stateVariables["/_answer1"].stateValues.submittedResponses,
          ).eqls([["+", "x", "y"]]);
          expect(stateVariables[mathinputName].stateValues.value).eqls("x");
          // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
        });

        cy.log("Submit answer");
        cy.get(mathinputSubmitAnchor).click();

        cy.log("Test value displayed in browser");
        // cy.get(mathinputAnchor).should('have.value', 'x');
        cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
        cy.get(cesc("#\\/cr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x");
          });
        cy.get(cesc("#\\/sr1"))
          .find(".mjx-mrow")
          .eq(0)
          .invoke("text")
          .then((text) => {
            expect(text.trim()).equal("x");
          });
        cy.get(cesc("#\\/ca1")).should("have.text", "0");

        cy.log("Test internal values");
        cy.window().then(async (win) => {
          let stateVariables = await win.returnAllStateVariables1();
          expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
          expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
            ["x"],
          );
          expect(
            stateVariables["/_answer1"].stateValues.submittedResponses,
          ).eqls(["x"]);
          expect(stateVariables[mathinputName].stateValues.value).eqls("x");
          // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
        });
      });
    });
  });

  it("answer sugar from macros and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><math name="x">x</math><math name="y">y</math></setup>
  <p><answer>$x+$y</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");

      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });

      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer sugar from maths and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><math>x</math>+<math>y</math></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");

      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });

      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer sugar from math, macro, and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><math name="y">y</math></setup>
  <p><answer><math>x</math>+$y</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");

      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });

      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer sugar from one string, set to text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="text">hello there</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from one string, set to text, expanded", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="text" expanded>hello there</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Pressing enter does not submit");
      cy.get(textinputAnchor).type(`{enter}`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there \n");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there \n");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there \n",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there \n",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there \n");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there \n");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there \n");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there \n",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there \n"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there \n",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there \n");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there \n"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from one macro, set to text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <text name='h'>hello there</text>
  <p><answer type="text">$h</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from one text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><text>hello there</text></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from one copy with createComponentOfType text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <text name='h'>hello there</text>
  <p><answer><copy target="h" createComponentOfType="text" /></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from one macro with createComponentOfType text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <text name='h'>hello there</text>
  <p><answer>$(h{createComponentOfType="text"})</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from macro and string, set to text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><text name="h">hello</text></setup>
  <p><answer type="text">$h there</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from text and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><text>hello</text> there</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from macros and string, does not ignore blank string, set to text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><text name="h">hello</text><text name="t">there</text></setup>
  <p><answer type="text">$h $t</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from macro, text, and string, does not ignore blank string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><text name="h">hello</text></setup>
  <p><answer>$h <text>there</text></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  // test for bug where submitted response was not initially text
  // when had only one copy of referring to all submitted responses
  it("answer sugar from one string, set to text, copy all responses", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="text">hello there</answer></p>
  <p>Submitted responses: <copy prop="submittedResponses" target="_answer1" createComponentOfType="text" assignNames="sr1" /></p>
  <p>To check how long to wait: <booleaninput name="bi" /> <copy prop="value" target="bi" assignNames="b" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.get(cesc("#\\/_p2")).should("have.text", "Submitted responses: ");

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there {enter}`);

      cy.get(cesc("#\\/_p2")).should(
        "have.text",
        "Submitted responses:  hello there ",
      );

      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("click boolean input to know when core has finished processing");
      cy.get(cesc("#\\/bi")).click();
      cy.get(cesc("#\\/b")).should("have.text", "true");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("click boolean input to know when core has finished processing");
      cy.get(cesc("#\\/bi")).click();
      cy.get(cesc("#\\/b")).should("have.text", "false");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );

        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from one string, set to boolean", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="boolean">true</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let booleaninputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let booleaninputAnchor = cesc2("#" + booleaninputName);
      let booleaninputSubmitAnchor = cesc2("#" + booleaninputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Select correct answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Press enter on submit button to submit");
      cy.get(booleaninputSubmitAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Select wrong answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Submit answer");
      cy.get(booleaninputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [false],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });
    });
  });

  it("answer sugar from one boolean", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><boolean>true</boolean></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let booleaninputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let booleaninputAnchor = cesc2("#" + booleaninputName);
      let booleaninputSubmitAnchor = cesc2("#" + booleaninputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Select correct answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Press enter on submit button to submit");
      cy.get(booleaninputSubmitAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Select wrong answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Submit answer");
      cy.get(booleaninputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [false],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });
    });
  });

  it("answer sugar from macro and string, set to boolean", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <boolean hide name="b">false</boolean>
  <p><answer type="boolean">not $b</answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let booleaninputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let booleaninputAnchor = cesc2("#" + booleaninputName);
      let booleaninputSubmitAnchor = cesc2("#" + booleaninputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Select correct answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Press enter on submit button to submit");
      cy.get(booleaninputSubmitAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Select wrong answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Submit answer");
      cy.get(booleaninputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [false],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });
    });
  });

  it("answer sugar from boolean and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer>not <boolean>false</boolean></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let booleaninputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let booleaninputAnchor = cesc2("#" + booleaninputName);
      let booleaninputSubmitAnchor = cesc2("#" + booleaninputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Select correct answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Press enter on submit button to submit");
      cy.get(booleaninputSubmitAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Select wrong answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Submit answer");
      cy.get(booleaninputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [false],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });
    });
  });

  it("warning for sugar with invalid type", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="bad">x</answer></p>
  <p>Credit for submitted response: $_answer1.creditAchieved</p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let errorWarnings = await win.returnErrorWarnings1();

      expect(errorWarnings.errors.length).eq(0);
      expect(errorWarnings.warnings.length).eq(1);

      expect(errorWarnings.warnings[0].message).contain(
        "Invalid type for answer: bad",
      );
      expect(errorWarnings.warnings[0].level).eq(1);
      expect(errorWarnings.warnings[0].doenetMLrange.lineBegin).eq(3);
      expect(errorWarnings.warnings[0].doenetMLrange.charBegin).eq(6);
      expect(errorWarnings.warnings[0].doenetMLrange.lineEnd).eq(3);
      expect(errorWarnings.warnings[0].doenetMLrange.charEnd).eq(34);
    });

    cy.get(cesc2("#/_answer1") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc2("#/_p2")).should(
      "have.text",
      "Credit for submitted response: 1",
    );
  });

  it("answer award with math", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award><math>x+y</math></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{end}{backspace}{backspace}`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer award with sugared string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award>x+y</award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{end}{backspace}{backspace}`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer award with sugared macro", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <math name="xy" hide>x+y</math>
  <p><answer><award>$xy</award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{end}{backspace}{backspace}`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer award with sugared macros and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><math name="x">x</math><math name="y">y</math></setup>
  <p><answer><award>$x+$y</award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{end}{backspace}{backspace}`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer award with sugared macro, text, and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><math name="x">x</math></setup>
  <p><answer><award>$x+<math>y</math></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{end}{backspace}{backspace}`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer with copied award, createComponentOfType specified", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><math name="x">x</math><award name="aw">$x+<math>y</math></award></setup>
  <p><answer><copy target="aw" createComponentOfType="award" /></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{end}{backspace}{backspace}`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer award with math, initally unresolved", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award><math>x+y-3+<copy target="n" /></math></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  <copy name="n2" target="n3" />
  <copy name="n" target="num1" />
  <math name="num1"><copy target="n2" />+<copy target="num2" /></math>
  <math name="num2"><copy target="n3" />+<copy target="num3" /></math>
  <copy name="n3" target="num3" />
  <number name="num3">1</number>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter wrong answer");
      cy.get(mathinputAnchor)
        .type(`{end}{backspace}{backspace}`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });
    });
  });

  it("answer sugar from mathList", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer matchPartial><mathList>x+y z</mathList></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y, z`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y,z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y,z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", ["+", "x", "y"], "z"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          ["+", "x", "y"],
          "z",
        ]);
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y,z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y,z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y,z");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", ["+", "x", "y"], "z"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", ["+", "x", "y"], "z"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          ["+", "x", "y"],
          "z",
        ]);
      });

      cy.log("Enter partially correct answer");
      cy.get(mathinputAnchor)
        .type(`{end}{leftArrow}{leftArrow}{leftArrow}{backspace}{backspace}`, {
          force: true,
        })
        .blur();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x,z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x,z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y,z");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", "x", "z"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", ["+", "x", "y"], "z"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          "x",
          "z",
        ]);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x,z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x,z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x,z");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", "x", "z"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", "x", "z"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          "x",
          "z",
        ]);
      });

      cy.log("Submit incorrect answer");
      cy.get(mathinputAnchor).type(`{end}{backspace}{backspace}{backspace}`, {
        force: true,
        delay: 100,
      });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
      });

      cy.log("Submit other partially correct answer");
      cy.get(mathinputAnchor).type(`{end}{backspace}{backspace}z`, {
        force: true,
        delay: 100,
      });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "z");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("z");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "z",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["z"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("z");
      });
    });
  });

  it("answer award with mathList", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer matchPartial><award><mathList>x+y z</mathList></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y, z`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y,z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y,z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", ["+", "x", "y"], "z"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          ["+", "x", "y"],
          "z",
        ]);
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y,z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y,z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y,z");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", ["+", "x", "y"], "z"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", ["+", "x", "y"], "z"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          ["+", "x", "y"],
          "z",
        ]);
      });

      cy.log("Enter partially correct answer");
      cy.get(mathinputAnchor)
        .type(`{end}{leftArrow}{leftArrow}{leftArrow}{backspace}{backspace}`, {
          force: true,
        })
        .blur();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x,z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x,z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y,z");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", "x", "z"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", ["+", "x", "y"], "z"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          "x",
          "z",
        ]);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x,z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x,z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x,z");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", "x", "z"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", "x", "z"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          "x",
          "z",
        ]);
      });

      cy.log("Submit incorrect answer");
      cy.get(mathinputAnchor).type(`{end}{backspace}{backspace}{backspace}`, {
        force: true,
        delay: 100,
      });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
      });

      cy.log("Submit other partially correct answer");
      cy.get(mathinputAnchor).type(`{end}{backspace}{backspace}z`, {
        force: true,
        delay: 100,
      });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "z");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "z");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("z");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("z");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "z",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["z"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("z");
      });
    });
  });

  it("answer from mathList", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><mathinput name="mi1" /> <mathinput name="mi2" />
    <answer matchPartial><award><when>
      <mathList isResponse>$mi1 $mi2</mathList> = <mathList>x+y z</mathList>
    </when></award></answer></p>
  <p>Current response: <copy prop="currentResponses" target="_answer1" assignNames="cr1 cr2" /></p>
  <p>Submitted response: <copy prop="submittedResponses" target="_answer1" createComponentOfType="math" numComponents="2" assignNames="sr1 sr2" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    let mathinput1Name = "/mi1";
    let mathinput1Anchor = cesc2("#" + mathinput1Name) + " textarea";
    let mathinput2Name = "/mi2";
    let mathinput2Anchor = cesc2("#" + mathinput2Name) + " textarea";
    let submitAnchor = cesc2("#/_answer1_submit");

    cy.log("Test value displayed in browser");
    // cy.get(mathinputAnchor).should('have.value', '');
    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/ca1")).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "\uFF3F",
        "\uFF3F",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables[mathinput1Name].stateValues.value).eq("\uFF3F");
      expect(stateVariables[mathinput2Name].stateValues.value).eq("\uFF3F");
    });

    cy.log("Type correct answer in");
    cy.get(mathinput1Anchor).type(`x+y`, { force: true }).blur();
    cy.get(mathinput2Anchor).type(`z`, { force: true }).blur();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
    cy.get(cesc("#\\/cr2") + " .mjx-mrow").should("have.text", "z");
    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/ca1")).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        ["+", "x", "y"],
        "z",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables[mathinput1Name].stateValues.value).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables[mathinput2Name].stateValues.value).eqls("z");
    });

    cy.log("Press enter to submit");
    cy.get(submitAnchor).type(`{enter}`);

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
    cy.get(cesc("#\\/sr2") + " .mjx-mrow").should("have.text", "z");
    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/ca1")).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        ["+", "x", "y"],
        "z",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        ["+", "x", "y"],
        "z",
      ]);
      expect(stateVariables[mathinput1Name].stateValues.value).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables[mathinput2Name].stateValues.value).eqls("z");
    });

    cy.log("Enter partially correct answer");
    cy.get(mathinput1Anchor)
      .type(`{end}{backspace}{backspace}`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
    cy.get(cesc("#\\/cr2") + " .mjx-mrow").should("have.text", "z");
    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/ca1")).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "x",
        "z",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        ["+", "x", "y"],
        "z",
      ]);
      expect(stateVariables[mathinput1Name].stateValues.value).eqls("x");
      expect(stateVariables[mathinput2Name].stateValues.value).eqls("z");
    });

    cy.log("Submit answer");
    cy.get(submitAnchor).click();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
    cy.get(cesc("#\\/sr2") + " .mjx-mrow").should("have.text", "z");
    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "x",
        "z",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "x",
        "z",
      ]);
      expect(stateVariables[mathinput1Name].stateValues.value).eqls("x");
      expect(stateVariables[mathinput2Name].stateValues.value).eqls("z");
    });

    cy.log("Submit incorrect answer");
    cy.get(mathinput2Anchor).type(`{end}{backspace}{backspace}{backspace}`, {
      force: true,
      delay: 100,
    });
    // Note: have to wait for core to respond to at least first keystroke
    // or the renderer will not be set to allow a submission
    // (delayed typing to make sure can test case where submit before core has responded to all,
    // in case where have core set for a delayed response)
    cy.get(submitAnchor).type(`{enter}`);

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
    cy.get(cesc("#\\/cr2") + " .mjx-mrow").should("contain.text", "\uff3f");
    cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
    cy.get(cesc("#\\/sr2") + " .mjx-mrow").should("contain.text", "\uff3f");
    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("\uff3f");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("\uff3f");
      });
    cy.get(cesc("#\\/ca1")).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "x",
        "\uff3f",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "x",
        "\uff3f",
      ]);
      expect(stateVariables[mathinput1Name].stateValues.value).eqls("x");
      expect(stateVariables[mathinput2Name].stateValues.value).eqls("\uff3f");
    });

    cy.log("Submit other partially correct answer");
    cy.get(mathinput1Anchor).type(`{end}{backspace}{backspace}z`, {
      force: true,
      delay: 100,
    });
    // Note: have to wait for core to respond to at least first keystroke
    // or the renderer will not be set to allow a submission
    // (delayed typing to make sure can test case where submit before core has responded to all,
    // in case where have core set for a delayed response)
    cy.get(submitAnchor).type(`{enter}`);

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "z");
    cy.get(cesc("#\\/cr2") + " .mjx-mrow").should("contain.text", "\uff3f");
    cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "z");
    cy.get(cesc("#\\/sr2") + " .mjx-mrow").should("contain.text", "\uff3f");
    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("\uff3f");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("\uff3f");
      });
    cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "z",
        "\uff3f",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "z",
        "\uff3f",
      ]);
      expect(stateVariables[mathinput1Name].stateValues.value).eqls("z");
      expect(stateVariables[mathinput2Name].stateValues.value).eqls("\uff3f");
    });
  });

  it("answer sugar from numberList", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer matchPartial><numberList>1 2</numberList></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`1,  2`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "1,2");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1,2");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", 1, 2],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          1,
          2,
        ]);
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "1,2");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1,2");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1,2");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", 1, 2],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", 1, 2]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          1,
          2,
        ]);
      });

      cy.log("Enter partially correct answer");
      cy.get(mathinputAnchor).type(`{home}3`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "31,2");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31,2");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1,2");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", 31, 2],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", 1, 2]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          31,
          2,
        ]);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "31,2");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31,2");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31,2");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", 31, 2],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", 31, 2]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          31,
          2,
        ]);
      });

      cy.log("Submit incorrect answer");
      cy.get(mathinputAnchor).type(
        `{end}{backspace}{backspace}{backspace}{backspace}`,
        { force: true, delay: 100 },
      );
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "31");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "31");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          31,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [31],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls(31);
      });

      cy.log("Submit other partially correct answer");
      cy.get(mathinputAnchor).type(`{end}{backspace}{backspace}1`, {
        force: true,
        delay: 100,
      });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "1");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "1");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          1,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [1],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls(1);
      });
    });
  });

  it("answer award with numberList", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer matchPartial><award><numberList>1 2</numberList></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`1,  2`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "1,2");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1,2");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", 1, 2],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          1,
          2,
        ]);
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "1,2");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1,2");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1,2");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", 1, 2],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", 1, 2]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          1,
          2,
        ]);
      });

      cy.log("Enter partially correct answer");
      cy.get(mathinputAnchor).type(`{home}3`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "31,2");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31,2");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1,2");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", 31, 2],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", 1, 2]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          31,
          2,
        ]);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "31,2");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31,2");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31,2");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["list", 31, 2],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["list", 31, 2]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "list",
          31,
          2,
        ]);
      });

      cy.log("Submit incorrect answer");
      cy.get(mathinputAnchor).type(
        `{end}{backspace}{backspace}{backspace}{backspace}`,
        { force: true, delay: 100 },
      );
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "31");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "31");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("31");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          31,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [31],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls(31);
      });

      cy.log("Submit other partially correct answer");
      cy.get(mathinputAnchor).type(`{end}{backspace}{backspace}1`, {
        force: true,
        delay: 100,
      });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "1");
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "1");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("1");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          1,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [1],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls(1);
      });
    });
  });

  it("answer award with text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award><text>  hello there </text></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer set to text, award with text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="text"><award><text>  hello there </text></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer set to text, award with sugared string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="text"><award>  hello there </award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer set to text, award with sugared macro and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><text name="h">hello</text></setup>
  <p><answer type="text"><award>$h there</award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer award with text and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award><text>hello</text> there</award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer award with text, macro, and string, does not ignore blank string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup><text name="h">hello</text></setup>
  <p><answer><award>$h <text>there</text></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer award with text, initally unresolved", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award><text><copy target="n" /></text></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="text" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  <copy name="n2" target="n3" />
  <copy name="n" target="text1" />
  <text name="text1"><copy target="n2" /> <copy target="text2" /></text>
  <text name="text2"><copy target="n4" /></text>
  <copy name="n3" target="text3" />
  <text name="text3">hello</text>
  <copy name="n4" target="text4" />
  <text name="text4">there</text>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter wrong answer");
      cy.get(textinputAnchor).clear().type(`hellothere`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hellothere");
      cy.get(cesc("#\\/cr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hellothere",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hellothere",
        );
      });

      cy.log("Enter another correct answer");
      cy.get(textinputAnchor).clear().type(`hello  there`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hellothere");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hellothere"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello  there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello  there");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello  there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello  there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello  there",
        );
      });
    });
  });

  it("answer sugar from textlist", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer matchPartial><textlist>  hello there </textlist></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello  , there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello  , there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello  , there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello  , there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello  , there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello  , there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello  , there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello  , there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello  , there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello  , there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello  , there ",
        );
      });

      cy.log("Enter partially correct answer");
      cy.get(textinputAnchor).clear().type(`hello,then`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello,then");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello,then");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello  , there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello,then",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello  , there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello,then",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello,then");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello,then");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello,then");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello,then",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello,then"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello,then",
        );
      });

      cy.log("Submit incorrect answer");
      cy.get(textinputAnchor).clear().type(`hello there`, { delay: 100 });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello there");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello there",
        );
      });

      cy.log("Submit other partially correct answer");
      cy.get(textinputAnchor).clear().type(`there`, { delay: 100 });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "there");
      cy.get(cesc("#\\/cr1")).should("have.text", "there");
      cy.get(cesc("#\\/sr1")).should("have.text", "there");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("there");
      });
    });
  });

  it("answer award with textlist", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award matchPartial><textlist>  hello there </textlist></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello  , there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello  , there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello  , there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello  , there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello  , there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello  , there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello  , there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello  , there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello  , there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello  , there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello  , there ",
        );
      });

      cy.log("Enter partially correct answer");
      cy.get(textinputAnchor).clear().type(`hello,then`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello,then");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello,then");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello  , there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello,then",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello  , there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello,then",
        );
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello,then");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello,then");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello,then");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello,then",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello,then"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello,then",
        );
      });

      cy.log("Submit incorrect answer");
      cy.get(textinputAnchor).clear().type(`hello there`, { delay: 100 });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "hello there");
      cy.get(cesc("#\\/cr1")).should("have.text", "hello there");
      cy.get(cesc("#\\/sr1")).should("have.text", "hello there");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "hello there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["hello there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          "hello there",
        );
      });

      cy.log("Submit other partially correct answer");
      cy.get(textinputAnchor).clear().type(`there`, { delay: 100 });
      // Note: have to wait for core to respond to at least first keystroke
      // or the renderer will not be set to allow a submission
      // (delayed typing to make sure can test case where submit before core has responded to all,
      // in case where have core set for a delayed response)
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "there");
      cy.get(cesc("#\\/cr1")).should("have.text", "there");
      cy.get(cesc("#\\/sr1")).should("have.text", "there");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "there",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["there"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("there");
      });
    });
  });

  it("answer from textlist", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><textinput name="ti1" /> <textinput name="ti2" />
    <answer><award matchPartial><when>
      <textlist isResponse>$ti1 $ti2</textlist>=<textlist>  hello there </textlist>
    </when></award></answer></p>
  <p>Current responses: <copy prop="currentResponses" target="_answer1" assignNames="cr1 cr2" /></p>
  <p>Submitted responses: <copy prop="submittedResponses" target="_answer1" assignNames="sr1 sr2" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    let textinput1Name = "/ti1";
    let textinput1Anchor = cesc2("#" + textinput1Name + "_input");
    let textinput2Name = "/ti2";
    let textinput2Anchor = cesc2("#" + textinput2Name + "_input");
    let submitAnchor = cesc2("#/_answer1_submit");

    cy.log("Test value displayed in browser");
    cy.get(textinput1Anchor).should("have.value", "");
    cy.get(textinput2Anchor).should("have.value", "");
    cy.get(cesc("#\\/cr1")).should("have.text", "");
    cy.get(cesc("#\\/cr2")).should("have.text", "");
    cy.get(cesc("#\\/sr1")).should("not.exist");
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/ca1")).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "",
        "",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables[textinput1Name].stateValues.value).eq("");
      expect(stateVariables[textinput2Name].stateValues.value).eq("");
    });

    cy.log("Type correct answers in");
    cy.get(textinput1Anchor).type(` hello  `).blur();
    cy.get(textinput2Anchor).type(` there `).blur();

    cy.log("Test value displayed in browser");
    cy.get(textinput1Anchor).should("have.value", " hello  ");
    cy.get(textinput2Anchor).should("have.value", " there ");
    cy.get(cesc("#\\/cr1")).should("have.text", " hello  ");
    cy.get(cesc("#\\/cr2")).should("have.text", " there ");
    cy.get(cesc("#\\/sr1")).should("not.exist");
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/ca1")).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        " hello  ",
        " there ",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables[textinput1Name].stateValues.value).eq(" hello  ");
      expect(stateVariables[textinput2Name].stateValues.value).eq(" there ");
    });

    cy.log("Press enter to submit");
    cy.get(submitAnchor).type(`{enter}`);

    cy.log("Test value displayed in browser");
    cy.get(textinput1Anchor).should("have.value", " hello  ");
    cy.get(textinput2Anchor).should("have.value", " there ");
    cy.get(cesc("#\\/cr1")).should("have.text", " hello  ");
    cy.get(cesc("#\\/cr2")).should("have.text", " there ");
    cy.get(cesc("#\\/sr1")).should("have.text", " hello  ");
    cy.get(cesc("#\\/sr2")).should("have.text", " there ");
    cy.get(cesc("#\\/ca1")).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        " hello  ",
        " there ",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        " hello  ",
        " there ",
      ]);
      expect(stateVariables[textinput1Name].stateValues.value).eq(" hello  ");
      expect(stateVariables[textinput2Name].stateValues.value).eq(" there ");
    });

    cy.log("Enter partially correct answer");
    cy.get(textinput1Anchor).clear().type(`hello`).blur();
    cy.get(textinput2Anchor).clear().type(`then`).blur();

    cy.log("Test value displayed in browser");
    cy.get(textinput1Anchor).should("have.value", "hello");
    cy.get(textinput2Anchor).should("have.value", "then");
    cy.get(cesc("#\\/cr1")).should("have.text", "hello");
    cy.get(cesc("#\\/cr2")).should("have.text", "then");
    cy.get(cesc("#\\/sr1")).should("have.text", " hello  ");
    cy.get(cesc("#\\/sr2")).should("have.text", " there ");
    cy.get(cesc("#\\/ca1")).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "hello",
        "then",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        " hello  ",
        " there ",
      ]);
      expect(stateVariables[textinput1Name].stateValues.value).eq("hello");
      expect(stateVariables[textinput2Name].stateValues.value).eq("then");
    });

    cy.log("Submit answer");
    cy.get(submitAnchor).click();

    cy.log("Test value displayed in browser");
    cy.get(textinput1Anchor).should("have.value", "hello");
    cy.get(textinput2Anchor).should("have.value", "then");
    cy.get(cesc("#\\/cr1")).should("have.text", "hello");
    cy.get(cesc("#\\/cr2")).should("have.text", "then");
    cy.get(cesc("#\\/sr1")).should("have.text", "hello");
    cy.get(cesc("#\\/sr2")).should("have.text", "then");
    cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "hello",
        "then",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "hello",
        "then",
      ]);
      expect(stateVariables[textinput1Name].stateValues.value).eq("hello");
      expect(stateVariables[textinput2Name].stateValues.value).eq("then");
    });

    cy.log("Submit incorrect answer");
    cy.get(textinput2Anchor).clear();
    cy.get(textinput1Anchor).clear().type(`hello, there`, { delay: 100 });
    // Note: have to wait for core to respond to at least first keystroke
    // or the renderer will not be set to allow a submission
    // (delayed typing to make sure can test case where submit before core has responded to all,
    // in case where have core set for a delayed response)
    cy.get(submitAnchor).type(`{enter}`);

    cy.log("Test value displayed in browser");
    cy.get(textinput1Anchor).should("have.value", "hello, there");
    cy.get(textinput2Anchor).should("have.value", "");
    cy.get(cesc("#\\/cr1")).should("have.text", "hello, there");
    cy.get(cesc("#\\/cr2")).should("have.text", "");
    cy.get(cesc("#\\/sr1")).should("have.text", "hello, there");
    cy.get(cesc("#\\/sr2")).should("have.text", "");
    cy.get(cesc("#\\/ca1")).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "hello, there",
        "",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "hello, there",
        "",
      ]);
      expect(stateVariables[textinput1Name].stateValues.value).eq(
        "hello, there",
      );
      expect(stateVariables[textinput2Name].stateValues.value).eq("");
    });

    cy.log("Submit other partially correct answer");
    cy.get(textinput1Anchor).clear().type(`there`, { delay: 100 });
    // Note: have to wait for core to respond to at least first keystroke
    // or the renderer will not be set to allow a submission
    // (delayed typing to make sure can test case where submit before core has responded to all,
    // in case where have core set for a delayed response)
    cy.get(submitAnchor).click();

    cy.log("Test value displayed in browser");
    cy.get(textinput1Anchor).should("have.value", "there");
    cy.get(textinput2Anchor).should("have.value", "");
    cy.get(cesc("#\\/cr1")).should("have.text", "there");
    cy.get(cesc("#\\/cr2")).should("have.text", "");
    cy.get(cesc("#\\/sr1")).should("have.text", "there");
    cy.get(cesc("#\\/sr2")).should("have.text", "");
    cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "there",
        "",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "there",
        "",
      ]);
      expect(stateVariables[textinput1Name].stateValues.value).eq("there");
      expect(stateVariables[textinput2Name].stateValues.value).eq("");
    });
  });

  it("answer award with boolean", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award><boolean>true</boolean></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let booleaninputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let booleaninputAnchor = cesc2("#" + booleaninputName);
      let booleaninputSubmitAnchor = cesc2("#" + booleaninputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Select correct answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Press enter on submit button to submit");
      cy.get(booleaninputSubmitAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Select wrong answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Submit answer");
      cy.get(booleaninputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [false],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });
    });
  });

  it("answer set to boolean, award with boolean", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="boolean"><award><boolean>true</boolean></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let booleaninputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let booleaninputAnchor = cesc2("#" + booleaninputName);
      let booleaninputSubmitAnchor = cesc2("#" + booleaninputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Select correct answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Press enter on submit button to submit");
      cy.get(booleaninputSubmitAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Select wrong answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Submit answer");
      cy.get(booleaninputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [false],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });
    });
  });

  it("answer set to boolean, award with sugared macro and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <boolean hide name="b">false</boolean>
  <p><answer type="boolean"><award>not $b</award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let booleaninputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let booleaninputAnchor = cesc2("#" + booleaninputName);
      let booleaninputSubmitAnchor = cesc2("#" + booleaninputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Select correct answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Press enter on submit button to submit");
      cy.get(booleaninputSubmitAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Select wrong answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Submit answer");
      cy.get(booleaninputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [false],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });
    });
  });

  it("answer award with sugared boolean and string", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <boolean hide name="b">false</boolean>
  <p><answer><award>not <boolean>false</boolean></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let booleaninputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let booleaninputAnchor = cesc2("#" + booleaninputName);
      let booleaninputSubmitAnchor = cesc2("#" + booleaninputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Select correct answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Press enter on submit button to submit");
      cy.get(booleaninputSubmitAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "true");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          true,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(true);
      });

      cy.log("Select wrong answer");
      cy.get(booleaninputAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "true");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [true],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });

      cy.log("Submit answer");
      cy.get(booleaninputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(cesc("#\\/cr1")).should("have.text", "false");
      cy.get(cesc("#\\/sr1")).should("have.text", "false");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          false,
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [false],
        );
        expect(stateVariables[booleaninputName].stateValues.value).eq(false);
      });
    });
  });

  it("answer multiple shortcut awards", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award><math>x+y</math></award><award credit="0.5"><math>x</math></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter partially correct answer");
      cy.get(mathinputAnchor)
        .type(`{end}{backspace}{backspace}`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });

      cy.log("Enter incorrect answer");
      // cy.get(mathinputAnchor);
      cy.get(mathinputAnchor).type(`{end}{backspace}y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("y");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });

      cy.log("Submit answer");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["y"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("y");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('y');
      });
    });
  });

  it("answer multiple shortcut awards, initially unresolved", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award><math><copy target="rightAnswer" /></math></award><award credit="0.5"><math>x-3+<copy target="n" /></math></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>

  <math name="rightAnswer">x+y-3+<copy target="n" /></math>
  <copy name="n2" target="n3" />
  <copy name="n" target="num1" />
  <math name="num1"><copy target="n2" />+<copy target="num2" /></math>
  <math name="num2"><copy target="n3" />+<copy target="num3" /></math>
  <copy name="n3" target="num3" />
  <number name="num3">1</number>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "\uFF3F",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          ["+", "x", "y"],
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter partially correct answer");
      cy.get(mathinputAnchor)
        .type(`{rightarrow}{rightarrow}{rightarrow}{backspace}{backspace}`, {
          force: true,
        })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "x",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });

      cy.log("Enter incorrect answer");
      cy.get(mathinputAnchor)
        .type(`{rightarrow}{backspace}y`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'y');
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["x"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("y");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });

      cy.log("Submit answer");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'y');
      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "y");
      cy.get(cesc("#\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("y");
        });
      cy.get(cesc("#\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["y"],
        );
        expect(stateVariables[mathinputName].stateValues.value).eqls("y");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('y');
      });
    });
  });

  it("answer multiple text awards", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer><award><text>hello there</text></award><award credit="0.5"><text>bye</text></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter partially correct answer");
      cy.get(textinputAnchor).clear().type(`bye`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(cesc("#\\/cr1")).should("have.text", "bye");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "bye",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("bye");
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(cesc("#\\/cr1")).should("have.text", "bye");
      cy.get(cesc("#\\/sr1")).should("have.text", "bye");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "bye",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["bye"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("bye");
      });

      cy.log("Enter incorrect answer");
      cy.get(textinputAnchor).clear().type(`y`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "y");
      cy.get(cesc("#\\/cr1")).should("have.text", "y");
      cy.get(cesc("#\\/sr1")).should("have.text", "bye");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["bye"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("y");
      });

      cy.log("Submit answer");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "y");
      cy.get(cesc("#\\/cr1")).should("have.text", "y");
      cy.get(cesc("#\\/sr1")).should("have.text", "y");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["y"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("y");
      });
    });
  });

  it("answer multiple awards, set to text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="text"><award><text>hello there</text></award><award credit="0.5"><text>bye</text></award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter partially correct answer");
      cy.get(textinputAnchor).clear().type(`bye`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(cesc("#\\/cr1")).should("have.text", "bye");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "bye",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("bye");
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(cesc("#\\/cr1")).should("have.text", "bye");
      cy.get(cesc("#\\/sr1")).should("have.text", "bye");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "bye",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["bye"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("bye");
      });

      cy.log("Enter incorrect answer");
      cy.get(textinputAnchor).clear().type(`y`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "y");
      cy.get(cesc("#\\/cr1")).should("have.text", "y");
      cy.get(cesc("#\\/sr1")).should("have.text", "bye");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["bye"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("y");
      });

      cy.log("Submit answer");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "y");
      cy.get(cesc("#\\/cr1")).should("have.text", "y");
      cy.get(cesc("#\\/sr1")).should("have.text", "y");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["y"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("y");
      });
    });
  });

  it("answer multiple string awards, set to text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="text"><award>hello there</award><award credit="0.5">bye</award></answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='text' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(cesc("#\\/cr1")).should("have.text", "");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("");
      });

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(` hello there `).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", "");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Press enter to submit");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", " hello there ");
      cy.get(cesc("#\\/cr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          " hello there ",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq(
          " hello there ",
        );
      });

      cy.log("Enter partially correct answer");
      cy.get(textinputAnchor).clear().type(`bye`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(cesc("#\\/cr1")).should("have.text", "bye");
      cy.get(cesc("#\\/sr1")).should("have.text", " hello there ");
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "bye",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [" hello there "],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("bye");
      });

      cy.log("Submit answer");
      cy.get(textinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(cesc("#\\/cr1")).should("have.text", "bye");
      cy.get(cesc("#\\/sr1")).should("have.text", "bye");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "bye",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["bye"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("bye");
      });

      cy.log("Enter incorrect answer");
      cy.get(textinputAnchor).clear().type(`y`).blur();

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "y");
      cy.get(cesc("#\\/cr1")).should("have.text", "y");
      cy.get(cesc("#\\/sr1")).should("have.text", "bye");
      cy.get(cesc("#\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["bye"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("y");
      });

      cy.log("Submit answer");
      cy.get(textinputAnchor).type(`{enter}`);

      cy.log("Test value displayed in browser");
      cy.get(textinputAnchor).should("have.value", "y");
      cy.get(cesc("#\\/cr1")).should("have.text", "y");
      cy.get(cesc("#\\/sr1")).should("have.text", "y");
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "y",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["y"],
        );
        expect(stateVariables[textinputName].stateValues.value).eq("y");
      });
    });
  });

  it("answer multiple awards, namespaces", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <section name="s" newNamespace>
  <p><answer newNamespace>
    <award newNamespace><math>x+y</math></award>
    <award credit="0.5" newNamespace><math>x</math></award>
  </answer></p>
  <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="ca1" /></p>
  </section>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/s/_answer1"].stateValues.inputChildren[0]
          .componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(cesc("#\\/s\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/s\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/s\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/s/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/s/_answer1"].stateValues.currentResponses).eqls(
          ["\uFF3F"],
        );
        expect(
          stateVariables["/s/_answer1"].stateValues.submittedResponses,
        ).eqls([]);
        expect(stateVariables[mathinputName].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/s\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/s\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/s\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/s\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/s/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/s/_answer1"].stateValues.currentResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(
          stateVariables["/s/_answer1"].stateValues.submittedResponses,
        ).eqls([]);
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Press enter to submit");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(cesc("#\\/s\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/s\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/s\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/s\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/s/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/s/_answer1"].stateValues.currentResponses).eqls(
          [["+", "x", "y"]],
        );
        expect(
          stateVariables["/s/_answer1"].stateValues.submittedResponses,
        ).eqls([["+", "x", "y"]]);
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "+",
          "x",
          "y",
        ]);
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Enter partially correct answer");
      cy.get(mathinputAnchor)
        .type(`{rightarrow}{rightarrow}{rightarrow}{backspace}{backspace}`, {
          force: true,
        })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/s\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/s\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/s\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x+y");
        });
      cy.get(cesc("#\\/s\\/ca1")).should("have.text", "1");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/s/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/s/_answer1"].stateValues.currentResponses).eqls(
          ["x"],
        );
        expect(
          stateVariables["/s/_answer1"].stateValues.submittedResponses,
        ).eqls([["+", "x", "y"]]);
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls(['+', 'x', 'y']);
      });

      cy.log("Submit answer");
      cy.get(mathinputSubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(cesc("#\\/s\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/s\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/s\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/s\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/s/_answer1"].stateValues.creditAchieved).eq(
          0.5,
        );
        expect(stateVariables["/s/_answer1"].stateValues.currentResponses).eqls(
          ["x"],
        );
        expect(
          stateVariables["/s/_answer1"].stateValues.submittedResponses,
        ).eqls(["x"]);
        expect(stateVariables[mathinputName].stateValues.value).eqls("x");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });

      cy.log("Enter incorrect answer");
      cy.get(mathinputAnchor)
        .type(`{rightarrow}{backspace}y`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'y');
      cy.get(cesc("#\\/s\\/cr1") + " .mjx-mrow").should("have.text", "y");
      cy.get(cesc("#\\/s\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("y");
        });
      cy.get(cesc("#\\/s\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/s\\/ca1")).should("have.text", "0.5");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/s/_answer1"].stateValues.creditAchieved).eq(
          0.5,
        );
        expect(stateVariables["/s/_answer1"].stateValues.currentResponses).eqls(
          ["y"],
        );
        expect(
          stateVariables["/s/_answer1"].stateValues.submittedResponses,
        ).eqls(["x"]);
        expect(stateVariables[mathinputName].stateValues.value).eqls("y");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('x');
      });

      cy.log("Submit answer");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });

      cy.log("Test value displayed in browser");
      // cy.get(mathinputAnchor).should('have.value', 'y');
      cy.get(cesc("#\\/s\\/sr1") + " .mjx-mrow").should("have.text", "y");
      cy.get(cesc("#\\/s\\/cr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("y");
        });
      cy.get(cesc("#\\/s\\/sr1"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("y");
        });
      cy.get(cesc("#\\/s\\/ca1")).should("have.text", "0");

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/s/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/s/_answer1"].stateValues.currentResponses).eqls(
          ["y"],
        );
        expect(
          stateVariables["/s/_answer1"].stateValues.submittedResponses,
        ).eqls(["y"]);
        expect(stateVariables[mathinputName].stateValues.value).eqls("y");
        // expect(stateVariables[mathinputName].stateValues.submittedValue).eqls('y');
      });
    });
  });

  it("full answer tag", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Enter values that sum to <m>3x</m>: <mathinput/> <mathinput/>
  <answer>
  <award><when><math><copy prop="immediateValue" target="_mathinput1" isResponse />+<copy prop="immediateValue" target="_mathinput2" isResponse /></math> = <math>3x</math></when></award>
  <award credit="0.5"><when><math><copy prop="immediateValue" target="_mathinput1" />+<copy prop="immediateValue" target="_mathinput2" /></math> = <math>3</math></when></award>
  </answer></p>
  <p>First current response: <copy assignNames="cr" prop="currentResponse" target="_answer1" /></p>
  <p>First current response again: <copy assignNames="cr1" prop="currentResponse1" target="_answer1" /></p>
  <p>Second current response: <copy assignNames="cr2" prop="currentResponse2" target="_answer1" /></p>
  <p>Both current responses together: <copy assignNames="crsa crsb" prop="currentResponses" target="_answer1" /></p>
  <p>First submitted response: <copy assignNames="sr" prop="submittedResponse" target="_answer1" createComponentOfType="math" /></p>
  <p>First submitted response again: <copy assignNames="sr1" prop="submittedResponse1" target="_answer1" createComponentOfType="math" /></p>
  <p>Second submitted response: <copy assignNames="sr2" prop="submittedResponse2" target="_answer1" createComponentOfType="math" /></p>
  <p>Both submitted responses together: <copy assignNames="srsa srsb" prop="submittedResponses" target="_answer1" /></p>
  <p>Credit for submitted responses: <copy assignNames="ca" prop="creditAchieved" target="_answer1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', '');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '');

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    // cy.get(cesc(`#\\/srsa`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    // cy.get(cesc(`#\\/srsb`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "\uFF3F",
        "\uFF3F",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "\uFF3F",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "\uFF3F",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        undefined,
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        undefined,
      );
      expect(stateVariables["/_mathinput1"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/_mathinput2"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/cr"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/cr1"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/cr2"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/crsa"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/crsb"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr1"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr2"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/srsa'].stateValues.value).eq('\uFF3F')
      // expect(stateVariables['/srsb'].stateValues.value).eq('\uFF3F')
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });

    cy.log("Enter a correct answer in");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`x+y`, { force: true })
      .blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea")
      .type(`2x-y`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");

    cy.get(cesc(`#\\/_mathinput1`) + ` .mq-editable-field`).should(
      "contain.text",
      "x+y",
    );
    cy.get(cesc(`#\\/_mathinput2`) + ` .mq-editable-field`).should(
      "contain.text",
      "2x−y",
    );
    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("contain.text", "x+y");
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("contain.text", "x+y");
    cy.get(cesc(`#\\/crsa`) + ` .mjx-mrow`).should("contain.text", "x+y");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("contain.text", "2x−y");
    cy.get(cesc(`#\\/crsb`) + ` .mjx-mrow`).should("contain.text", "2x−y");

    cy.get(cesc(`#\\/_mathinput1`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("x+y");
      });
    cy.get(cesc(`#\\/_mathinput2`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("2x−y");
      });
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    // cy.get(cesc(`#\\/srsa`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    // cy.get(cesc(`#\\/srsb`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        undefined,
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        undefined,
      );
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls([
        "+",
        "x",
        "y",
      ]);
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/cr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr1"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr2"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/srsa'].stateValues.value).eq('\uFF3F')
      // expect(stateVariables['/srsb'].stateValues.value).eq('\uFF3F')
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("contain.text", "x+y");
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("contain.text", "x+y");
    cy.get(cesc(`#\\/srsa`) + ` .mjx-mrow`).should("contain.text", "x+y");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("contain.text", "2x−y");
    cy.get(cesc(`#\\/srsb`) + ` .mjx-mrow`).should("contain.text", "2x−y");

    cy.get(cesc(`#\\/_mathinput1`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("x+y");
      });
    cy.get(cesc(`#\\/_mathinput2`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("2x−y");
      });

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls([
        "+",
        "x",
        "y",
      ]);
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls(["+", 'x', 'y']);
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", ['*', 2, 'x'], ['-', 'y']]);
      expect(stateVariables["/cr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Enter partially correct answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
      .blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea")
      .type(`{ctrl+home}{shift+end}{backspace}3-x`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");

    cy.get(cesc(`#\\/_mathinput1`) + ` .mq-editable-field`).should(
      "contain.text",
      "x",
    );
    cy.get(cesc(`#\\/_mathinput2`) + ` .mq-editable-field`).should(
      "contain.text",
      "3−x",
    );
    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("contain.text", "x");
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("contain.text", "x");
    cy.get(cesc(`#\\/crsa`) + ` .mjx-mrow`).should("contain.text", "x");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("contain.text", "3−x");
    cy.get(cesc(`#\\/crsb`) + ` .mjx-mrow`).should("contain.text", "3−x");

    cy.get(cesc(`#\\/_mathinput1`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("x");
      });
    cy.get(cesc(`#\\/_mathinput2`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("3−x");
      });

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("x");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls(["+", 'x', 'y']);
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", ['*', 2, 'x'], ['-', 'y']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("x");
      expect(stateVariables["/cr1"].stateValues.value).eqls("x");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("x");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("contain.text", "x");
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("contain.text", "x");
    cy.get(cesc(`#\\/srsa`) + ` .mjx-mrow`).should("contain.text", "x");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("contain.text", "3−x");
    cy.get(cesc(`#\\/srsb`) + ` .mjx-mrow`).should("contain.text", "3−x");

    cy.get(cesc(`#\\/_mathinput1`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("x");
      });
    cy.get(cesc(`#\\/_mathinput2`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("3−x");
      });

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("x");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls('x');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", 3, ['-', 'x']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("x");
      expect(stateVariables["/cr1"].stateValues.value).eqls("x");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("x");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls("x");
      expect(stateVariables["/sr1"].stateValues.value).eqls("x");
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls("x");
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Enter incorrect answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`{rightarrow}{backspace}y`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");

    cy.get(cesc(`#\\/_mathinput1`) + ` .mq-editable-field`).should(
      "contain.text",
      "y",
    );
    cy.get(cesc(`#\\/_mathinput2`) + ` .mq-editable-field`).should(
      "contain.text",
      "3−x",
    );
    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("contain.text", "y");
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("contain.text", "y");
    cy.get(cesc(`#\\/crsa`) + ` .mjx-mrow`).should("contain.text", "y");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("contain.text", "3−x");
    cy.get(cesc(`#\\/crsb`) + ` .mjx-mrow`).should("contain.text", "3−x");

    cy.get(cesc(`#\\/_mathinput1`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("y");
      });
    cy.get(cesc(`#\\/_mathinput2`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("3−x");
      });

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "y",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "y",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("y");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls('x');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", 3, ['-', 'x']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("y");
      expect(stateVariables["/cr1"].stateValues.value).eqls("y");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("y");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls("x");
      expect(stateVariables["/sr1"].stateValues.value).eqls("x");
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls("x");
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("contain.text", "y");
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("contain.text", "y");
    cy.get(cesc(`#\\/srsa`) + ` .mjx-mrow`).should("contain.text", "y");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("contain.text", "3−x");
    cy.get(cesc(`#\\/srsb`) + ` .mjx-mrow`).should("contain.text", "3−x");

    cy.get(cesc(`#\\/_mathinput1`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("y");
      });
    cy.get(cesc(`#\\/_mathinput2`) + ` .mq-editable-field`)
      .invoke("text")
      .then((text) => {
        expect(text.replace(/[\s\u200B-\u200D\uFEFF]/g, "")).equal("3−x");
      });

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "y",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "y",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "y",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "y",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("y");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls('y');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", 3, ['-', 'x']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("y");
      expect(stateVariables["/cr1"].stateValues.value).eqls("y");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("y");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls("y");
      expect(stateVariables["/sr1"].stateValues.value).eqls("y");
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls("y");
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });
  });

  it("full answer tag, two inputs inside answer, shorter form", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Enter values that sum to <m>3x</m>: 
  <answer>
  <mathinput /> <mathinput/>
  <award><when>$_mathinput1+$_mathinput2 = 3x</when></award>
  <award credit="0.5"><when>$_mathinput1+$_mathinput2 = 3</when></award>
  </answer></p>
  <p>First current response: <copy assignNames="cr" prop="currentResponse" target="_answer1" /></p>
  <p>First current response again: <copy assignNames="cr1" prop="currentResponse1" target="_answer1" /></p>
  <p>Second current response: <copy assignNames="cr2" prop="currentResponse2" target="_answer1" /></p>
  <p>Both current responses together: <copy assignNames="crsa crsb" prop="currentResponses" target="_answer1" /></p>
  <p>First submitted response: <copy assignNames="sr" prop="submittedResponse" target="_answer1" createComponentOfType="math" /></p>
  <p>First submitted response again: <copy assignNames="sr1" prop="submittedResponse1" target="_answer1" createComponentOfType="math" /></p>
  <p>Second submitted response: <copy assignNames="sr2" prop="submittedResponse2" target="_answer1" createComponentOfType="math" /></p>
  <p>Both submitted responses together: <copy assignNames="srsa srsb" prop="submittedResponses" target="_answer1" /></p>
  <p>Credit for submitted responses: <copy assignNames="ca" prop="creditAchieved" target="_answer1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', '');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '');

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    // cy.get(cesc(`#\\/srsa`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    // cy.get(cesc(`#\\/srsb`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "\uFF3F",
        "\uFF3F",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "\uFF3F",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "\uFF3F",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        undefined,
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        undefined,
      );
      expect(stateVariables["/_mathinput1"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/_mathinput2"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/cr"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/cr1"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/cr2"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/crsa"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/crsb"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr1"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr2"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/srsa'].stateValues.value).eq('\uFF3F')
      // expect(stateVariables['/srsb'].stateValues.value).eq('\uFF3F')
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });

    cy.log("Enter a correct answer in");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`x+y`, { force: true })
      .blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea")
      .type(`2x-y`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'x+y');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '2x-y');

    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "x+y");
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "x+y");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("have.text", "2x−y");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    // cy.get(cesc(`#\\/srsa`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    // cy.get(cesc(`#\\/srsb`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        undefined,
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        undefined,
      );
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls([
        "+",
        "x",
        "y",
      ]);
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/cr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr1"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr2"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/srsa'].stateValues.value).eq('\uFF3F')
      // expect(stateVariables['/srsb'].stateValues.value).eq('\uFF3F')
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'x+y');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '2x-y');

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "x+y");
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "x+y");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("have.text", "2x−y");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls([
        "+",
        "x",
        "y",
      ]);
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls(["+", 'x', 'y']);
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", ['*', 2, 'x'], ['-', 'y']]);
      expect(stateVariables["/cr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Enter partially correct answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
      .blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea")
      .type(`{ctrl+home}{shift+end}{backspace}3-x`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'x');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '3-x');

    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "x");
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "x");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("have.text", "3−x");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("x");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls(["+", 'x', 'y']);
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", ['*', 2, 'x'], ['-', 'y']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("x");
      expect(stateVariables["/cr1"].stateValues.value).eqls("x");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("x");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'x');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '3-x');

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "x");
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "x");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("have.text", "3−x");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("x");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls('x');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", 3, ['-', 'x']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("x");
      expect(stateVariables["/cr1"].stateValues.value).eqls("x");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("x");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls("x");
      expect(stateVariables["/sr1"].stateValues.value).eqls("x");
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls("x");
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Enter incorrect answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`{rightarrow}{backspace}y`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'y');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '3-x');

    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "y");
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "y");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("have.text", "3−x");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "y",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "y",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("y");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls('x');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", 3, ['-', 'x']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("y");
      expect(stateVariables["/cr1"].stateValues.value).eqls("y");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("y");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls("x");
      expect(stateVariables["/sr1"].stateValues.value).eqls("x");
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls("x");
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'y');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '3-x');

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "y");
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "y");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("have.text", "3−x");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "y",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "y",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "y",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "y",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("y");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls('y');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", 3, ['-', 'x']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("y");
      expect(stateVariables["/cr1"].stateValues.value).eqls("y");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("y");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls("y");
      expect(stateVariables["/sr1"].stateValues.value).eqls("y");
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls("y");
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });
  });

  it("full answer tag, copied in awards, shorter form", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <setup>
    <award name="aw1" sourcesAreResponses="_mathinput1 _mathinput2"><when>$_mathinput1+$_mathinput2 = 3x</when></award>
    <award name="aw2" credit="0.5"><when>$_mathinput1+$_mathinput2 = 3</when></award>
  </setup>

  <p>Enter values that sum to <m>3x</m>: 
  <mathinput /> <mathinput/>
  <answer>
    <copy target="aw1" createComponentOfType="award" />
    <copy target="aw2" createComponentOfType="award" />
  </answer></p>
  <p>First current response: <copy assignNames="cr" prop="currentResponse" target="_answer1" /></p>
  <p>First current response again: <copy assignNames="cr1" prop="currentResponse1" target="_answer1" /></p>
  <p>Second current response: <copy assignNames="cr2" prop="currentResponse2" target="_answer1" /></p>
  <p>Both current responses together: <copy assignNames="crsa crsb" prop="currentResponses" target="_answer1" /></p>
  <p>First submitted response: <copy assignNames="sr" prop="submittedResponse" target="_answer1" createComponentOfType="math" /></p>
  <p>First submitted response again: <copy assignNames="sr1" prop="submittedResponse1" target="_answer1" createComponentOfType="math" /></p>
  <p>Second submitted response: <copy assignNames="sr2" prop="submittedResponse2" target="_answer1" createComponentOfType="math" /></p>
  <p>Both submitted responses together: <copy assignNames="srsa srsb" prop="submittedResponses" target="_answer1" /></p>
  <p>Credit for submitted responses: <copy assignNames="ca" prop="creditAchieved" target="_answer1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', '');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '');

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    // cy.get(cesc(`#\\/srsa`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    // cy.get(cesc(`#\\/srsb`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "\uFF3F",
        "\uFF3F",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "\uFF3F",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "\uFF3F",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        undefined,
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        undefined,
      );
      expect(stateVariables["/_mathinput1"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/_mathinput2"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/cr"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/cr1"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/cr2"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/crsa"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/crsb"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr1"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr2"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/srsa'].stateValues.value).eq('\uFF3F')
      // expect(stateVariables['/srsb'].stateValues.value).eq('\uFF3F')
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });

    cy.log("Enter a correct answer in");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`x+y`, { force: true })
      .blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea")
      .type(`2x-y`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'x+y');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '2x-y');

    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "x+y");
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "x+y");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("have.text", "2x−y");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    // cy.get(cesc(`#\\/srsa`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    // cy.get(cesc(`#\\/srsb`)).find('.mjx-mrow').eq(0).invoke('text').then((text) => {
    //   expect(text.trim()).equal('＿')
    // });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        undefined,
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        undefined,
      );
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls([
        "+",
        "x",
        "y",
      ]);
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/cr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr1"].stateValues.value).eq("\uFF3F");
      expect(stateVariables["/sr2"].stateValues.value).eq("\uFF3F");
      // expect(stateVariables['/srsa'].stateValues.value).eq('\uFF3F')
      // expect(stateVariables['/srsb'].stateValues.value).eq('\uFF3F')
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'x+y');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '2x-y');

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "x+y");
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "x+y");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("have.text", "2x−y");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls([
        "+",
        "x",
        "y",
      ]);
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls(["+", 'x', 'y']);
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", ['*', 2, 'x'], ['-', 'y']]);
      expect(stateVariables["/cr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Enter partially correct answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
      .blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea")
      .type(`{ctrl+home}{shift+end}{backspace}3-x`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'x');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '3-x');

    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "x");
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "x");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("have.text", "3−x");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x+y");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2x−y");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        ["+", "x", "y"],
        ["+", ["*", 2, "x"], ["-", "y"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls([
        "+",
        "x",
        "y",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("x");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls(["+", 'x', 'y']);
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", ['*', 2, 'x'], ['-', 'y']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("x");
      expect(stateVariables["/cr1"].stateValues.value).eqls("x");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("x");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr1"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls(["+", "x", "y"]);
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        ["*", 2, "x"],
        ["-", "y"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'x');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '3-x');

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "x");
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "x");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("have.text", "3−x");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("x");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls('x');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", 3, ['-', 'x']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("x");
      expect(stateVariables["/cr1"].stateValues.value).eqls("x");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("x");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls("x");
      expect(stateVariables["/sr1"].stateValues.value).eqls("x");
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls("x");
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Enter incorrect answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`{rightarrow}{backspace}y`, { force: true })
      .blur();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'y');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '3-x');

    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "y");
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "y");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("have.text", "3−x");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "y",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "y",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "x",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "x",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("y");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls('x');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", 3, ['-', 'x']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("y");
      expect(stateVariables["/cr1"].stateValues.value).eqls("y");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("y");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls("x");
      expect(stateVariables["/sr1"].stateValues.value).eqls("x");
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls("x");
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', 'y');
    // cy.get(cesc('#\\/_mathinput2_input')).should('have.value', '3-x');

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "y");
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "y");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("have.text", "3−x");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/crsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/crsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/srsa`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc(`#\\/srsb`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3−x");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "y",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "y",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "y",
        ["+", 3, ["-", "x"]],
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "y",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/_mathinput1"].stateValues.value).eqls("y");
      // expect(stateVariables['/_mathinput1'].stateValues.submittedValue).eqls('y');
      expect(stateVariables["/_mathinput2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      // expect(stateVariables['/_mathinput2'].stateValues.submittedValue).eqls(["+", 3, ['-', 'x']]);
      expect(stateVariables["/cr"].stateValues.value).eqls("y");
      expect(stateVariables["/cr1"].stateValues.value).eqls("y");
      expect(stateVariables["/cr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/crsa"].stateValues.value).eqls("y");
      expect(stateVariables["/crsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/sr"].stateValues.value).eqls("y");
      expect(stateVariables["/sr1"].stateValues.value).eqls("y");
      expect(stateVariables["/sr2"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/srsa"].stateValues.value).eqls("y");
      expect(stateVariables["/srsb"].stateValues.value).eqls([
        "+",
        3,
        ["-", "x"],
      ]);
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });
  });

  it("full answer tag, text inputs", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Enter rain and snow in either order: <textinput/> <textinput/>
  <answer>
  <award><when><text><copy prop="immediateValue" target="_textinput1" isResponse /> <copy prop="immediateValue" target="_textinput2" isResponse /></text> = <text>rain snow</text></when></award>
  <award><when><text><copy prop="immediateValue" target="_textinput1" /> <copy prop="immediateValue" target="_textinput2" /></text> = <text>snow rain</text></when></award>
  <award credit="0.5"><when><copy prop="immediateValue" target="_textinput1" /> = rain</when></award>
  <award credit="0.5"><when><copy prop="immediateValue" target="_textinput1" /> = snow</when></award>
  <award credit="0.5"><when><copy prop="immediateValue" target="_textinput2" /> = rain</when></award>
  <award credit="0.5"><when><copy prop="immediateValue" target="_textinput2" /> = snow</when></award>
  </answer></p>
  <p>First current response: <copy assignNames="cr" prop="currentResponse" target="_answer1" /></p>
  <p>First current response again: <copy assignNames="cr1" prop="currentResponse1" target="_answer1" /></p>
  <p>Second current response: <copy assignNames="cr2" prop="currentResponse2" target="_answer1" /></p>
  <p>Both current responses together: <copy assignNames="crsa crsb" prop="currentResponses" target="_answer1" /></p>
  <p>First submitted response: <copy assignNames="sr" prop="submittedResponse" target="_answer1" createComponentOfType="text" /></p>
  <p>First submitted response again: <copy assignNames="sr1" prop="submittedResponse1" target="_answer1" createComponentOfType="text" /></p>
  <p>Second submitted response: <copy assignNames="sr2" prop="submittedResponse2" target="_answer1" createComponentOfType="text" /></p>
  <p>Both submitted responses together: <copy assignNames="srsa srsb" prop="submittedResponses" target="_answer1" /></p>
  <p>Credit for submitted responses: <copy assignNames="ca" prop="creditAchieved" target="_answer1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "");

    cy.get(cesc(`#\\/cr`)).should("have.text", "");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "");
    cy.get(cesc(`#\\/sr`)).should("have.text", "");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    // cy.get(cesc(`#\\/srsa`)).should('have.text', '＿')
    // cy.get(cesc(`#\\/srsb`)).should('have.text', '＿')
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "",
        "",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls("");
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls("");
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        undefined,
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        undefined,
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/cr"].stateValues.value).eq("");
      expect(stateVariables["/cr1"].stateValues.value).eq("");
      expect(stateVariables["/cr2"].stateValues.value).eq("");
      expect(stateVariables["/crsa"].stateValues.value).eq("");
      expect(stateVariables["/crsb"].stateValues.value).eq("");
      expect(stateVariables["/sr"].stateValues.value).eq("");
      expect(stateVariables["/sr1"].stateValues.value).eq("");
      expect(stateVariables["/sr2"].stateValues.value).eq("");
      // expect(stateVariables['/srsa'].stateValues.value).eq('\uFF3F')
      // expect(stateVariables['/srsb'].stateValues.value).eq('\uFF3F')
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });

    cy.log("Enter a correct answer in");
    cy.get(cesc("#\\/_textinput1_input")).type(`rain`).blur();
    cy.get(cesc("#\\/_textinput2_input")).type(`snow{enter}`).blur();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");

    cy.get(cesc(`#\\/cr`)).should("have.text", "rain");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "rain");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "snow");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "rain");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr`)).should("have.text", "");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    // cy.get(cesc(`#\\/srsa`)).should('have.text', '＿')
    // cy.get(cesc(`#\\/srsb`)).should('have.text', '＿')
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "rain",
        "snow",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        undefined,
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        undefined,
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("rain");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("snow");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('\uFF3F');
      expect(stateVariables["/cr"].stateValues.value).eq("rain");
      expect(stateVariables["/cr1"].stateValues.value).eq("rain");
      expect(stateVariables["/cr2"].stateValues.value).eq("snow");
      expect(stateVariables["/crsa"].stateValues.value).eq("rain");
      expect(stateVariables["/crsb"].stateValues.value).eq("snow");
      expect(stateVariables["/sr"].stateValues.value).eq("");
      expect(stateVariables["/sr1"].stateValues.value).eq("");
      expect(stateVariables["/sr2"].stateValues.value).eq("");
      // expect(stateVariables['/srsa'].stateValues.value).eq('\uFF3F')
      // expect(stateVariables['/srsb'].stateValues.value).eq('\uFF3F')
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");

    cy.get(cesc(`#\\/cr`)).should("have.text", "rain");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "rain");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "snow");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "rain");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "snow");
    cy.get(cesc(`#\\/srsa`)).should("have.text", "rain");
    cy.get(cesc(`#\\/srsb`)).should("have.text", "snow");
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "rain",
        "snow",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "rain",
        "snow",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        "snow",
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("rain");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('rain');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("snow");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('snow');
      expect(stateVariables["/cr"].stateValues.value).eq("rain");
      expect(stateVariables["/cr1"].stateValues.value).eq("rain");
      expect(stateVariables["/cr2"].stateValues.value).eq("snow");
      expect(stateVariables["/crsa"].stateValues.value).eq("rain");
      expect(stateVariables["/crsb"].stateValues.value).eq("snow");
      expect(stateVariables["/sr"].stateValues.value).eq("rain");
      expect(stateVariables["/sr1"].stateValues.value).eq("rain");
      expect(stateVariables["/sr2"].stateValues.value).eq("snow");
      expect(stateVariables["/srsa"].stateValues.value).eq("rain");
      expect(stateVariables["/srsb"].stateValues.value).eq("snow");
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Enter partially correct answer");
    cy.get(cesc("#\\/_textinput2_input")).clear().type(`rain`).blur();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "rain");

    cy.get(cesc(`#\\/cr`)).should("have.text", "rain");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "rain");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "rain");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "rain");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "snow");
    cy.get(cesc(`#\\/srsa`)).should("have.text", "rain");
    cy.get(cesc(`#\\/srsb`)).should("have.text", "snow");
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.wait(100);

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "rain",
        "rain",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "rain",
        "snow",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        "snow",
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("rain");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('rain');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("rain");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('snow');
      expect(stateVariables["/cr"].stateValues.value).eq("rain");
      expect(stateVariables["/cr1"].stateValues.value).eq("rain");
      expect(stateVariables["/cr2"].stateValues.value).eq("rain");
      expect(stateVariables["/crsa"].stateValues.value).eq("rain");
      expect(stateVariables["/crsb"].stateValues.value).eq("rain");
      expect(stateVariables["/sr"].stateValues.value).eq("rain");
      expect(stateVariables["/sr1"].stateValues.value).eq("rain");
      expect(stateVariables["/sr2"].stateValues.value).eq("snow");
      expect(stateVariables["/srsa"].stateValues.value).eq("rain");
      expect(stateVariables["/srsb"].stateValues.value).eq("snow");
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "rain");

    cy.get(cesc(`#\\/cr`)).should("have.text", "rain");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "rain");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "rain");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "rain");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "rain");
    cy.get(cesc(`#\\/srsa`)).should("have.text", "rain");
    cy.get(cesc(`#\\/srsb`)).should("have.text", "rain");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "rain",
        "rain",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "rain",
        "rain",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        "rain",
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("rain");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('rain');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("rain");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('rain');
      expect(stateVariables["/cr"].stateValues.value).eq("rain");
      expect(stateVariables["/cr1"].stateValues.value).eq("rain");
      expect(stateVariables["/cr2"].stateValues.value).eq("rain");
      expect(stateVariables["/crsa"].stateValues.value).eq("rain");
      expect(stateVariables["/crsb"].stateValues.value).eq("rain");
      expect(stateVariables["/sr"].stateValues.value).eq("rain");
      expect(stateVariables["/sr1"].stateValues.value).eq("rain");
      expect(stateVariables["/sr2"].stateValues.value).eq("rain");
      expect(stateVariables["/srsa"].stateValues.value).eq("rain");
      expect(stateVariables["/srsb"].stateValues.value).eq("rain");
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Make correct again");
    cy.get(cesc("#\\/_textinput1_input")).clear().type(`snow`).blur();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "rain");

    cy.get(cesc(`#\\/cr`)).should("have.text", "snow");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "snow");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "rain");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "snow");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "rain");
    cy.get(cesc(`#\\/srsa`)).should("have.text", "rain");
    cy.get(cesc(`#\\/srsb`)).should("have.text", "rain");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.wait(100);

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "snow",
        "rain",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "rain",
        "rain",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        "rain",
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("snow");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('rain');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("rain");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('rain');
      expect(stateVariables["/cr"].stateValues.value).eq("snow");
      expect(stateVariables["/cr1"].stateValues.value).eq("snow");
      expect(stateVariables["/cr2"].stateValues.value).eq("rain");
      expect(stateVariables["/crsa"].stateValues.value).eq("snow");
      expect(stateVariables["/crsb"].stateValues.value).eq("rain");
      expect(stateVariables["/sr"].stateValues.value).eq("rain");
      expect(stateVariables["/sr1"].stateValues.value).eq("rain");
      expect(stateVariables["/sr2"].stateValues.value).eq("rain");
      expect(stateVariables["/srsa"].stateValues.value).eq("rain");
      expect(stateVariables["/srsb"].stateValues.value).eq("rain");
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "rain");

    cy.get(cesc(`#\\/cr`)).should("have.text", "snow");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "snow");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "rain");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "snow");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "rain");
    cy.get(cesc(`#\\/sr`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "rain");
    cy.get(cesc(`#\\/srsa`)).should("have.text", "snow");
    cy.get(cesc(`#\\/srsb`)).should("have.text", "rain");
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "snow",
        "rain",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "rain",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "snow",
        "rain",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        "rain",
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("snow");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('snow');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("rain");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('rain');
      expect(stateVariables["/cr"].stateValues.value).eq("snow");
      expect(stateVariables["/cr1"].stateValues.value).eq("snow");
      expect(stateVariables["/cr2"].stateValues.value).eq("rain");
      expect(stateVariables["/crsa"].stateValues.value).eq("snow");
      expect(stateVariables["/crsb"].stateValues.value).eq("rain");
      expect(stateVariables["/sr"].stateValues.value).eq("snow");
      expect(stateVariables["/sr1"].stateValues.value).eq("snow");
      expect(stateVariables["/sr2"].stateValues.value).eq("rain");
      expect(stateVariables["/srsa"].stateValues.value).eq("snow");
      expect(stateVariables["/srsb"].stateValues.value).eq("rain");
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Enter another partially correct answer");
    cy.get(cesc("#\\/_textinput2_input")).clear().type(`snow`).blur();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");

    cy.get(cesc(`#\\/cr`)).should("have.text", "snow");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "snow");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "snow");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "snow");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "rain");
    cy.get(cesc(`#\\/srsa`)).should("have.text", "snow");
    cy.get(cesc(`#\\/srsb`)).should("have.text", "rain");
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.wait(100);

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "snow",
        "snow",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "snow",
        "rain",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        "rain",
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("snow");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('snow');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("snow");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('rain');
      expect(stateVariables["/cr"].stateValues.value).eq("snow");
      expect(stateVariables["/cr1"].stateValues.value).eq("snow");
      expect(stateVariables["/cr2"].stateValues.value).eq("snow");
      expect(stateVariables["/crsa"].stateValues.value).eq("snow");
      expect(stateVariables["/crsb"].stateValues.value).eq("snow");
      expect(stateVariables["/sr"].stateValues.value).eq("snow");
      expect(stateVariables["/sr1"].stateValues.value).eq("snow");
      expect(stateVariables["/sr2"].stateValues.value).eq("rain");
      expect(stateVariables["/srsa"].stateValues.value).eq("snow");
      expect(stateVariables["/srsb"].stateValues.value).eq("rain");
      expect(stateVariables["/ca"].stateValues.value).eq(1);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");

    cy.get(cesc(`#\\/cr`)).should("have.text", "snow");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "snow");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "snow");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "snow");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "snow");
    cy.get(cesc(`#\\/srsa`)).should("have.text", "snow");
    cy.get(cesc(`#\\/srsb`)).should("have.text", "snow");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "snow",
        "snow",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "snow",
        "snow",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        "snow",
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("snow");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('snow');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("snow");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('snow');
      expect(stateVariables["/cr"].stateValues.value).eq("snow");
      expect(stateVariables["/cr1"].stateValues.value).eq("snow");
      expect(stateVariables["/cr2"].stateValues.value).eq("snow");
      expect(stateVariables["/crsa"].stateValues.value).eq("snow");
      expect(stateVariables["/crsb"].stateValues.value).eq("snow");
      expect(stateVariables["/sr"].stateValues.value).eq("snow");
      expect(stateVariables["/sr1"].stateValues.value).eq("snow");
      expect(stateVariables["/sr2"].stateValues.value).eq("snow");
      expect(stateVariables["/srsa"].stateValues.value).eq("snow");
      expect(stateVariables["/srsb"].stateValues.value).eq("snow");
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Enter incorrect answer");
    cy.get(cesc("#\\/_textinput1_input")).clear().type(`fog`).blur();
    cy.get(cesc("#\\/_textinput2_input")).clear().type(`hail`).blur();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "fog");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "hail");

    cy.get(cesc(`#\\/cr`)).should("have.text", "fog");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "fog");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hail");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "fog");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "hail");
    cy.get(cesc(`#\\/sr`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "snow");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "snow");
    cy.get(cesc(`#\\/srsa`)).should("have.text", "snow");
    cy.get(cesc(`#\\/srsb`)).should("have.text", "snow");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.wait(100);

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "fog",
        "hail",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "fog",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "hail",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "snow",
        "snow",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "snow",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        "snow",
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("fog");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('snow');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("hail");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('snow');
      expect(stateVariables["/cr"].stateValues.value).eq("fog");
      expect(stateVariables["/cr1"].stateValues.value).eq("fog");
      expect(stateVariables["/cr2"].stateValues.value).eq("hail");
      expect(stateVariables["/crsa"].stateValues.value).eq("fog");
      expect(stateVariables["/crsb"].stateValues.value).eq("hail");
      expect(stateVariables["/sr"].stateValues.value).eq("snow");
      expect(stateVariables["/sr1"].stateValues.value).eq("snow");
      expect(stateVariables["/sr2"].stateValues.value).eq("snow");
      expect(stateVariables["/srsa"].stateValues.value).eq("snow");
      expect(stateVariables["/srsb"].stateValues.value).eq("snow");
      expect(stateVariables["/ca"].stateValues.value).eq(0.5);
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "fog");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "hail");

    cy.get(cesc(`#\\/cr`)).should("have.text", "fog");
    cy.get(cesc(`#\\/cr1`)).should("have.text", "fog");
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hail");
    cy.get(cesc(`#\\/crsa`)).should("have.text", "fog");
    cy.get(cesc(`#\\/crsb`)).should("have.text", "hail");
    cy.get(cesc(`#\\/sr`)).should("have.text", "fog");
    cy.get(cesc(`#\\/sr1`)).should("have.text", "fog");
    cy.get(cesc(`#\\/sr2`)).should("have.text", "hail");
    cy.get(cesc(`#\\/srsa`)).should("have.text", "fog");
    cy.get(cesc(`#\\/srsb`)).should("have.text", "hail");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Test internal values");
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "fog",
        "hail",
      ]);
      expect(stateVariables["/_answer1"].stateValues.currentResponse1).eqls(
        "fog",
      );
      expect(stateVariables["/_answer1"].stateValues.currentResponse2).eqls(
        "hail",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "fog",
        "hail",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponse1).eqls(
        "fog",
      );
      expect(stateVariables["/_answer1"].stateValues.submittedResponse2).eqls(
        "hail",
      );
      expect(stateVariables["/_textinput1"].stateValues.value).eq("fog");
      // expect(stateVariables['/_textinput1'].stateValues.submittedValue).eq('fog');
      expect(stateVariables["/_textinput2"].stateValues.value).eq("hail");
      // expect(stateVariables['/_textinput2'].stateValues.submittedValue).eq('hail');
      expect(stateVariables["/cr"].stateValues.value).eq("fog");
      expect(stateVariables["/cr1"].stateValues.value).eq("fog");
      expect(stateVariables["/cr2"].stateValues.value).eq("hail");
      expect(stateVariables["/crsa"].stateValues.value).eq("fog");
      expect(stateVariables["/crsb"].stateValues.value).eq("hail");
      expect(stateVariables["/sr"].stateValues.value).eq("fog");
      expect(stateVariables["/sr1"].stateValues.value).eq("fog");
      expect(stateVariables["/sr2"].stateValues.value).eq("hail");
      expect(stateVariables["/srsa"].stateValues.value).eq("fog");
      expect(stateVariables["/srsb"].stateValues.value).eq("hail");
      expect(stateVariables["/ca"].stateValues.value).eq(0);
    });
  });

  it("answer inequalities", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  Enter enter number larger than 5 or less than 2: 
  <answer>
  <mathinput name="m" />
  <award sourcesAreResponses="m"><when>$m > 5</when></award>
  <award><when>$m < <math>2</math></when></award>
  </answer>
  <p>Submitted response: <copy assignNames="sr" prop="submittedResponse" target="_answer1" /></p>
  <p>Credit achieved: <copy assignNames="ca" prop="creditAchieved" target="_answer1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.log("Test initial values");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Submit a correct answer");
    cy.get(cesc("#\\/m") + " textarea").type(`6`, { force: true });
    cy.get(cesc("#\\/m_submit")).click();

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "6");
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Submit an incorrect answer");
    cy.get(cesc("#\\/m") + " textarea").type(`{rightarrow}{backspace}5`, {
      force: true,
    });
    cy.get(cesc("#\\/m_submit")).click();

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "5");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.log("Submit a different correct answer");
    cy.get(cesc("#\\/m") + " textarea").type(`{rightarrow}{backspace}-3`, {
      force: true,
    });
    cy.get(cesc("#\\/m_submit")).click();

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "−3");
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Submit a correct answer that must be simplified");
    cy.get(cesc("#\\/m") + " textarea").type(
      `{end}{backspace}{backspace}5xy-5xy+9`,
      { force: true },
    );
    cy.get(cesc("#\\/m_submit")).click();

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "5xy−5xy+9");
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.log("Submit a non-numerical answer");
    cy.get(cesc("#\\/m") + " textarea").type(`{end}{leftarrow}{leftarrow}z`, {
      force: true,
    });
    cy.get(cesc("#\\/m_submit")).click();

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "5xy−5xyz+9");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");
  });

  it("answer extended inequalities", () => {
    cy.log("Number between -1 and 1, inclusive");
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer><mathinput/>
  <award><when>-1 <= <copy prop="immediateValue" target="_mathinput1" isResponse /> <= 1</when></award>
  </answer>
  <p>Submitted response: <copy assignNames="sr" prop="submittedResponse" target="_answer1" /></p>
  <p>Credit achieved: <copy assignNames="ca" prop="creditAchieved" target="_answer1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', '');

    let answers1 = {
      1: "1",
      "-1": "1",
      0.5: "1",
      1.1: "0",
      "-2": "0",
      "x-x": "1",
      x: "0",
    };

    for (let answerString in answers1) {
      cy.get(cesc("#\\/_mathinput1") + " textarea").type(
        "{ctrl+home}{shift+end}{backspace}" + answerString,
        { delay: 5, force: true },
      );
      cy.get(cesc("#\\/_mathinput1_submit")).click();

      cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should(
        "have.text",
        answerString.replace(/-/g, "−"),
      );
      cy.get(cesc(`#\\/ca`)).should("have.text", answers1[answerString]);
    }

    cy.wait(500);

    cy.log("Number between -1 and 1, exclusive");
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>b</text>
  <answer><mathinput/>
  <award><when>-1 < <copy prop="immediateValue" isResponse target="_mathinput1" /> < 1</when></award>
  </answer>
  <p>Submitted response: <copy assignNames="sr" prop="submittedResponse" target="_answer1" /></p>
  <p>Credit achieved: <copy assignNames="ca" prop="creditAchieved" target="_answer1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "b"); // to wait until loaded

    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', '');

    let answers2 = {
      1: "0",
      "-1": "0",
      0.5: "1",
      0.99: "1",
      "-2": "0",
      "x-x": "1",
      x: "0",
    };
    for (let answerString in answers2) {
      cy.get(cesc("#\\/_mathinput1") + " textarea").type(
        "{ctrl+home}{shift+end}{backspace}" + answerString,
        { delay: 5, force: true },
      );
      cy.get(cesc("#\\/_mathinput1_submit")).click();

      cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should(
        "have.text",
        answerString.replace(/-/g, "−"),
      );
      cy.get(cesc(`#\\/ca`)).should("have.text", answers2[answerString]);
    }

    cy.wait(500);

    cy.log("Number between -1 and 1, as greater than");
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>c</text>
  <answer><mathinput/>
  <award><when>1 > <copy prop="immediateValue" isResponse target="_mathinput1" /> >= -1</when></award>
  </answer>
  <p>Submitted response: <copy assignNames="sr" prop="submittedResponse" target="_answer1" /></p>
  <p>Credit achieved: <copy assignNames="ca" prop="creditAchieved" target="_answer1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "c"); // to wait until loaded

    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', '');

    let answers3 = {
      1: "0",
      "-1": "1",
      0.5: "1",
      0.99: "1",
      "-2": "0",
      "x-x": "1",
      x: "0",
    };

    for (let answerString in answers3) {
      cy.get(cesc("#\\/_mathinput1") + " textarea").type(
        "{ctrl+home}{shift+end}{backspace}" + answerString,
        { delay: 5, force: true },
      );
      cy.get(cesc("#\\/_mathinput1_submit")).click();

      cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should(
        "have.text",
        answerString.replace(/-/g, "−"),
      );
      cy.get(cesc(`#\\/ca`)).should("have.text", answers3[answerString]);
    }
  });

  it("compound logic", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <mathinput/> <mathinput/> <mathinput/>
  <answer>
    <award><when>
      ((<copy prop="immediateValue" target="_mathinput1" isResponse /> = x
      and <copy prop="immediateValue" target="_mathinput2" isResponse /> != <copy prop="immediateValue" target="_mathinput1"  />)
      or
      (<copy prop="immediateValue" target="_mathinput1" /> = <math>y</math>
      and <copy prop="immediateValue" target="_mathinput2" /> != z
      and <copy prop="immediateValue" target="_mathinput2" /> != q))
      and <copy prop="immediateValue" target="_mathinput3" isResponse /> > 5
   </when></award>
  </answer>
  <p>Submitted responses: <copy assignNames="sr1 sr2 sr3" prop="submittedResponses" target="_answer1" /></p>
  <p>Credit achieved: <copy assignNames="ca" prop="creditAchieved" target="_answer1" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    // cy.get(cesc('#\\/_mathinput1_input')).should('have.value', '');

    let answers1 = [
      ["1", "x", "z", "6"],
      ["0", "x", "x", "6"],
      ["0", "x", "z", "5"],
      ["1", "y", "y", "7"],
      ["0", "y", "z", "7"],
      ["0", "y", "q", "7"],
      ["1", "y", "y^2", "7"],
      ["0", "y", "y", "a"],
    ];

    for (let answer of answers1) {
      cy.get(cesc("#\\/_mathinput1") + " textarea")
        .type("{end}{backspace}" + answer[1], { delay: 5, force: true })
        .blur();
      cy.get(cesc("#\\/_mathinput2") + " textarea")
        .type("{ctrl+home}{shift+end}{backspace}" + answer[2], {
          delay: 5,
          force: true,
        })
        .blur();
      cy.get(cesc("#\\/_mathinput3") + " textarea")
        .type("{end}{backspace}" + answer[3], { delay: 5, force: true })
        .blur();
      cy.get(cesc("#\\/_answer1_submit")).click();

      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", answer[1]);
      cy.get(cesc("#\\/sr2") + " .mjx-mrow").should(
        "contain.text",
        answer[2].replace("^", ""),
      );
      cy.get(cesc("#\\/sr3") + " .mjx-mrow").should("have.text", answer[3]);

      cy.get(cesc("#\\/ca")).should("have.text", answer[0]);
    }
  });

  it("answer inside map", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
    <text>a</text>
    <map assignNames="a b c">
      <template newNamespace>
        <p>Enter <m>x^$n</m>: <answer><award><math>x^$n</math></award></answer></p>
        <p>Credit achieved: <copy prop="creditAchieved" target="_answer1" assignNames="ca" /></p>
        <p>Current response: <copy prop="currentResponse" target="_answer1" assignNames="cr" /></p>
        <p>Submitted response: <copy prop="submittedResponse" target="_answer1" createComponentOfType="math" assignNames="sr" /></p>
      </template>
      <sources alias="n"><sequence from="1" to="3" /></sources>
    </map>
    `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      let mathinput1Name =
        stateVariables["/a/_answer1"].stateValues.inputChildren[0]
          .componentName;
      let mathinput1Anchor = cesc2("#" + mathinput1Name) + " textarea";
      let mathinput1SubmitAnchor = cesc2("#" + mathinput1Name + "_submit");

      let mathinput2Name =
        stateVariables["/b/_answer1"].stateValues.inputChildren[0]
          .componentName;
      let mathinput2Anchor = cesc2("#" + mathinput2Name) + " textarea";
      let mathinput2SubmitAnchor = cesc2("#" + mathinput2Name + "_submit");

      let mathinput3Name =
        stateVariables["/c/_answer1"].stateValues.inputChildren[0]
          .componentName;
      let mathinput3Anchor = cesc2("#" + mathinput3Name) + " textarea";
      let mathinput3SubmitAnchor = cesc2("#" + mathinput3Name + "_submit");

      cy.log("Test value displayed in browser");
      // cy.get(mathinput1Anchor).should('have.value', '');
      // cy.get(mathinput2Anchor).should('have.value', '');
      // cy.get(mathinput3Anchor).should('have.value', '');
      cy.get(cesc("#\\/a\\/ca")).should("have.text", "0");
      cy.get(cesc("#\\/b\\/ca")).should("have.text", "0");
      cy.get(cesc("#\\/c\\/ca")).should("have.text", "0");
      cy.get(cesc("#\\/a\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/b\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/c\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/a\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/b\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/c\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/a/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/a/_answer1"].stateValues.currentResponses).eqls(
          ["\uFF3F"],
        );
        expect(
          stateVariables["/a/_answer1"].stateValues.submittedResponses,
        ).eqls([]);
        expect(stateVariables[mathinput1Name].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinput1Name].stateValues.submittedValue).eq('\uFF3F');
        expect(stateVariables["/b/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/b/_answer1"].stateValues.currentResponses).eqls(
          ["\uFF3F"],
        );
        expect(
          stateVariables["/b/_answer1"].stateValues.submittedResponses,
        ).eqls([]);
        expect(stateVariables[mathinput2Name].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinput2Name].stateValues.submittedValue).eq('\uFF3F');
        expect(stateVariables["/c/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/c/_answer1"].stateValues.currentResponses).eqls(
          ["\uFF3F"],
        );
        expect(
          stateVariables["/c/_answer1"].stateValues.submittedResponses,
        ).eqls([]);
        expect(stateVariables[mathinput3Name].stateValues.value).eq("\uFF3F");
        // expect(stateVariables[mathinput3Name].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Enter correct answer in all three blanks");
      cy.get(mathinput1Anchor).type(`x`, { force: true }).blur();
      cy.get(mathinput2Anchor).type(`x^2`, { force: true }).blur();
      cy.get(mathinput3Anchor).type(`x^3`, { force: true }).blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinput1Anchor).should('have.value', 'x');
      // cy.get(mathinput2Anchor).should('have.value', 'x^2');
      // cy.get(mathinput3Anchor).should('have.value', 'x^3');

      cy.get(cesc("#\\/a\\/cr") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/b\\/cr") + " .mjx-mrow").should("contain.text", "x2");
      cy.get(cesc("#\\/c\\/cr") + " .mjx-mrow").should("contain.text", "x3");

      cy.get(cesc("#\\/a\\/ca")).should("have.text", "0");
      cy.get(cesc("#\\/b\\/ca")).should("have.text", "0");
      cy.get(cesc("#\\/c\\/ca")).should("have.text", "0");
      cy.get(cesc("#\\/a\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/b\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x2");
        });
      cy.get(cesc("#\\/c\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x3");
        });
      cy.get(cesc("#\\/a\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/b\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });
      cy.get(cesc("#\\/c\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("＿");
        });

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/a/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/a/_answer1"].stateValues.currentResponses).eqls(
          ["x"],
        );
        expect(
          stateVariables["/a/_answer1"].stateValues.submittedResponses,
        ).eqls([]);
        expect(stateVariables[mathinput1Name].stateValues.value).eq("x");
        // expect(stateVariables[mathinput1Name].stateValues.submittedValue).eq('\uFF3F');
        expect(stateVariables["/b/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/b/_answer1"].stateValues.currentResponses).eqls(
          [["^", "x", 2]],
        );
        expect(
          stateVariables["/b/_answer1"].stateValues.submittedResponses,
        ).eqls([]);
        expect(stateVariables[mathinput2Name].stateValues.value).eqls([
          "^",
          "x",
          2,
        ]);
        // expect(stateVariables[mathinput2Name].stateValues.submittedValue).eq('\uFF3F');
        expect(stateVariables["/c/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/c/_answer1"].stateValues.currentResponses).eqls(
          [["^", "x", 3]],
        );
        expect(
          stateVariables["/c/_answer1"].stateValues.submittedResponses,
        ).eqls([]);
        expect(stateVariables[mathinput3Name].stateValues.value).eqls([
          "^",
          "x",
          3,
        ]);
        // expect(stateVariables[mathinput3Name].stateValues.submittedValue).eq('\uFF3F');
      });

      cy.log("Submit answers");
      cy.get(mathinput1SubmitAnchor).click();
      cy.get(mathinput2SubmitAnchor).click();
      cy.get(mathinput3SubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinput1Anchor).should('have.value', 'x');
      // cy.get(mathinput2Anchor).should('have.value', 'x^2');
      // cy.get(mathinput3Anchor).should('have.value', 'x^3');

      cy.get(cesc("#\\/a\\/ca")).should("have.text", "1");
      cy.get(cesc("#\\/b\\/ca")).should("have.text", "1");
      cy.get(cesc("#\\/c\\/ca")).should("have.text", "1");
      cy.get(cesc("#\\/a\\/sr") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/b\\/sr") + " .mjx-mrow").should("contain.text", "x2");
      cy.get(cesc("#\\/c\\/sr") + " .mjx-mrow").should("contain.text", "x3");
      cy.get(cesc("#\\/a\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/b\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x2");
        });
      cy.get(cesc("#\\/c\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x3");
        });
      cy.get(cesc("#\\/a\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/b\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x2");
        });
      cy.get(cesc("#\\/c\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x3");
        });

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/a/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/a/_answer1"].stateValues.currentResponses).eqls(
          ["x"],
        );
        expect(
          stateVariables["/a/_answer1"].stateValues.submittedResponses,
        ).eqls(["x"]);
        expect(stateVariables[mathinput1Name].stateValues.value).eq("x");
        // expect(stateVariables[mathinput1Name].stateValues.submittedValue).eq('x');
        expect(stateVariables["/b/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/b/_answer1"].stateValues.currentResponses).eqls(
          [["^", "x", 2]],
        );
        expect(
          stateVariables["/b/_answer1"].stateValues.submittedResponses,
        ).eqls([["^", "x", 2]]);
        expect(stateVariables[mathinput2Name].stateValues.value).eqls([
          "^",
          "x",
          2,
        ]);
        // expect(stateVariables[mathinput2Name].stateValues.submittedValue).eqls(['^', 'x', 2]);
        expect(stateVariables["/c/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/c/_answer1"].stateValues.currentResponses).eqls(
          [["^", "x", 3]],
        );
        expect(
          stateVariables["/c/_answer1"].stateValues.submittedResponses,
        ).eqls([["^", "x", 3]]);
        expect(stateVariables[mathinput3Name].stateValues.value).eqls([
          "^",
          "x",
          3,
        ]);
        // expect(stateVariables[mathinput3Name].stateValues.submittedValue).eqls(['^', 'x', 3]);
      });

      cy.log("Enter wrong answers");
      cy.get(mathinput1Anchor)
        .type(`{end}{backspace}u`, { force: true })
        .blur();
      cy.get(mathinput2Anchor)
        .type(`{ctrl+home}{shift+end}{backspace}v`, { force: true })
        .blur();
      cy.get(mathinput3Anchor)
        .type(`{ctrl+home}{shift+end}{backspace}w`, { force: true })
        .blur();

      cy.log("Test value displayed in browser");
      // cy.get(mathinput1Anchor).should('have.value', 'u');
      // cy.get(mathinput2Anchor).should('have.value', 'v');
      // cy.get(mathinput3Anchor).should('have.value', 'w');

      cy.get(cesc("#\\/a\\/cr") + " .mjx-mrow").should("have.text", "u");
      cy.get(cesc("#\\/b\\/cr") + " .mjx-mrow").should("have.text", "v");
      cy.get(cesc("#\\/c\\/cr") + " .mjx-mrow").should("have.text", "w");

      cy.get(cesc("#\\/a\\/ca")).should("have.text", "1");
      cy.get(cesc("#\\/b\\/ca")).should("have.text", "1");
      cy.get(cesc("#\\/c\\/ca")).should("have.text", "1");

      cy.get(cesc("#\\/a\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("u");
        });
      cy.get(cesc("#\\/b\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("v");
        });
      cy.get(cesc("#\\/c\\/cr") + " .mjx-mrow").should("have.text", "w");
      cy.get(cesc("#\\/c\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("w");
        });
      cy.get(cesc("#\\/a\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x");
        });
      cy.get(cesc("#\\/b\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x2");
        });
      cy.get(cesc("#\\/c\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("x3");
        });

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/a/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/a/_answer1"].stateValues.currentResponses).eqls(
          ["u"],
        );
        expect(
          stateVariables["/a/_answer1"].stateValues.submittedResponses,
        ).eqls(["x"]);
        expect(stateVariables[mathinput1Name].stateValues.value).eq("u");
        // expect(stateVariables[mathinput1Name].stateValues.submittedValue).eq('x');
        expect(stateVariables["/b/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/b/_answer1"].stateValues.currentResponses).eqls(
          ["v"],
        );
        expect(
          stateVariables["/b/_answer1"].stateValues.submittedResponses,
        ).eqls([["^", "x", 2]]);
        expect(stateVariables[mathinput2Name].stateValues.value).eq("v");
        // expect(stateVariables[mathinput2Name].stateValues.submittedValue).eqls(['^', 'x', 2]);
        expect(stateVariables["/c/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/c/_answer1"].stateValues.currentResponses).eqls(
          ["w"],
        );
        expect(
          stateVariables["/c/_answer1"].stateValues.submittedResponses,
        ).eqls([["^", "x", 3]]);
        expect(stateVariables[mathinput3Name].stateValues.value).eq("w");
        // expect(stateVariables[mathinput3Name].stateValues.submittedValue).eqls(['^', 'x', 3]);
      });

      cy.log("Submit answers");
      cy.get(mathinput1SubmitAnchor).click();
      cy.get(mathinput2SubmitAnchor).click();
      cy.get(mathinput3SubmitAnchor).click();

      cy.log("Test value displayed in browser");
      // cy.get(mathinput1Anchor).should('have.value', 'u');
      // cy.get(mathinput2Anchor).should('have.value', 'v');
      // cy.get(mathinput3Anchor).should('have.value', 'w');

      cy.get(cesc("#\\/a\\/ca")).should("have.text", "0");
      cy.get(cesc("#\\/b\\/ca")).should("have.text", "0");
      cy.get(cesc("#\\/c\\/ca")).should("have.text", "0");

      cy.get(cesc("#\\/a\\/sr") + " .mjx-mrow").should("have.text", "u");
      cy.get(cesc("#\\/b\\/sr") + " .mjx-mrow").should("have.text", "v");
      cy.get(cesc("#\\/c\\/sr") + " .mjx-mrow").should("have.text", "w");

      cy.get(cesc("#\\/a\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("u");
        });
      cy.get(cesc("#\\/b\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("v");
        });
      cy.get(cesc("#\\/c\\/cr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("w");
        });
      cy.get(cesc("#\\/a\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("u");
        });
      cy.get(cesc("#\\/b\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("v");
        });
      cy.get(cesc("#\\/c\\/sr"))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("w");
        });

      cy.log("Test internal values");
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/a/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/a/_answer1"].stateValues.currentResponses).eqls(
          ["u"],
        );
        expect(
          stateVariables["/a/_answer1"].stateValues.submittedResponses,
        ).eqls(["u"]);
        expect(stateVariables[mathinput1Name].stateValues.value).eq("u");
        // expect(stateVariables[mathinput1Name].stateValues.submittedValue).eq('u');
        expect(stateVariables["/b/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/b/_answer1"].stateValues.currentResponses).eqls(
          ["v"],
        );
        expect(
          stateVariables["/b/_answer1"].stateValues.submittedResponses,
        ).eqls(["v"]);
        expect(stateVariables[mathinput2Name].stateValues.value).eq("v");
        // expect(stateVariables[mathinput2Name].stateValues.submittedValue).eq('v');
        expect(stateVariables["/c/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/c/_answer1"].stateValues.currentResponses).eqls(
          ["w"],
        );
        expect(
          stateVariables["/c/_answer1"].stateValues.submittedResponses,
        ).eqls(["w"]);
        expect(stateVariables[mathinput3Name].stateValues.value).eq("w");
        // expect(stateVariables[mathinput3Name].stateValues.submittedValue).eq('w');
      });
    });
  });

  it("integrated submit buttons", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer>
    <award><math>x+y</math></award>
    <award credit="0.3215"><math>x+z</math></award>
  </answer></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");
      let mathinputPartialAnchor = cesc2("#" + mathinputName + "_partial");

      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x+y`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Press enter");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Add space");
      cy.get(mathinputAnchor).type(`{end} `, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+yz');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Press enter");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Delete space");
      cy.get(mathinputAnchor).type(`{end}{backspace}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+yz');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Press enter");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Add letter");
      cy.get(mathinputAnchor).type(`{end}z`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+yz');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Delete letter (no longer goes back to saying correct)");
      cy.get(mathinputAnchor).type(`{end}{backspace}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Delete more");
      cy.get(mathinputAnchor).type(`{end}{backspace}{backspace}`, {
        force: true,
      });
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Back to correct (no longer goes back to saying correct)");
      cy.get(mathinputAnchor).type(`{end}+y`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Press enter");
      cy.get(mathinputAnchor).type(`{enter}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+y');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Delete again");
      cy.get(mathinputAnchor).type(`{end}{backspace}{backspace}`, {
        force: true,
      });
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Press enter on submit button");
      cy.get(mathinputSubmitAnchor).type(`{enter}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("be.visible");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Add letter");
      cy.get(mathinputAnchor).type(`{end}a`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'xa');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Delete letter (no longer goes back to saying incorrect)");
      cy.get(mathinputAnchor).type(`{end}{backspace}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Delete all");
      cy.get(mathinputAnchor).type(`{end}{backspace}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', '');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log(
        "Restore incorrect submitted answer (no longer goes back to saying incorrect)",
      );
      cy.get(mathinputAnchor).type(`x`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(mathinputSubmitAnchor).click();
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("be.visible");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Enter partially correct answer");
      cy.get(mathinputAnchor).type(`{end}+z`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+z');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(mathinputSubmitAnchor).click();
      // cy.get(mathinputAnchor).should('have.value', 'x+z');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("have.text", "32 %");

      cy.log("Add letter");
      cy.get(mathinputAnchor).type(`{end}z`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+zz');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Delete letter (no longer goes back to saying partially correct)");
      cy.get(mathinputAnchor).type(`{end}{backspace}`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+z');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Delete more");
      cy.get(mathinputAnchor).type(`{end}{backspace}{backspace}`, {
        force: true,
      });
      // cy.get(mathinputAnchor).should('have.value', 'x');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log(
        "Back to partial (no longer goes back to saying partially correct)",
      );
      cy.get(mathinputAnchor).type(`{end}+z`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+z');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(mathinputSubmitAnchor).click();
      // cy.get(mathinputAnchor).should('have.value', 'x+z');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("have.text", "32 %");

      cy.log("Enter invalid answer");
      cy.get(mathinputAnchor).type(`{end}/`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+z');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(mathinputSubmitAnchor).click();
      // cy.get(mathinputAnchor).should('have.value', 'x+z/');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("be.visible");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Another invalid answer shows submit button again");
      cy.get(mathinputAnchor).type(`{end}^`, { force: true });
      // cy.get(mathinputAnchor).should('have.value', 'x+z/^');
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(mathinputSubmitAnchor).click();
      // cy.get(mathinputAnchor).should('have.value', 'x+z/^');
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("be.visible");
      cy.get(mathinputPartialAnchor).should("not.exist");
    });
  });

  it("integrated submit buttons, text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer type="text">
    <award><text>hello there</text></award>
    <award credit="0.3215"><text>bye</text></award>
  </answer></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");
      let textinputCorrectAnchor = cesc2("#" + textinputName + "_correct");
      let textinputIncorrectAnchor = cesc2("#" + textinputName + "_incorrect");
      let textinputPartialAnchor = cesc2("#" + textinputName + "_partial");

      cy.get(textinputAnchor).should("have.value", "");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(`hello there`);
      cy.get(textinputAnchor).should("have.value", "hello there");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Press enter");
      cy.get(textinputAnchor).type(`{enter}`);
      cy.get(textinputAnchor).should("have.value", "hello there");
      cy.get(textinputSubmitAnchor).should("not.exist");
      cy.get(textinputCorrectAnchor).should("be.visible");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Add letter");
      cy.get(textinputAnchor).type(`z`);
      cy.get(textinputAnchor).should("have.value", "hello therez");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Delete letter (no longer goes back to saying correct)");
      cy.get(textinputAnchor).type(`{backspace}`);
      cy.get(textinputAnchor).should("have.value", "hello there");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Delete more");
      cy.get(textinputAnchor).type(`{backspace}{backspace}`);
      cy.get(textinputAnchor).should("have.value", "hello the");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Back to correct");
      cy.get(textinputAnchor).type(`re`);
      cy.get(textinputAnchor).should("have.value", "hello there");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Press enter");
      cy.get(textinputAnchor).type(`{enter}`);
      cy.get(textinputAnchor).should("have.value", "hello there");
      cy.get(textinputSubmitAnchor).should("not.exist");
      cy.get(textinputCorrectAnchor).should("be.visible");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Add a space");
      cy.get(textinputAnchor).type(` `);
      cy.get(textinputAnchor).should("have.value", "hello there ");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Press enter");
      cy.get(textinputAnchor).type(`{enter}`);
      cy.get(textinputAnchor).should("have.value", "hello there ");
      cy.get(textinputSubmitAnchor).should("not.exist");
      cy.get(textinputCorrectAnchor).should("be.visible");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Delete again");
      cy.get(textinputAnchor).type(`{backspace}{backspace}{backspace}`);
      cy.get(textinputAnchor).should("have.value", "hello the");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Press enter on submit button");
      cy.get(textinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(textinputAnchor).should("have.value", "hello the");
      cy.get(textinputSubmitAnchor).should("not.exist");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("be.visible");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Add letter");
      cy.get(textinputAnchor).type(`a`);
      cy.get(textinputAnchor).should("have.value", "hello thea");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Delete letter (no longer goes back to saying incorrect)");
      cy.get(textinputAnchor).type(`{backspace}`);
      cy.get(textinputAnchor).should("have.value", "hello the");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Delete all");
      cy.get(textinputAnchor).clear();
      cy.get(textinputAnchor).should("have.value", "");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log(
        "Restore incorrect submitted answer (no longer goes back to saying incorrect)",
      );
      cy.get(textinputAnchor).type(`hello the`);
      cy.get(textinputAnchor).should("have.value", "hello the");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Press enter");
      cy.get(textinputAnchor).type(`{enter}`);
      cy.get(textinputAnchor).should("have.value", "hello the");
      cy.get(textinputSubmitAnchor).should("not.exist");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("be.visible");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Enter partially correct answer");
      cy.get(textinputAnchor).clear().type(`bye`);
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(textinputSubmitAnchor).click();
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(textinputSubmitAnchor).should("not.exist");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("have.text", "32 %");

      cy.log("Add letter");
      cy.get(textinputAnchor).type(`z`);
      cy.get(textinputAnchor).should("have.value", "byez");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Delete letter (no longer goes back to saying partially correct)");
      cy.get(textinputAnchor).type(`{backspace}`);
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Delete more");
      cy.get(textinputAnchor).type(`{backspace}{backspace}`);
      cy.get(textinputAnchor).should("have.value", "b");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log(
        "Back to partial (no longer goes back to saying partially correct)",
      );
      cy.get(textinputAnchor).type(`ye`);
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(textinputSubmitAnchor).click();
      cy.get(textinputAnchor).should("have.value", "bye");
      cy.get(textinputSubmitAnchor).should("not.exist");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");
      cy.get(textinputPartialAnchor).should("have.text", "32 %");
    });
  });

  it("submit buttons with two answer blanks", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Enter values that sum to <m>3x</m>: <mathinput/> <mathinput/>
  <answer>
  <award><when><math><copy prop="immediateValue" target="_mathinput1" isResponse />+<copy prop="immediateValue" target="_mathinput2" isResponse /></math> = <math>3x</math></when></award>
  <award credit="0.5"><when><math><copy prop="immediateValue" target="_mathinput1" />+<copy prop="immediateValue" target="_mathinput2" /></math> = <math>3</math></when></award>
  </answer></p>

  <p><copy prop="immediateValue" target="_mathinput1" /></p>
  <p><copy prop="immediateValue" target="_mathinput2" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Enter correct answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea").type(`x+y`, { force: true });
    cy.get(cesc("#\\/_mathinput2") + " textarea").type(`2x-y`, { force: true });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_mathinput2") + " textarea").blur();
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Type letter in input1");
    cy.get(cesc("#\\/_mathinput1") + " textarea").type("{end}z", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Delete letter (no longer goes back to saying correct)");
    cy.get(cesc("#\\/_mathinput1") + " textarea").type("{end}{backspace}", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Type letter in input2");
    cy.get(cesc("#\\/_mathinput1") + " textarea").blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea").type("{end}q", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Delete letter (no longer goes back to saying correct)");
    cy.get(cesc("#\\/_mathinput2") + " textarea").type("{end}{backspace}", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Type letter in input1");
    cy.get(cesc("#\\/_mathinput1") + " textarea").type("{end}z", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Type letter in input2");
    cy.get(cesc("#\\/_mathinput1") + " textarea").blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea").type("{end}q", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Delete letter in input1");
    cy.get(cesc("#\\/_mathinput1") + " textarea").type("{end}{backspace}", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Don't go back to saying correct if return to previous answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea").blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea")
      .type("{end}{backspace}", { force: true })
      .blur();
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Enter partially correct answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`{ctrl+home}{shift+end}{backspace}x`, { force: true })
      .blur();
    cy.get(cesc("#\\/_mathinput2") + " textarea")
      .type(`{ctrl+home}{shift+end}{backspace}3-x`, { force: true })
      .blur();
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("50% correct");
      });

    cy.log("Delete letter in input1");
    cy.get(cesc("#\\/_mathinput1") + " textarea").type("{end}{backspace}", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Add letter back (no longer goes back to saying partially correct)");
    cy.get(cesc("#\\/_mathinput1") + " textarea").type("{end}x", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("50% correct");
      });

    cy.log("Enter incorrect answer");
    cy.get(cesc("#\\/_mathinput1") + " textarea")
      .type(`{end}{backspace}y`, { force: true })
      .blur();
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).type("{enter}", { force: true });
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Delete letter in input2");
    cy.get(cesc("#\\/_mathinput2") + " textarea").type("{end}{backspace}", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Add letter back (no longer goes back to saying incorrect)");
    cy.get(cesc("#\\/_mathinput2") + " textarea").type("{end}x", {
      force: true,
    });
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).type("{enter}", { force: true });
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");
  });

  it("submit buttons with two text answer blanks", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>Enter rain and snow in either order: <textinput/> <textinput/>
        <answer>
        <award><when><text><copy prop="immediateValue" target="_textinput1" isResponse /> <copy prop="immediateValue" target="_textinput2" isResponse /></text> = <text>rain snow</text></when></award>
        <award><when><text><copy prop="immediateValue" target="_textinput1" /> <copy prop="immediateValue" target="_textinput2" /></text> = <text>snow rain</text></when></award>
        <award credit="0.5"><when><copy prop="immediateValue" target="_textinput1" /> = rain</when></award>
        <award credit="0.5"><when><copy prop="immediateValue" target="_textinput1" /> = snow</when></award>
        <award credit="0.5"><when><copy prop="immediateValue" target="_textinput2" /> = rain</when></award>
        <award credit="0.5"><when><copy prop="immediateValue" target="_textinput2" /> = snow</when></award>
        </answer></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.log("Test value displayed in browser");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Enter a correct answer");
    cy.get(cesc("#\\/_textinput1_input")).type(`rain`);
    cy.get(cesc("#\\/_textinput2_input")).type(`snow`).blur();
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Type letter in input1");
    cy.get(cesc("#\\/_textinput1_input")).type("z");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rainz");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Delete letter (no longer goes back to saying correct)");
    cy.get(cesc("#\\/_textinput1_input")).type("{backspace}");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Type letter in input2");
    cy.get(cesc("#\\/_textinput1_input")).blur();
    cy.get(cesc("#\\/_textinput2_input")).type("q");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snowq");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Delete letter (no longer goes back to saying correct)");
    cy.get(cesc("#\\/_textinput2_input")).type("{backspace}");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Type letter in input1");
    cy.get(cesc("#\\/_textinput1_input")).type("z");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rainz");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Type letter in input2");
    cy.get(cesc("#\\/_textinput2_input")).type("q");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rainz");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snowq");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Delete letter in input1");
    cy.get(cesc("#\\/_textinput1_input")).type("{backspace}");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snowq");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Don't go back to saying correct if return to previous answer");
    cy.get(cesc("#\\/_textinput2_input")).type("{backspace}").blur();
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "rain");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Enter partially correct answer");
    cy.get(cesc("#\\/_textinput1_input")).clear().type(`x`).blur();
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "x");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "x");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("50% correct");
      });

    cy.log("Delete letter in input2");
    cy.get(cesc("#\\/_textinput2_input")).type("{backspace}");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "x");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "sno");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Add letter back (no longer to back to saying partially correct)");
    cy.get(cesc("#\\/_textinput2_input")).type("w");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "x");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "snow");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("50% correct");
      });

    cy.log("Enter incorrect answer");
    cy.get(cesc("#\\/_textinput2_input")).clear().type(`y`).blur();
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "x");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "y");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).type("{enter}", { force: true });
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "x");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "y");
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Delete letter in input2");
    cy.get(cesc("#\\/_textinput2_input")).type("{backspace}");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "x");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Add letter back (no longer go back to saying incorrect");
    cy.get(cesc("#\\/_textinput2_input")).type("y");
    cy.get(cesc("#\\/_textinput1_input")).should("have.value", "x");
    cy.get(cesc("#\\/_textinput2_input")).should("have.value", "y");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).type("{enter}", { force: true });
    cy.get(cesc("#\\/_answer1_submit")).should("not.exist");
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");
  });

  it("submit button with external inputs", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
    <text>a</text>
    <p>Favorite variable: <mathinput name="var" prefill="x"/></p>
    <p>Second favorite variable: <mathinput name="var2" prefill="y"/></p>
    <p>Enter variable:
    <answer>
      <mathinput name="ans"/>
      <award><when><copy prop="immediatevalue" target="ans" isResponse /> = <copy prop="immediatevalue" target="var" /></when></award>
      <award credit="0.5"><when><copy prop="immediatevalue" target="ans" /> = <copy prop="immediatevalue" target="var2" /></when></award>
    </answer>
    </p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    // cy.get(cesc('#\\/var') + ' textarea').should('have.value', 'x');
    // cy.get(cesc('#\\/var2') + ' textarea').should('have.value', 'y');
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', '');
    cy.get(cesc("#\\/ans_submit")).should("be.visible");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Type correct answer in");
    cy.get(cesc("#\\/ans") + " textarea").type(`x`, { force: true });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'x');
    cy.get(cesc("#\\/ans_submit")).should("be.visible");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Press enter");
    cy.get(cesc("#\\/ans") + " textarea").type(`{enter}`, { force: true });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'x');
    cy.get(cesc("#\\/ans_submit")).should("not.exist");
    cy.get(cesc("#\\/ans_correct")).should("be.visible");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Change correct answer");
    cy.get(cesc("#\\/var") + " textarea").type(`{end}{backspace}u{enter}`, {
      force: true,
    });
    // cy.get(cesc('#\\/var') + ' textarea').should('have.value', 'u');
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'x');
    cy.get(cesc("#\\/ans_submit")).should("be.visible");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Press enter");
    cy.get(cesc("#\\/ans") + " textarea").type(`{enter}`, { force: true });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'x');
    cy.get(cesc("#\\/ans_submit")).should("not.exist");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("be.visible");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Change to new correct answer");
    cy.get(cesc("#\\/ans") + " textarea").type(`{end}{backspace}u`, {
      force: true,
    });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'u');
    cy.get(cesc("#\\/ans_submit")).should("be.visible");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Press enter");
    cy.get(cesc("#\\/ans") + " textarea").type(`{enter}`, { force: true });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'u');
    cy.get(cesc("#\\/ans_submit")).should("not.exist");
    cy.get(cesc("#\\/ans_correct")).should("be.visible");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Change partial credit answer");
    cy.get(cesc("#\\/var2") + " textarea").type(`{end}{backspace}v{enter}`, {
      force: true,
    });
    // cy.get(cesc('#\\/var2') + ' textarea').should('have.value', 'v');
    // cy.get(cesc('#\\/var') + ' textarea').should('have.value', 'u');
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'u');
    cy.get(cesc("#\\/ans_submit")).should("be.visible");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Press enter");
    cy.get(cesc("#\\/ans") + " textarea").type(`{enter}`, { force: true });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'u');
    cy.get(cesc("#\\/ans_submit")).should("not.exist");
    cy.get(cesc("#\\/ans_correct")).should("be.visible");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Change to new partial correct answer");
    cy.get(cesc("#\\/ans") + " textarea").type(`{end}{backspace}v`, {
      force: true,
    });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'v');
    cy.get(cesc("#\\/ans_submit")).should("be.visible");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Press enter");
    cy.get(cesc("#\\/ans") + " textarea").type(`{enter}`, { force: true });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'v');
    cy.get(cesc("#\\/ans_submit")).should("not.exist");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("be.visible");

    cy.log("Change correct answer");
    cy.get(cesc("#\\/var") + " textarea").type(`{end}{backspace}w{enter}`, {
      force: true,
    });
    // cy.get(cesc('#\\/var') + ' textarea').should('have.value', 'w');
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'v');
    // cy.get(cesc('#\\/var2') + ' textarea').should('have.value', 'v');
    cy.get(cesc("#\\/ans_submit")).should("be.visible");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Press enter");
    cy.get(cesc("#\\/ans") + " textarea").type(`{enter}`, { force: true });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'v');
    cy.get(cesc("#\\/ans_submit")).should("not.exist");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("be.visible");

    cy.log("Change to new correct answer");
    cy.get(cesc("#\\/ans") + " textarea").type(`{end}{backspace}w`, {
      force: true,
    });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'w');
    cy.get(cesc("#\\/ans_submit")).should("be.visible");
    cy.get(cesc("#\\/ans_correct")).should("not.exist");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");

    cy.log("Press enter");
    cy.get(cesc("#\\/ans") + " textarea").type(`{enter}`, { force: true });
    // cy.get(cesc('#\\/ans') + ' textarea').should('have.value', 'w');
    cy.get(cesc("#\\/ans_submit")).should("not.exist");
    cy.get(cesc("#\\/ans_correct")).should("be.visible");
    cy.get(cesc("#\\/ans_incorrect")).should("not.exist");
    cy.get(cesc("#\\/ans_partial")).should("not.exist");
  });

  it("answer with shuffled inline choiceinput", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer>
  <choiceinput inline shuffleOrder>
    <choice credit="0.5">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </choiceinput>
  </answer>.</p>
  <p>Current response: <text name="cr"><copy prop="currentResponse" target="_answer1" /></text></p>
  <p>Submitted response: <text name="sr"><copy prop="submittedResponse" target="_answer1" /></text></p>
  <p>Credit for submitted response: <number name="credit"><copy prop="creditAchieved" target="_answer1" /></number></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1")).should("have.value", "");
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "");
    cy.get(cesc("#\\/sr")).should("have.text", "");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    let indexByName = {};
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      for (let [ind, val] of stateVariables[
        "/_choiceinput1"
      ].stateValues.choiceTexts.entries()) {
        indexByName[val] = ind + 1;
      }

      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [],
      );
    });

    cy.log("Select correct answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`dog`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "dog");
    cy.get(cesc("#\\/sr")).should("have.text", "");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "dog");
    cy.get(cesc("#\\/sr")).should("have.text", "dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`monkey`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Select partially correct answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`cat`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("have.text", "50 %");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Select incorrect answer again");
    cy.get(cesc("#\\/_choiceinput1")).select(`monkey`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Does not remember previously submitted answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`cat`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("have.text", "50 %");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });
  });

  it("answer inline, shuffled with sugared choices", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer inline shuffleOrder>
    <choice credit="0.5">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </answer>.</p>
  <p>Current response: <text name="cr"><copy prop="currentResponse" target="_answer1" /></text></p>
  <p>Submitted response: <text name="sr"><copy prop="submittedResponse" target="_answer1" /></text></p>
  <p>Credit for submitted response: <number name="credit"><copy prop="creditAchieved" target="_answer1" /></number></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let choiceinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let choiceinputAnchor = cesc2("#" + choiceinputName);
      let choiceinputSubmitAnchor = cesc2("#" + choiceinputName + "_submit");
      let choiceinputCorrectAnchor = cesc2("#" + choiceinputName + "_correct");
      let choiceinputIncorrectAnchor = cesc2(
        "#" + choiceinputName + "_incorrect",
      );
      let choiceinputPartialAnchor = cesc2("#" + choiceinputName + "_partial");

      cy.get(choiceinputAnchor).should("have.value", "");
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "");
      cy.get(cesc("#\\/sr")).should("have.text", "");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      let indexByName = {};
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        for (let [ind, val] of stateVariables[
          choiceinputName
        ].stateValues.choiceTexts.entries()) {
          indexByName[val] = ind + 1;
        }

        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
          [],
        );
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          [],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([]);
      });

      cy.log("Select correct answer");
      cy.get(choiceinputAnchor).select(`dog`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "dog");
      cy.get(cesc("#\\/sr")).should("have.text", "");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("be.visible");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "dog");
      cy.get(cesc("#\\/sr")).should("have.text", "dog");
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Select incorrect answer");
      cy.get(choiceinputAnchor).select(`monkey`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "dog");
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("be.visible");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Select partially correct answer");
      cy.get(choiceinputAnchor).select(`cat`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "50 %");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });

      cy.log("Select incorrect answer again");
      cy.get(choiceinputAnchor).select(`monkey`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Does not remember previously submitted answer");
      cy.get(choiceinputAnchor).select(`cat`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });

      cy.log("Submit answer");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "50 %");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });
    });
  });

  it("answer with inline choiceinput, specify component type for submitted", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer>
  <choiceinput inline shuffleOrder>
    <choice credit="0.5">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </choiceinput>
  </answer>.</p>
  <p>Current response: <text name="cr"><copy prop="currentResponse" target="_answer1" /></text></p>
  <p>Submitted response: <text name="sr"><copy prop="submittedResponse" target="_answer1" createComponentOfType="text" /></text></p>
  <p>Credit for submitted response: <number name="credit"><copy prop="creditAchieved" target="_answer1" /></number></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1")).should("have.value", "");
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "");
    cy.get(cesc("#\\/sr")).should("have.text", "");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    let indexByName = {};
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      for (let [ind, val] of stateVariables[
        "/_choiceinput1"
      ].stateValues.choiceTexts.entries()) {
        indexByName[val] = ind + 1;
      }

      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [],
      );
    });

    cy.log("Select correct answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`dog`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "dog");
    cy.get(cesc("#\\/sr")).should("have.text", "");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "dog");
    cy.get(cesc("#\\/sr")).should("have.text", "dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`monkey`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Select partially correct answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`cat`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("have.text", "50 %");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Select incorrect answer again");
    cy.get(cesc("#\\/_choiceinput1")).select(`monkey`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Does not remember previously submitted answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`cat`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("have.text", "50 %");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });
  });

  it("answer with inline choiceinput, fixedorder", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer>
  <choiceinput inline>
    <choice credit="0.5">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </choiceinput>
  </answer>.</p>
  <p>Current response: <text name="cr"><copy prop="currentResponse" target="_answer1" /></text></p>
  <p>Submitted response: <text name="sr"><copy prop="submittedResponse" target="_answer1" createComponentOfType="text" /></text></p>
  <p>Credit for submitted response: <number name="credit"><copy prop="creditAchieved" target="_answer1" /></number></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1")).should("have.value", "");
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/_choiceinput1")).should("have.text", "catdogmonkey");

    cy.get(cesc("#\\/cr")).should("have.text", "");
    cy.get(cesc("#\\/sr")).should("have.text", "");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    let indexByName = { cat: 1, dog: 2, monkey: 3 };
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      for (let [ind, val] of stateVariables[
        "/_choiceinput1"
      ].stateValues.choiceTexts.entries()) {
        expect(indexByName[val]).eq(ind + 1);
      }

      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [],
      );
    });

    cy.log("Select correct answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`dog`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "dog");
    cy.get(cesc("#\\/sr")).should("have.text", "");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "dog");
    cy.get(cesc("#\\/sr")).should("have.text", "dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`monkey`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Select partially correct answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`cat`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("have.text", "50 %");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`monkey`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Does not remember previously submitted answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`cat`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("have.text", "50 %");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });
  });

  it("answer inline, fixedorder with sugared choices", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer inline>
    <choice credit="0.5">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </answer>.</p>
  <p>Current response: <text name="cr"><copy prop="currentResponse" target="_answer1" /></text></p>
  <p>Submitted response: <text name="sr"><copy prop="submittedResponse" target="_answer1" createComponentOfType="text" /></text></p>
  <p>Credit for submitted response: <number name="credit"><copy prop="creditAchieved" target="_answer1" /></number></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let choiceinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let choiceinputAnchor = cesc2("#" + choiceinputName);
      let choiceinputSubmitAnchor = cesc2("#" + choiceinputName + "_submit");
      let choiceinputCorrectAnchor = cesc2("#" + choiceinputName + "_correct");
      let choiceinputIncorrectAnchor = cesc2(
        "#" + choiceinputName + "_incorrect",
      );
      let choiceinputPartialAnchor = cesc2("#" + choiceinputName + "_partial");

      cy.get(choiceinputAnchor).should("have.value", "");
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(choiceinputAnchor).should("have.text", "catdogmonkey");

      cy.get(cesc("#\\/cr")).should("have.text", "");
      cy.get(cesc("#\\/sr")).should("have.text", "");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      let indexByName = { cat: 1, dog: 2, monkey: 3 };
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        for (let [ind, val] of stateVariables[
          choiceinputName
        ].stateValues.choiceTexts.entries()) {
          expect(indexByName[val]).eq(ind + 1);
        }

        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
          [],
        );
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          [],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([]);
      });

      cy.log("Select correct answer");
      cy.get(choiceinputAnchor).select(`dog`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "dog");
      cy.get(cesc("#\\/sr")).should("have.text", "");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("be.visible");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "dog");
      cy.get(cesc("#\\/sr")).should("have.text", "dog");
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Select incorrect answer");
      cy.get(choiceinputAnchor).select(`monkey`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "dog");
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("be.visible");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Select partially correct answer");
      cy.get(choiceinputAnchor).select(`cat`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "50 %");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });

      cy.log("Select incorrect answer");
      cy.get(choiceinputAnchor).select(`monkey`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Does not remember previously submitted answer");
      cy.get(choiceinputAnchor).select(`cat`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });

      cy.log("Submit answer");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "50 %");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });
    });
  });

  it("answer with select-multiple inline choiceinput, fixedorder", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer>
  <choiceinput inline selectMultiple matchPartial>
    <choice credit="1">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </choiceinput>
  </answer>.</p>
  <p name="cr">Current response: <aslist><copy prop="currentResponses" target="_answer1" /></aslist></p>
  <p name="sr">Submitted response: <aslist><copy prop="submittedResponses" target="_answer1" /></aslist></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="credit" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1")).invoke("val").should("deep.equal", []);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/_choiceinput1")).should("have.text", "catdogmonkey");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: ");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    let indexByName = { cat: 1, dog: 2, monkey: 3 };
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      for (let [ind, val] of stateVariables[
        "/_choiceinput1"
      ].stateValues.choiceTexts.entries()) {
        expect(indexByName[val]).eq(ind + 1);
      }

      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [],
      );
    });

    cy.log("Select half of correct answer");
    cy.get(cesc("#\\/_choiceinput1")).select([`dog`]);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("have.text", "50 %");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Select both correct answers");
    cy.get(cesc("#\\/_choiceinput1")).select(["dog", "cat"]);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: cat, dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"]],
      );
    });

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1")).select(`monkey`);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: cat, dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Select all answers");
    cy.get(cesc("#\\/_choiceinput1")).select([`monkey`, `cat`, `dog`]);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should(
      "have.text",
      "Current response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("have.text", "67 %");

    cy.get(cesc("#\\/cr")).should(
      "have.text",
      "Current response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0.667");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(2 / 3);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Select partially correct and incorrect answers");
    cy.get(cesc("#\\/_choiceinput1")).select([`monkey`, , `dog`]);
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog, monkey");
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0.667");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(2 / 3);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("have.text", "33 %");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog, monkey");
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0.333");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1 / 3);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"], indexByName["monkey"]],
      );
    });
  });

  it("answer select-multiple, inline, fixedorder with sugared choices", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer inline selectMultiple matchPartial>
    <choice credit="1">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </answer>.</p>
  <p name="cr">Current response: <aslist><copy prop="currentResponses" target="_answer1" /></aslist></p>
  <p name="sr">Submitted response: <aslist><copy prop="submittedResponses" target="_answer1" /></aslist></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="credit" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let choiceinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let choiceinputAnchor = cesc2("#" + choiceinputName);
      let choiceinputSubmitAnchor = cesc2("#" + choiceinputName + "_submit");
      let choiceinputCorrectAnchor = cesc2("#" + choiceinputName + "_correct");
      let choiceinputIncorrectAnchor = cesc2(
        "#" + choiceinputName + "_incorrect",
      );
      let choiceinputPartialAnchor = cesc2("#" + choiceinputName + "_partial");

      cy.get(choiceinputAnchor).invoke("val").should("deep.equal", []);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(choiceinputAnchor).should("have.text", "catdogmonkey");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: ");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      let indexByName = { cat: 1, dog: 2, monkey: 3 };
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        for (let [ind, val] of stateVariables[
          choiceinputName
        ].stateValues.choiceTexts.entries()) {
          expect(indexByName[val]).eq(ind + 1);
        }

        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
          [],
        );
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          [],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([]);
      });

      cy.log("Select half of correct answer");
      cy.get(choiceinputAnchor).select([`dog`]);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "50 %");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Select both correct answers");
      cy.get(choiceinputAnchor).select(["dog", "cat"]);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"]]);
      });

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("be.visible");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"]]);
      });

      cy.log("Select incorrect answer");
      cy.get(choiceinputAnchor).select(`monkey`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("be.visible");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Select all answers");
      cy.get(choiceinputAnchor).select([`monkey`, `cat`, `dog`]);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"], indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "67 %");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "0.667");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(
          2 / 3,
        );
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"], indexByName["monkey"]]);
      });

      cy.log("Select partially correct and incorrect answers");
      cy.get(choiceinputAnchor).select([`monkey`, , `dog`]);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "0.667");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(
          2 / 3,
        );
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"], indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "33 %");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: dog, monkey",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "0.333");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(
          1 / 3,
        );
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog", "monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"], indexByName["monkey"]]);
      });
    });
  });

  it("answer with block choiceinput", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a:</p>
  <answer>
  <choiceinput shuffleOrder>
    <choice credit="0.5">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </choiceinput>
  </answer>
  <p>Current response: <text name="cr"><copy prop="currentResponse" target="_answer1" /></text></p>
  <p>Submitted response: <text name="sr"><copy prop="submittedResponse" target="_answer1" createComponentOfType="text" /></text></p>
  <p>Credit for submitted response: <number name="credit"><copy prop="creditAchieved" target="_answer1" /></number></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1")).should("have.value", "");
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "");
    cy.get(cesc("#\\/sr")).should("have.text", "");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    let indexByName = {};
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      for (let [ind, val] of stateVariables[
        "/_choiceinput1"
      ].stateValues.choiceTexts.entries()) {
        indexByName[val] = ind + 1;
      }

      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [],
      );
    });

    cy.log("Select correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "dog");
    cy.get(cesc("#\\/sr")).should("have.text", "");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "dog");
    cy.get(cesc("#\\/sr")).should("have.text", "dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`monkey`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Select partially correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("50% correct");
      });

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Select incorrect answer again");
    cy.get(cesc("#\\/_choiceinput1")).contains(`monkey`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Does not remember previously submitted answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });

    cy.log("Submit answer");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("50% correct");
      });

    cy.get(cesc("#\\/cr")).should("have.text", "cat");
    cy.get(cesc("#\\/sr")).should("have.text", "cat");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"]],
      );
    });
  });

  it("answer block, shuffled, with sugared choices", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a:</p>
  <answer shuffleOrder>
    <choice credit="0.5">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </answer>
  <p>Current response: <text name="cr"><copy prop="currentResponse" target="_answer1" /></text></p>
  <p>Submitted response: <text name="sr"><copy prop="submittedResponse" target="_answer1" createComponentOfType="text" /></text></p>
  <p>Credit for submitted response: <number name="credit"><copy prop="creditAchieved" target="_answer1" /></number></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let choiceinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let choiceinputAnchor = cesc2("#" + choiceinputName);
      let choiceinputSubmitAnchor = cesc2("#" + choiceinputName + "_submit");
      let choiceinputCorrectAnchor = cesc2("#" + choiceinputName + "_correct");
      let choiceinputIncorrectAnchor = cesc2(
        "#" + choiceinputName + "_incorrect",
      );
      let choiceinputPartialAnchor = cesc2("#" + choiceinputName + "_partial");

      cy.get(choiceinputAnchor).should("have.value", "");
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "");
      cy.get(cesc("#\\/sr")).should("have.text", "");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      let indexByName = {};
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        for (let [ind, val] of stateVariables[
          choiceinputName
        ].stateValues.choiceTexts.entries()) {
          indexByName[val] = ind + 1;
        }

        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
          [],
        );
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          [],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([]);
      });

      cy.log("Select correct answer");
      cy.get(choiceinputAnchor).contains(`dog`).click({ force: true });
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "dog");
      cy.get(cesc("#\\/sr")).should("have.text", "");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("correct");
        });
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "dog");
      cy.get(cesc("#\\/sr")).should("have.text", "dog");
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Select incorrect answer");
      cy.get(choiceinputAnchor).contains(`monkey`).click({ force: true });
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "dog");
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("incorrect");
        });
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Select partially correct answer");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("50% correct");
        });

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });

      cy.log("Select incorrect answer again");
      cy.get(choiceinputAnchor).contains(`monkey`).click({ force: true });
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Does not remember previously submitted answer");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });

      cy.log("Submit answer");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("50% correct");
        });

      cy.get(cesc("#\\/cr")).should("have.text", "cat");
      cy.get(cesc("#\\/sr")).should("have.text", "cat");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"]]);
      });
    });
  });

  it("answer with select-multiple block choiceinput, fixedorder", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer>
  <choiceinput selectMultiple>
    <choice credit="1">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </choiceinput>
  </answer>.</p>
  <p name="cr">Current response: <aslist><copy prop="currentResponses" target="_answer1" /></aslist></p>
  <p name="sr">Submitted response: <aslist><copy prop="submittedResponses" target="_answer1" /></aslist></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="credit" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: ");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    let indexByName = { cat: 1, dog: 2, monkey: 3 };
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      for (let [ind, val] of stateVariables[
        "/_choiceinput1"
      ].stateValues.choiceTexts.entries()) {
        expect(indexByName[val]).eq(ind + 1);
      }

      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [],
      );
    });

    cy.log("Select half of correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Select both correct answers");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: cat, dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"]],
      );
    });

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1")).contains(`monkey`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: cat, dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Select all answers");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should(
      "have.text",
      "Current response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should(
      "have.text",
      "Current response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Select partially correct and incorrect answers");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog, monkey");
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog, monkey");
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"], indexByName["monkey"]],
      );
    });
  });

  it("answer select-multiple, block, fixedorder with sugared choices", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer selectMultiple>
    <choice credit="1">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </answer>.</p>
  <p name="cr">Current response: <aslist><copy prop="currentResponses" target="_answer1" /></aslist></p>
  <p name="sr">Submitted response: <aslist><copy prop="submittedResponses" target="_answer1" /></aslist></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="credit" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let choiceinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let choiceinputAnchor = cesc2("#" + choiceinputName);
      let choiceinputSubmitAnchor = cesc2("#" + choiceinputName + "_submit");
      let choiceinputCorrectAnchor = cesc2("#" + choiceinputName + "_correct");
      let choiceinputIncorrectAnchor = cesc2(
        "#" + choiceinputName + "_incorrect",
      );
      let choiceinputPartialAnchor = cesc2("#" + choiceinputName + "_partial");

      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: ");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      let indexByName = { cat: 1, dog: 2, monkey: 3 };
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        for (let [ind, val] of stateVariables[
          choiceinputName
        ].stateValues.choiceTexts.entries()) {
          expect(indexByName[val]).eq(ind + 1);
        }

        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
          [],
        );
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          [],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([]);
      });

      cy.log("Select half of correct answer");
      cy.get(choiceinputAnchor).contains(`dog`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("be.visible");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Select both correct answers");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"]]);
      });

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("be.visible");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"]]);
      });

      cy.log("Select incorrect answer");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputAnchor).contains(`dog`).click({ force: true });
      cy.get(choiceinputAnchor).contains(`monkey`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("be.visible");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Select all answers");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputAnchor).contains(`dog`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"], indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("be.visible");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"], indexByName["monkey"]]);
      });

      cy.log("Select partially correct and incorrect answers");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"], indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("be.visible");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: dog, monkey",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog", "monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"], indexByName["monkey"]]);
      });
    });
  });

  it("answer with select-multiple block choiceinput, fixedorder, match partial", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer>
  <choiceinput selectMultiple matchPartial>
    <choice credit="1">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </choiceinput>
  </answer>.</p>
  <p name="cr">Current response: <aslist><copy prop="currentResponses" target="_answer1" /></aslist></p>
  <p name="sr">Submitted response: <aslist><copy prop="submittedResponses" target="_answer1" /></aslist></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="credit" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: ");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    let indexByName = { cat: 1, dog: 2, monkey: 3 };
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      for (let [ind, val] of stateVariables[
        "/_choiceinput1"
      ].stateValues.choiceTexts.entries()) {
        expect(indexByName[val]).eq(ind + 1);
      }

      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [],
      );
    });

    cy.log("Select half of correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should(
      "have.text",
      "50% Correct",
    );

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Select both correct answers");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: cat, dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"]],
      );
    });

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1")).contains(`monkey`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: cat, dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Select all answers");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should(
      "have.text",
      "Current response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should(
      "have.text",
      "67% Correct",
    );

    cy.get(cesc("#\\/cr")).should(
      "have.text",
      "Current response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0.667");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(2 / 3);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Select partially correct and incorrect answers");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog, monkey");
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0.667");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(2 / 3);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should(
      "have.text",
      "33% Correct",
    );

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog, monkey");
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0.333");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1 / 3);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"], indexByName["monkey"]],
      );
    });
  });

  it("answer select-multiple, block, fixedorder, match partial, with sugared choices", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer selectMultiple matchPartial>
    <choice credit="1">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </answer>.</p>
  <p name="cr">Current response: <aslist><copy prop="currentResponses" target="_answer1" /></aslist></p>
  <p name="sr">Submitted response: <aslist><copy prop="submittedResponses" target="_answer1" /></aslist></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="credit" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let choiceinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let choiceinputAnchor = cesc2("#" + choiceinputName);
      let choiceinputSubmitAnchor = cesc2("#" + choiceinputName + "_submit");
      let choiceinputCorrectAnchor = cesc2("#" + choiceinputName + "_correct");
      let choiceinputIncorrectAnchor = cesc2(
        "#" + choiceinputName + "_incorrect",
      );
      let choiceinputPartialAnchor = cesc2("#" + choiceinputName + "_partial");

      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: ");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      let indexByName = { cat: 1, dog: 2, monkey: 3 };
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        for (let [ind, val] of stateVariables[
          choiceinputName
        ].stateValues.choiceTexts.entries()) {
          expect(indexByName[val]).eq(ind + 1);
        }

        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls(
          [],
        );
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          [],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([]);
      });

      cy.log("Select half of correct answer");
      cy.get(choiceinputAnchor).contains(`dog`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          [],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "50% Correct");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"]]);
      });

      cy.log("Select both correct answers");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
      cy.get(cesc("#\\/credit")).should("have.text", "0.5");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"]]);
      });

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("be.visible");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"]]);
      });

      cy.log("Select incorrect answer");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputAnchor).contains(`dog`).click({ force: true });
      cy.get(choiceinputAnchor).contains(`monkey`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "1");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("be.visible");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["monkey"]]);
      });

      cy.log("Select all answers");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputAnchor).contains(`dog`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
      cy.get(cesc("#\\/credit")).should("have.text", "0");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"], indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "67% Correct");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "0.667");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(
          2 / 3,
        );
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "cat",
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["cat"], indexByName["dog"], indexByName["monkey"]]);
      });

      cy.log("Select partially correct and incorrect answers");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: cat, dog, monkey",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "0.667");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(
          2 / 3,
        );
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["cat", "dog", "monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"], indexByName["monkey"]]);
      });

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "33% Correct");

      cy.get(cesc("#\\/cr")).should(
        "have.text",
        "Current response: dog, monkey",
      );
      cy.get(cesc("#\\/sr")).should(
        "have.text",
        "Submitted response: dog, monkey",
      );
      cy.get(cesc("#\\/credit")).should("have.text", "0.333");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(
          1 / 3,
        );
        expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
          "dog",
          "monkey",
        ]);
        expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
          ["dog", "monkey"],
        );
        expect(stateVariables[choiceinputName].stateValues.selectedValues).eqls(
          ["dog", "monkey"],
        );
        expect(
          stateVariables[choiceinputName].stateValues.selectedIndices,
        ).eqls([indexByName["dog"], indexByName["monkey"]]);
      });
    });
  });

  it("answer with select-multiple block choiceinput, fixedorder, match partial in answer", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a <answer matchPartial>
  <choiceinput selectMultiple>
    <choice credit="1">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </choiceinput>
  </answer>.</p>
  <p name="cr">Current response: <aslist><copy prop="currentResponses" target="_answer1" /></aslist></p>
  <p name="sr">Submitted response: <aslist><copy prop="submittedResponses" target="_answer1" /></aslist></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="_answer1" assignNames="credit" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: ");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    let indexByName = { cat: 1, dog: 2, monkey: 3 };
    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      for (let [ind, val] of stateVariables[
        "/_choiceinput1"
      ].stateValues.choiceTexts.entries()) {
        expect(indexByName[val]).eq(ind + 1);
      }

      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [],
      );
    });

    cy.log("Select half of correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls(
        [],
      );
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should(
      "have.text",
      "50% Correct",
    );

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"]],
      );
    });

    cy.log("Select both correct answers");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: dog");
    cy.get(cesc("#\\/credit")).should("have.text", "0.5");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0.5);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"]],
      );
    });

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: cat, dog");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: cat, dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"]],
      );
    });

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1")).contains(`monkey`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: cat, dog");
    cy.get(cesc("#\\/credit")).should("have.text", "1");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: monkey");
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["monkey"]],
      );
    });

    cy.log("Select all answers");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should(
      "have.text",
      "Current response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/sr")).should("have.text", "Submitted response: monkey");
    cy.get(cesc("#\\/credit")).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(0);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should(
      "have.text",
      "67% Correct",
    );

    cy.get(cesc("#\\/cr")).should(
      "have.text",
      "Current response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0.667");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(2 / 3);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["cat"], indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Select partially correct and incorrect answers");
    cy.get(cesc("#\\/_choiceinput1")).contains(`cat`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("be.visible");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog, monkey");
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: cat, dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0.667");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(2 / 3);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "cat",
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"], indexByName["monkey"]],
      );
    });

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should(
      "have.text",
      "33% Correct",
    );

    cy.get(cesc("#\\/cr")).should("have.text", "Current response: dog, monkey");
    cy.get(cesc("#\\/sr")).should(
      "have.text",
      "Submitted response: dog, monkey",
    );
    cy.get(cesc("#\\/credit")).should("have.text", "0.333");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.creditAchieved).eq(1 / 3);
      expect(stateVariables["/_answer1"].stateValues.currentResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_answer1"].stateValues.submittedResponses).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedValues).eqls([
        "dog",
        "monkey",
      ]);
      expect(stateVariables["/_choiceinput1"].stateValues.selectedIndices).eqls(
        [indexByName["dog"], indexByName["monkey"]],
      );
    });
  });

  it("answer with choiceinput, no bug when submit first", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>The animal is a:</p>
  <answer>
  <choiceinput>
    <choice credit="0.5">cat</choice>
    <choice credit="1">dog</choice>
    <choice>monkey</choice>
  </choiceinput>
  </answer>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1")).should("have.value", "");
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`dog`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");
  });

  it("answer with variable number of choices", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
    <text>a</text>
    <p>Num: <mathinput name="num" prefill="3"/></p>

    <answer>
    <choiceinput shuffleOrder>
      <map>
        <template>
          <choice credit="$m">
          Get <number displaydigits="3"><copy target="m" /></number>, plus a bit is <math displaydigits="3" simplify><copy target="m" />+0.001</math></choice>
        </template>
        <sources alias="m">
          <sequence from="0" to="1" length="$num" />
        </sources>
      </map>
    </choiceinput>
    </answer>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1")).should("have.value", "");
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(
        stateVariables["/_choiceinput1"].stateValues.choiceTexts.length,
      ).eq(3);
    });

    cy.log("Select correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`Get 1`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`plus a bit is 0.001`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select partially correct answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`Get 0.5`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("50% correct");
      });

    cy.log("add another choice");
    cy.get(cesc("#\\/num") + " textarea").type("{end}{backspace}4{enter}", {
      force: true,
    });

    cy.get(cesc("#\\/_choiceinput1") + " label:nth-of-type(4)").should(
      "be.visible",
    );

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(
        stateVariables["/_choiceinput1"].stateValues.choiceTexts.length,
      ).eq(4);
    });

    cy.get(cesc("#\\/_choiceinput1")).should("have.value", "");
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`Get 1`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`plus a bit is 0.001`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select partially correct answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`Get 0.333`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("33% correct");
      });

    cy.log("Select another partially correct answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`Get 0.667`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("67% correct");
      });

    cy.log("go back to 3 choices");
    cy.get(cesc("#\\/num") + " textarea").type("{end}{backspace}3{enter}", {
      force: true,
    });

    cy.get(cesc("#\\/_choiceinput1") + " label:nth-of-type(4)").should(
      "not.exist",
    );

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(
        stateVariables["/_choiceinput1"].stateValues.choiceTexts.length,
      ).eq(3);
    });

    cy.get(cesc("#\\/_choiceinput1")).should("have.value", "");
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`Get 1`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`plus a bit is 0.001`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select partially correct answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`Get 0.5`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("50% correct");
      });

    cy.log("create 6 choices");
    cy.get(cesc("#\\/num") + " textarea").type("{end}{backspace}6{enter}", {
      force: true,
    });

    cy.get(cesc("#\\/_choiceinput1") + " label:nth-of-type(6)").should(
      "be.visible",
    );

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(
        stateVariables["/_choiceinput1"].stateValues.choiceTexts.length,
      ).eq(6);
    });

    cy.get(cesc("#\\/_choiceinput1")).should("have.value", "");
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select correct answer");
    cy.get(cesc("#\\/_choiceinput1")).contains(`Get 1`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Click submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select incorrect answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`plus a bit is 0.001`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Select partially correct answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`Get 0.2`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("20% correct");
      });

    cy.log("Select another partially correct answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`Get 0.4`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("40% correct");
      });

    cy.log("Select another partially correct answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`Get 0.6`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("60% correct");
      });

    cy.log("Select another partially correct answer");
    cy.get(cesc("#\\/_choiceinput1"))
      .contains(`Get 0.8`)
      .click({ force: true });
    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial")).should("not.exist");

    cy.log("Press enter on submit button");
    cy.get(cesc("#\\/_choiceinput1_submit")).type(`{enter}`, { force: true });
    cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_choiceinput1_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("80% correct");
      });
  });

  it("answer with user-defined choice and credit", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
      <text>a</text>
      <p>Credit for cat: <mathinput name="catcredit" prefill="0.3" /> </p>
      <p>Last option: <textinput prefill="bird" name="last" /></p>
      <answer>
        <choiceinput>
        <choice credit="$catcredit">cat</choice>
        <choice credit="1">dog</choice>
        <choice>monkey</choice>
        <choice><copy prop="value" target="last" /></choice>
        </choiceinput>
      </answer>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let choiceinputName = cesc2(
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName,
      );
      let choiceinputAnchor = "#" + choiceinputName;
      let choiceinputSubmitAnchor = "#" + choiceinputName + "_submit";
      let choiceinputCorrectAnchor = "#" + choiceinputName + "_correct";
      let choiceinputIncorrectAnchor = "#" + choiceinputName + "_incorrect";
      let choiceinputPartialAnchor = "#" + choiceinputName + "_partial";

      cy.get(choiceinputAnchor).should("have.value", "");
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Select correct answer");
      cy.get(choiceinputAnchor).contains(`dog`).click({ force: true });
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("correct");
        });
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Change partial credit for cat");
      cy.get(cesc("#\\/catcredit") + " textarea").type(
        "{end}{backspace}4{enter}",
        { force: true },
      );
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("correct");
        });
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Change last choice");
      cy.get(cesc("#\\/last_input")).clear().type("mouse{enter}");
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("correct");
        });
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Select partially correct answer");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("40% correct");
        });

      cy.log("Change partial credit for cat");
      cy.get(cesc("#\\/catcredit") + " textarea").type(
        "{end}{backspace}2{enter}",
        { force: true },
      );
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("20% correct");
        });

      cy.log("Select variable answer");
      cy.get(choiceinputAnchor).contains(`mouse`).click({ force: true });
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Press enter on submit button");
      cy.get(choiceinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("incorrect");
        });
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Change animal name");
      cy.get(cesc("#\\/last_input")).clear().type("rabbit{enter}");
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("incorrect");
        });
      cy.get(choiceinputPartialAnchor).should("not.exist");
    });
  });

  it("switch answer between inline and block", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
      <text>a</text>
      <p>Inline: <booleaninput name="inline" /> </p>
      <answer inline="$inline">
        <choiceinput shuffleOrder>
        <choice credit="0.5">cat</choice>
        <choice credit="1">dog</choice>
        <choice>monkey</choice>
        </choiceinput>
      </answer>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let choiceinputName = cesc2(
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName,
      );
      let choiceinputAnchor = "#" + choiceinputName;
      let choiceinputSubmitAnchor = "#" + choiceinputName + "_submit";
      let choiceinputCorrectAnchor = "#" + choiceinputName + "_correct";
      let choiceinputIncorrectAnchor = "#" + choiceinputName + "_incorrect";
      let choiceinputPartialAnchor = "#" + choiceinputName + "_partial";

      cy.get(choiceinputAnchor).should("have.value", "");
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("toggle inline");
      cy.get(cesc("#\\/inline")).click();
      cy.get(`${choiceinputAnchor} option:nth-of-type(3)`).should("be.visible");
      cy.get(choiceinputAnchor).should("have.value", "");
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Select correct answer");
      cy.get(choiceinputAnchor).select(`dog`);
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("be.visible");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("toggle inline");
      cy.get(cesc("#\\/inline")).click();
      cy.get(`${choiceinputAnchor} label:nth-of-type(3)`).should("be.visible");
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("correct");
        });
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Select partial credit answer");
      cy.get(choiceinputAnchor).contains(`cat`).click({ force: true });
      cy.get(choiceinputSubmitAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("check work");
        });
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("not.exist");

      cy.log("Click submit button");
      cy.get(choiceinputSubmitAnchor).click();
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor)
        .invoke("text")
        .then((text) => {
          expect(text.trim().toLowerCase()).equal("50% correct");
        });

      cy.log("toggle inline");
      cy.get(cesc("#\\/inline")).click();
      cy.get(`${choiceinputAnchor} option:nth-of-type(3)`).should("be.visible");
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputCorrectAnchor).should("not.exist");
      cy.get(choiceinputIncorrectAnchor).should("not.exist");
      cy.get(choiceinputPartialAnchor).should("have.text", "50 %");
    });
  });

  it("answer, any letter", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Enter any letter:
  <answer name='userx'>
  <mathinput name="userx_input"/>
  <award><when>
    <copy prop="immediatevalue" target="userx_input" /> elementof {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}
    </when>
  </award>
  </answer>
  </p>

 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    // cy.get(cesc('#\\/userx_input_input')).should('have.value', '');
    cy.get(cesc("#\\/userx_input_submit")).should("be.visible");

    cy.log("Enter a letter");
    cy.get(cesc("#\\/userx_input") + " textarea").type("a{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/userx_input_correct")).should("be.visible");

    cy.log("Enter letter combination");
    cy.get(cesc("#\\/userx_input") + " textarea").type("{end}{backspace}c,d", {
      force: true,
    });
    cy.get(cesc("#\\/userx_input_submit")).click();
    cy.get(cesc("#\\/userx_input_incorrect")).should("be.visible");

    cy.log("Enter another letter");
    cy.get(cesc("#\\/userx_input") + " textarea").type(
      "{ctrl+home}{shift+end}{backspace}q",
      { force: true },
    );
    cy.get(cesc("#\\/userx_input_submit")).click();
    cy.get(cesc("#\\/userx_input_correct")).should("be.visible");

    cy.log("Enter a number");
    cy.get(cesc("#\\/userx_input") + " textarea").type("{end}{backspace}1", {
      force: true,
    });
    cy.get(cesc("#\\/userx_input_submit")).click();
    cy.get(cesc("#\\/userx_input_incorrect")).should("be.visible");
  });

  it("answer element of user defined set", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>

  <p>Enter a set <mathinput name="set" prefill="{1,2,3}" /></p>
  <p>Enter an element of that set: 
  <answer>
  <mathinput name="element" />
  <award>
    <when><copy prop="immediatevalue" target="element" /> elementof <copy prop="value" target="set" /></when>
  </award>
  </answer>
  </p>
 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    // cy.get(cesc('#\\/element_input')).should('have.value', '');
    // cy.get(cesc('#\\/set_input')).should('have.value', '{ 1, 2, 3 }');
    cy.get(cesc("#\\/element_submit")).should("be.visible");

    cy.log("Enter a number from set");
    cy.get(cesc("#\\/element") + " textarea").type("2{enter}", { force: true });
    cy.get(cesc("#\\/element_correct")).should("be.visible");

    cy.log("Enter all numbers from set");
    cy.get(cesc("#\\/element") + " textarea").type("{end}{backspace}1,2,3", {
      force: true,
    });
    cy.get(cesc("#\\/element_submit")).click();
    cy.get(cesc("#\\/element_incorrect")).should("be.visible");

    cy.log("Enter a letter");
    cy.get(cesc("#\\/element") + " textarea").type(
      "{ctrl+home}{shift+end}{backspace}c",
      { force: true },
    );
    cy.get(cesc("#\\/element_submit")).click();
    cy.get(cesc("#\\/element_incorrect")).should("be.visible");

    cy.log("Change set to letters");
    cy.get(cesc("#\\/set") + " textarea").type(
      "{ctrl+home}{shift+end}{backspace}{{}a,b,c,d,e,f,g",
      { force: true },
    );
    cy.get(cesc("#\\/element_submit")).click();
    cy.get(cesc("#\\/element_correct")).should("be.visible");

    cy.log("Enter another letter");
    cy.get(cesc("#\\/element") + " textarea").type("{end}{backspace}g", {
      force: true,
    });
    cy.get(cesc("#\\/element_submit")).click();
    cy.get(cesc("#\\/element_correct")).should("be.visible");

    cy.log("Enter a number");
    cy.get(cesc("#\\/element") + " textarea").type("{end}{backspace}2", {
      force: true,
    });
    cy.get(cesc("#\\/element_submit")).click();
    cy.get(cesc("#\\/element_incorrect")).should("be.visible");

    cy.log("Change set to mathematical expressions");
    cy.get(cesc("#\\/set") + " textarea").type(
      "{ctrl+home}{shift+end}{backspace}{{}(x+y)/2{rightarrow}, e^(x^2{rightarrow} + y){rightArrow}, (1,2,3)",
      { force: true },
    );
    cy.get(cesc("#\\/element_submit")).click();
    cy.get(cesc("#\\/element_incorrect")).should("be.visible");

    cy.log("Enter one of the expressions");
    cy.get(cesc("#\\/element") + " textarea").type("{end}{backspace}(1,2,3)", {
      force: true,
    });
    cy.get(cesc("#\\/element_submit")).click();
    cy.get(cesc("#\\/element_correct")).should("be.visible");

    cy.log("Enter another of the expressions");
    cy.get(cesc("#\\/element") + " textarea").type(
      "{ctrl+home}{shift+end}{backspace}e^(x^2{rightarrow} + y)",
      { force: true },
    );
    cy.get(cesc("#\\/element_submit")).click();
    cy.get(cesc("#\\/element_correct")).should("be.visible");

    cy.log("Enter third expression");
    cy.get(cesc("#\\/element") + " textarea").type(
      "{ctrl+home}{shift+end}{backspace}x+2y-x/2{rightarrow}-3y/2",
      { force: true },
    );
    cy.get(cesc("#\\/element_submit")).click();
    cy.get(cesc("#\\/element_correct")).should("be.visible");
  });

  it("answer based on math and text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>Enter a number larger than one <mathinput/></p>
        <p>Say hello: <textinput/></p>
        
        <answer name="a"> 
         <award matchpartial><when>
         <copy prop="immediateValue" target="_mathinput1" isResponse /> > 1 
          and
          <copy prop="immediateValue" target="_textinput1" isResponse/> = hello
          </when></award>
        </answer>
        
        <p>Your current math answer is <copy assignNames="cr1" prop="currentResponse" target="a" createComponentOfType="math" /></p>
        <p>Your current text answer is <copy assignNames="cr2" prop="currentResponse2" target="a" createComponentOfType="text" /></p>
        <p>Your submitted math answer is <copy assignNames="sr1" prop="submittedResponse" target="a" createComponentOfType="math" /></p>
        <p>Your submitted text answer is <copy assignNames="sr2" prop="submittedResponse2" target="a" createComponentOfType="text" /></p>
        <p>Credit for your answers <copy assignNames="ca" prop="creditAchieved" target="a" /></p>
 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/_mathinput1") + " textarea").type("2{enter}", {
      force: true,
    });
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "2");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "2");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.get(cesc("#\\/_textinput1_input")).clear().type(`hello{enter}`);
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.get(cesc("#\\/a_submit")).click();
    cy.get(cesc(`#\\/sr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.get(cesc("#\\/_mathinput1") + " textarea").type(
      "{end}{backspace}0{enter}",
      { force: true },
    );
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "0");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.get(cesc("#\\/a_submit")).click();
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "0");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");
  });

  it("answer based on math and text, match partial in answer", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>Enter a number larger than one <mathinput/></p>
        <p>Say hello: <textinput/></p>
        
        <answer name="a" matchpartial> 
         <award sourcesAreResponses="_mathinput1 _textinput1"><when>
          $_mathinput1 > 1 
          and
          $_textinput1 = hello
          </when></award>
        </answer>
        
        <p>Your current math answer is <copy assignNames="cr1" prop="currentResponse" target="a" createComponentOfType="math" /></p>
        <p>Your current text answer is <copy assignNames="cr2" prop="currentResponse2" target="a" createComponentOfType="text" /></p>
        <p>Your submitted math answer is <copy assignNames="sr1" prop="submittedResponse" target="a" createComponentOfType="math" /></p>
        <p>Your submitted text answer is <copy assignNames="sr2" prop="submittedResponse2" target="a" createComponentOfType="text" /></p>
        <p>Credit for your answers <copy assignNames="ca" prop="creditAchieved" target="a" /></p>
 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/_mathinput1") + " textarea").type("2{enter}", {
      force: true,
    });
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "2");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "2");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.get(cesc("#\\/_textinput1_input")).clear().type(`hello{enter}`);
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");

    cy.get(cesc("#\\/a_submit")).click();
    cy.get(cesc(`#\\/sr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.get(cesc("#\\/_mathinput1") + " textarea").type(
      "{end}{backspace}0{enter}",
      { force: true },
    );
    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "0");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.get(cesc("#\\/a_submit")).click();
    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "0");

    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc(`#\\/cr2`)).should("have.text", "hello");

    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc(`#\\/sr2`)).should("have.text", "hello");
    cy.get(cesc(`#\\/ca`)).should("have.text", "0.5");
  });

  it("answer with submitted response based on point", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>Criterion: <mathinput prefill="1" /></p>
        <p>Move point so that its x-coordinate is larger than <copy prop="value" target="_mathinput1" />.</p>
        
        <graph>
          <point>(0,0)</point>
        </graph>

        <answer name="a"> 
          <award><when>
            <copy prop="immediateValue" target="_mathinput1"/> < <copy prop="x" target="_point1" isResponse />
          </when></award>
        </answer>
        
        <p>Your current answer: <copy assignNames="cr" prop="currentResponse" target="a" createComponentOfType="math" /></p>
        <p>Your submitted answer: <copy assignNames="sr" prop="submittedResponse" target="a" createComponentOfType="math" /></p>
        <p>Credit for your answer <copy assignNames="ca" prop="creditAchieved" target="a"/></p>
 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "0");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.window().then(async (win) => {
      await win.callAction1({
        actionName: "movePoint",
        componentName: "/_point1",
        args: { x: 3, y: -3 },
      });

      cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "3");
      cy.get(cesc(`#\\/cr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("3");
        });
      cy.get(cesc(`#\\/sr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("0");
        });
      cy.get(cesc(`#\\/ca`)).should("have.text", "0");

      cy.get(cesc("#\\/a_submit")).click();
      cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "3");
      cy.get(cesc(`#\\/cr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("3");
        });
      cy.get(cesc(`#\\/sr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("3");
        });
      cy.get(cesc(`#\\/ca`)).should("have.text", "1");

      cy.get(cesc("#\\/_mathinput1") + " textarea").type(
        "{end}{backspace}4{enter}",
        { force: true },
      );

      cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "3");
      cy.get(cesc(`#\\/cr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("3");
        });
      cy.get(cesc(`#\\/sr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("3");
        });
      cy.get(cesc(`#\\/ca`)).should("have.text", "1");

      cy.get(cesc("#\\/a_submit")).click();
      cy.get(cesc(`#\\/ca`)).should("have.text", "0");

      cy.get(cesc(`#\\/cr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("3");
        });
      cy.get(cesc(`#\\/sr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("3");
        });
    });

    cy.window().then(async (win) => {
      await win.callAction1({
        actionName: "movePoint",
        componentName: "/_point1",
        args: { x: 8, y: 9 },
      });

      cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "8");
      cy.get(cesc(`#\\/cr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("8");
        });
      cy.get(cesc(`#\\/sr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("3");
        });
      cy.get(cesc(`#\\/ca`)).should("have.text", "0");

      cy.get(cesc("#\\/a_submit")).click();
      cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "8");

      cy.get(cesc(`#\\/cr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("8");
        });
      cy.get(cesc(`#\\/sr`))
        .find(".mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("8");
        });
      cy.get(cesc(`#\\/ca`)).should("have.text", "1");
    });
  });

  it("answer with unicode", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer>x+2pi+3gamma+4mu+5xi+6eta</answer></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");

      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");

      cy.log("Symbols as escaped text");
      cy.get(mathinputAnchor).type(
        `x+2\\pi+3\\gamma+4\\mu+5\\xi+6\\eta{enter}{enter}`,
        { force: true },
      );
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");

      cy.log("Incorrect answer");
      cy.get(mathinputAnchor).type(`{ctrl+home}{shift+end}{backspace}x`, {
        force: true,
      });
      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("be.visible");

      cy.log("Symbols as unicode");
      cy.get(mathinputAnchor).type(`{end}{backspace}x+2π+3γ+4μ+5ξ+6η`, {
        force: true,
      });
      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
    });
  });

  it("mark targets as responses", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>Enter minimum: <mathinput name="min" /></p>
        <p>Enter value larger than $min: <mathinput name="val" /></p>
        
        <answer name="a"> 
         <award sourcesAreResponses="val"><when>$val > $min</when></award>
        </answer>
        
        <p>Current response <copy assignNames="cr" prop="currentResponses" target="a" createComponentOfType="math" /></p>
        <p>Submitted response <copy assignNames="sr" prop="submittedResponses" target="a" createComponentOfType="math" /></p>
        <p>Credit: <copy assignNames="ca" prop="creditAchieved" target="a" /></p>
 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/a"].stateValues.numResponses).eq(1);
    });

    cy.get(cesc("#\\/min") + " textarea").type("2{enter}", { force: true });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/val") + " textarea").type("3{enter}", { force: true });

    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "3");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(cesc(`#\\/sr`) + ` .mjx-mrow`).should("have.text", "3");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");
  });

  it("consider as responses", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>Enter two 2D points, where second to upward and to the right of the first:
         <mathinput name="P" /> <mathinput name="Q" /></p>
        
        <setup>
          <point name="PP" coords="$P" />
          <point name="QQ" coords="$Q" />
        </setup>

        <answer name="a">
          <considerAsResponses>$P $Q</considerAsResponses>
         <award><when>$(QQ.x) > $(PP.x) and $(QQ.y) > $(PP.y)</when></award>
        </answer>
        
        <p>Current responses <aslist><copy assignNames="cr1 cr2" prop="currentResponses" target="a" createComponentOfType="math" numComponents="2" /></aslist></p>
        <p>Submitted responses <aslist><copy assignNames="sr1 sr2" prop="submittedResponses" target="a" createComponentOfType="math" numComponents="2" /></aslist></p>
        <p>Credit: <copy assignNames="ca" prop="creditAchieved" target="a" /></p>
 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/a"].stateValues.numResponses).eq(2);
    });

    cy.get(cesc("#\\/P") + " textarea").type("(2,3){enter}", { force: true });
    cy.get(cesc("#\\/Q") + " textarea").type("(3,4){enter}", { force: true });

    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("contain.text", "(2,3)");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("contain.text", "(3,4)");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(2,3)");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(3,4)");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("contain.text", "(2,3)");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("contain.text", "(3,4)");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(2,3)");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(3,4)");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(2,3)");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(3,4)");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.get(cesc("#\\/P") + " textarea").type(
      "{home}{rightArrow}{rightArrow}{backspace}5{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/Q") + " textarea").type(
      "{end}{leftArrow}{backspace}1{enter}",
      { force: true },
    );

    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("contain.text", "(5,3)");
    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("contain.text", "(3,1)");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(5,3)");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(3,1)");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(2,3)");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(3,4)");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("contain.text", "(5,3)");
    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("contain.text", "(3,1)");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(5,3)");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(3,1)");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(5,3)");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("(3,1)");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");
  });

  it("isResponse is not copied", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p><mathinput name="mi" />
        <answer name="ans">
          <award>
            <when><copy prop="value" target="mi" isResponse assignNames="v" name="cm" /> = x</when>
          </award>
          <award credit="0.9">
            <when>$v = y</when>
          </award>
          <award credit="0.8">
            <when>$cm = z</when>
          </award>
        </answer>
        </p>
        <p>Submitted responses of ans: <copy prop="submittedResponses" target="ans" assignNames="sr1 sr2 sr3" /></p>


 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/mi") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/ans_submit")).click();
    cy.get(cesc("#\\/ans_correct")).should("be.visible");
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/sr3")).should("not.exist");

    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}y{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/ans_submit")).click();
    cy.get(cesc("#\\/ans_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("90% correct");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/sr3")).should("not.exist");

    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}z{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/ans_submit")).click();
    cy.get(cesc("#\\/ans_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("80% correct");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/sr3")).should("not.exist");
  });

  it("isResponse from sourcesAreResponses is not copied", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>a1: <mathinput name="mi" />
        <answer name="ans">
          <award sourcesAreResponses="mi">
            <when><copy prop="value" target="mi" assignNames="v" name="cm" /> = x</when>
          </award>
          <award credit="0.9">
            <when>$v = y</when>
          </award>
          <award credit="0.8">
            <when>$cm = z</when>
          </award>
        </answer>
        </p>
        <p>Submitted responses of ans: <copy prop="submittedResponses" target="ans" assignNames="sr1 sr2 sr3" /></p>


 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/mi") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/ans_submit")).click();
    cy.get(cesc("#\\/ans_correct")).should("be.visible");
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/sr3")).should("not.exist");

    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}y{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/ans_submit")).click();
    cy.get(cesc("#\\/ans_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("90% correct");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/sr3")).should("not.exist");

    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}z{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/ans_submit")).click();
    cy.get(cesc("#\\/ans_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("80% correct");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/sr3")).should("not.exist");
  });

  it("isResponse from sourcesAreResponses is not recursively copied", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>a1: <mathinput name="mi" />
        <answer name="ans">
          <award sourcesAreResponses="mi">
            <when><math name="m">$mi</math> = x</when>
          </award>
          <award credit="0.9">
            <when>$m = y</when>
          </award>
          <award credit="0.8">
            <when>$m.value = z</when>
          </award>
        </answer>
        </p>
        <p>Submitted responses of ans: <copy prop="submittedResponses" target="ans" assignNames="sr1 sr2 sr3" /></p>


 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/mi") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/ans_submit")).click();
    cy.get(cesc("#\\/ans_correct")).should("be.visible");
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("x");
      });
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/sr3")).should("not.exist");

    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}y{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/ans_submit")).click();
    cy.get(cesc("#\\/ans_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("90% correct");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("y");
      });
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/sr3")).should("not.exist");

    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}z{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/ans_submit")).click();
    cy.get(cesc("#\\/ans_partial"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("80% correct");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("z");
      });
    cy.get(cesc("#\\/sr2")).should("not.exist");
    cy.get(cesc("#\\/sr3")).should("not.exist");
  });

  it("all composites are responses if no responses indicated", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>Enter minimum: <mathinput name="min" /></p>
        <p>Enter value larger than $min: <mathinput name="val" /></p>
        
        <answer name="a"> 
         <award ><when>$val > $min</when></award>
        </answer>
        
        <p>Current responses <copy assignNames="cr1 cr2" prop="currentResponses" target="a" createComponentOfType="math" numComponents="2" /></p>
        <p>Submitted response <copy assignNames="sr1 sr2" prop="submittedResponses" target="a" createComponentOfType="math" numComponents="2" /></p>
        <p>Credit: <copy assignNames="ca" prop="creditAchieved" target="a" /></p>
 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/a"].stateValues.numResponses).eq(2);
    });

    cy.get(cesc("#\\/min") + " textarea").type("2{enter}", { force: true });

    cy.get(cesc(`#\\/cr2`) + ` .mjx-mrow`).should("have.text", "2");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(cesc(`#\\/sr2`) + ` .mjx-mrow`).should("have.text", "2");

    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/val") + " textarea").type("3{enter}", { force: true });

    cy.get(cesc(`#\\/cr1`) + ` .mjx-mrow`).should("have.text", "3");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(cesc(`#\\/sr1`) + ` .mjx-mrow`).should("have.text", "3");
    cy.get(cesc(`#\\/cr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/cr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/sr1`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/sr2`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("2");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");
  });

  it("immediate value used for submit button", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>Enter value larger than 3: <mathinput name="val" /></p>
        
        <answer name="a"> 
         <award sourcesAreResponses="val"><when>$val > 3</when></award>
        </answer>
        
        <p>Current response: <copy assignNames="cr" prop="currentResponses" target="a" createComponentOfType="math" /></p>
        <p>Submitted response: <copy assignNames="sr" prop="submittedResponses" target="a" createComponentOfType="math" /></p>
        <p>Credit: <copy assignNames="ca" prop="creditAchieved" target="a" /></p>
 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    let submitAnchor = cesc2("#/a_submit");
    let correctAnchor = cesc2("#/a_correct");
    let incorrectAnchor = cesc2("#/a_incorrect");

    cy.get(submitAnchor).should("be.visible");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/val") + " textarea").type("3{enter}", { force: true });

    cy.get(submitAnchor).should("be.visible");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");

    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("contain.text", "3");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/val") + " textarea").type("{end}{backspace}4", {
      force: true,
    });

    cy.get(submitAnchor).should("be.visible");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/val") + " textarea").type("{end}{backspace}3", {
      force: true,
    });

    cy.get(submitAnchor).should("be.visible");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();
    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/val") + " textarea").type("{end}{backspace}5", {
      force: true,
    });

    cy.get(submitAnchor).should("be.visible");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/val") + " textarea").blur();

    cy.get(submitAnchor).should("be.visible");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");

    cy.get(cesc(`#\\/cr`) + ` .mjx-mrow`).should("have.text", "5");
    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("3");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();
    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("be.visible");
    cy.get(incorrectAnchor).should("not.exist");

    cy.get(cesc(`#\\/cr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc(`#\\/sr`))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc(`#\\/ca`)).should("have.text", "1");
  });

  it("choiceinput credit from boolean", () => {
    let options = ["meow", "woof", "squeak", "blub"];
    for (let ind = 1; ind <= 4; ind++) {
      cy.window().then(async (win) => {
        win.postMessage(
          {
            doenetML: `
        <text>${ind}</text>
        <variantControl numVariants="4" variantNames="cat dog mouse fish"/>
  
        <select assignNames="(animal)" hide>
          <option selectForVariants="cat">
            <text>cat</text>
          </option>
          <option selectForVariants="dog">
            <text>dog</text>
          </option>
          <option selectForVariants="mouse">
            <text>mouse</text>
          </option>
          <option selectForVariants="fish">
            <text>fish</text>
          </option>
        </select>
        
        <p>What does the $animal say?
          <answer name="ans">
            <choiceinput shuffleOrder>
            <choice credit="$animal=cat" >meow</choice>
            <choice credit="$animal=dog" >woof</choice>
            <choice credit="$animal=mouse" >squeak</choice>
            <choice credit="$animal=fish" >blub</choice>
            </choiceinput>
          </answer>
        </p>
        `,
            requestedVariantIndex: ind,
          },
          "*",
        );
      });

      cy.get(cesc("#\\/_text1")).should("have.text", `${ind}`); // to wait until loaded

      for (let ind2 = 1; ind2 <= 4; ind2++) {
        cy.get(cesc("#\\/_choiceinput1"))
          .contains(options[ind2 - 1])
          .click({ force: true });

        cy.get(cesc("#\\/_choiceinput1_submit")).click();
        cy.get(cesc("#\\/_choiceinput1_submit")).should("not.exist");
        if (ind2 === ind) {
          cy.get(cesc("#\\/_choiceinput1_correct")).should("be.visible");
          cy.get(cesc("#\\/_choiceinput1_incorrect")).should("not.exist");
        } else {
          cy.get(cesc("#\\/_choiceinput1_correct")).should("not.exist");
          cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
        }
      }
    }
  });

  it("award credit from boolean", () => {
    let options = ["meow", "woof", "squeak", "blub"];
    for (let ind = 1; ind <= 4; ind++) {
      cy.window().then(async (win) => {
        win.postMessage(
          {
            doenetML: `
        <text>${ind}</text>
        <variantControl numVariants="4" variantNames="cat dog mouse fish"/>
  
        <select assignNames="(animal sound)" hide>
          <option selectForVariants="cat">
            <text>cat</text><text>meow</text>
          </option>
          <option selectForVariants="dog">
            <text>dog</text><text>woof</text>
          </option>
          <option selectForVariants="mouse">
            <text>mouse</text><text>squeak</text>
          </option>
          <option selectForVariants="fish">
            <text>fish</text><text>blub</text>
          </option>
        </select>
        
        <p>What does the $animal say?
          <answer name="ans" type="text">
            <award credit="$animal=cat" ><text>meow</text></award>
            <award credit="$animal=dog" ><text>woof</text></award>
            <award credit="$animal=mouse" ><text>squeak</text></award>
            <award credit="$animal=fish" ><text>blub</text></award>
          </answer>
        </p>
        `,
            requestedVariantIndex: ind,
          },
          "*",
        );
      });

      cy.get(cesc("#\\/_text1")).should("have.text", `${ind}`); // to wait until loaded

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        let textinputName =
          stateVariables["/ans"].stateValues.inputChildren[0].componentName;
        let textinputAnchor = cesc2("#" + textinputName + "_input");
        let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");
        let textinputCorrectAnchor = cesc2("#" + textinputName + "_correct");
        let textinputIncorrectAnchor = cesc2(
          "#" + textinputName + "_incorrect",
        );

        for (let ind2 = 1; ind2 <= 4; ind2++) {
          cy.get(textinputAnchor)
            .clear()
            .type(options[ind2 - 1]);
          cy.get(textinputSubmitAnchor).click();

          cy.get(textinputSubmitAnchor).should("not.exist");
          if (ind2 === ind) {
            cy.get(textinputCorrectAnchor).should("be.visible");
            cy.get(textinputIncorrectAnchor).should("not.exist");
          } else {
            cy.get(textinputCorrectAnchor).should("not.exist");
            cy.get(textinputIncorrectAnchor).should("be.visible");
          }
        }
      });
    }
  });

  it("number of awards credited", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>Number of awards credited: <mathinput name="nawards" prefill="1" /></p>
        <p>Credit for combined award: <mathinput name="creditForCombined" prefill="1" /></p>
        <p>Distinct numbers greater than 3:
        <mathinput name="mi1" />
        <mathinput name="mi2" />
        <answer numAwardsCredited="$nawards" name="a">
          <award feedbackText="First is greater than 3" credit="0.4" sourcesAreResponses="mi1"><when>$mi1 > 3</when></award>
          <award feedbackText="Second is greater than 3" credit="0.4" sourcesAreResponses="mi2"><when>$mi2 > 3</when></award>
          <award feedbackText="Distinct and greater than 3" credit="$creditForCombined"><when>$mi1 > 3 and $mi2 > 3 and $mi1 != $mi2</when></award>
          <award feedbackText="At least the first is a number" credit="0"><when><isNumber>$mi1</isNumber></when></award>
          <award feedbackText="At least the second is a number" credit="0"><when>isnumber($mi2)</when></award>
        </answer>
        </p>

        <copy prop="feedbacks" target="a" assignNames="fb1 fb2 fb3 fb4 fb5" />

        <p>Current responses: <aslist><copy prop="currentResponses" target="a" createComponentOfType="math" numComponents="2" assignNames="cr1 cr2" /></aslist></p>
        <p>Submitted response: <aslist><copy prop="submittedResponses" target="a" createComponentOfType="math" numComponents="2" assignNames="sr1 sr2" /></aslist></p>
        <p>Credit: <copy assignNames="ca" prop="creditAchieved" target="a" /></p>
 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    let submitAnchor = cesc2("#/a_submit");
    let correctAnchor = cesc2("#/a_correct");
    let incorrectAnchor = cesc2("#/a_incorrect");
    let partialAnchor = cesc2("#/a_partial");

    cy.get(submitAnchor).should("be.visible");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("not.exist");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("not.exist");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi2") + " textarea").type("1{enter}", { force: true });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should(
      "have.text",
      "At least the second is a number",
    );
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("＿");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi1") + " textarea").type("0{enter}", { force: true });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should(
      "have.text",
      "At least the first is a number",
    );
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/nawards") + " textarea").type("{end}{backspace}3{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should(
      "have.text",
      "At least the first is a number",
    );
    cy.get(cesc("#\\/fb2")).should(
      "have.text",
      "At least the second is a number",
    );
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("0");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi1") + " textarea").type("{end}{backspace}4{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("40% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is greater than 3");
    cy.get(cesc("#\\/fb2")).should(
      "have.text",
      "At least the first is a number",
    );
    cy.get(cesc("#\\/fb3")).should(
      "have.text",
      "At least the second is a number",
    );
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0.4");

    cy.get(cesc("#\\/nawards") + " textarea").type("{end}{backspace}1{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("40% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is greater than 3");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("1");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0.4");

    cy.get(cesc("#\\/mi2") + " textarea").type("{end}{backspace}4{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("40% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is greater than 3");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0.4");

    cy.get(cesc("#\\/nawards") + " textarea").type("{end}{backspace}3{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("80% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is greater than 3");
    cy.get(cesc("#\\/fb2")).should("have.text", "Second is greater than 3");
    cy.get(cesc("#\\/fb3")).should(
      "have.text",
      "At least the first is a number",
    );
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0.8");

    cy.get(cesc("#\\/mi2") + " textarea").type("{end}{backspace}5{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("be.visible");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("have.text", "First is greater than 3");
    cy.get(cesc("#\\/fb2")).should("have.text", "Second is greater than 3");
    cy.get(cesc("#\\/fb3")).should("have.text", "Distinct and greater than 3");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "1");

    cy.get(cesc("#\\/nawards") + " textarea").type("{end}{backspace}1{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("be.visible");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("have.text", "Distinct and greater than 3");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "1");

    cy.get(cesc("#\\/creditForCombined") + " textarea").type(
      "{end}{backspace}0.2{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("40% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is greater than 3");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0.4");

    cy.get(cesc("#\\/nawards") + " textarea").type("{end}{backspace}2{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("80% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is greater than 3");
    cy.get(cesc("#\\/fb2")).should("have.text", "Second is greater than 3");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "0.8");

    cy.get(cesc("#\\/nawards") + " textarea").type("{end}{backspace}3{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("be.visible");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("have.text", "First is greater than 3");
    cy.get(cesc("#\\/fb2")).should("have.text", "Second is greater than 3");
    cy.get(cesc("#\\/fb3")).should("have.text", "Distinct and greater than 3");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/cr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/cr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/sr1"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("4");
      });
    cy.get(cesc("#\\/sr2"))
      .find(".mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("5");
      });
    cy.get(cesc("#\\/ca")).should("have.text", "1");
  });

  it("number of awards credited 2", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>
        <mathinput name="mi1" />
        <mathinput name="mi2" />
        <mathinput name="mi3" />
        <answer numAwardsCredited="3" name="a">
          <award feedbackText="First is positive" credit="0.2" sourcesAreResponses="mi1"><when>$mi1 > 0</when></award>
          <award feedbackText="Second is positive" credit="0.2" sourcesAreResponses="mi2"><when>$mi2 > 0</when></award>
          <award feedbackText="Third is positive" credit="0.2" sourcesAreResponses="mi3"><when>$mi3 > 0</when></award>
          <award feedbackText="First is larger than second" credit="0.1"><when>$mi1 > $mi2</when></award>
          <award feedbackText="First is larger than third" credit="0.1"><when>$mi1 > $mi3</when></award>
          <award feedbackText="Second is larger than third" credit="0.1"><when>$mi2 > $mi3</when></award>
          <award feedbackText="Sum of first two is larger than 5!" credit="0.35"><when>$mi1 + $mi2 > 5</when></award>
          <award feedbackText="Sum of first and third is larger than 5!" credit="0.35"><when>$mi1 + $mi3 > 5</when></award>
          <award feedbackText="Sum of second and third is larger than 5!" credit="0.35"><when>$mi2 + $mi3 > 5</when></award>
          <award feedbackText="The first should be a number" credit="0"><when><not><isNumber>$mi1</isNumber></not></when></award>
          <award feedbackText="The second should be a number" credit="0"><when>not isnumber($mi2)</when></award>
          <award feedbackText="The third should be a number" credit="0"><when><not>isnumber($mi3)</not></when></award>
          </answer>
        </p>

        <copy prop="feedbacks" target="a" assignNames="fb1 fb2 fb3 fb4 fb5" />

        <p>Credit: <copy assignNames="ca" prop="creditAchieved" target="a" /></p>

 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    let submitAnchor = cesc2("#/a_submit");
    let correctAnchor = cesc2("#/a_correct");
    let incorrectAnchor = cesc2("#/a_incorrect");
    let partialAnchor = cesc2("#/a_partial");

    cy.get(submitAnchor).should("be.visible");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("not.exist");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("have.text", "The first should be a number");
    cy.get(cesc("#\\/fb2")).should(
      "have.text",
      "The second should be a number",
    );
    cy.get(cesc("#\\/fb3")).should("have.text", "The third should be a number");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi1") + " textarea").type("-5{enter}", { force: true });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should(
      "have.text",
      "The second should be a number",
    );
    cy.get(cesc("#\\/fb2")).should("have.text", "The third should be a number");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi2") + " textarea").type("-5{enter}", { force: true });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("have.text", "The third should be a number");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi3") + " textarea").type("-5{enter}", { force: true });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("not.exist");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi2") + " textarea").type("{end}{backspace}4{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("10% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "Second is larger than third");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.1");

    cy.get(cesc("#\\/mi1") + " textarea").type("{end}{backspace}4{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("20% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is larger than third");
    cy.get(cesc("#\\/fb2")).should("have.text", "Second is larger than third");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.2");

    cy.get(cesc("#\\/mi1") + " textarea").type("{end}{backspace}3{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("30% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is larger than second");
    cy.get(cesc("#\\/fb2")).should("have.text", "First is larger than third");
    cy.get(cesc("#\\/fb3")).should("have.text", "Second is larger than third");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.3");

    cy.get(cesc("#\\/mi1") + " textarea").type(
      "{end}{backspace}{backspace}8{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("40% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is positive");
    cy.get(cesc("#\\/fb2")).should("have.text", "First is larger than second");
    cy.get(cesc("#\\/fb3")).should("have.text", "First is larger than third");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.4");

    cy.get(cesc("#\\/mi2") + " textarea").type(
      "{end}{backspace}{backspace}-2{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("65% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is positive");
    cy.get(cesc("#\\/fb2")).should("have.text", "First is larger than second");
    cy.get(cesc("#\\/fb3")).should(
      "have.text",
      "Sum of first two is larger than 5!",
    );
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.65");

    cy.get(cesc("#\\/mi2") + " textarea").type(
      "{end}{backspace}{backspace}9{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("75% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is positive");
    cy.get(cesc("#\\/fb2")).should("have.text", "Second is positive");
    cy.get(cesc("#\\/fb3")).should(
      "have.text",
      "Sum of first two is larger than 5!",
    );
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.75");

    cy.get(cesc("#\\/mi2") + " textarea").type(
      "{end}{backspace}{backspace}11{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("90% correct");
      });

    cy.get(cesc("#\\/fb1")).should("have.text", "First is positive");
    cy.get(cesc("#\\/fb2")).should(
      "have.text",
      "Sum of first two is larger than 5!",
    );
    cy.get(cesc("#\\/fb3")).should(
      "have.text",
      "Sum of second and third is larger than 5!",
    );
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.9");

    cy.get(cesc("#\\/mi3") + " textarea").type(
      "{end}{backspace}{backspace}-1{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("be.visible");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should(
      "have.text",
      "Sum of first two is larger than 5!",
    );
    cy.get(cesc("#\\/fb2")).should(
      "have.text",
      "Sum of first and third is larger than 5!",
    );
    cy.get(cesc("#\\/fb3")).should(
      "have.text",
      "Sum of second and third is larger than 5!",
    );
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "1");

    cy.get(cesc("#\\/mi3") + " textarea").type(
      "{end}{backspace}{backspace}6{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("be.visible");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should(
      "have.text",
      "Sum of first two is larger than 5!",
    );
    cy.get(cesc("#\\/fb2")).should(
      "have.text",
      "Sum of first and third is larger than 5!",
    );
    cy.get(cesc("#\\/fb3")).should(
      "have.text",
      "Sum of second and third is larger than 5!",
    );
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "1");

    cy.get(cesc("#\\/mi1") + " textarea").type(
      "{end}{backspace}{backspace}15{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("be.visible");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should(
      "have.text",
      "Sum of first two is larger than 5!",
    );
    cy.get(cesc("#\\/fb2")).should(
      "have.text",
      "Sum of first and third is larger than 5!",
    );
    cy.get(cesc("#\\/fb3")).should(
      "have.text",
      "Sum of second and third is larger than 5!",
    );
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "1");
  });

  it("number of awards credited, zero credits are triggered", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
        <text>a</text>
        <p>
        <mathinput name="mi1" />
        <mathinput name="mi2" />
        <mathinput name="mi3" />
        <answer numAwardsCredited="3" name="a">
          <award sourcesAreResponses="mi1 mi2 mi3" matchPartial>
            <when>$mi1=x and $mi2=y and $mi3=z</when>
          </award>
          <award credit="0" feedbackText="Nothing is in the right spot">
            <when>$mi1!=x and $mi2!=y and $mi3!=z</when>
          </award>
          <award credit="0" feedbackText="x is in the wrong spot">
            <when>$mi2=x or $mi3=x</when>
          </award>
          <award credit="0" feedbackText="y is in the wrong spot">
            <when>$mi1=y or $mi3=y</when>
          </award>
          <award credit="0" feedbackText="z is in the wrong spot">
            <when>$mi1=z or $mi2=z</when>
          </award>
          </answer>
        </p>

        <copy prop="feedbacks" target="a" assignNames="fb1 fb2 fb3 fb4 fb5" />

        <p>Credit: <copy assignNames="ca" prop="creditAchieved" target="a" displayDecimals="3" /></p>

 `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    let submitAnchor = cesc2("#/a_submit");
    let correctAnchor = cesc2("#/a_correct");
    let incorrectAnchor = cesc2("#/a_incorrect");
    let partialAnchor = cesc2("#/a_partial");

    cy.get(submitAnchor).should("be.visible");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("not.exist");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");

    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("have.text", "Nothing is in the right spot");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi1") + " textarea").type("z{enter}", { force: true });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("have.text", "Nothing is in the right spot");
    cy.get(cesc("#\\/fb2")).should("have.text", "z is in the wrong spot");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi2") + " textarea").type("y{enter}", { force: true });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("33% correct");
      });
    cy.get(cesc("#\\/fb1")).should("have.text", "z is in the wrong spot");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.333");

    cy.get(cesc("#\\/mi3") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("33% correct");
      });
    cy.get(cesc("#\\/fb1")).should("have.text", "x is in the wrong spot");
    cy.get(cesc("#\\/fb2")).should("have.text", "z is in the wrong spot");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.333");

    cy.get(cesc("#\\/mi1") + " textarea").type("{end}{backspace}y{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("33% correct");
      });
    cy.get(cesc("#\\/fb1")).should("have.text", "x is in the wrong spot");
    cy.get(cesc("#\\/fb2")).should("have.text", "y is in the wrong spot");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.333");

    cy.get(cesc("#\\/mi2") + " textarea").type("{end}{backspace}z{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("be.visible");
    cy.get(partialAnchor).should("not.exist");

    cy.get(cesc("#\\/fb1")).should("have.text", "Nothing is in the right spot");
    cy.get(cesc("#\\/fb2")).should("have.text", "x is in the wrong spot");
    cy.get(cesc("#\\/fb3")).should("have.text", "y is in the wrong spot");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi2") + " textarea").type("{end}{backspace}y{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/mi3") + " textarea").type("{end}{backspace}z{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("not.exist");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor)
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("67% correct");
      });
    cy.get(cesc("#\\/fb1")).should("have.text", "y is in the wrong spot");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "0.667");

    cy.get(cesc("#\\/mi1") + " textarea").type("{end}{backspace}x{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/a_submit")).click();

    cy.get(submitAnchor).should("not.exist");
    cy.get(correctAnchor).should("be.visible");
    cy.get(incorrectAnchor).should("not.exist");
    cy.get(partialAnchor).should("not.exist");
    cy.get(cesc("#\\/fb1")).should("not.exist");
    cy.get(cesc("#\\/fb2")).should("not.exist");
    cy.get(cesc("#\\/fb3")).should("not.exist");
    cy.get(cesc("#\\/fb4")).should("not.exist");
    cy.get(cesc("#\\/fb5")).should("not.exist");
    cy.get(cesc("#\\/ca")).should("have.text", "1");
  });

  it("numSubmissions", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer>
    <award><math>x+y</math></award>
  </answer></p>
  <p><answer type="text">hello</answer></p>
  <p>Number of submissions 1: <copy target="_answer1" prop="numSubmissions" assignNames="nsubs1" /></p>
  <p>Number of submissions 2: <copy target="_answer2" prop="numSubmissions" assignNames="nsubs2" /></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/nsubs1")).should("have.text", 0);
    cy.get(cesc("#\\/nsubs2")).should("have.text", 0);

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/_answer1"].stateValues.numSubmissions).eq(0);
      expect(stateVariables["/nsubs1"].stateValues.value).eq(0);
      expect(stateVariables["/_answer2"].stateValues.numSubmissions).eq(0);
      expect(stateVariables["/nsubs2"].stateValues.value).eq(0);

      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      let textinputName =
        stateVariables["/_answer2"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName + "_input");
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");

      cy.get(mathinputAnchor).type("x+y{enter}", { force: true });

      cy.get(cesc("#\\/nsubs1")).should("have.text", 1);
      cy.get(cesc("#\\/nsubs2")).should("have.text", 0);
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.numSubmissions).eq(1);
        expect(stateVariables["/nsubs1"].stateValues.value).eq(1);
        expect(stateVariables["/_answer2"].stateValues.numSubmissions).eq(0);
        expect(stateVariables["/nsubs2"].stateValues.value).eq(0);
      });

      cy.get(mathinputAnchor).type("{end}{backspace}{backspace}", {
        force: true,
      });

      cy.get(cesc("#\\/nsubs1")).should("have.text", 1);
      cy.get(cesc("#\\/nsubs2")).should("have.text", 0);
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.numSubmissions).eq(1);
        expect(stateVariables["/nsubs1"].stateValues.value).eq(1);
        expect(stateVariables["/_answer2"].stateValues.numSubmissions).eq(0);
        expect(stateVariables["/nsubs2"].stateValues.value).eq(0);
      });

      cy.get(textinputAnchor).type("h").blur();
      cy.get(cesc("#\\/nsubs1")).should("have.text", 1);
      cy.get(cesc("#\\/nsubs2")).should("have.text", 0);
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.numSubmissions).eq(1);
        expect(stateVariables["/nsubs1"].stateValues.value).eq(1);
        expect(stateVariables["/_answer2"].stateValues.numSubmissions).eq(0);
        expect(stateVariables["/nsubs2"].stateValues.value).eq(0);
      });

      cy.get(mathinputSubmitAnchor).click();

      cy.get(cesc("#\\/nsubs1")).should("have.text", 2);
      cy.get(cesc("#\\/nsubs2")).should("have.text", 0);
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.numSubmissions).eq(2);
        expect(stateVariables["/nsubs1"].stateValues.value).eq(2);
        expect(stateVariables["/_answer2"].stateValues.numSubmissions).eq(0);
        expect(stateVariables["/nsubs2"].stateValues.value).eq(0);
      });

      cy.get(textinputSubmitAnchor).click();

      cy.get(cesc("#\\/nsubs1")).should("have.text", 2);
      cy.get(cesc("#\\/nsubs2")).should("have.text", 1);

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.numSubmissions).eq(2);
        expect(stateVariables["/nsubs1"].stateValues.value).eq(2);
        expect(stateVariables["/_answer2"].stateValues.numSubmissions).eq(1);
        expect(stateVariables["/nsubs2"].stateValues.value).eq(1);
      });

      cy.get(textinputAnchor).clear().type("hello").blur();
      cy.get(mathinputAnchor).type("{end}+y", { force: true }).blur();

      cy.get(cesc("#\\/nsubs1")).should("have.text", 2);
      cy.get(cesc("#\\/nsubs2")).should("have.text", 1);
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.numSubmissions).eq(2);
        expect(stateVariables["/nsubs1"].stateValues.value).eq(2);
        expect(stateVariables["/_answer2"].stateValues.numSubmissions).eq(1);
        expect(stateVariables["/nsubs2"].stateValues.value).eq(1);
      });

      cy.get(mathinputSubmitAnchor).click();
      cy.get(cesc("#\\/nsubs1")).should("have.text", 3);
      cy.get(cesc("#\\/nsubs2")).should("have.text", 1);
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.numSubmissions).eq(3);
        expect(stateVariables["/nsubs1"].stateValues.value).eq(3);
        expect(stateVariables["/_answer2"].stateValues.numSubmissions).eq(1);
        expect(stateVariables["/nsubs2"].stateValues.value).eq(1);
      });

      cy.get(textinputSubmitAnchor).click();
      cy.get(cesc("#\\/nsubs1")).should("have.text", 3);
      cy.get(cesc("#\\/nsubs2")).should("have.text", 2);
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables["/_answer1"].stateValues.numSubmissions).eq(3);
        expect(stateVariables["/nsubs1"].stateValues.value).eq(3);
        expect(stateVariables["/_answer2"].stateValues.numSubmissions).eq(2);
        expect(stateVariables["/nsubs2"].stateValues.value).eq(2);
      });
    });
  });

  it("answer with choiceinput inside invalid child logic", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <problem>
    <sideBySide>
    
      <choiceInput inline name='choice1'>
        <choice>1</choice>
        <choice>2</choice>
        <choice>3</choice>
        <choice>4</choice>
        <choice>5</choice>
      </choiceInput>
    
    </sideBySide>
    <copy prop='selectedValue' target='choice1' assignNames="sv" />
    
    <answer>
      <award><when><copy prop='selectedValue' target='choice1' /> = 4</when></award>
    </answer>
  
  </problem>
    `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.log("Select correct answer");
    cy.get(cesc("#\\/choice1")).select(`4`);
    cy.get(cesc("#\\/sv")).should("have.text", "4");
    cy.get(cesc("#\\/_answer1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("check work");
      });
    cy.get(cesc("#\\/_answer1_correct")).should("not.exist");
    cy.get(cesc("#\\/_answer1_incorrect")).should("not.exist");
    cy.get(cesc("#\\/_answer1_partial")).should("not.exist");

    cy.log("Submit answer");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_answer1_correct"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("correct");
      });

    cy.log("Select incorrect answer and submit");
    cy.get(cesc("#\\/choice1")).select(`3`);
    cy.get(cesc("#\\/sv")).should("have.text", "3");
    cy.get(cesc("#\\/_answer1_submit")).click();
    cy.get(cesc("#\\/_answer1_incorrect"))
      .invoke("text")
      .then((text) => {
        expect(text.trim().toLowerCase()).equal("incorrect");
      });
  });

  it("maximum number of attempts", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer>x</answer></p>
  <p><answer maxNumAttempts="2">x</answer></p>
  <p><answer forceFullCheckworkButton>x</answer></p>
  <p><answer forceFullCheckworkButton maxNumAttempts="2">x</answer></p>
  
  <p><answer type="text">hello</answer></p>
  <p><answer type="text" maxNumAttempts="2">hello</answer></p>
  <p><answer type="text" forceFullCheckworkButton>hello</answer></p>
  <p><answer type="text" forceFullCheckworkButton maxNumAttempts="2">hello</answer></p>
    
  <p><answer>
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer maxNumAttempts="2">
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer forceFullCheckworkButton>
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer forceFullCheckworkButton maxNumAttempts="2">
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  
  <p><answer>
    <choiceinput inline>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer maxNumAttempts="2">
    <choiceinput inline>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer forceFullCheckworkButton>
    <choiceinput inline>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer forceFullCheckworkButton maxNumAttempts="2">
    <choiceinput inline>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>

  <p><answer type="boolean">true</answer></p>
  <p><answer type="boolean" maxNumAttempts="2">true</answer></p>
  <p><answer type="boolean" forceFullCheckworkButton>true</answer></p>
  <p><answer type="boolean" forceFullCheckworkButton maxNumAttempts="2">true</answer></p>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      let inputNames = [...Array(20).keys()].map(
        (n) =>
          stateVariables[`/_answer${n + 1}`].stateValues.inputChildren[0]
            .componentName,
      );

      cy.log("Submit correct answers");
      cy.get(cesc2("#" + inputNames[0]) + " textarea").type("x{enter}", {
        force: true,
      });
      cy.get(cesc2("#" + inputNames[1]) + " textarea").type("x{enter}", {
        force: true,
      });
      cy.get(cesc2("#" + inputNames[2]) + " textarea").type("x{enter}", {
        force: true,
      });
      cy.get(cesc2("#" + inputNames[3]) + " textarea").type("x{enter}", {
        force: true,
      });
      cy.get(cesc2("#/_answer3_submit")).click();
      cy.get(cesc2("#/_answer4_submit")).click();
      cy.get(cesc2("#" + inputNames[0]) + "_correct").should("be.visible");
      cy.get(cesc2("#" + inputNames[1]) + "_correct").should("be.visible");
      cy.get(cesc2("#/_answer3_correct")).should("be.visible");
      cy.get(cesc2("#/_answer4_correct")).should("be.visible");

      cy.get(cesc2("#" + inputNames[4]) + "_input").type("hello{enter}");
      cy.get(cesc2("#" + inputNames[5]) + "_input").type("hello{enter}");
      cy.get(cesc2("#" + inputNames[6]) + "_input").type("hello{enter}");
      cy.get(cesc2("#" + inputNames[7]) + "_input").type("hello{enter}");
      cy.get(cesc2("#/_answer7_submit")).click();
      cy.get(cesc2("#/_answer8_submit")).click();
      cy.get(cesc2("#" + inputNames[4]) + "_correct").should("be.visible");
      cy.get(cesc2("#" + inputNames[5]) + "_correct").should("be.visible");
      cy.get(cesc2("#/_answer7_correct")).should("be.visible");
      cy.get(cesc2("#/_answer8_correct")).should("be.visible");

      cy.get(cesc2("#/_choiceinput1")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput2")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput3")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput4")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput1_submit")).click();
      cy.get(cesc2("#/_choiceinput2_submit")).click();
      cy.get(cesc2("#/_answer11_submit")).click();
      cy.get(cesc2("#/_answer12_submit")).click();
      cy.get(cesc2("#/_choiceinput1_correct")).should("be.visible");
      cy.get(cesc2("#/_choiceinput2_correct")).should("be.visible");
      cy.get(cesc2("#/_answer11_correct")).should("be.visible");
      cy.get(cesc2("#/_answer12_correct")).should("be.visible");

      cy.get(cesc("#\\/_choiceinput5")).select(`yes`);
      cy.get(cesc("#\\/_choiceinput6")).select(`yes`);
      cy.get(cesc("#\\/_choiceinput7")).select(`yes`);
      cy.get(cesc("#\\/_choiceinput8")).select(`yes`);
      cy.get(cesc2("#/_choiceinput5_submit")).click();
      cy.get(cesc2("#/_choiceinput6_submit")).click();
      cy.get(cesc2("#/_answer15_submit")).click();
      cy.get(cesc2("#/_answer16_submit")).click();
      cy.get(cesc2("#/_choiceinput5_correct")).should("be.visible");
      cy.get(cesc2("#/_choiceinput6_correct")).should("be.visible");
      cy.get(cesc2("#/_answer15_correct")).should("be.visible");
      cy.get(cesc2("#/_answer16_correct")).should("be.visible");

      cy.get(cesc2("#" + inputNames[16])).click();
      cy.get(cesc2("#" + inputNames[17])).click();
      cy.get(cesc2("#" + inputNames[18])).click();
      cy.get(cesc2("#" + inputNames[19])).click();
      cy.get(cesc2("#" + inputNames[16]) + "_submit").click();
      cy.get(cesc2("#" + inputNames[17]) + "_submit").click();
      cy.get(cesc2("#/_answer19_submit")).click();
      cy.get(cesc2("#/_answer20_submit")).click();
      cy.get(cesc2("#" + inputNames[16]) + "_correct").should("be.visible");
      cy.get(cesc2("#" + inputNames[17]) + "_correct").should("be.visible");
      cy.get(cesc2("#/_answer19_correct")).should("be.visible");
      cy.get(cesc2("#/_answer20_correct")).should("be.visible");

      cy.log("Submit incorrect answers");
      cy.get(cesc2("#" + inputNames[0]) + " textarea").type(
        "{end}{backspace}y",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[1]) + " textarea").type(
        "{end}{backspace}y",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[2]) + " textarea").type(
        "{end}{backspace}y",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[3]) + " textarea").type(
        "{end}{backspace}y",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[0]) + "_submit").click();
      cy.get(cesc2("#" + inputNames[1]) + "_submit").click();
      cy.get(cesc2("#/_answer3_submit")).click();
      cy.get(cesc2("#/_answer4_submit")).click();
      cy.get(cesc2("#" + inputNames[0]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#" + inputNames[1]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#/_answer3_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer4_incorrect")).should("be.visible");

      cy.get(cesc2("#" + inputNames[4]) + "_input")
        .clear()
        .type("bye");
      cy.get(cesc2("#" + inputNames[5]) + "_input")
        .clear()
        .type("bye");
      cy.get(cesc2("#" + inputNames[6]) + "_input")
        .clear()
        .type("bye");
      cy.get(cesc2("#" + inputNames[7]) + "_input")
        .clear()
        .type("bye");
      cy.get(cesc2("#" + inputNames[4]) + "_submit").click();
      cy.get(cesc2("#" + inputNames[5]) + "_submit").click();
      cy.get(cesc2("#/_answer7_submit")).click();
      cy.get(cesc2("#/_answer8_submit")).click();
      cy.get(cesc2("#" + inputNames[4]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#" + inputNames[5]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#/_answer7_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer8_incorrect")).should("be.visible");

      cy.get(cesc2("#/_choiceinput1")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput2")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput3")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput4")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput1_submit")).click();
      cy.get(cesc2("#/_choiceinput2_submit")).click();
      cy.get(cesc2("#/_answer11_submit")).click();
      cy.get(cesc2("#/_answer12_submit")).click();
      cy.get(cesc2("#/_choiceinput1_incorrect")).should("be.visible");
      cy.get(cesc2("#/_choiceinput2_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer11_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer12_incorrect")).should("be.visible");

      cy.get(cesc("#\\/_choiceinput5")).select(`no`);
      cy.get(cesc("#\\/_choiceinput6")).select(`no`);
      cy.get(cesc("#\\/_choiceinput7")).select(`no`);
      cy.get(cesc("#\\/_choiceinput8")).select(`no`);
      cy.get(cesc2("#/_choiceinput5_submit")).click();
      cy.get(cesc2("#/_choiceinput6_submit")).click();
      cy.get(cesc2("#/_answer15_submit")).click();
      cy.get(cesc2("#/_answer16_submit")).click();
      cy.get(cesc2("#/_choiceinput5_incorrect")).should("be.visible");
      cy.get(cesc2("#/_choiceinput6_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer15_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer16_incorrect")).should("be.visible");

      cy.get(cesc2("#" + inputNames[16])).click();
      cy.get(cesc2("#" + inputNames[17])).click();
      cy.get(cesc2("#" + inputNames[18])).click();
      cy.get(cesc2("#" + inputNames[19])).click();
      cy.get(cesc2("#" + inputNames[16]) + "_submit").click();
      cy.get(cesc2("#" + inputNames[17]) + "_submit").click();
      cy.get(cesc2("#/_answer19_submit")).click();
      cy.get(cesc2("#/_answer20_submit")).click();
      cy.get(cesc2("#" + inputNames[16]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#" + inputNames[17]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#/_answer19_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer20_incorrect")).should("be.visible");

      cy.log("Type to submit correct answers again");

      // the 2nd and 4th input should be disabled,
      // but this isn't working yet.
      // For now, best we can do is make sure button still say incorrect
      cy.get(cesc2("#" + inputNames[0]) + " textarea").type(
        "{end}{backspace}x",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[1]) + " textarea").type(
        "{end}{backspace}x",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[2]) + " textarea").type(
        "{end}{backspace}x",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[3]) + " textarea").type(
        "{end}{backspace}x",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[0]) + "_submit").click();
      cy.get(cesc2("#/_answer3_submit")).click();
      cy.get(cesc2("#" + inputNames[0]) + "_correct").should("be.visible");
      cy.get(cesc2("#" + inputNames[1]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#/_answer3_correct")).should("be.visible");
      cy.get(cesc2("#/_answer4_incorrect")).should("be.visible");

      cy.get(cesc2("#" + inputNames[4]) + "_input")
        .clear()
        .type("hello");
      cy.get(cesc2("#" + inputNames[5]) + "_input").should("be.disabled");
      cy.get(cesc2("#" + inputNames[6]) + "_input")
        .clear()
        .type("hello");
      cy.get(cesc2("#" + inputNames[7]) + "_input").should("be.disabled");
      cy.get(cesc2("#" + inputNames[4]) + "_submit").click();
      cy.get(cesc2("#/_answer7_submit")).click();
      cy.get(cesc2("#" + inputNames[4]) + "_correct").should("be.visible");
      cy.get(cesc2("#" + inputNames[5]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#/_answer7_correct")).should("be.visible");
      cy.get(cesc2("#/_answer8_incorrect")).should("be.visible");

      cy.get(cesc2("#/_choiceinput1")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput2")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput3")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput4")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput1_submit")).click();
      cy.get(cesc2("#/_answer11_submit")).click();
      cy.get(cesc2("#/_choiceinput1_correct")).should("be.visible");
      cy.get(cesc2("#/_choiceinput2_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer11_correct")).should("be.visible");
      cy.get(cesc2("#/_answer12_incorrect")).should("be.visible");

      cy.get(cesc("#\\/_choiceinput5")).select(`yes`);
      cy.get(cesc("#\\/_choiceinput6")).should("be.disabled");
      cy.get(cesc("#\\/_choiceinput7")).select(`yes`);
      cy.get(cesc("#\\/_choiceinput8")).should("be.disabled");
      cy.get(cesc2("#/_choiceinput5_submit")).click();
      cy.get(cesc2("#/_answer15_submit")).click();
      cy.get(cesc2("#/_choiceinput5_correct")).should("be.visible");
      cy.get(cesc2("#/_choiceinput6_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer15_correct")).should("be.visible");
      cy.get(cesc2("#/_answer16_incorrect")).should("be.visible");

      cy.get(cesc2("#" + inputNames[16])).click();
      cy.get(cesc2("#" + inputNames[17]) + "_input").should("be.disabled");
      cy.get(cesc2("#" + inputNames[18])).click();
      cy.get(cesc2("#" + inputNames[19]) + "_input").should("be.disabled");
      cy.get(cesc2("#" + inputNames[16]) + "_submit").click();
      cy.get(cesc2("#/_answer19_submit")).click();
      cy.get(cesc2("#" + inputNames[16]) + "_correct").should("be.visible");
      cy.get(cesc2("#" + inputNames[17]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#/_answer19_correct")).should("be.visible");
      cy.get(cesc2("#/_answer20_incorrect")).should("be.visible");
    });
  });

  it("disable after correct", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer>x</answer></p>
  <p><answer disableAfterCorrect>x</answer></p>
  <p><answer forceFullCheckworkButton>x</answer></p>
  <p><answer forceFullCheckworkButton disableAfterCorrect>x</answer></p>
  
  <p><answer type="text">hello</answer></p>
  <p><answer type="text" disableAfterCorrect>hello</answer></p>
  <p><answer type="text" forceFullCheckworkButton>hello</answer></p>
  <p><answer type="text" forceFullCheckworkButton disableAfterCorrect>hello</answer></p>
    
  <p><answer>
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer disableAfterCorrect>
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer forceFullCheckworkButton>
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer forceFullCheckworkButton disableAfterCorrect>
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  
  <p><answer>
    <choiceinput inline>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer disableAfterCorrect>
    <choiceinput inline>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer forceFullCheckworkButton>
    <choiceinput inline>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer forceFullCheckworkButton disableAfterCorrect>
    <choiceinput inline>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>

  <p><answer type="boolean">true</answer></p>
  <p><answer type="boolean" disableAfterCorrect>true</answer></p>
  <p><answer type="boolean" forceFullCheckworkButton>true</answer></p>
  <p><answer type="boolean" forceFullCheckworkButton disableAfterCorrect>true</answer></p>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      let inputNames = [...Array(20).keys()].map(
        (n) =>
          stateVariables[`/_answer${n + 1}`].stateValues.inputChildren[0]
            .componentName,
      );

      cy.log("Submit incorrect answers");
      cy.get(cesc2("#" + inputNames[0]) + " textarea").type("y{enter}", {
        force: true,
      });
      cy.get(cesc2("#" + inputNames[1]) + " textarea").type("y{enter}", {
        force: true,
      });
      cy.get(cesc2("#" + inputNames[2]) + " textarea").type("y{enter}", {
        force: true,
      });
      cy.get(cesc2("#" + inputNames[3]) + " textarea").type("y{enter}", {
        force: true,
      });
      cy.get(cesc2("#/_answer3_submit")).click();
      cy.get(cesc2("#/_answer4_submit")).click();
      cy.get(cesc2("#" + inputNames[0]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#" + inputNames[1]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#/_answer3_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer4_incorrect")).should("be.visible");

      cy.get(cesc2("#" + inputNames[4]) + "_input").type("bye{enter}");
      cy.get(cesc2("#" + inputNames[5]) + "_input").type("bye{enter}");
      cy.get(cesc2("#" + inputNames[6]) + "_input").type("bye{enter}");
      cy.get(cesc2("#" + inputNames[7]) + "_input").type("bye{enter}");
      cy.get(cesc2("#/_answer7_submit")).click();
      cy.get(cesc2("#/_answer8_submit")).click();
      cy.get(cesc2("#" + inputNames[4]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#" + inputNames[5]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#/_answer7_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer8_incorrect")).should("be.visible");

      cy.get(cesc2("#/_choiceinput1")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput2")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput3")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput4")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput1_submit")).click();
      cy.get(cesc2("#/_choiceinput2_submit")).click();
      cy.get(cesc2("#/_answer11_submit")).click();
      cy.get(cesc2("#/_answer12_submit")).click();
      cy.get(cesc2("#/_choiceinput1_incorrect")).should("be.visible");
      cy.get(cesc2("#/_choiceinput2_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer11_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer12_incorrect")).should("be.visible");

      cy.get(cesc("#\\/_choiceinput5")).select(`no`);
      cy.get(cesc("#\\/_choiceinput6")).select(`no`);
      cy.get(cesc("#\\/_choiceinput7")).select(`no`);
      cy.get(cesc("#\\/_choiceinput8")).select(`no`);
      cy.get(cesc2("#/_choiceinput5_submit")).click();
      cy.get(cesc2("#/_choiceinput6_submit")).click();
      cy.get(cesc2("#/_answer15_submit")).click();
      cy.get(cesc2("#/_answer16_submit")).click();
      cy.get(cesc2("#/_choiceinput5_incorrect")).should("be.visible");
      cy.get(cesc2("#/_choiceinput6_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer15_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer16_incorrect")).should("be.visible");

      cy.get(cesc2("#" + inputNames[16]) + "_submit").click();
      cy.get(cesc2("#" + inputNames[17]) + "_submit").click();
      cy.get(cesc2("#/_answer19_submit")).click();
      cy.get(cesc2("#/_answer20_submit")).click();
      cy.get(cesc2("#" + inputNames[16]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#" + inputNames[17]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#/_answer19_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer20_incorrect")).should("be.visible");

      cy.log("Submit correct answers");
      cy.get(cesc2("#" + inputNames[0]) + " textarea").type(
        "{end}{backspace}x",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[1]) + " textarea").type(
        "{end}{backspace}x",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[2]) + " textarea").type(
        "{end}{backspace}x",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[3]) + " textarea").type(
        "{end}{backspace}x",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[0]) + "_submit").click();
      cy.get(cesc2("#" + inputNames[1]) + "_submit").click();
      cy.get(cesc2("#/_answer3_submit")).click();
      cy.get(cesc2("#/_answer4_submit")).click();
      cy.get(cesc2("#" + inputNames[0]) + "_correct").should("be.visible");
      cy.get(cesc2("#" + inputNames[1]) + "_correct").should("be.visible");
      cy.get(cesc2("#/_answer3_correct")).should("be.visible");
      cy.get(cesc2("#/_answer4_correct")).should("be.visible");

      cy.get(cesc2("#" + inputNames[4]) + "_input")
        .clear()
        .type("hello");
      cy.get(cesc2("#" + inputNames[5]) + "_input")
        .clear()
        .type("hello");
      cy.get(cesc2("#" + inputNames[6]) + "_input")
        .clear()
        .type("hello");
      cy.get(cesc2("#" + inputNames[7]) + "_input")
        .clear()
        .type("hello");
      cy.get(cesc2("#" + inputNames[4]) + "_submit").click();
      cy.get(cesc2("#" + inputNames[5]) + "_submit").click();
      cy.get(cesc2("#/_answer7_submit")).click();
      cy.get(cesc2("#/_answer8_submit")).click();
      cy.get(cesc2("#" + inputNames[4]) + "_correct").should("be.visible");
      cy.get(cesc2("#" + inputNames[5]) + "_correct").should("be.visible");
      cy.get(cesc2("#/_answer7_correct")).should("be.visible");
      cy.get(cesc2("#/_answer8_correct")).should("be.visible");

      cy.get(cesc2("#/_choiceinput1")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput2")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput3")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput4")).contains("yes").click({ force: true });
      cy.get(cesc2("#/_choiceinput1_submit")).click();
      cy.get(cesc2("#/_choiceinput2_submit")).click();
      cy.get(cesc2("#/_answer11_submit")).click();
      cy.get(cesc2("#/_answer12_submit")).click();
      cy.get(cesc2("#/_choiceinput1_correct")).should("be.visible");
      cy.get(cesc2("#/_choiceinput2_correct")).should("be.visible");
      cy.get(cesc2("#/_answer11_correct")).should("be.visible");
      cy.get(cesc2("#/_answer12_correct")).should("be.visible");

      cy.get(cesc("#\\/_choiceinput5")).select(`yes`);
      cy.get(cesc("#\\/_choiceinput6")).select(`yes`);
      cy.get(cesc("#\\/_choiceinput7")).select(`yes`);
      cy.get(cesc("#\\/_choiceinput8")).select(`yes`);
      cy.get(cesc2("#/_choiceinput5_submit")).click();
      cy.get(cesc2("#/_choiceinput6_submit")).click();
      cy.get(cesc2("#/_answer15_submit")).click();
      cy.get(cesc2("#/_answer16_submit")).click();
      cy.get(cesc2("#/_choiceinput5_correct")).should("be.visible");
      cy.get(cesc2("#/_choiceinput6_correct")).should("be.visible");
      cy.get(cesc2("#/_answer15_correct")).should("be.visible");
      cy.get(cesc2("#/_answer16_correct")).should("be.visible");

      cy.get(cesc2("#" + inputNames[16])).click();
      cy.get(cesc2("#" + inputNames[17])).click();
      cy.get(cesc2("#" + inputNames[18])).click();
      cy.get(cesc2("#" + inputNames[19])).click();
      cy.get(cesc2("#" + inputNames[16]) + "_submit").click();
      cy.get(cesc2("#" + inputNames[17]) + "_submit").click();
      cy.get(cesc2("#/_answer19_submit")).click();
      cy.get(cesc2("#/_answer20_submit")).click();
      cy.get(cesc2("#" + inputNames[16]) + "_correct").should("be.visible");
      cy.get(cesc2("#" + inputNames[17]) + "_correct").should("be.visible");
      cy.get(cesc2("#/_answer19_correct")).should("be.visible");
      cy.get(cesc2("#/_answer20_correct")).should("be.visible");

      cy.log("Type to submit incorrect answers again");

      // the 2nd and 4th input should be disabled,
      // but this isn't working yet.
      // For now, best we can do is make sure button still say incorrect
      cy.get(cesc2("#" + inputNames[0]) + " textarea").type(
        "{end}{backspace}y",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[1]) + " textarea").type(
        "{end}{backspace}y",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[2]) + " textarea").type(
        "{end}{backspace}y",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[3]) + " textarea").type(
        "{end}{backspace}y",
        { force: true },
      );
      cy.get(cesc2("#" + inputNames[0]) + "_submit").click();
      cy.get(cesc2("#/_answer3_submit")).click();
      cy.get(cesc2("#" + inputNames[0]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#" + inputNames[1]) + "_correct").should("be.visible");
      cy.get(cesc2("#/_answer3_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer4_correct")).should("be.visible");

      cy.get(cesc2("#" + inputNames[4]) + "_input")
        .clear()
        .type("bye");
      cy.get(cesc2("#" + inputNames[5]) + "_input").should("be.disabled");
      cy.get(cesc2("#" + inputNames[6]) + "_input")
        .clear()
        .type("bye");
      cy.get(cesc2("#" + inputNames[7]) + "_input").should("be.disabled");
      cy.get(cesc2("#" + inputNames[4]) + "_submit").click();
      cy.get(cesc2("#/_answer7_submit")).click();
      cy.get(cesc2("#" + inputNames[4]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#" + inputNames[5]) + "_correct").should("be.visible");
      cy.get(cesc2("#/_answer7_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer8_correct")).should("be.visible");

      cy.get(cesc2("#/_choiceinput1")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput2")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput3")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput4")).contains("no").click({ force: true });
      cy.get(cesc2("#/_choiceinput1_submit")).click();
      cy.get(cesc2("#/_answer11_submit")).click();
      cy.get(cesc2("#/_choiceinput1_incorrect")).should("be.visible");
      cy.get(cesc2("#/_choiceinput2_correct")).should("be.visible");
      cy.get(cesc2("#/_answer11_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer12_correct")).should("be.visible");

      cy.get(cesc("#\\/_choiceinput5")).select(`no`);
      cy.get(cesc("#\\/_choiceinput6")).should("be.disabled");
      cy.get(cesc("#\\/_choiceinput7")).select(`no`);
      cy.get(cesc("#\\/_choiceinput8")).should("be.disabled");
      cy.get(cesc2("#/_choiceinput5_submit")).click();
      cy.get(cesc2("#/_answer15_submit")).click();
      cy.get(cesc2("#/_choiceinput5_incorrect")).should("be.visible");
      cy.get(cesc2("#/_choiceinput6_correct")).should("be.visible");
      cy.get(cesc2("#/_answer15_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer16_correct")).should("be.visible");

      cy.get(cesc2("#" + inputNames[16])).click();
      cy.get(cesc2("#" + inputNames[17]) + "_input").should("be.disabled");
      cy.get(cesc2("#" + inputNames[18])).click();
      cy.get(cesc2("#" + inputNames[19]) + "_input").should("be.disabled");
      cy.get(cesc2("#" + inputNames[16]) + "_submit").click();
      cy.get(cesc2("#/_answer19_submit")).click();
      cy.get(cesc2("#" + inputNames[16]) + "_incorrect").should("be.visible");
      cy.get(cesc2("#" + inputNames[17]) + "_correct").should("be.visible");
      cy.get(cesc2("#/_answer19_incorrect")).should("be.visible");
      cy.get(cesc2("#/_answer20_correct")).should("be.visible");
    });
  });

  it("disable after correct, depends on external", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>

  <graph>
    <point name="A" x="0" y="0">
      <constraints>
        <attractTo><point>(3,4)</point></attractTo>
        <attractTo><point>(-5,6)</point></attractTo>
      </constraints>
    </point>
  </graph>

  <p>Move point to <m>(3,4)</m>: </p>
  <p><answer>
    <award sourcesAreResponses="A">
      <when>$A = (3,4)</when>
    </award>
  </answer></p>
  <p><answer disableAfterCorrect>
    <award sourcesAreResponses="A">
      <when>$A = (3,4)</when>
    </award>
  </answer></p>

  <p>Move point to <m>(-5,6)</m>: </p>
  <p><answer>
    <award sourcesAreResponses="A">
      <when>$A = (-5,6)</when>
    </award>
  </answer></p>
  <p><answer disableAfterCorrect>
    <award sourcesAreResponses="A">
      <when>$A = (-5,6)</when>
    </award>
  </answer></p>

  <p><mathinput name="mi" /></p>

  <p>Enter <m>x</m> in above blank.</p>
  <p><answer>
    <award sourcesAreResponses="mi"><when>$mi=x</when></award>
  </answer></p>
  <p><answer disableAfterCorrect>
    <award sourcesAreResponses="mi"><when>$mi=x</when></award>
  </answer></p>

  <p>Enter <m>y</m> in above blank.</p>
  <p><answer>
    <award sourcesAreResponses="mi"><when>$mi=y</when></award>
  </answer></p>
  <p><answer disableAfterCorrect>
    <award sourcesAreResponses="mi"><when>$mi=y</when></award>
  </answer></p>

   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.log("Submit incorrect answers");
    for (let i = 1; i <= 8; i++) {
      cy.get(cesc(`#\\/_answer${i}_submit`)).click();
      cy.get(cesc(`#\\/_answer${i}_incorrect`)).should("be.visible");
    }

    cy.log("submit first correct answers");
    cy.window().then(async (win) => {
      await win.callAction1({
        actionName: "movePoint",
        componentName: "/A",
        args: { x: 3, y: 4 },
      });
    });
    cy.get(cesc("#\\/mi") + " textarea").type("x{enter}", { force: true });

    for (let i = 1; i <= 8; i++) {
      cy.get(cesc(`#\\/_answer${i}_submit`)).click();
      if (i % 4 === 1 || i % 4 == 2) {
        cy.get(cesc(`#\\/_answer${i}_correct`)).should("be.visible");
      } else {
        cy.get(cesc(`#\\/_answer${i}_incorrect`)).should("be.visible");
      }
    }

    cy.log("submit second correct answers");
    cy.window().then(async (win) => {
      await win.callAction1({
        actionName: "movePoint",
        componentName: "/A",
        args: { x: -5, y: 6 },
      });
    });
    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}y{enter}", {
      force: true,
    });

    for (let i = 1; i <= 8; i++) {
      if (i % 4 !== 2) {
        cy.get(cesc(`#\\/_answer${i}_submit`)).click();
      }
      if (i % 4 === 1) {
        cy.get(cesc(`#\\/_answer${i}_incorrect`)).should("be.visible");
      } else {
        cy.get(cesc(`#\\/_answer${i}_correct`)).should("be.visible");
      }
    }

    cy.log("submit second incorrect answers");
    cy.window().then(async (win) => {
      await win.callAction1({
        actionName: "movePoint",
        componentName: "/A",
        args: { x: 1, y: -1 },
      });
    });
    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}z{enter}", {
      force: true,
    });

    for (let i = 1; i <= 8; i++) {
      if (i % 4 === 2 || i % 4 === 0) {
        cy.get(cesc(`#\\/_answer${i}_correct`)).should("be.visible");
      } else {
        cy.get(cesc(`#\\/_answer${i}_submit`)).click();
        cy.get(cesc(`#\\/_answer${i}_incorrect`)).should("be.visible");
      }
    }
  });

  it("award based on choice text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer>
    <choiceinput inline>
      <choice name="ca">cat</choice>
      <choice credit="1">dog</choice>
      <choice>monkey</choice>
    </choiceinput>
    <award><when>$_choiceinput1 = <copy prop="text" target="ca" /></when></award>
  </answer>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1")).select(`cat`);
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_correct")).should("be.visible");

    cy.get(cesc("#\\/_choiceinput1")).select(`dog`);
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");

    cy.get(cesc("#\\/_choiceinput1")).select(`monkey`);
    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput1_incorrect")).should("be.visible");
  });

  it("error expressions are not matched", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer>x^</answer>
  <answer symbolicEquality>x^</answer>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinput1Name =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinput1Anchor = cesc2("#" + mathinput1Name) + " textarea";
      let mathinput1SubmitAnchor = cesc2("#" + mathinput1Name + "_submit");
      let mathinput1CorrectAnchor = cesc2("#" + mathinput1Name + "_correct");
      let mathinput1IncorrectAnchor = cesc2(
        "#" + mathinput1Name + "_incorrect",
      );

      let mathinput2Name =
        stateVariables["/_answer2"].stateValues.inputChildren[0].componentName;
      let mathinput2Anchor = cesc2("#" + mathinput2Name) + " textarea";
      let mathinput2SubmitAnchor = cesc2("#" + mathinput2Name + "_submit");
      let mathinput2CorrectAnchor = cesc2("#" + mathinput2Name + "_correct");
      let mathinput2IncorrectAnchor = cesc2(
        "#" + mathinput2Name + "_incorrect",
      );

      cy.get(mathinput1SubmitAnchor).click();
      cy.get(mathinput1IncorrectAnchor).should("be.visible");
      cy.get(mathinput2SubmitAnchor).click();
      cy.get(mathinput2IncorrectAnchor).should("be.visible");

      cy.get(mathinput1Anchor).type("x^{enter}", { force: true });
      cy.get(mathinput1IncorrectAnchor).should("be.visible");
      cy.get(mathinput2Anchor).type("x^{enter}", { force: true });
      cy.get(mathinput2IncorrectAnchor).should("be.visible");

      cy.get(mathinput1Anchor).type("{end}{leftArrow}2{enter}", {
        force: true,
      });
      cy.get(mathinput1IncorrectAnchor).should("be.visible");
      cy.get(mathinput2Anchor).type("{end}{leftArrow}2{enter}", {
        force: true,
      });
      cy.get(mathinput2IncorrectAnchor).should("be.visible");
    });
  });

  it("with split symbols, specified directly on mathinput and math", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>split symbols: <booleaninput name="split" /></p>
  <p>Answer: <math name="ans" splitSymbols="$split">xyz</math></p>
  <answer>
    <mathinput name="mi" splitSymbols="$ans.splitSymbols" />
    <award>$ans</award>
  </answer>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/mi") + " textarea").type("xyz{enter}", { force: true });
    cy.get(cesc("#\\/mi_correct")).should("be.visible");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/ans"].stateValues.value).eqls("xyz");
      expect(stateVariables["/mi"].stateValues.value).eqls("xyz");
    });

    cy.get(cesc("#\\/split")).click();

    // modify mathinput so that recalculates value
    cy.get(cesc("#\\/mi") + " textarea").type("{end}a{backspace}", {
      force: true,
    });
    cy.get(cesc("#\\/mi_submit")).click();
    cy.get(cesc("#\\/mi_correct")).should("be.visible");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/ans"].stateValues.value).eqls([
        "*",
        "x",
        "y",
        "z",
      ]);
      expect(stateVariables["/mi"].stateValues.value).eqls([
        "*",
        "x",
        "y",
        "z",
      ]);
    });

    cy.get(cesc("#\\/split")).click();

    // modify mathinput so that recalculates value
    cy.get(cesc("#\\/mi") + " textarea").type("{end}b{backspace}", {
      force: true,
    });
    cy.get(cesc("#\\/mi_submit")).click();

    cy.get(cesc("#\\/mi_correct")).should("be.visible");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/ans"].stateValues.value).eqls("xyz");
      expect(stateVariables["/mi"].stateValues.value).eqls("xyz");
    });
  });

  it("with split symbols, sugared answer", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>split symbols: <booleaninput name="split" /></p>
  <answer splitSymbols="$split">xyz</answer>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");
      let mathName =
        stateVariables[
          stateVariables["/_answer1"].activeChildren[1].componentName
        ].activeChildren[0].componentName;

      cy.get(mathinputAnchor).type("xyz{enter}", { force: true });
      cy.get(mathinputCorrectAnchor).should("be.visible");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables[mathName].stateValues.value).eqls("xyz");
        expect(stateVariables[mathinputName].stateValues.value).eqls("xyz");
      });

      cy.get(cesc("#\\/split")).click();

      // modify mathinput so that recalculates value
      cy.get(mathinputAnchor).type("{end}a{backspace}", { force: true });
      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputCorrectAnchor).should("be.visible");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables[mathName].stateValues.value).eqls([
          "*",
          "x",
          "y",
          "z",
        ]);
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "*",
          "x",
          "y",
          "z",
        ]);
      });

      cy.get(cesc("#\\/split")).click();

      // modify mathinput so that recalculates value
      cy.get(mathinputAnchor).type("{end}b{backspace}", { force: true });
      cy.get(mathinputSubmitAnchor).click();

      cy.get(mathinputCorrectAnchor).should("be.visible");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables[mathName].stateValues.value).eqls("xyz");
        expect(stateVariables[mathinputName].stateValues.value).eqls("xyz");
      });
    });
  });

  it("with split symbols, shortcut award, sugared math", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>split symbols: <booleaninput name="split" /></p>
  <answer splitSymbols="$split">
    <award>xyz</award>
  </answer>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");
      let mathName = stateVariables["/_award1"].activeChildren[0].componentName;

      cy.get(mathinputAnchor).type("xyz{enter}", { force: true });
      cy.get(mathinputCorrectAnchor).should("be.visible");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables[mathName].stateValues.value).eqls("xyz");
        expect(stateVariables[mathinputName].stateValues.value).eqls("xyz");
      });

      cy.get(cesc("#\\/split")).click();

      // modify mathinput so that recalculates value
      cy.get(mathinputAnchor).type("{end}a{backspace}", { force: true });
      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputCorrectAnchor).should("be.visible");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables[mathName].stateValues.value).eqls([
          "*",
          "x",
          "y",
          "z",
        ]);
        expect(stateVariables[mathinputName].stateValues.value).eqls([
          "*",
          "x",
          "y",
          "z",
        ]);
      });

      cy.get(cesc("#\\/split")).click();

      // modify mathinput so that recalculates value
      cy.get(mathinputAnchor).type("{end}b{backspace}", { force: true });
      cy.get(mathinputSubmitAnchor).click();

      cy.get(mathinputCorrectAnchor).should("be.visible");

      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();
        expect(stateVariables[mathName].stateValues.value).eqls("xyz");
        expect(stateVariables[mathinputName].stateValues.value).eqls("xyz");
      });
    });
  });

  it("with split symbols, explicit mathinput and math, but inferred split symbols", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>split symbols: <booleaninput name="split" /></p>
  <answer splitSymbols="$split">
    <mathinput name="mi" />
    <award><math name="ans">xyz</math></award>
  </answer>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/mi") + " textarea").type("xyz{enter}", { force: true });
    cy.get(cesc("#\\/mi_correct")).should("be.visible");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/ans"].stateValues.value).eqls("xyz");
      expect(stateVariables["/mi"].stateValues.value).eqls("xyz");
    });

    cy.get(cesc("#\\/split")).click();

    // modify mathinput so that recalculates value
    cy.get(cesc("#\\/mi") + " textarea").type("{end}a{backspace}", {
      force: true,
    });
    cy.get(cesc("#\\/mi_submit")).click();
    cy.get(cesc("#\\/mi_correct")).should("be.visible");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/ans"].stateValues.value).eqls([
        "*",
        "x",
        "y",
        "z",
      ]);
      expect(stateVariables["/mi"].stateValues.value).eqls([
        "*",
        "x",
        "y",
        "z",
      ]);
    });

    cy.get(cesc("#\\/split")).click();

    // modify mathinput so that recalculates value
    cy.get(cesc("#\\/mi") + " textarea").type("{end}b{backspace}", {
      force: true,
    });
    cy.get(cesc("#\\/mi_submit")).click();

    cy.get(cesc("#\\/mi_correct")).should("be.visible");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      expect(stateVariables["/ans"].stateValues.value).eqls("xyz");
      expect(stateVariables["/mi"].stateValues.value).eqls("xyz");
    });
  });

  it("justSubmitted with expression containing NaN", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer><mathinput name="mi" /><award><math><number>0/0</number>+1</math></award></answer>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/mi") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/mi_incorrect")).should("be.visible");
  });

  it("copy justSubmitted attribute", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer name="ans">
    <mathinput name="mi" />
    <award>1</award>
  </answer>
  <conditionalContent condition="$ans.justSubmitted" assignNames="just">
    <p>The answer was just submitted.</p>
  </conditionalContent>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/mi_submit")).should("be.visible");
    cy.get(cesc("#\\/mi_correct")).should("not.exist");
    cy.get(cesc("#\\/mi_incorrect")).should("not.exist");
    cy.get(cesc("#\\/just")).should("not.exist");

    cy.get(cesc("#\\/mi") + " textarea").type("x", { force: true });
    cy.get(cesc("#\\/mi_submit")).should("be.visible");
    cy.get(cesc("#\\/mi_correct")).should("not.exist");
    cy.get(cesc("#\\/mi_incorrect")).should("not.exist");
    cy.get(cesc("#\\/just")).should("not.exist");

    cy.get(cesc("#\\/mi_submit")).click();
    cy.get(cesc("#\\/mi_submit")).should("not.exist");
    cy.get(cesc("#\\/mi_correct")).should("not.exist");
    cy.get(cesc("#\\/mi_incorrect")).should("be.visible");
    cy.get(cesc("#\\/just")).should(
      "have.text",
      "The answer was just submitted.",
    );

    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}1", {
      force: true,
    });
    cy.get(cesc("#\\/mi_submit")).should("be.visible");
    cy.get(cesc("#\\/mi_correct")).should("not.exist");
    cy.get(cesc("#\\/mi_incorrect")).should("not.exist");
    cy.get(cesc("#\\/just")).should("not.exist");

    cy.get(cesc("#\\/mi") + " textarea").type("{enter}", { force: true });
    cy.get(cesc("#\\/mi_submit")).should("not.exist");
    cy.get(cesc("#\\/mi_correct")).should("be.visible");
    cy.get(cesc("#\\/mi_incorrect")).should("not.exist");
    cy.get(cesc("#\\/just")).should(
      "have.text",
      "The answer was just submitted.",
    );

    cy.get(cesc("#\\/mi") + " textarea").type("{end}{backspace}1", {
      force: true,
    });
    cy.get(cesc("#\\/mi_submit")).should("be.visible");
    cy.get(cesc("#\\/mi_correct")).should("not.exist");
    cy.get(cesc("#\\/mi_incorrect")).should("not.exist");
    cy.get(cesc("#\\/just")).should("not.exist");
  });

  it("empty mathlists always equal", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer name="ans1">
    <award>
      <when>
        <mathlist/> = <mathlist/>
      </when>
    </award>
  </answer>
  <answer name="ans2">
    <award>
      <when unorderedCompare>
        <mathlist/> = <mathlist/>
      </when>
    </award>
  </answer>
  <answer name="ans3">
    <award>
      <when matchPartial>
        <mathlist/> = <mathlist/>
      </when>
    </award>
  </answer>
  <answer name="ans4">
    <award>
      <when unorderedCompare matchPartial>
        <mathlist/> = <mathlist/>
      </when>
    </award>
  </answer>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/ans1_submit")).click();
    cy.get(cesc("#\\/ans1_correct")).should("be.visible");

    cy.get(cesc("#\\/ans2_submit")).click();
    cy.get(cesc("#\\/ans2_correct")).should("be.visible");

    cy.get(cesc("#\\/ans3_submit")).click();
    cy.get(cesc("#\\/ans3_correct")).should("be.visible");

    cy.get(cesc("#\\/ans4_submit")).click();
    cy.get(cesc("#\\/ans4_correct")).should("be.visible");
  });

  it("cannot change submitted or changed response", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer name="a"><mathinput name="mia" />x</answer>

  <p>Current Response: <copy target="a" prop="currentResponse" assignNames="cr" /></p>
  <p>Submitted Response: <copy target="a" prop="submittedResponse" assignNames="sr" /></p>
  
  <p>Change current response: <mathinput bindValueTo="$a.currentResponse" name="micr" /></p>
  <p>Change submitted response: <mathinput bindValueTo="$a.submittedResponse" name="misr"  /></p>
   `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/cr") + " .mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text).eq("\uff3f");
      });
    cy.get(cesc("#\\/sr")).should("not.exist");

    cy.log("cannot change from mathinputs");
    cy.get(cesc("#\\/micr") + " textarea").type("y{enter}", { force: true });
    cy.get(cesc("#\\/misr") + " textarea").type("z{enter}", { force: true });

    cy.get(cesc("#\\/cr") + " .mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text).eq("\uff3f");
      });
    cy.get(cesc("#\\/sr")).should("not.exist");

    cy.log("submit response");
    cy.get(cesc("#\\/mia") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/cr") + " .mjx-mrow").should("have.text", "x");
    cy.get(cesc("#\\/cr") + " .mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text).eq("x");
      });
    cy.get(cesc("#\\/sr") + " .mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text).eq("x");
      });

    cy.log("cannot change from mathinputs");
    cy.get(cesc("#\\/micr") + " textarea").type("{end}{backspace}y{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/misr") + " textarea").type("{end}{backspace}z{enter}", {
      force: true,
    });

    cy.get(cesc("#\\/cr") + " .mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text).eq("x");
      });
    cy.get(cesc("#\\/sr") + " .mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text).eq("x");
      });
  });

  it("answer award with sugared string, copy award and overwrite properties", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <p><answer name="an">
    <award name="aw">1.1</award>
    <award copysource="aw" name="aw2" credit="0.5" allowedErrorInNumbers="0.001" />
  </answer></p>
  <p>Number of responses: <copy prop="numResponses" target="an" assignNames="nr" /></p>
  <p>Submitted response: <copy prop="submittedResponses" target="an" assignNames="sr" /></p>
  <p name="pfa1">First award awarded: $aw</p>
  <p name="pfa2">First award awarded: $aw.awarded</p>
  <p name="pfa3">First award awarded: <copy source="aw" /></p>
  <p name="pfa4">First award awarded: <copy source="aw.awarded" /></p>
  <p name="pfa5">First award awarded: <boolean copysource="aw" /></p>
  <p name="pfa6">First award awarded: <boolean copysource="aw.awarded" /></p>
  <p name="psa1">Second award awarded: $aw2</p>
  <p name="psa2">Second award awarded: $aw2.awarded</p>
  <p name="psa3">Second award awarded: <copy source="aw2" /></p>
  <p name="psa4">Second award awarded: <copy source="aw2.awarded" /></p>
  <p name="psa5">Second award awarded: <boolean copysource="aw2" /></p>
  <p name="psa6">Second award awarded: <boolean copysource="aw2.awarded" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/nr")).should("have.text", "1");

    cy.get(cesc("#\\/pfa1")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa2")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa3")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa4")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa5")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa6")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/psa1")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa2")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa3")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa4")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa5")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa6")).should("have.text", "Second award awarded: false");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/an"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");
      let mathinputPartialAnchor = cesc2("#" + mathinputName + "_partial");

      cy.get(mathinputAnchor).type("1.1{enter}", { force: true });
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");
      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("1.1");
        });

      cy.get(cesc("#\\/pfa1")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa2")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa3")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa4")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa5")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa6")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/psa1")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa2")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa3")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa4")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa5")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa6")).should(
        "have.text",
        "Second award awarded: false",
      );

      cy.get(mathinputAnchor).type("{end}1", { force: true });
      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("be.visible");
      cy.get(mathinputPartialAnchor).should("not.exist");
      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("1.11");
        });

      cy.get(cesc("#\\/pfa1")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa2")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa3")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa4")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa5")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa6")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/psa1")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa2")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa3")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa4")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa5")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa6")).should(
        "have.text",
        "Second award awarded: false",
      );

      cy.get(mathinputAnchor).type("{end}{leftArrow}0", { force: true });
      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("have.text", "50 %");
      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("1.101");
        });

      cy.get(cesc("#\\/pfa1")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa2")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa3")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa4")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa5")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa6")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/psa1")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa2")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa3")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa4")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa5")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa6")).should(
        "have.text",
        "Second award awarded: true",
      );
    });
  });

  it("answer award with full award, copy award and overwrite properties", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <p><answer name="an">
    <mathinput name="mi" />
    <award name="aw"><when>$mi=1.1</when></award>
    <award copysource="aw" name="aw2" credit="0.5" allowedErrorInNumbers="0.001" />
  </answer></p>
  <p>Number of responses: <copy prop="numResponses" target="an" assignNames="nr" /></p>
  <p>Submitted response: <copy prop="submittedResponses" target="an" assignNames="sr" /></p>
  <p name="pfa1">First award awarded: $aw</p>
  <p name="pfa2">First award awarded: $aw.awarded</p>
  <p name="pfa3">First award awarded: <copy source="aw" /></p>
  <p name="pfa4">First award awarded: <copy source="aw.awarded" /></p>
  <p name="pfa5">First award awarded: <boolean copysource="aw" /></p>
  <p name="pfa6">First award awarded: <boolean copysource="aw.awarded" /></p>
  <p name="psa1">Second award awarded: $aw2</p>
  <p name="psa2">Second award awarded: $aw2.awarded</p>
  <p name="psa3">Second award awarded: <copy source="aw2" /></p>
  <p name="psa4">Second award awarded: <copy source="aw2.awarded" /></p>
  <p name="psa5">Second award awarded: <boolean copysource="aw2" /></p>
  <p name="psa6">Second award awarded: <boolean copysource="aw2.awarded" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/nr")).should("have.text", "1");

    cy.get(cesc("#\\/pfa1")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa2")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa3")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa4")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa5")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/pfa6")).should("have.text", "First award awarded: false");
    cy.get(cesc("#\\/psa1")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa2")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa3")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa4")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa5")).should("have.text", "Second award awarded: false");
    cy.get(cesc("#\\/psa6")).should("have.text", "Second award awarded: false");

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/an"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");
      let mathinputPartialAnchor = cesc2("#" + mathinputName + "_partial");

      cy.get(mathinputAnchor).type("1.1{enter}", { force: true });
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");
      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("1.1");
        });

      cy.get(cesc("#\\/pfa1")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa2")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa3")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa4")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa5")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/pfa6")).should("have.text", "First award awarded: true");
      cy.get(cesc("#\\/psa1")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa2")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa3")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa4")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa5")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa6")).should(
        "have.text",
        "Second award awarded: false",
      );

      cy.get(mathinputAnchor).type("{end}1", { force: true });
      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("be.visible");
      cy.get(mathinputPartialAnchor).should("not.exist");
      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("1.11");
        });

      cy.get(cesc("#\\/pfa1")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa2")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa3")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa4")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa5")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa6")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/psa1")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa2")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa3")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa4")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa5")).should(
        "have.text",
        "Second award awarded: false",
      );
      cy.get(cesc("#\\/psa6")).should(
        "have.text",
        "Second award awarded: false",
      );

      cy.get(mathinputAnchor).type("{end}{leftArrow}0", { force: true });
      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("have.text", "50 %");
      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("1.101");
        });

      cy.get(cesc("#\\/pfa1")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa2")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa3")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa4")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa5")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/pfa6")).should(
        "have.text",
        "First award awarded: false",
      );
      cy.get(cesc("#\\/psa1")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa2")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa3")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa4")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa5")).should(
        "have.text",
        "Second award awarded: true",
      );
      cy.get(cesc("#\\/psa6")).should(
        "have.text",
        "Second award awarded: true",
      );
    });
  });

  it("answer award with full award and outside input, copy award and overwrite properties", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>
  <mathinput name="mi" />
  <answer name="an">
    <award name="aw" sourcesAreResponses="mi"><when>$mi=1.1</when></award>
    <copy target="aw" credit="0.5" allowedErrorInNumbers="0.001" createComponentOfType="award" sourcesAreResponses="" />
  </answer></p>
  <p>Number of responses: <copy prop="numResponses" target="an" assignNames="nr" /></p>
  <p>Submitted response: <copy prop="submittedResponses" target="an" assignNames="sr" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/nr")).should("have.text", "1");

    cy.get(cesc("#\\/mi") + " textarea").type("1.1{enter}", { force: true });
    cy.get(cesc("#\\/an_submit")).click();
    cy.get(cesc("#\\/an_correct")).should("be.visible");
    cy.get(cesc("#\\/an_incorrect")).should("not.exist");
    cy.get(cesc("#\\/an_partial")).should("not.exist");
    cy.get(cesc("#\\/sr") + " .mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text).eq("1.1");
      });

    cy.get(cesc("#\\/mi") + " textarea").type("{end}1{enter}", { force: true });
    cy.get(cesc("#\\/an_submit")).click();
    cy.get(cesc("#\\/an_correct")).should("not.exist");
    cy.get(cesc("#\\/an_incorrect")).should("be.visible");
    cy.get(cesc("#\\/an_partial")).should("not.exist");
    cy.get(cesc("#\\/sr") + " .mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text).eq("1.11");
      });

    cy.get(cesc("#\\/mi") + " textarea").type("{end}{leftArrow}0{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/an_submit")).click();
    cy.get(cesc("#\\/an_correct")).should("not.exist");
    cy.get(cesc("#\\/an_incorrect")).should("not.exist");
    cy.get(cesc("#\\/an_partial")).should("have.text", "50% Correct");
    cy.get(cesc("#\\/sr") + " .mjx-mrow")
      .eq(0)
      .invoke("text")
      .then((text) => {
        expect(text).eq("1.101");
      });
  });

  it("copied answer mirrors original", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer name="ans1">x+y</answer></p>
  <p>Current response: <copy prop="currentResponse" target="ans1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="ans1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="ans1" assignNames="ca1" /></p>

  <p><answer copySource="ans1" name="ans2" /></p>
  <p>Current response: <copy prop="currentResponse" target="ans2" assignNames="cr2" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="ans2" createComponentOfType='math' assignNames="sr2" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="ans2" assignNames="ca2" /></p>


  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      let mathinput1Name =
        stateVariables["/ans1"].stateValues.inputChildren[0].componentName;
      let mathinput1Anchor = cesc2("#" + mathinput1Name) + " textarea";
      let mathinput1SubmitAnchor = cesc2("#" + mathinput1Name + "_submit");
      let mathinput1CorrectAnchor = cesc2("#" + mathinput1Name + "_correct");
      let mathinput1IncorrectAnchor = cesc2(
        "#" + mathinput1Name + "_incorrect",
      );

      let mathinput2Name =
        stateVariables["/ans2"].stateValues.inputChildren[0].componentName;
      let mathinput2Anchor = cesc2("#" + mathinput2Name) + " textarea";
      let mathinput2SubmitAnchor = cesc2("#" + mathinput2Name + "_submit");
      let mathinput2CorrectAnchor = cesc2("#" + mathinput2Name + "_correct");
      let mathinput2IncorrectAnchor = cesc2(
        "#" + mathinput2Name + "_incorrect",
      );

      cy.get(mathinput1SubmitAnchor).should("be.visible");
      cy.get(mathinput2SubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");

      cy.log("Type correct answer in first blank");

      cy.get(mathinput1Anchor).type("x+y", { force: true }).blur();

      cy.get(mathinput1SubmitAnchor).should("be.visible");
      cy.get(mathinput2SubmitAnchor).should("be.visible");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr2") + " .mjx-mrow").should("have.text", "x+y");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");

      cy.log("Click second submit button");

      cy.get(mathinput2SubmitAnchor).click();

      cy.get(mathinput1CorrectAnchor).should("be.visible");
      cy.get(mathinput2CorrectAnchor).should("be.visible");

      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/sr2") + " .mjx-mrow").should("have.text", "x+y");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "1");

      cy.log("type incorrect answer into second blank");

      cy.get(mathinput2Anchor)
        .type("{end}{backspace}{backspace}", { force: true })
        .blur();

      cy.get(mathinput1SubmitAnchor).should("be.visible");
      cy.get(mathinput2SubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/cr2") + " .mjx-mrow").should("have.text", "x");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "1");

      cy.log("Click first submit button");

      cy.get(mathinput1SubmitAnchor).click();

      cy.get(mathinput1IncorrectAnchor).should("be.visible");
      cy.get(mathinput2IncorrectAnchor).should("be.visible");

      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");
      cy.get(cesc("#\\/sr2") + " .mjx-mrow").should("have.text", "x");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");
    });
  });

  it("copy answer with no link", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer name="ans1">x+y</answer></p>
  <p>Current response: <copy prop="currentResponse" target="ans1" assignNames="cr1" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="ans1" createComponentOfType='math' assignNames="sr1" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="ans1" assignNames="ca1" /></p>

  <p><answer copySource="ans1" name="ans2" link='false' /></p>
  <p>Current response: <copy prop="currentResponse" target="ans2" assignNames="cr2" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="ans2" createComponentOfType='math' assignNames="sr2" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="ans2" assignNames="ca2" /></p>


  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      let mathinput1Name =
        stateVariables["/ans1"].stateValues.inputChildren[0].componentName;
      let mathinput1Anchor = cesc2("#" + mathinput1Name) + " textarea";
      let mathinput1SubmitAnchor = cesc2("#" + mathinput1Name + "_submit");
      let mathinput1CorrectAnchor = cesc2("#" + mathinput1Name + "_correct");
      let mathinput1IncorrectAnchor = cesc2(
        "#" + mathinput1Name + "_incorrect",
      );

      let mathinput2Name =
        stateVariables["/ans2"].stateValues.inputChildren[0].componentName;
      let mathinput2Anchor = cesc2("#" + mathinput2Name) + " textarea";
      let mathinput2SubmitAnchor = cesc2("#" + mathinput2Name + "_submit");
      let mathinput2CorrectAnchor = cesc2("#" + mathinput2Name + "_correct");
      let mathinput2IncorrectAnchor = cesc2(
        "#" + mathinput2Name + "_incorrect",
      );

      cy.get(mathinput1SubmitAnchor).should("be.visible");
      cy.get(mathinput2SubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");

      cy.log("Type correct answer in first blank");

      cy.get(mathinput1Anchor).type("x+y", { force: true }).blur();

      cy.get(mathinput1SubmitAnchor).should("be.visible");
      cy.get(mathinput2SubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x+y");
      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");

      cy.log("Click first submit button");

      cy.get(mathinput1SubmitAnchor).click();

      cy.get(mathinput1CorrectAnchor).should("be.visible");
      cy.get(mathinput2SubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x+y");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");

      cy.log("type correct answer into second blank");

      cy.get(mathinput2Anchor).type("x+y", { force: true }).blur();

      cy.get(mathinput1CorrectAnchor).should("be.visible");
      cy.get(mathinput2SubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow").should("have.text", "x+y");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");

      cy.log("Click second submit button");

      cy.get(mathinput2SubmitAnchor).click();

      cy.get(mathinput1CorrectAnchor).should("be.visible");
      cy.get(mathinput2CorrectAnchor).should("be.visible");

      cy.get(cesc("#\\/sr2") + " .mjx-mrow").should("have.text", "x+y");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "1");

      cy.log("type incorrect answer into second blank");

      cy.get(mathinput2Anchor)
        .type("{end}{backspace}{backspace}", { force: true })
        .blur();

      cy.get(mathinput1CorrectAnchor).should("be.visible");
      cy.get(mathinput2SubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow").should("have.text", "x");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "1");

      cy.log("press enter in second blank");

      cy.get(mathinput2Anchor).type("{enter}", { force: true });

      cy.get(mathinput1CorrectAnchor).should("be.visible");
      cy.get(mathinput2IncorrectAnchor).should("be.visible");

      cy.get(cesc("#\\/sr2") + " .mjx-mrow").should("have.text", "x");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");

      cy.log("type incorrect answer into first blank");

      cy.get(mathinput1Anchor)
        .type("{end}{backspace}{backspace}", { force: true })
        .blur();

      cy.get(mathinput1SubmitAnchor).should("be.visible");
      cy.get(mathinput2IncorrectAnchor).should("be.visible");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow").should("have.text", "x");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x+y");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "1");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");

      cy.log("press enter in first blank");

      cy.get(mathinput1Anchor).type("{enter}", { force: true });

      cy.get(mathinput1IncorrectAnchor).should("be.visible");
      cy.get(mathinput2IncorrectAnchor).should("be.visible");

      cy.get(cesc("#\\/sr1") + " .mjx-mrow").should("have.text", "x");

      cy.get(cesc("#\\/cr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/ca1")).should("have.text", "0");

      cy.get(cesc("#\\/cr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x");
        });
      cy.get(cesc("#\\/ca2")).should("have.text", "0");
    });
  });

  // TODO: is there any way to check this now that core is in a web worker?
  it.skip("credit achieved not calculated before submit", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer name="ans">
    <award>x^2-2x+3</award>
    <award credit="0.5" numSignErrorsMatched="1">x^2-2x+3</award>
  </answer>
  <p>Current response: <copy prop="currentResponse" target="ans" assignNames="cr" /></p>
  <p>Submitted response: <copy prop="submittedResponse" target="ans" createComponentOfType='math' assignNames="sr" /></p>
  <p>Credit for submitted response: <copy prop="creditAchieved" target="ans" assignNames="ca" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      let mathinputName =
        stateVariables["/ans"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");
      let mathinputPartialAnchor = cesc2("#" + mathinputName + "_partial");

      cy.get(mathinputSubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/cr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca")).should("have.text", "0");

      cy.log(
        "check that have getters for creditAchievedIfSubmit/fractionSatisfiedIfSubmit",
      );
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        let stateVarObj =
          stateVariables["/_award1"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj =
          stateVariables["/_award1"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj = stateVariables["/_award2"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj =
          stateVariables["/_award2"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj = stateVariables["/ans"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;

        expect(stateVariables["/ans"].state.creditAchieved.value).eq(0);
        expect(stateVariables["/_award1"].state.creditAchieved.value).eq(0);
        expect(stateVariables["/_award1"].state.fractionSatisfied.value).eq(0);
        expect(stateVariables["/_award2"].state.creditAchieved.value).eq(0);
        expect(stateVariables["/_award2"].state.fractionSatisfied.value).eq(0);
      });

      cy.log("type correct answer");

      cy.get(mathinputAnchor)
        .type("x^2{rightArrow}-2x+3", { force: true })
        .blur();

      cy.get(mathinputSubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/cr") + " .mjx-mrow").should("contain.text", "x2−2x+3");

      cy.get(cesc("#\\/cr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2−2x+3");
        });
      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.get(cesc("#\\/ca")).should("have.text", "0");

      cy.log(
        "check that still have getters for creditAchievedIfSubmit/fractionSatisfiedIfSubmit",
      );
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        let stateVarObj =
          stateVariables["/_award1"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj =
          stateVariables["/_award1"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj = stateVariables["/_award2"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj =
          stateVariables["/_award2"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj = stateVariables["/ans"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;

        expect(stateVariables["/ans"].state.creditAchieved.value).eq(0);
        expect(stateVariables["/_award1"].state.creditAchieved.value).eq(0);
        expect(stateVariables["/_award1"].state.fractionSatisfied.value).eq(0);
        expect(stateVariables["/_award2"].state.creditAchieved.value).eq(0);
        expect(stateVariables["/_award2"].state.fractionSatisfied.value).eq(0);
      });

      cy.log("click submit");

      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputCorrectAnchor).should("be.visible");

      cy.get(cesc("#\\/cr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2−2x+3");
        });
      cy.get(cesc("#\\/sr") + " .mjx-mrow").should("contain.text", "x2−2x+3");

      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2−2x+3");
        });
      cy.get(cesc("#\\/ca")).should("have.text", "1");

      cy.log(
        "check that no longer have getters for creditAchievedIfSubmit/fractionSatisfiedIfSubmit",
      );
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        let stateVarObj =
          stateVariables["/_award1"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;
        stateVarObj =
          stateVariables["/_award1"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;
        stateVarObj = stateVariables["/_award2"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;
        stateVarObj =
          stateVariables["/_award2"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;
        stateVarObj = stateVariables["/ans"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;

        expect(
          stateVariables["/_award1"].state.creditAchievedIfSubmit.value,
        ).eq(1);
        expect(
          stateVariables["/_award1"].state.fractionSatisfiedIfSubmit.value,
        ).eq(1);
        expect(stateVariables["/_award1"].state.creditAchieved.value).eq(1);
        expect(stateVariables["/_award1"].state.fractionSatisfied.value).eq(1);
        expect(
          stateVariables["/_award2"].state.creditAchievedIfSubmit.value,
        ).eq(0.5);
        expect(
          stateVariables["/_award2"].state.fractionSatisfiedIfSubmit.value,
        ).eq(1);
        expect(stateVariables["/_award2"].state.creditAchieved.value).eq(0.5);
        expect(stateVariables["/_award2"].state.fractionSatisfied.value).eq(1);
        expect(stateVariables["/ans"].state.creditAchievedIfSubmit.value).eq(1);
        expect(stateVariables["/ans"].state.creditAchieved.value).eq(1);
      });

      cy.log("type partially correct answer");

      cy.get(mathinputAnchor)
        .type("{end}{leftArrow}{backspace}-", { force: true })
        .blur();

      cy.get(mathinputSubmitAnchor).should("be.visible");

      cy.get(cesc("#\\/cr") + " .mjx-mrow").should("contain.text", "x2−2x−3");

      cy.get(cesc("#\\/cr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2−2x−3");
        });
      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2−2x+3");
        });
      cy.get(cesc("#\\/ca")).should("have.text", "1");

      cy.log(
        "check that still have getters for creditAchievedIfSubmit/fractionSatisfiedIfSubmit",
      );
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        let stateVarObj =
          stateVariables["/_award1"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj =
          stateVariables["/_award1"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj = stateVariables["/_award2"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj =
          stateVariables["/_award2"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;
        stateVarObj = stateVariables["/ans"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.true;

        expect(stateVariables["/ans"].state.creditAchieved.value).eq(1);
        expect(stateVariables["/_award1"].state.creditAchieved.value).eq(1);
        expect(stateVariables["/_award1"].state.fractionSatisfied.value).eq(1);
        expect(stateVariables["/_award2"].state.creditAchieved.value).eq(0.5);
        expect(stateVariables["/_award2"].state.fractionSatisfied.value).eq(1);
      });

      cy.log("click submit");

      cy.get(mathinputSubmitAnchor).click();
      cy.get(mathinputPartialAnchor).should("have.text", "50 %");

      cy.get(cesc("#\\/cr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2−2x−3");
        });
      cy.get(cesc("#\\/sr") + " .mjx-mrow").should("contain.text", "x2−2x−3");

      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2−2x−3");
        });
      cy.get(cesc("#\\/ca")).should("have.text", "0.5");

      cy.log(
        "check that no longer have getters for creditAchievedIfSubmit/fractionSatisfiedIfSubmit",
      );
      cy.window().then(async (win) => {
        let stateVariables = await win.returnAllStateVariables1();

        let stateVarObj =
          stateVariables["/_award1"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;
        stateVarObj =
          stateVariables["/_award1"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;
        stateVarObj = stateVariables["/_award2"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;
        stateVarObj =
          stateVariables["/_award2"].state.fractionSatisfiedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;
        stateVarObj = stateVariables["/ans"].state.creditAchievedIfSubmit;
        expect(
          Boolean(
            Object.getOwnPropertyDescriptor(stateVarObj, "value").get ||
              stateVarObj.immutable,
          ),
        ).to.be.false;

        expect(
          stateVariables["/_award1"].state.creditAchievedIfSubmit.value,
        ).eq(0);
        expect(
          stateVariables["/_award1"].state.fractionSatisfiedIfSubmit.value,
        ).eq(0);
        expect(stateVariables["/_award1"].state.creditAchieved.value).eq(0);
        expect(stateVariables["/_award1"].state.fractionSatisfied.value).eq(0);
        expect(
          stateVariables["/_award2"].state.creditAchievedIfSubmit.value,
        ).eq(0.5);
        expect(
          stateVariables["/_award2"].state.fractionSatisfiedIfSubmit.value,
        ).eq(1);
        expect(stateVariables["/_award2"].state.creditAchieved.value).eq(0.5);
        expect(stateVariables["/_award2"].state.fractionSatisfied.value).eq(1);
        expect(stateVariables["/ans"].state.creditAchievedIfSubmit.value).eq(
          0.5,
        );
        expect(stateVariables["/ans"].state.creditAchieved.value).eq(0.5);
      });
    });
  });

  it("verify tab behavior, math", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer>x</answer>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");

      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");

      cy.log("Type correct answer in");
      cy.get(mathinputAnchor).type(`x`, { force: true });
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");

      cy.log("Press tab");
      cy.get(mathinputSubmitAnchor).focus();
      cy.get(mathinputAnchor).tab();
      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");

      cy.log("Press enter on submit button");
      cy.get(mathinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
    });
  });

  it("verify tab behavior, text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer type="text">hello</answer>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let textinputAnchor = cesc2("#" + textinputName) + "_input";
      let textinputSubmitAnchor = cesc2("#" + textinputName + "_submit");
      let textinputCorrectAnchor = cesc2("#" + textinputName + "_correct");
      let textinputIncorrectAnchor = cesc2("#" + textinputName + "_incorrect");

      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");

      cy.log("Type correct answer in");
      cy.get(textinputAnchor).type(`hello`);
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");

      cy.log("Press tab");
      cy.get(textinputAnchor).tab();
      cy.get(textinputSubmitAnchor).should("be.visible");
      cy.get(textinputCorrectAnchor).should("not.exist");
      cy.get(textinputIncorrectAnchor).should("not.exist");

      cy.log("Press enter on submit button");
      cy.get(textinputSubmitAnchor).type(`{enter}`, { force: true });
      cy.get(textinputSubmitAnchor).should("not.exist");
      cy.get(textinputCorrectAnchor).should("be.visible");
      cy.get(textinputIncorrectAnchor).should("not.exist");
    });
  });

  it("submit label", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer name="ans1" forceFullCheckworkButton>x</answer></p>
  <p><answer name="ans2" forceFullCheckworkButton submitLabel="Hit it!">x</answer></p>
  <p><answer name="ans3" forceFullCheckworkButton submitLabelNoCorrectness="Guess">x</answer></p>
  <p><answer name="ans4" forceFullCheckworkButton submitLabel="Hit it!" submitLabelNoCorrectness="Guess">x</answer></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();

      let mathinput1Name =
        stateVariables["/ans1"].stateValues.inputChildren[0].componentName;
      let mathinput1Anchor = cesc2("#" + mathinput1Name) + " textarea";

      let mathinput2Name =
        stateVariables["/ans2"].stateValues.inputChildren[0].componentName;
      let mathinput2Anchor = cesc2("#" + mathinput2Name) + " textarea";

      let mathinput3Name =
        stateVariables["/ans3"].stateValues.inputChildren[0].componentName;
      let mathinput3Anchor = cesc2("#" + mathinput3Name) + " textarea";

      let mathinput4Name =
        stateVariables["/ans4"].stateValues.inputChildren[0].componentName;
      let mathinput4Anchor = cesc2("#" + mathinput4Name) + " textarea";

      cy.get(cesc("#\\/ans1_submit"))
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("Check Work");
        });
      cy.get(cesc("#\\/ans2_submit"))
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("Hit it!");
        });
      cy.get(cesc("#\\/ans3_submit"))
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("Check Work");
        });
      cy.get(cesc("#\\/ans4_submit"))
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("Hit it!");
        });

      cy.get(mathinput1Anchor).type("x{enter}", { force: true });
      cy.get(mathinput2Anchor).type("x{enter}", { force: true });
      cy.get(mathinput3Anchor).type("x{enter}", { force: true });
      cy.get(mathinput4Anchor).type("x{enter}", { force: true });

      cy.get(cesc("#\\/ans1_submit")).click();
      cy.get(cesc("#\\/ans2_submit")).click();
      cy.get(cesc("#\\/ans3_submit")).click();
      cy.get(cesc("#\\/ans4_submit")).click();

      cy.get(cesc("#\\/ans1_correct")).should("contain.text", "Correct");
      cy.get(cesc("#\\/ans2_correct")).should("contain.text", "Correct");
      cy.get(cesc("#\\/ans3_correct")).should("contain.text", "Correct");
      cy.get(cesc("#\\/ans4_correct")).should("contain.text", "Correct");

      cy.get("#testRunner_toggleControls").click();
      cy.get("#testRunner_showCorrectness").click();
      cy.wait(100);
      cy.get("#testRunner_toggleControls").click();

      cy.get(cesc("#\\/ans1_submit")).should("contain.text", "Submit Response");
      cy.get(cesc("#\\/ans2_submit")).should("contain.text", "Submit Response");
      cy.get(cesc("#\\/ans3_submit")).should("contain.text", "Guess");
      cy.get(cesc("#\\/ans4_submit")).should("contain.text", "Guess");

      cy.get(cesc("#\\/ans1_submit"))
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("Submit Response");
        });
      cy.get(cesc("#\\/ans2_submit"))
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("Submit Response");
        });
      cy.get(cesc("#\\/ans3_submit"))
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("Guess");
        });
      cy.get(cesc("#\\/ans4_submit"))
        .invoke("text")
        .then((text) => {
          expect(text.trim()).equal("Guess");
        });

      cy.get(mathinput1Anchor).type("x{enter}", { force: true });
      cy.get(mathinput2Anchor).type("x{enter}", { force: true });
      cy.get(mathinput3Anchor).type("x{enter}", { force: true });
      cy.get(mathinput4Anchor).type("x{enter}", { force: true });

      cy.get(cesc("#\\/ans1_submit")).click();
      cy.get(cesc("#\\/ans2_submit")).click();
      cy.get(cesc("#\\/ans3_submit")).click();
      cy.get(cesc("#\\/ans4_submit")).click();

      cy.get(cesc("#\\/ans1_saved")).should("contain.text", "Response Saved");
      cy.get(cesc("#\\/ans2_saved")).should("contain.text", "Response Saved");
      cy.get(cesc("#\\/ans3_saved")).should("contain.text", "Response Saved");
      cy.get(cesc("#\\/ans4_saved")).should("contain.text", "Response Saved");
    });
  });

  it("submit label, choiceinput", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p><answer name="ans1">
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer name="ans2" submitLabel="Hit it!">
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer name="ans3" submitLabelNoCorrectness="Guess">
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  <p><answer name="ans4" submitLabel="Hit it!" submitLabelNoCorrectness="Guess">
    <choiceinput>
      <choice credit="1">yes</choice>
      <choice>no</choice>
    </choiceinput>
  </answer></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("Check Work");
      });
    cy.get(cesc("#\\/_choiceinput2_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("Hit it!");
      });
    cy.get(cesc("#\\/_choiceinput3_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("Check Work");
      });
    cy.get(cesc("#\\/_choiceinput4_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("Hit it!");
      });

    cy.get(cesc("#\\/_choiceinput1")).contains(`yes`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput2")).contains(`yes`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput3")).contains(`yes`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput4")).contains(`yes`).click({ force: true });

    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput2_submit")).click();
    cy.get(cesc("#\\/_choiceinput3_submit")).click();
    cy.get(cesc("#\\/_choiceinput4_submit")).click();

    cy.get(cesc("#\\/_choiceinput1_correct")).should("contain.text", "Correct");
    cy.get(cesc("#\\/_choiceinput2_correct")).should("contain.text", "Correct");
    cy.get(cesc("#\\/_choiceinput3_correct")).should("contain.text", "Correct");
    cy.get(cesc("#\\/_choiceinput4_correct")).should("contain.text", "Correct");

    cy.get("#testRunner_toggleControls").click();
    cy.get("#testRunner_showCorrectness").click();
    cy.wait(100);
    cy.get("#testRunner_toggleControls").click();

    cy.get(cesc("#\\/_choiceinput1_submit")).should(
      "contain.text",
      "Submit Response",
    );
    cy.get(cesc("#\\/_choiceinput2_submit")).should(
      "contain.text",
      "Submit Response",
    );
    cy.get(cesc("#\\/_choiceinput3_submit")).should("contain.text", "Guess");
    cy.get(cesc("#\\/_choiceinput4_submit")).should("contain.text", "Guess");

    cy.get(cesc("#\\/_choiceinput1_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("Submit Response");
      });
    cy.get(cesc("#\\/_choiceinput2_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("Submit Response");
      });
    cy.get(cesc("#\\/_choiceinput3_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("Guess");
      });
    cy.get(cesc("#\\/_choiceinput4_submit"))
      .invoke("text")
      .then((text) => {
        expect(text.trim()).equal("Guess");
      });

    cy.get(cesc("#\\/_choiceinput1")).contains(`yes`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput2")).contains(`yes`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput3")).contains(`yes`).click({ force: true });
    cy.get(cesc("#\\/_choiceinput4")).contains(`yes`).click({ force: true });

    cy.get(cesc("#\\/_choiceinput1_submit")).click();
    cy.get(cesc("#\\/_choiceinput2_submit")).click();
    cy.get(cesc("#\\/_choiceinput3_submit")).click();
    cy.get(cesc("#\\/_choiceinput4_submit")).click();

    cy.get(cesc("#\\/_choiceinput1_saved")).should(
      "contain.text",
      "Response Saved",
    );
    cy.get(cesc("#\\/_choiceinput2_saved")).should(
      "contain.text",
      "Response Saved",
    );
    cy.get(cesc("#\\/_choiceinput3_saved")).should(
      "contain.text",
      "Response Saved",
    );
    cy.get(cesc("#\\/_choiceinput4_saved")).should(
      "contain.text",
      "Response Saved",
    );
  });

  it("short award and full award combined", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <graph>
    <point name="P" />
  </graph>
  <answer numAwardsCredited="2">
    <award credit="0.6"><math>x^2</math></award>
    <award credit="0.4" sourcesAreResponses="P">
      <when><copy prop="x" target="P"/> > 0</when>
    </award>
  </answer>
  <p>Submitted responses: <aslist><copy prop="submittedResponses" target="_answer1" assignNames="sr1 sr2" /></aslist></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");
      let mathinputPartialAnchor = cesc2("#" + mathinputName + "_partial");

      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");

      cy.log("Correct answer in mathinput");
      cy.get(mathinputAnchor).type(`x^2{enter}`, { force: true });
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("have.text", "60 %");

      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("0");
        });

      cy.log("Correct point location");
      cy.window().then(async (win) => {
        await win.callAction1({
          actionName: "movePoint",
          componentName: "/P",
          args: { x: 2, y: -7 },
        });
      });
      cy.get(mathinputSubmitAnchor).click();

      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("not.exist");

      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("2");
        });

      cy.log("Incorrect answer in mathinput");
      cy.get(mathinputAnchor).type(`{end}y{enter}`, { force: true });
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");
      cy.get(mathinputPartialAnchor).should("have.text", "40 %");

      cy.get(cesc("#\\/sr1") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("x2y");
        });
      cy.get(cesc("#\\/sr2") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("2");
        });
    });
  });

  it("derivative works without award", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>What is the derivative of <function name="f">x^2</function>?
  <answer><derivative>$f</derivative</answer></p>
  <p>Submitted response: <aslist><math name="sr" copySource="_answer1.submittedResponses" /></aslist></p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/_answer1"].stateValues.inputChildren[0].componentName;
      let mathinputAnchor = cesc2("#" + mathinputName) + " textarea";
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");
      let mathinputCorrectAnchor = cesc2("#" + mathinputName + "_correct");
      let mathinputIncorrectAnchor = cesc2("#" + mathinputName + "_incorrect");

      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("not.exist");

      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("\uff3f");
        });
      cy.log("Correct answer in mathinput");
      cy.get(mathinputAnchor).type(`2x{enter}`, { force: true });
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("be.visible");
      cy.get(mathinputIncorrectAnchor).should("not.exist");

      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("2x");
        });

      cy.log("Incorrect answer in mathinput");
      cy.get(mathinputAnchor).type(`{end}x/2{enter}`, { force: true });
      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(mathinputCorrectAnchor).should("not.exist");
      cy.get(mathinputIncorrectAnchor).should("be.visible");

      cy.get(cesc("#\\/sr") + " .mjx-mrow")
        .eq(0)
        .invoke("text")
        .then((text) => {
          expect(text).eq("2xx2");
        });
    });
  });

  it("case-insensitive match, math", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Default, sugar: <answer name="defSugar">x+Y</answer></p>
  <p>Case-insensitive, sugar: <answer caseInsensitiveMatch name="insSugar">x+Y</answer></p>
  <p>Partial credit for insensitive, shortcut award: 
    <answer name="shortAwards">
      <award>x+Y</award>
      <award caseInsensitiveMatch credit="0.5">x+Y</award>
    </answer>
  </p>
  <p>Partial credit for insensitive, full syntax: 
    <answer name="full">
      <mathinput name="fullmi" />
      <award><when>$fullmi = x+Y</when></award>
      <award credit="0.5"><when caseInsensitiveMatch>$fullmi = x+Y</when></award>
    </answer>
  </p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputDefSugarName =
        stateVariables["/defSugar"].stateValues.inputChildren[0].componentName;
      let mathinputDefSugarAnchor =
        cesc2("#" + mathinputDefSugarName) + " textarea";
      let mathinputDefSugarSubmitAnchor = cesc2(
        "#" + mathinputDefSugarName + "_submit",
      );
      let mathinputDefSugarCorrectAnchor = cesc2(
        "#" + mathinputDefSugarName + "_correct",
      );
      let mathinputDefSugarIncorrectAnchor = cesc2(
        "#" + mathinputDefSugarName + "_incorrect",
      );
      let mathinputInsSugarName =
        stateVariables["/insSugar"].stateValues.inputChildren[0].componentName;
      let mathinputInsSugarAnchor =
        cesc2("#" + mathinputInsSugarName) + " textarea";
      let mathinputInsSugarSubmitAnchor = cesc2(
        "#" + mathinputInsSugarName + "_submit",
      );
      let mathinputInsSugarCorrectAnchor = cesc2(
        "#" + mathinputInsSugarName + "_correct",
      );
      let mathinputInsSugarIncorrectAnchor = cesc2(
        "#" + mathinputInsSugarName + "_incorrect",
      );
      let mathinputAwardName =
        stateVariables["/shortAwards"].stateValues.inputChildren[0]
          .componentName;
      let mathinputAwardAnchor = cesc2("#" + mathinputAwardName) + " textarea";
      let mathinputAwardSubmitAnchor = cesc2(
        "#" + mathinputAwardName + "_submit",
      );
      let mathinputAwardCorrectAnchor = cesc2(
        "#" + mathinputAwardName + "_correct",
      );
      let mathinputAwardIncorrectAnchor = cesc2(
        "#" + mathinputAwardName + "_incorrect",
      );
      let mathinputAwardPartialAnchor = cesc2(
        "#" + mathinputAwardName + "_partial",
      );
      let mathinputFullName = "/fullmi";
      let mathinputFullAnchor = cesc2("#" + mathinputFullName) + " textarea";
      let mathinputFullSubmitAnchor = cesc2(
        "#" + mathinputFullName + "_submit",
      );
      let mathinputFullCorrectAnchor = cesc2(
        "#" + mathinputFullName + "_correct",
      );
      let mathinputFullIncorrectAnchor = cesc2(
        "#" + mathinputFullName + "_incorrect",
      );
      let mathinputFullPartialAnchor = cesc2(
        "#" + mathinputFullName + "_partial",
      );

      cy.get(mathinputDefSugarSubmitAnchor).should("be.visible");
      cy.get(mathinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputDefSugarIncorrectAnchor).should("not.exist");
      cy.get(mathinputInsSugarSubmitAnchor).should("be.visible");
      cy.get(mathinputInsSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputInsSugarIncorrectAnchor).should("not.exist");
      cy.get(mathinputAwardSubmitAnchor).should("be.visible");
      cy.get(mathinputAwardCorrectAnchor).should("not.exist");
      cy.get(mathinputAwardIncorrectAnchor).should("not.exist");
      cy.get(mathinputAwardPartialAnchor).should("not.exist");
      cy.get(mathinputFullSubmitAnchor).should("be.visible");
      cy.get(mathinputFullCorrectAnchor).should("not.exist");
      cy.get(mathinputFullIncorrectAnchor).should("not.exist");
      cy.get(mathinputFullPartialAnchor).should("not.exist");

      cy.log("wrong case 1");
      cy.get(mathinputDefSugarAnchor).type(`x+y{enter}`, { force: true });
      cy.get(mathinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(mathinputInsSugarAnchor).type(`x+y{enter}`, { force: true });
      cy.get(mathinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputInsSugarCorrectAnchor).should("be.visible");
      cy.get(mathinputInsSugarIncorrectAnchor).should("not.exist");

      cy.get(mathinputAwardAnchor).type(`x+y{enter}`, { force: true });
      cy.get(mathinputAwardSubmitAnchor).should("not.exist");
      cy.get(mathinputAwardCorrectAnchor).should("not.exist");
      cy.get(mathinputAwardIncorrectAnchor).should("not.exist");
      cy.get(mathinputAwardPartialAnchor).should("have.text", "50 %");

      cy.get(mathinputFullAnchor).type(`x+y{enter}`, { force: true });
      cy.get(mathinputFullSubmitAnchor).should("not.exist");
      cy.get(mathinputFullCorrectAnchor).should("not.exist");
      cy.get(mathinputFullIncorrectAnchor).should("not.exist");
      cy.get(mathinputFullPartialAnchor).should("have.text", "50 %");

      cy.log("correct case");
      cy.get(mathinputDefSugarAnchor).type(
        `{end}{backspace}{backspace}{backspace}x+Y{enter}`,
        { force: true },
      );
      cy.get(mathinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputDefSugarCorrectAnchor).should("be.visible");
      cy.get(mathinputDefSugarIncorrectAnchor).should("not.exist");

      cy.get(mathinputInsSugarAnchor).type(
        `{end}{backspace}{backspace}{backspace}x+Y{enter}`,
        { force: true },
      );
      cy.get(mathinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputInsSugarCorrectAnchor).should("be.visible");
      cy.get(mathinputInsSugarIncorrectAnchor).should("not.exist");

      cy.get(mathinputAwardAnchor).type(
        `{end}{backspace}{backspace}{backspace}x+Y{enter}`,
        { force: true },
      );
      cy.get(mathinputAwardSubmitAnchor).should("not.exist");
      cy.get(mathinputAwardCorrectAnchor).should("be.visible");
      cy.get(mathinputAwardIncorrectAnchor).should("not.exist");
      cy.get(mathinputAwardPartialAnchor).should("not.exist");

      cy.get(mathinputFullAnchor).type(
        `{end}{backspace}{backspace}{backspace}x+Y{enter}`,
        { force: true },
      );
      cy.get(mathinputFullSubmitAnchor).should("not.exist");
      cy.get(mathinputFullCorrectAnchor).should("be.visible");
      cy.get(mathinputFullIncorrectAnchor).should("not.exist");
      cy.get(mathinputFullPartialAnchor).should("not.exist");

      cy.log("wrong case 2");
      cy.get(mathinputDefSugarAnchor).type(
        `{end}{backspace}{backspace}{backspace}X+Y{enter}`,
        { force: true },
      );
      cy.get(mathinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(mathinputInsSugarAnchor).type(
        `{end}{backspace}{backspace}{backspace}X+Y{enter}`,
        { force: true },
      );
      cy.get(mathinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputInsSugarCorrectAnchor).should("be.visible");
      cy.get(mathinputInsSugarIncorrectAnchor).should("not.exist");

      cy.get(mathinputAwardAnchor).type(
        `{end}{backspace}{backspace}{backspace}X+Y{enter}`,
        { force: true },
      );
      cy.get(mathinputAwardSubmitAnchor).should("not.exist");
      cy.get(mathinputAwardCorrectAnchor).should("not.exist");
      cy.get(mathinputAwardIncorrectAnchor).should("not.exist");
      cy.get(mathinputAwardPartialAnchor).should("have.text", "50 %");

      cy.get(mathinputFullAnchor).type(
        `{end}{backspace}{backspace}{backspace}X+Y{enter}`,
        { force: true },
      );
      cy.get(mathinputFullSubmitAnchor).should("not.exist");
      cy.get(mathinputFullCorrectAnchor).should("not.exist");
      cy.get(mathinputFullIncorrectAnchor).should("not.exist");
      cy.get(mathinputFullPartialAnchor).should("have.text", "50 %");

      cy.log("incorrect answer");
      cy.get(mathinputDefSugarAnchor).type(
        `{end}{backspace}{backspace}{enter}`,
        { force: true },
      );
      cy.get(mathinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(mathinputInsSugarAnchor).type(
        `{end}{backspace}{backspace}{enter}`,
        { force: true },
      );
      cy.get(mathinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputInsSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputInsSugarIncorrectAnchor).should("be.visible");

      cy.get(mathinputAwardAnchor).type(`{end}{backspace}{backspace}{enter}`, {
        force: true,
      });
      cy.get(mathinputAwardSubmitAnchor).should("not.exist");
      cy.get(mathinputAwardCorrectAnchor).should("not.exist");
      cy.get(mathinputAwardIncorrectAnchor).should("be.visible");
      cy.get(mathinputAwardPartialAnchor).should("not.exist");

      cy.get(mathinputFullAnchor).type(`{end}{backspace}{backspace}{enter}`, {
        force: true,
      });
      cy.get(mathinputFullSubmitAnchor).should("not.exist");
      cy.get(mathinputFullCorrectAnchor).should("not.exist");
      cy.get(mathinputFullIncorrectAnchor).should("be.visible");
      cy.get(mathinputFullPartialAnchor).should("not.exist");

      cy.log("wrong case 3");
      cy.get(mathinputDefSugarAnchor).type(`{end}+y{enter}`, { force: true });
      cy.get(mathinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(mathinputInsSugarAnchor).type(`{end}+y{enter}`, { force: true });
      cy.get(mathinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputInsSugarCorrectAnchor).should("be.visible");
      cy.get(mathinputInsSugarIncorrectAnchor).should("not.exist");

      cy.get(mathinputAwardAnchor).type(`{end}+y{enter}`, { force: true });
      cy.get(mathinputAwardSubmitAnchor).should("not.exist");
      cy.get(mathinputAwardCorrectAnchor).should("not.exist");
      cy.get(mathinputAwardIncorrectAnchor).should("not.exist");
      cy.get(mathinputAwardPartialAnchor).should("have.text", "50 %");

      cy.get(mathinputFullAnchor).type(`{end}+y{enter}`, { force: true });
      cy.get(mathinputFullSubmitAnchor).should("not.exist");
      cy.get(mathinputFullCorrectAnchor).should("not.exist");
      cy.get(mathinputFullIncorrectAnchor).should("not.exist");
      cy.get(mathinputFullPartialAnchor).should("have.text", "50 %");
    });
  });

  it("case-insensitive match, text", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Default, sugar: <answer type="text" name="defSugar">Hello there!</answer></p>
  <p>Case-insensitive, sugar: <answer type="text" caseInsensitiveMatch name="insSugar">Hello there!</answer></p>
  <p>Partial credit for insensitive, shortcut award: 
    <answer type="text" name="shortAwards">
      <award>Hello there!</award>
      <award caseInsensitiveMatch credit="0.5">Hello there!</award>
    </answer>
  </p>
  <p>Partial credit for insensitive, full syntax: 
    <answer name="full">
      <textinput name="fullmi" />
      <award><when>$fullmi = <text>Hello there!</text></when></award>
      <award credit="0.5"><when caseInsensitiveMatch>$fullmi = <text>Hello there!</text></when></award>
    </answer>
  </p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let textinputDefSugarName =
        stateVariables["/defSugar"].stateValues.inputChildren[0].componentName;
      let textinputDefSugarAnchor =
        cesc2("#" + textinputDefSugarName) + "_input";
      let textinputDefSugarSubmitAnchor = cesc2(
        "#" + textinputDefSugarName + "_submit",
      );
      let textinputDefSugarCorrectAnchor = cesc2(
        "#" + textinputDefSugarName + "_correct",
      );
      let textinputDefSugarIncorrectAnchor = cesc2(
        "#" + textinputDefSugarName + "_incorrect",
      );
      let textinputInsSugarName =
        stateVariables["/insSugar"].stateValues.inputChildren[0].componentName;
      let textinputInsSugarAnchor =
        cesc2("#" + textinputInsSugarName) + "_input";
      let textinputInsSugarSubmitAnchor = cesc2(
        "#" + textinputInsSugarName + "_submit",
      );
      let textinputInsSugarCorrectAnchor = cesc2(
        "#" + textinputInsSugarName + "_correct",
      );
      let textinputInsSugarIncorrectAnchor = cesc2(
        "#" + textinputInsSugarName + "_incorrect",
      );
      let textinputAwardName =
        stateVariables["/shortAwards"].stateValues.inputChildren[0]
          .componentName;
      let textinputAwardAnchor = cesc2("#" + textinputAwardName) + "_input";
      let textinputAwardSubmitAnchor = cesc2(
        "#" + textinputAwardName + "_submit",
      );
      let textinputAwardCorrectAnchor = cesc2(
        "#" + textinputAwardName + "_correct",
      );
      let textinputAwardIncorrectAnchor = cesc2(
        "#" + textinputAwardName + "_incorrect",
      );
      let textinputAwardPartialAnchor = cesc2(
        "#" + textinputAwardName + "_partial",
      );
      let textinputFullName = "/fullmi";
      let textinputFullAnchor = cesc2("#" + textinputFullName) + "_input";
      let textinputFullSubmitAnchor = cesc2(
        "#" + textinputFullName + "_submit",
      );
      let textinputFullCorrectAnchor = cesc2(
        "#" + textinputFullName + "_correct",
      );
      let textinputFullIncorrectAnchor = cesc2(
        "#" + textinputFullName + "_incorrect",
      );
      let textinputFullPartialAnchor = cesc2(
        "#" + textinputFullName + "_partial",
      );

      cy.get(textinputDefSugarSubmitAnchor).should("be.visible");
      cy.get(textinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(textinputDefSugarIncorrectAnchor).should("not.exist");
      cy.get(textinputInsSugarSubmitAnchor).should("be.visible");
      cy.get(textinputInsSugarCorrectAnchor).should("not.exist");
      cy.get(textinputInsSugarIncorrectAnchor).should("not.exist");
      cy.get(textinputAwardSubmitAnchor).should("be.visible");
      cy.get(textinputAwardCorrectAnchor).should("not.exist");
      cy.get(textinputAwardIncorrectAnchor).should("not.exist");
      cy.get(textinputAwardPartialAnchor).should("not.exist");
      cy.get(textinputFullSubmitAnchor).should("be.visible");
      cy.get(textinputFullCorrectAnchor).should("not.exist");
      cy.get(textinputFullIncorrectAnchor).should("not.exist");
      cy.get(textinputFullPartialAnchor).should("not.exist");

      cy.log("wrong case 1");
      cy.get(textinputDefSugarAnchor).type(`hello there!{enter}`);
      cy.get(textinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(textinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(textinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(textinputInsSugarAnchor).type(`hello there!{enter}`);
      cy.get(textinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(textinputInsSugarCorrectAnchor).should("be.visible");
      cy.get(textinputInsSugarIncorrectAnchor).should("not.exist");

      cy.get(textinputAwardAnchor).type(`hello there!{enter}`);
      cy.get(textinputAwardSubmitAnchor).should("not.exist");
      cy.get(textinputAwardCorrectAnchor).should("not.exist");
      cy.get(textinputAwardIncorrectAnchor).should("not.exist");
      cy.get(textinputAwardPartialAnchor).should("have.text", "50 %");

      cy.get(textinputFullAnchor).type(`hello there!{enter}`);
      cy.get(textinputFullSubmitAnchor).should("not.exist");
      cy.get(textinputFullCorrectAnchor).should("not.exist");
      cy.get(textinputFullIncorrectAnchor).should("not.exist");
      cy.get(textinputFullPartialAnchor).should("have.text", "50 %");

      cy.log("correct case");
      cy.get(textinputDefSugarAnchor).clear().type(`Hello there!{enter}`);
      cy.get(textinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(textinputDefSugarCorrectAnchor).should("be.visible");
      cy.get(textinputDefSugarIncorrectAnchor).should("not.exist");

      cy.get(textinputInsSugarAnchor).clear().type(`Hello there!{enter}`);
      cy.get(textinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(textinputInsSugarCorrectAnchor).should("be.visible");
      cy.get(textinputInsSugarIncorrectAnchor).should("not.exist");

      cy.get(textinputAwardAnchor).clear().type(`Hello there!{enter}`);
      cy.get(textinputAwardSubmitAnchor).should("not.exist");
      cy.get(textinputAwardCorrectAnchor).should("be.visible");
      cy.get(textinputAwardIncorrectAnchor).should("not.exist");
      cy.get(textinputAwardPartialAnchor).should("not.exist");

      cy.get(textinputFullAnchor).clear().type(`Hello there!{enter}`);
      cy.get(textinputFullSubmitAnchor).should("not.exist");
      cy.get(textinputFullCorrectAnchor).should("be.visible");
      cy.get(textinputFullIncorrectAnchor).should("not.exist");
      cy.get(textinputFullPartialAnchor).should("not.exist");

      cy.log("wrong case 2");
      cy.get(textinputDefSugarAnchor).clear().type(`Hello There!{enter}`);
      cy.get(textinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(textinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(textinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(textinputInsSugarAnchor).clear().type(`Hello There!{enter}`);
      cy.get(textinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(textinputInsSugarCorrectAnchor).should("be.visible");
      cy.get(textinputInsSugarIncorrectAnchor).should("not.exist");

      cy.get(textinputAwardAnchor).clear().type(`Hello There!{enter}`);
      cy.get(textinputAwardSubmitAnchor).should("not.exist");
      cy.get(textinputAwardCorrectAnchor).should("not.exist");
      cy.get(textinputAwardIncorrectAnchor).should("not.exist");
      cy.get(textinputAwardPartialAnchor).should("have.text", "50 %");

      cy.get(textinputFullAnchor).clear().type(`Hello There!{enter}`);
      cy.get(textinputFullSubmitAnchor).should("not.exist");
      cy.get(textinputFullCorrectAnchor).should("not.exist");
      cy.get(textinputFullIncorrectAnchor).should("not.exist");
      cy.get(textinputFullPartialAnchor).should("have.text", "50 %");

      cy.log("incorrect answer");
      cy.get(textinputDefSugarAnchor).clear().type(`Hello{enter}`);
      cy.get(textinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(textinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(textinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(textinputInsSugarAnchor).clear().type(`Hello{enter}`);
      cy.get(textinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(textinputInsSugarCorrectAnchor).should("not.exist");
      cy.get(textinputInsSugarIncorrectAnchor).should("be.visible");

      cy.get(textinputAwardAnchor).clear().type(`Hello{enter}`);
      cy.get(textinputAwardSubmitAnchor).should("not.exist");
      cy.get(textinputAwardCorrectAnchor).should("not.exist");
      cy.get(textinputAwardIncorrectAnchor).should("be.visible");
      cy.get(textinputAwardPartialAnchor).should("not.exist");

      cy.get(textinputFullAnchor).clear().type(`Hello{enter}`);
      cy.get(textinputFullSubmitAnchor).should("not.exist");
      cy.get(textinputFullCorrectAnchor).should("not.exist");
      cy.get(textinputFullIncorrectAnchor).should("be.visible");
      cy.get(textinputFullPartialAnchor).should("not.exist");

      cy.log("wrong case 3");
      cy.get(textinputDefSugarAnchor).clear().type(`hello There!{enter}`);
      cy.get(textinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(textinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(textinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(textinputInsSugarAnchor).clear().type(`hello There!{enter}`);
      cy.get(textinputInsSugarSubmitAnchor).should("not.exist");
      cy.get(textinputInsSugarCorrectAnchor).should("be.visible");
      cy.get(textinputInsSugarIncorrectAnchor).should("not.exist");

      cy.get(textinputAwardAnchor).clear().type(`hello There!{enter}`);
      cy.get(textinputAwardSubmitAnchor).should("not.exist");
      cy.get(textinputAwardCorrectAnchor).should("not.exist");
      cy.get(textinputAwardIncorrectAnchor).should("not.exist");
      cy.get(textinputAwardPartialAnchor).should("have.text", "50 %");

      cy.get(textinputFullAnchor).clear().type(`hello There!{enter}`);
      cy.get(textinputFullSubmitAnchor).should("not.exist");
      cy.get(textinputFullCorrectAnchor).should("not.exist");
      cy.get(textinputFullIncorrectAnchor).should("not.exist");
      cy.get(textinputFullPartialAnchor).should("have.text", "50 %");
    });
  });

  it("match blanks", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Default, sugar: <answer name="defSugar">_6^14C</answer></p>
  <p>Match blanks, sugar: <answer matchBlanks name="blankSugar">_6^14C</answer></p>
  <p>Default, shortcut award: 
    <answer name="defShort"><award>_6^14C</award></answer>
  </p>
  <p>Match blanks, shortcut award: 
    <answer name="blankShort" matchBlanks><award>_6^14C</award></answer>
  </p>
  <p>Default, full syntax: 
    <answer name="defFull">
      <mathinput name="deffullmi" />
      <award><when>$deffullmi = _6^14C</when></award>
    </answer>
  </p>
  <p>Match blanks, full syntax: 
    <answer name="blankFull">
      <mathinput name="blankfullmi" />
      <award><when matchBlanks>$blankfullmi = _6^14C</when></award>
    </answer>
  </p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputDefSugarName =
        stateVariables["/defSugar"].stateValues.inputChildren[0].componentName;
      let mathinputDefSugarAnchor =
        cesc2("#" + mathinputDefSugarName) + " textarea";
      let mathinputDefSugarSubmitAnchor = cesc2(
        "#" + mathinputDefSugarName + "_submit",
      );
      let mathinputDefSugarCorrectAnchor = cesc2(
        "#" + mathinputDefSugarName + "_correct",
      );
      let mathinputDefSugarIncorrectAnchor = cesc2(
        "#" + mathinputDefSugarName + "_incorrect",
      );
      let mathinputBlankSugarName =
        stateVariables["/blankSugar"].stateValues.inputChildren[0]
          .componentName;
      let mathinputBlankSugarAnchor =
        cesc2("#" + mathinputBlankSugarName) + " textarea";
      let mathinputBlankSugarSubmitAnchor = cesc2(
        "#" + mathinputBlankSugarName + "_submit",
      );
      let mathinputBlankSugarCorrectAnchor = cesc2(
        "#" + mathinputBlankSugarName + "_correct",
      );
      let mathinputBlankSugarIncorrectAnchor = cesc2(
        "#" + mathinputBlankSugarName + "_incorrect",
      );
      let mathinputDefShortName =
        stateVariables["/defShort"].stateValues.inputChildren[0].componentName;
      let mathinputDefShortAnchor =
        cesc2("#" + mathinputDefShortName) + " textarea";
      let mathinputDefShortSubmitAnchor = cesc2(
        "#" + mathinputDefShortName + "_submit",
      );
      let mathinputDefShortCorrectAnchor = cesc2(
        "#" + mathinputDefShortName + "_correct",
      );
      let mathinputDefShortIncorrectAnchor = cesc2(
        "#" + mathinputDefShortName + "_incorrect",
      );
      let mathinputBlankShortName =
        stateVariables["/blankShort"].stateValues.inputChildren[0]
          .componentName;
      let mathinputBlankShortAnchor =
        cesc2("#" + mathinputBlankShortName) + " textarea";
      let mathinputBlankShortSubmitAnchor = cesc2(
        "#" + mathinputBlankShortName + "_submit",
      );
      let mathinputBlankShortCorrectAnchor = cesc2(
        "#" + mathinputBlankShortName + "_correct",
      );
      let mathinputBlankShortIncorrectAnchor = cesc2(
        "#" + mathinputBlankShortName + "_incorrect",
      );
      let mathinputDefFullName = "/deffullmi";
      let mathinputDefFullAnchor =
        cesc2("#" + mathinputDefFullName) + " textarea";
      let mathinputDefFullSubmitAnchor = cesc2(
        "#" + mathinputDefFullName + "_submit",
      );
      let mathinputDefFullCorrectAnchor = cesc2(
        "#" + mathinputDefFullName + "_correct",
      );
      let mathinputDefFullIncorrectAnchor = cesc2(
        "#" + mathinputDefFullName + "_incorrect",
      );
      let mathinputBlankFullName = "/blankfullmi";
      let mathinputBlankFullAnchor =
        cesc2("#" + mathinputBlankFullName) + " textarea";
      let mathinputBlankFullSubmitAnchor = cesc2(
        "#" + mathinputBlankFullName + "_submit",
      );
      let mathinputBlankFullCorrectAnchor = cesc2(
        "#" + mathinputBlankFullName + "_correct",
      );
      let mathinputBlankFullIncorrectAnchor = cesc2(
        "#" + mathinputBlankFullName + "_incorrect",
      );

      cy.get(mathinputDefSugarSubmitAnchor).should("be.visible");
      cy.get(mathinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputDefSugarIncorrectAnchor).should("not.exist");
      cy.get(mathinputBlankSugarSubmitAnchor).should("be.visible");
      cy.get(mathinputBlankSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputBlankSugarIncorrectAnchor).should("not.exist");
      cy.get(mathinputDefShortSubmitAnchor).should("be.visible");
      cy.get(mathinputDefShortCorrectAnchor).should("not.exist");
      cy.get(mathinputDefShortIncorrectAnchor).should("not.exist");
      cy.get(mathinputBlankShortSubmitAnchor).should("be.visible");
      cy.get(mathinputBlankShortCorrectAnchor).should("not.exist");
      cy.get(mathinputBlankShortIncorrectAnchor).should("not.exist");
      cy.get(mathinputDefFullSubmitAnchor).should("be.visible");
      cy.get(mathinputDefFullCorrectAnchor).should("not.exist");
      cy.get(mathinputDefFullIncorrectAnchor).should("not.exist");
      cy.get(mathinputBlankFullSubmitAnchor).should("be.visible");
      cy.get(mathinputBlankFullCorrectAnchor).should("not.exist");
      cy.get(mathinputBlankFullIncorrectAnchor).should("not.exist");

      cy.log("wrong answer");
      cy.get(mathinputDefSugarAnchor).type(`C_6{rightArrow}^14{enter}`, {
        force: true,
      });
      cy.get(mathinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(mathinputBlankSugarAnchor).type(`C_6{rightArrow}^14{enter}`, {
        force: true,
      });
      cy.get(mathinputBlankSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputBlankSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputBlankSugarIncorrectAnchor).should("be.visible");

      cy.get(mathinputDefShortAnchor).type(`C_6{rightArrow}^14{enter}`, {
        force: true,
      });
      cy.get(mathinputDefShortSubmitAnchor).should("not.exist");
      cy.get(mathinputDefShortCorrectAnchor).should("not.exist");
      cy.get(mathinputDefShortIncorrectAnchor).should("be.visible");

      cy.get(mathinputBlankShortAnchor).type(`C_6{rightArrow}^14{enter}`, {
        force: true,
      });
      cy.get(mathinputBlankShortSubmitAnchor).should("not.exist");
      cy.get(mathinputBlankShortCorrectAnchor).should("not.exist");
      cy.get(mathinputBlankShortIncorrectAnchor).should("be.visible");

      cy.get(mathinputDefFullAnchor).type(`C_6{rightArrow}^14{enter}`, {
        force: true,
      });
      cy.get(mathinputDefFullSubmitAnchor).should("not.exist");
      cy.get(mathinputDefFullCorrectAnchor).should("not.exist");
      cy.get(mathinputDefFullIncorrectAnchor).should("be.visible");

      cy.get(mathinputBlankFullAnchor).type(`C_6{rightArrow}^14{enter}`, {
        force: true,
      });
      cy.get(mathinputBlankFullSubmitAnchor).should("not.exist");
      cy.get(mathinputBlankFullCorrectAnchor).should("not.exist");
      cy.get(mathinputBlankFullIncorrectAnchor).should("be.visible");

      cy.log("correct answer");
      cy.get(mathinputDefSugarAnchor).type(
        `{ctrl+home}{rightarrow}{backspace}{ctrl+end}C{enter}`,
        { force: true },
      );
      cy.get(mathinputDefSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputDefSugarCorrectAnchor).should("not.exist");
      cy.get(mathinputDefSugarIncorrectAnchor).should("be.visible");

      cy.get(mathinputBlankSugarAnchor).type(
        `{ctrl+home}{rightarrow}{backspace}{ctrl+end}C{enter}`,
        { force: true },
      );
      cy.get(mathinputBlankSugarSubmitAnchor).should("not.exist");
      cy.get(mathinputBlankSugarCorrectAnchor).should("be.visible");
      cy.get(mathinputBlankSugarIncorrectAnchor).should("not.exist");

      cy.get(mathinputDefShortAnchor).type(
        `{ctrl+home}{rightarrow}{backspace}{ctrl+end}C{enter}`,
        { force: true },
      );
      cy.get(mathinputDefShortSubmitAnchor).should("not.exist");
      cy.get(mathinputDefShortCorrectAnchor).should("not.exist");
      cy.get(mathinputDefShortIncorrectAnchor).should("be.visible");

      cy.get(mathinputBlankShortAnchor).type(
        `{ctrl+home}{rightarrow}{backspace}{ctrl+end}C{enter}`,
        { force: true },
      );
      cy.get(mathinputBlankShortSubmitAnchor).should("not.exist");
      cy.get(mathinputBlankShortCorrectAnchor).should("be.visible");
      cy.get(mathinputBlankShortIncorrectAnchor).should("not.exist");

      cy.get(mathinputDefFullAnchor).type(
        `{ctrl+home}{rightarrow}{backspace}{ctrl+end}C{enter}`,
        { force: true },
      );
      cy.get(mathinputDefFullSubmitAnchor).should("not.exist");
      cy.get(mathinputDefFullCorrectAnchor).should("not.exist");
      cy.get(mathinputDefFullIncorrectAnchor).should("be.visible");

      cy.get(mathinputBlankFullAnchor).type(
        `{ctrl+home}{rightarrow}{backspace}{ctrl+end}C{enter}`,
        { force: true },
      );
      cy.get(mathinputBlankFullSubmitAnchor).should("not.exist");
      cy.get(mathinputBlankFullCorrectAnchor).should("be.visible");
      cy.get(mathinputBlankFullIncorrectAnchor).should("not.exist");
    });
  });

  it("auto submit", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Enter x: <answer name="x">x</answer></p>
  <p name="pSubX">Submitted response: $x</p>
  <p name="pCreditX">Credit for this answer: $x.creditAchieved</p>
  
  <p>Select the correct answer:
  <answer name="correct">
    <choice credit="1">correct</choice>
    <choice>incorrect</choice>
  </answer></p>
  <p name="pSubCorrect">Submitted response: $correct</p>
  <p name="pCreditCorrect">Credit for this answer: $correct.creditAchieved</p>
  
  <graph size="small">
    <point name="P" labelIsName />
  </graph>
  
  <p>Move point P into first quadrant
    <answer name="firstQuad"><award><when>$P.x > 0 and $P.y > 0</when></award></answer>
  </p>
  
  <p name="pSubFirstQuad">Submitted response: <aslist>$firstQuad.submittedResponses</aslist></p>
  <p name="pCreditFirstQuad">Credit for this answer: $firstQuad.creditAchieved</p>

  <p name="pCreditDoc">Document credit achieved: $_document1.creditAchieved</p>
  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/x"].stateValues.inputChildren[0].componentName;
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      let choiceinputName =
        stateVariables["/correct"].stateValues.inputChildren[0].componentName;
      let choiceinputSubmitAnchor = cesc2("#" + choiceinputName + "_submit");

      cy.get(mathinputSubmitAnchor).should("be.visible");
      cy.get(choiceinputSubmitAnchor).should("be.visible");
      cy.get(cesc2("#/firstQuad_submit")).should("be.visible");
    });

    cy.get("#testRunner_toggleControls").click();
    cy.get("#testRunner_autoSubmit").click();
    cy.wait(100);
    cy.get("#testRunner_toggleControls").click();

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.window().then(async (win) => {
      let stateVariables = await win.returnAllStateVariables1();
      let mathinputName =
        stateVariables["/x"].stateValues.inputChildren[0].componentName;
      let mathinputSubmitAnchor = cesc2("#" + mathinputName + "_submit");

      let choiceinputName =
        stateVariables["/correct"].stateValues.inputChildren[0].componentName;
      let choiceinputSubmitAnchor = cesc2("#" + choiceinputName + "_submit");

      cy.get(mathinputSubmitAnchor).should("not.exist");
      cy.get(choiceinputSubmitAnchor).should("not.exist");
      cy.get(cesc2("#/firstQuad_submit")).should("not.exist");
    });

    cy.get(cesc("#\\/pSubX")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/pCreditX")).should(
      "have.text",
      "Credit for this answer: 0",
    );
    cy.get(cesc("#\\/pSubCorrect")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/pCreditCorrect")).should(
      "have.text",
      "Credit for this answer: 0",
    );
    cy.get(cesc("#\\/pSubFirstQuad")).should(
      "have.text",
      "Submitted response: ",
    );
    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );
    cy.get(cesc("#\\/pCreditDoc")).should(
      "have.text",
      "Document credit achieved: 0",
    );

    cy.get(cesc("#\\/x") + " textarea").type("y", { force: true });

    cy.wait(1500); // wait for debounce

    cy.get(cesc("#\\/pSubX")).should("have.text", "Submitted response: ");
    cy.get(cesc("#\\/pCreditX")).should(
      "have.text",
      "Credit for this answer: 0",
    );
    cy.get(cesc("#\\/pCreditDoc")).should(
      "have.text",
      "Document credit achieved: 0",
    );

    cy.get(cesc("#\\/x") + " textarea").blur();
    cy.get(cesc("#\\/pSubX") + " .mjx-mrow").should("contain.text", "y");
    cy.get(cesc("#\\/pCreditX")).should(
      "have.text",
      "Credit for this answer: 0",
    );
    cy.get(cesc("#\\/pCreditDoc")).should(
      "have.text",
      "Document credit achieved: 0",
    );

    cy.get(cesc("#\\/x") + " textarea").type("{end}{backspace}x{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/pSubX") + " .mjx-mrow").should("contain.text", "x");
    cy.get(cesc("#\\/pCreditX")).should(
      "have.text",
      "Credit for this answer: 1",
    );
    cy.get(cesc("#\\/pCreditDoc")).should(
      "have.text",
      "Document credit achieved: 0.333",
    );

    cy.get(cesc("#\\/_choice1")).click();
    cy.get(cesc("#\\/pSubCorrect")).should(
      "have.text",
      "Submitted response: correct",
    );
    cy.get(cesc("#\\/pCreditCorrect")).should(
      "have.text",
      "Credit for this answer: 1",
    );
    cy.get(cesc("#\\/pCreditDoc")).should(
      "have.text",
      "Document credit achieved: 0.667",
    );

    cy.get(cesc("#\\/_choice2")).click();
    cy.get(cesc("#\\/pSubCorrect")).should(
      "have.text",
      "Submitted response: incorrect",
    );
    cy.get(cesc("#\\/pCreditCorrect")).should(
      "have.text",
      "Credit for this answer: 0",
    );
    cy.get(cesc("#\\/pCreditDoc")).should(
      "have.text",
      "Document credit achieved: 0.333",
    );

    cy.get(cesc("#\\/_choice1")).click();
    cy.get(cesc("#\\/pSubCorrect")).should(
      "have.text",
      "Submitted response: correct",
    );
    cy.get(cesc("#\\/pCreditCorrect")).should(
      "have.text",
      "Credit for this answer: 1",
    );
    cy.get(cesc("#\\/pCreditDoc")).should(
      "have.text",
      "Document credit achieved: 0.667",
    );

    cy.window().then(async (win) => {
      win.callAction1({
        actionName: "movePoint",
        componentName: "/P",
        args: { x: 3, y: 1 },
      });
    });

    cy.wait(200);
    cy.get(cesc("#\\/pSubFirstQuad")).should(
      "have.text",
      "Submitted response: ",
    );
    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );

    cy.window().then(async (win) => {
      win.callAction1({
        actionName: "movePoint",
        componentName: "/P",
        args: { x: 4, y: 2 },
      });
    });

    cy.wait(200);
    cy.get(cesc("#\\/pSubFirstQuad")).should(
      "have.text",
      "Submitted response: ",
    );
    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );

    cy.window().then(async (win) => {
      win.callAction1({
        actionName: "movePoint",
        componentName: "/P",
        args: { x: 5, y: 3 },
      });
    });

    cy.wait(200);
    cy.get(cesc("#\\/pSubFirstQuad")).should(
      "have.text",
      "Submitted response: ",
    );
    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );

    cy.window().then(async (win) => {
      win.callAction1({
        actionName: "movePoint",
        componentName: "/P",
        args: { x: 6, y: 4 },
      });
    });

    cy.wait(200);
    cy.get(cesc("#\\/pSubFirstQuad")).should(
      "have.text",
      "Submitted response: ",
    );
    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );

    cy.window().then(async (win) => {
      win.callAction1({
        actionName: "movePoint",
        componentName: "/P",
        args: { x: 7, y: 5 },
      });
    });

    cy.wait(200);
    cy.get(cesc("#\\/pSubFirstQuad")).should(
      "have.text",
      "Submitted response: ",
    );
    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );

    cy.window().then(async (win) => {
      win.callAction1({
        actionName: "movePoint",
        componentName: "/P",
        args: { x: 8, y: 6 },
      });
    });

    cy.wait(200);
    cy.get(cesc("#\\/pSubFirstQuad")).should(
      "have.text",
      "Submitted response: ",
    );
    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );

    cy.window().then(async (win) => {
      win.callAction1({
        actionName: "movePoint",
        componentName: "/P",
        args: { x: 9, y: 7 },
      });
    });

    cy.wait(200);
    cy.get(cesc("#\\/pSubFirstQuad")).should(
      "have.text",
      "Submitted response: ",
    );
    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );

    cy.window().then(async (win) => {
      win.callAction1({
        actionName: "movePoint",
        componentName: "/P",
        args: { x: 3, y: -5 },
      });
    });

    cy.wait(200);
    cy.get(cesc("#\\/pSubFirstQuad")).should(
      "have.text",
      "Submitted response: ",
    );
    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );

    cy.get(cesc("#\\/pSubFirstQuad") + " .mjx-mrow").should(
      "contain.text",
      "3",
    );
    cy.get(cesc("#\\/pSubFirstQuad") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "3");
    cy.get(cesc("#\\/pSubFirstQuad") + " .mjx-mrow")
      .eq(1)
      .should("have.text", "−5");

    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 0",
    );
    cy.get(cesc("#\\/pCreditDoc")).should(
      "have.text",
      "Document credit achieved: 0.667",
    );

    cy.window().then(async (win) => {
      win.callAction1({
        actionName: "movePoint",
        componentName: "/P",
        args: { x: 9, y: 8 },
      });
    });

    cy.get(cesc("#\\/pSubFirstQuad") + " .mjx-mrow").should(
      "contain.text",
      "9",
    );
    cy.get(cesc("#\\/pSubFirstQuad") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "9");
    cy.get(cesc("#\\/pSubFirstQuad") + " .mjx-mrow")
      .eq(1)
      .should("have.text", "8");

    cy.get(cesc("#\\/pCreditFirstQuad")).should(
      "have.text",
      "Credit for this answer: 1",
    );
    cy.get(cesc("#\\/pCreditDoc")).should(
      "have.text",
      "Document credit achieved: 1",
    );
  });

  it("submitted responses from copy source", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  
  <p><answer name="x">x</answer> 
    <math name="xsr" copySource="x" />
    <math name="xcr" copySource="x.currentResponse" />
  </p>
  <p><answer name="hello" type="text">hello</answer>
    <text name="hellosr" copySource="hello" />
    <text name="hellocr" copySource="hello.currentResponse" />
  </p>
  <p><answer name="b" type="boolean" forceFullCheckworkButton>true</answer> 
    <boolean name="bsr" copySource="b" />
    <boolean name="bcr" copySource="b.currentResponse" />
  </p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/xsr") + " .mjx-mrow").should("contain.text", "\uff3f");
    cy.get(cesc("#\\/xcr") + " .mjx-mrow").should("contain.text", "\uff3f");

    cy.get(cesc("#\\/x") + " textarea")
      .type("x", { force: true })
      .blur();
    cy.get(cesc("#\\/xcr") + " .mjx-mrow").should("contain.text", "x");
    cy.get(cesc("#\\/xsr") + " .mjx-mrow").should("contain.text", "\uff3f");
    cy.get(cesc("#\\/x") + " textarea").type("{enter}", { force: true });
    cy.get(cesc("#\\/xsr") + " .mjx-mrow").should("contain.text", "x");
    cy.get(cesc("#\\/xcr") + " .mjx-mrow").should("contain.text", "x");

    cy.get(cesc("#\\/hellosr")).should("have.text", "");
    cy.get(cesc("#\\/hellocr")).should("have.text", "");

    cy.get(cesc("#\\/hello") + " input")
      .type("hello")
      .blur();
    cy.get(cesc("#\\/hellocr")).should("have.text", "hello");
    cy.get(cesc("#\\/hellosr")).should("have.text", "");
    cy.get(cesc("#\\/hello") + " input").type("{enter}");
    cy.get(cesc("#\\/hellosr")).should("have.text", "hello");
    cy.get(cesc("#\\/hellocr")).should("have.text", "hello");

    cy.get(cesc("#\\/bsr")).should("have.text", "false");
    cy.get(cesc("#\\/bcr")).should("have.text", "false");
    cy.get(cesc("#\\/b") + " .checkmark").click();
    cy.get(cesc("#\\/bcr")).should("have.text", "true");
    cy.get(cesc("#\\/bsr")).should("have.text", "false");
    cy.get(cesc("#\\/b_submit")).click();
    cy.get(cesc("#\\/bsr")).should("have.text", "true");
    cy.get(cesc("#\\/bcr")).should("have.text", "true");
  });

  it("parse scientific notation", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  
  <p><answer name="np1"><mathinput name="minp1" />4E3</answer> <math name="np1a" copySource="np1" /></p>
  <p><answer name="np2"><mathinput name="minp2" /><math>4E3</math></answer> <math name="np2a" copySource="np2" /></p>
  <p><answer name="np3"><mathinput name="minp3" /><award><math>4E3</math></award></answer> <math name="np3a" copySource="np3" /></p>
  <p><answer name="np4"><mathinput name="minp4" /><award><when><math>4E3</math>=$minp4</when></award></answer> <math name="np4a" copySource="np4" /></p>

  <p><answer parseScientificNotation name="p1"><mathinput name="mip1" />4E3</answer> <math name="p1a" copySource="p1" /></p>
  <p><answer parseScientificNotation name="p2"><mathinput name="mip2" /><math>4E3</math></answer> <math name="p2a" copySource="p2" /></p>
  <p><answer parseScientificNotation name="p3"><mathinput name="mip3" /><award><math>4E3</math></award></answer> <math name="p3a" copySource="p3" /></p>
  <p><answer parseScientificNotation name="p4"><mathinput name="mip4" /><award><when><math parseScientificNotation>4E3</math>=$mip4</when></award></answer> <math name="p4a" copySource="p4" /></p>



  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/np1a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "\uff3f");

    cy.get(cesc("#\\/minp1") + " textarea").type("4E3{enter}", { force: true });
    cy.get(cesc("#\\/minp1_correct")).should("be.visible");
    cy.get(cesc("#\\/np1a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4E3");

    cy.get(cesc("#\\/minp2") + " textarea").type("4E3{enter}", { force: true });
    cy.get(cesc("#\\/minp2_correct")).should("be.visible");
    cy.get(cesc("#\\/np2a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4E3");

    cy.get(cesc("#\\/minp3") + " textarea").type("4E3{enter}", { force: true });
    cy.get(cesc("#\\/minp3_correct")).should("be.visible");
    cy.get(cesc("#\\/np3a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4E3");

    cy.get(cesc("#\\/minp4") + " textarea").type("4E3{enter}", { force: true });
    cy.get(cesc("#\\/minp4_correct")).should("be.visible");
    cy.get(cesc("#\\/np4a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4E3");

    cy.get(cesc("#\\/mip1") + " textarea").type("4E3{enter}", { force: true });
    cy.get(cesc("#\\/mip1_correct")).should("be.visible");
    cy.get(cesc("#\\/p1a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/mip2") + " textarea").type("4E3{enter}", { force: true });
    cy.get(cesc("#\\/mip2_correct")).should("be.visible");
    cy.get(cesc("#\\/p2a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/mip3") + " textarea").type("4E3{enter}", { force: true });
    cy.get(cesc("#\\/mip3_correct")).should("be.visible");
    cy.get(cesc("#\\/p3a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/mip4") + " textarea").type("4E3{enter}", { force: true });
    cy.get(cesc("#\\/mip4_correct")).should("be.visible");
    cy.get(cesc("#\\/p4a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/minp1") + " textarea").type(
      "{end}{backspace}{backspace}{backspace}4000{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/minp1_incorrect")).should("be.visible");
    cy.get(cesc("#\\/np1a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/minp2") + " textarea").type(
      "{end}{backspace}{backspace}{backspace}4000{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/minp2_incorrect")).should("be.visible");
    cy.get(cesc("#\\/np2a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/minp3") + " textarea").type(
      "{end}{backspace}{backspace}{backspace}4000{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/minp3_incorrect")).should("be.visible");
    cy.get(cesc("#\\/np3a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/minp4") + " textarea").type(
      "{end}{backspace}{backspace}{backspace}4000{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/minp4_incorrect")).should("be.visible");
    cy.get(cesc("#\\/np4a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/mip1") + " textarea").type(
      "{end}{backspace}{backspace}{backspace}4000{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/mip1_correct")).should("be.visible");
    cy.get(cesc("#\\/p1a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/mip2") + " textarea").type(
      "{end}{backspace}{backspace}{backspace}4000{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/mip2_correct")).should("be.visible");
    cy.get(cesc("#\\/p2a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/mip3") + " textarea").type(
      "{end}{backspace}{backspace}{backspace}4000{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/mip3_correct")).should("be.visible");
    cy.get(cesc("#\\/p3a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");

    cy.get(cesc("#\\/mip4") + " textarea").type(
      "{end}{backspace}{backspace}{backspace}4000{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/mip4_correct")).should("be.visible");
    cy.get(cesc("#\\/p4a") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "4000");
  });

  it("submitted response from matrixInput", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <answer name="ans">
    <matrixInput name="mi" numColumns="2" numRows="2" showSizeControls="false" />
    <award><matrix><row>a b</row><row>c d</row></matrix></award>
  </answer>

  <p name="pCurrent">current response: $ans.currentResponses</p>
  <p name="pSubmitted">submitted response: $ans</p>


  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a"); // to wait until loaded

    cy.get(cesc("#\\/pCurrent") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "[＿＿＿＿]");
    cy.get(cesc("#\\/pSubmitted") + " .mjx-mrow").should("not.exist");

    cy.get(cesc("#\\/mi_component_0_0") + " textarea").type("x{enter}", {
      force: true,
    });

    cy.get(cesc("#\\/pCurrent") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "[x＿＿＿]");
    cy.get(cesc("#\\/pSubmitted") + " .mjx-mrow").should("not.exist");

    cy.get(cesc("#\\/mi_component_0_1") + " textarea").type("y{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/mi_component_1_0") + " textarea").type("z{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/mi_component_1_1") + " textarea").type("0{enter}", {
      force: true,
    });

    cy.get(cesc("#\\/pCurrent") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "[xyz0]");
    cy.get(cesc("#\\/pSubmitted") + " .mjx-mrow").should("not.exist");

    cy.get(cesc("#\\/mi_submit")).click();
    cy.get(cesc("#\\/mi_incorrect")).should("be.visible");

    cy.get(cesc("#\\/pSubmitted") + " .mjx-mrow").should(
      "contain.text",
      "[xyz0]",
    );
    cy.get(cesc("#\\/pCurrent") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "[xyz0]");
    cy.get(cesc("#\\/pSubmitted") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "[xyz0]");

    cy.get(cesc("#\\/mi_component_0_0") + " textarea").type(
      "{end}{backspace}a{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/mi_component_0_1") + " textarea").type(
      "{end}{backspace}b{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/mi_component_1_0") + " textarea").type(
      "{end}{backspace}c{enter}",
      { force: true },
    );
    cy.get(cesc("#\\/mi_component_1_1") + " textarea").type(
      "{end}{backspace}d{enter}",
      { force: true },
    );

    cy.get(cesc("#\\/pCurrent") + " .mjx-mrow").should(
      "contain.text",
      "[abcd]",
    );
    cy.get(cesc("#\\/pCurrent") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "[abcd]");
    cy.get(cesc("#\\/pSubmitted") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "[xyz0]");

    cy.get(cesc("#\\/mi_submit")).click();
    cy.get(cesc("#\\/mi_correct")).should("be.visible");

    cy.get(cesc("#\\/pSubmitted") + " .mjx-mrow").should(
      "contain.text",
      "[abcd]",
    );
    cy.get(cesc("#\\/pCurrent") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "[abcd]");
    cy.get(cesc("#\\/pSubmitted") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "[abcd]");
  });

  it("reload math answer without blurring or hitting enter", () => {
    let doenetML = `
    <p>Enter 1: <answer>
      <mathinput name="n" />
      <award><when>$n=1</when></award>
    </answer>
    </p>
    `;

    cy.get("#testRunner_toggleControls").click();
    cy.get("#testRunner_allowLocalState").click();
    cy.wait(100);
    cy.get("#testRunner_toggleControls").click();

    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/n") + " textarea").type("1", { force: true });

    cy.wait(1500); // wait for debounce

    cy.reload();

    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/n_submit")).click();
    cy.get(cesc("#\\/n_correct")).should("be.visible");
  });

  it("reload text answer without blurring or hitting enter", () => {
    let doenetML = `
    <p>Enter 1: <answer>
      <textinput name="ti" />
      <award><when>$ti=hello</when></award>
    </answer>
    </p>
    `;

    cy.get("#testRunner_toggleControls").click();
    cy.get("#testRunner_allowLocalState").click();
    cy.wait(100);
    cy.get("#testRunner_toggleControls").click();

    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/ti_input")).type("hello", { force: true });

    cy.wait(1500); // wait for debounce

    cy.reload();

    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/ti_submit")).click();
    cy.get(cesc("#\\/ti_correct")).should("be.visible");
  });

  it("a function defined by formula uses formula for a response", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Type the function <m>f(x) = <function name="correctFunction">x^2</function></m></p>
  <p><m>f(x) = </m><mathInput name="userFormula"/></p>
  
  <answer>
    <award>
      <when>$userFormula = $correctFunction</when>
    </award>
  </answer>

  <p>Submitted responses: <copy prop="submittedResponses" source="_answer1" assignNames="sr1 sr2" /></p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_p1")).should("contain.text", "Type the function");

    cy.get(cesc("#\\/userFormula") + " textarea").type("x^2{enter}", {
      force: true,
    });

    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.get(cesc("#\\/_answer1_correct")).should("be.visible");

    cy.get(cesc("#\\/sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x2");
    cy.get(cesc("#\\/sr2") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x2");

    cy.get(cesc("#\\/userFormula") + " textarea").type("{home}3{enter}", {
      force: true,
    });

    cy.get(cesc("#\\/_answer1_submit")).click();

    cy.get(cesc("#\\/_answer1_incorrect")).should("be.visible");

    cy.get(cesc("#\\/sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "3x2");
    cy.get(cesc("#\\/sr2") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x2");
  });

  it("hand-graded answers", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  <p>Maths: 
    <answer handGraded name="m1" />
    <answer handGraded type="math" name="m2" />
    <answer handGraded name="m3" ><mathinput /></answer>
    <answer handGraded name="m4">x</answer>
    <answer handGraded name="m5"><math>x</math></answer>
    <answer handGraded name="m6"><award><math>x</math></award></answer>
    <answer handGraded name="m7"><mathinput /><award><math>x</math></award></answer>
  </p>
  <p>Submitted responses:
    <math name="m1sr" copySource="m1" />
    <math name="m2sr" copySource="m2" />
    <math name="m3sr" copySource="m3" />
    <math name="m4sr" copySource="m4" />
    <math name="m5sr" copySource="m5" />
    <math name="m6sr" copySource="m6" />
    <math name="m7sr" copySource="m7" />
  </p>
  <p>Credit achieved:
    <number name="m1ca" copySource="m1.creditAchieved" />
    <number name="m2ca" copySource="m2.creditAchieved" />
    <number name="m3ca" copySource="m3.creditAchieved" />
    <number name="m4ca" copySource="m4.creditAchieved" />
    <number name="m5ca" copySource="m5.creditAchieved" />
    <number name="m6ca" copySource="m6.creditAchieved" />
    <number name="m7ca" copySource="m7.creditAchieved" />
  </p>
  <p>Texts: 
    <answer handGraded type="text" name="t1" />
    <answer handGraded name="t2"><textinput /></answer>
    <answer handGraded name="t3"><text>hello</text></answer>
    <answer handGraded name="t4"><award><text>hello</text></award></answer>
  </p>
  <p>Submitted responses:
    <text name="t1sr" copySource="t1" />
    <text name="t2sr" copySource="t2" />
    <text name="t3sr" copySource="t3" />
    <text name="t4sr" copySource="t4" />
  </p>
  <p>Credit achieved:
    <number name="t1ca" copySource="t1.creditAchieved" />
    <number name="t2ca" copySource="t2.creditAchieved" />
    <number name="t3ca" copySource="t3.creditAchieved" />
    <number name="t4ca" copySource="t4.creditAchieved" />
  </p>
  <p>Multiple inputs
    <answer handGraded name="mi1"><mathinput /><mathinput /></answer>
    <answer handGraded name="mi2"><textinput /><textinput /></answer>
    <answer handGraded name="mi3"><mathinput /><textinput /></answer>
  </p>
  <p>Submitted responses:
    <math name="mi1sr1" copySource="mi1.submittedResponse1" />
    <math name="mi1sr2" copySource="mi1.submittedResponse2" />
    <text name="mi2sr1" copySource="mi2.submittedResponse1" />
    <text name="mi2sr2" copySource="mi2.submittedResponse2" />
    <math name="mi3sr1" copySource="mi3.submittedResponse1" />
    <text name="mi3sr2" copySource="mi3.submittedResponse2" />
  </p>
  <p>Credit achieved:
    <number name="mi1ca" copySource="mi1.creditAchieved" />
    <number name="mi2ca" copySource="mi2.creditAchieved" />
    <number name="mi3ca" copySource="mi3.creditAchieved" />
  </p>
  <p>Inputs outside answer
    <mathinput name="oi1i1" /> <mathinput name="oi1i2" /> <answer handGraded name="oi1"><award><when>$oi1i1$oi1i2</when></award></answer>
    <textinput name="oi2i1" /> <textinput name="oi2i2" /> <answer handGraded name="oi2"><award><when>$oi2i1$oi2i2</when></award></answer>
    <mathinput name="oi3i1" /> <textinput name="oi3i2" /> <answer handGraded name="oi3"><award><when>$oi3i1$oi3i2</when></award></answer>
  </p>
  <p>Submitted responses:
    <math name="oi1sr1" copySource="oi1.submittedResponse1" />
    <math name="oi1sr2" copySource="oi1.submittedResponse2" />
    <text name="oi2sr1" copySource="oi2.submittedResponse1" />
    <text name="oi2sr2" copySource="oi2.submittedResponse2" />
    <math name="oi3sr1" copySource="oi3.submittedResponse1" />
    <text name="oi3sr2" copySource="oi3.submittedResponse2" />
  </p>
  <p>Credit achieved:
    <number name="oi1ca" copySource="oi1.creditAchieved" />
    <number name="oi2ca" copySource="oi2.creditAchieved" />
    <number name="oi3ca" copySource="oi3.creditAchieved" />
  </p>


  `,
        },
        "*",
      );
    });

    cy.get(cesc("#\\/_text1")).should("have.text", "a");

    cy.get(cesc("#\\/m1") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/m2") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/m3") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/m4") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/m5") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/m6") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/m7") + " textarea").type("x{enter}", { force: true });

    cy.get(cesc("#\\/t1") + " input").type("hello{enter}");
    cy.get(cesc("#\\/t2") + " input").type("hello{enter}");
    cy.get(cesc("#\\/t3") + " input").type("hello{enter}");
    cy.get(cesc("#\\/t4") + " input").type("hello{enter}");

    cy.get(cesc("#\\/mi1") + " textarea")
      .eq(0)
      .type("x{enter}", { force: true });
    cy.get(cesc("#\\/mi1") + " textarea")
      .eq(1)
      .type("y{enter}", { force: true });
    cy.get(cesc("#\\/mi1_submit")).click();
    cy.get(cesc("#\\/mi2") + " input")
      .eq(0)
      .type("hello{enter}");
    cy.get(cesc("#\\/mi2") + " input")
      .eq(1)
      .type("bye{enter}");
    cy.get(cesc("#\\/mi2_submit")).click();
    cy.get(cesc("#\\/mi3") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/mi3") + " input").type("bye{enter}");
    cy.get(cesc("#\\/mi3_submit")).click();

    cy.get(cesc("#\\/oi1i1") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/oi1i2") + " textarea").type("y{enter}", { force: true });
    cy.get(cesc("#\\/oi1_submit")).click();
    cy.get(cesc("#\\/oi2i1") + " input").type("hello{enter}");
    cy.get(cesc("#\\/oi2i2") + " input").type("bye{enter}");
    cy.get(cesc("#\\/oi2_submit")).click();
    cy.get(cesc("#\\/oi3i1") + " textarea").type("x{enter}", { force: true });
    cy.get(cesc("#\\/oi3i2") + " input").type("bye{enter}");
    cy.get(cesc("#\\/oi3_submit")).click();

    cy.get(cesc("#\\/oi3sr2")).should("have.text", "bye");

    cy.get(cesc("#\\/m1sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/m2sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/m3sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/m4sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/m5sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/m6sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/m7sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");

    cy.get(cesc("#\\/t1sr")).should("have.text", "hello");
    cy.get(cesc("#\\/t2sr")).should("have.text", "hello");
    cy.get(cesc("#\\/t3sr")).should("have.text", "hello");
    cy.get(cesc("#\\/t4sr")).should("have.text", "hello");

    cy.get(cesc("#\\/mi1sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/mi1sr2") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "y");
    cy.get(cesc("#\\/mi2sr1")).should("have.text", "hello");
    cy.get(cesc("#\\/mi2sr2")).should("have.text", "bye");
    cy.get(cesc("#\\/mi3sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/mi3sr2")).should("have.text", "bye");

    cy.get(cesc("#\\/oi1sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/oi1sr2") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "y");
    cy.get(cesc("#\\/oi2sr1")).should("have.text", "hello");
    cy.get(cesc("#\\/oi2sr2")).should("have.text", "bye");
    cy.get(cesc("#\\/oi3sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "x");
    cy.get(cesc("#\\/oi3sr2")).should("have.text", "bye");

    cy.get(cesc("#\\/m1ca")).should("have.text", "0");
    cy.get(cesc("#\\/m2ca")).should("have.text", "0");
    cy.get(cesc("#\\/m3ca")).should("have.text", "0");
    cy.get(cesc("#\\/m4ca")).should("have.text", "0");
    cy.get(cesc("#\\/m5ca")).should("have.text", "0");
    cy.get(cesc("#\\/m6ca")).should("have.text", "0");
    cy.get(cesc("#\\/m7ca")).should("have.text", "0");

    cy.get(cesc("#\\/t1ca")).should("have.text", "0");
    cy.get(cesc("#\\/t2ca")).should("have.text", "0");
    cy.get(cesc("#\\/t3ca")).should("have.text", "0");
    cy.get(cesc("#\\/t4ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi1ca")).should("have.text", "0");
    cy.get(cesc("#\\/mi2ca")).should("have.text", "0");
    cy.get(cesc("#\\/mi3ca")).should("have.text", "0");

    cy.get(cesc("#\\/oi1ca")).should("have.text", "0");
    cy.get(cesc("#\\/oi2ca")).should("have.text", "0");
    cy.get(cesc("#\\/oi3ca")).should("have.text", "0");

    cy.log("revise answers and submit");

    cy.get(cesc("#\\/m1") + " textarea").type("{end}y{enter}", { force: true });
    cy.get(cesc("#\\/m2") + " textarea").type("{end}y{enter}", { force: true });
    cy.get(cesc("#\\/m3") + " textarea").type("{end}y{enter}", { force: true });
    cy.get(cesc("#\\/m4") + " textarea").type("{end}y{enter}", { force: true });
    cy.get(cesc("#\\/m5") + " textarea").type("{end}y{enter}", { force: true });
    cy.get(cesc("#\\/m6") + " textarea").type("{end}y{enter}", { force: true });
    cy.get(cesc("#\\/m7") + " textarea").type("{end}y{enter}", { force: true });

    cy.get(cesc("#\\/t1") + " input").type(" there{enter}");
    cy.get(cesc("#\\/t2") + " input").type(" there{enter}");
    cy.get(cesc("#\\/t3") + " input").type(" there{enter}");
    cy.get(cesc("#\\/t4") + " input").type(" there{enter}");

    cy.get(cesc("#\\/mi1") + " textarea")
      .eq(0)
      .type("{end}z{enter}", { force: true });
    cy.get(cesc("#\\/mi1_submit")).click();
    cy.get(cesc("#\\/mi1") + " textarea")
      .eq(1)
      .type("{end}z{enter}", { force: true });
    cy.get(cesc("#\\/mi1_submit")).click();
    cy.get(cesc("#\\/mi2") + " input")
      .eq(0)
      .type(" there{enter}");
    cy.get(cesc("#\\/mi2_submit")).click();
    cy.get(cesc("#\\/mi2") + " input")
      .eq(1)
      .type(" now{enter}");
    cy.get(cesc("#\\/mi2_submit")).click();
    cy.get(cesc("#\\/mi3") + " textarea").type("{end}y{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/mi3_submit")).click();
    cy.get(cesc("#\\/mi3") + " input").type(" now{enter}");
    cy.get(cesc("#\\/mi3_submit")).click();

    cy.get(cesc("#\\/oi1i1") + " textarea").type("{end}z{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/oi1_submit")).click();
    cy.get(cesc("#\\/oi1i2") + " textarea").type("{end}z{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/oi1_submit")).click();
    cy.get(cesc("#\\/oi2i1") + " input").type(" there{enter}");
    cy.get(cesc("#\\/oi2_submit")).click();
    cy.get(cesc("#\\/oi2i2") + " input").type(" now{enter}");
    cy.get(cesc("#\\/oi2_submit")).click();
    cy.get(cesc("#\\/oi3i1") + " textarea").type("{end}y{enter}", {
      force: true,
    });
    cy.get(cesc("#\\/oi3_submit")).click();
    cy.get(cesc("#\\/oi3i2") + " input").type(" now{enter}");
    cy.get(cesc("#\\/oi3_submit")).click();

    cy.get(cesc("#\\/oi3sr2")).should("have.text", "bye now");

    cy.get(cesc("#\\/m1sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xy");
    cy.get(cesc("#\\/m2sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xy");
    cy.get(cesc("#\\/m3sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xy");
    cy.get(cesc("#\\/m4sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xy");
    cy.get(cesc("#\\/m5sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xy");
    cy.get(cesc("#\\/m6sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xy");
    cy.get(cesc("#\\/m7sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xy");

    cy.get(cesc("#\\/t1sr")).should("have.text", "hello there");
    cy.get(cesc("#\\/t2sr")).should("have.text", "hello there");
    cy.get(cesc("#\\/t3sr")).should("have.text", "hello there");
    cy.get(cesc("#\\/t4sr")).should("have.text", "hello there");

    cy.get(cesc("#\\/mi1sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xz");
    cy.get(cesc("#\\/mi1sr2") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "yz");
    cy.get(cesc("#\\/mi2sr1")).should("have.text", "hello there");
    cy.get(cesc("#\\/mi2sr2")).should("have.text", "bye now");
    cy.get(cesc("#\\/mi3sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xy");
    cy.get(cesc("#\\/mi3sr2")).should("have.text", "bye now");

    cy.get(cesc("#\\/oi1sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xz");
    cy.get(cesc("#\\/oi1sr2") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "yz");
    cy.get(cesc("#\\/oi2sr1")).should("have.text", "hello there");
    cy.get(cesc("#\\/oi2sr2")).should("have.text", "bye now");
    cy.get(cesc("#\\/oi3sr1") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "xy");
    cy.get(cesc("#\\/oi3sr2")).should("have.text", "bye now");

    cy.get(cesc("#\\/m1ca")).should("have.text", "0");
    cy.get(cesc("#\\/m2ca")).should("have.text", "0");
    cy.get(cesc("#\\/m3ca")).should("have.text", "0");
    cy.get(cesc("#\\/m4ca")).should("have.text", "0");
    cy.get(cesc("#\\/m5ca")).should("have.text", "0");
    cy.get(cesc("#\\/m6ca")).should("have.text", "0");
    cy.get(cesc("#\\/m7ca")).should("have.text", "0");

    cy.get(cesc("#\\/t1ca")).should("have.text", "0");
    cy.get(cesc("#\\/t2ca")).should("have.text", "0");
    cy.get(cesc("#\\/t3ca")).should("have.text", "0");
    cy.get(cesc("#\\/t4ca")).should("have.text", "0");

    cy.get(cesc("#\\/mi1ca")).should("have.text", "0");
    cy.get(cesc("#\\/mi2ca")).should("have.text", "0");
    cy.get(cesc("#\\/mi3ca")).should("have.text", "0");

    cy.get(cesc("#\\/oi1ca")).should("have.text", "0");
    cy.get(cesc("#\\/oi2ca")).should("have.text", "0");
    cy.get(cesc("#\\/oi3ca")).should("have.text", "0");
  });

  it("display digits for credit achieved", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  
  <p><answer name="def">
    <award>x</award>
    <award credit="1/3">y</award>
  </answer>
  Credit: <number copysource="def.creditAchieved" name="def_credit" />
  </p>

  <p><answer displayDigitsForCreditAchieved="8" name="long">
    <award>x</award>
    <award credit="1/3">y</award>
  </answer>
  Credit: <number copysource="long.creditAchieved" name="long_credit" />
  </p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc2("#/_text1")).should("have.text", "a");

    cy.get(cesc2("#/def") + " textarea").type("y{enter}", { force: true });
    cy.get(cesc2("#/long") + " textarea").type("y{enter}", { force: true });

    cy.get(cesc2("#/def_credit")).should("have.text", "0.333");
    cy.get(cesc2("#/long_credit")).should("have.text", "0.33333333");
  });

  it("display digits for responses", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  
  <p><answer name="def">1.23456789</answer>
  Current response: <math copysource="def.currentResponse" name="def_cr" />
  Submitted response: <math copysource="def.SubmittedResponse" name="def_sr" />
  </p>

  <p><answer displayDigitsForResponses="3" name="short">1.23456789</answer>
  Current response: <math copysource="short.CurrentResponse" name="short_cr" />
  Submitted response: <math copysource="short.SubmittedResponse" name="short_sr" />
  </p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc2("#/_text1")).should("have.text", "a");

    cy.get(cesc2("#/def") + " textarea")
      .type("1.23456789", { force: true })
      .blur();
    cy.get(cesc2("#/short") + " textarea")
      .type("1.23456789", { force: true })
      .blur();

    cy.get(cesc2("#/short_cr")).should("contain.text", "1.23");
    cy.get(cesc2("#/def_cr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "1.23456789");
    cy.get(cesc2("#/short_cr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "1.23");
    cy.get(cesc2("#/def_sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "\uff3f");
    cy.get(cesc2("#/short_sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "\uff3f");

    cy.get(cesc2("#/def") + " textarea")
      .type("{enter}", { force: true })
      .blur();
    cy.get(cesc2("#/short") + " textarea")
      .type("{enter}", { force: true })
      .blur();

    cy.get(cesc2("#/short_sr")).should("contain.text", "1.23");

    cy.get(cesc2("#/def_cr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "1.23456789");
    cy.get(cesc2("#/short_cr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "1.23");
    cy.get(cesc2("#/def_sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "1.23456789");
    cy.get(cesc2("#/short_sr") + " .mjx-mrow")
      .eq(0)
      .should("have.text", "1.23");
  });

  it("display digits for responses, turn math to number", () => {
    cy.window().then(async (win) => {
      win.postMessage(
        {
          doenetML: `
  <text>a</text>
  
  <p><answer name="def">1.23456789</answer>
  Current response: <number copysource="def.currentResponse" name="def_cr" />
  Submitted response: <number copysource="def.SubmittedResponse" name="def_sr" />
  </p>

  <p><answer displayDigitsForResponses="3" name="short">1.23456789</answer>
  Current response: <number copysource="short.CurrentResponse" name="short_cr" />
  Submitted response: <number copysource="short.SubmittedResponse" name="short_sr" />
  </p>

  `,
        },
        "*",
      );
    });

    cy.get(cesc2("#/_text1")).should("have.text", "a");

    cy.get(cesc2("#/def") + " textarea")
      .type("1.23456789", { force: true })
      .blur();
    cy.get(cesc2("#/short") + " textarea")
      .type("1.23456789", { force: true })
      .blur();

    cy.get(cesc2("#/short_cr")).should("contain.text", "1.23");
    cy.get(cesc2("#/def_cr")).should("have.text", "1.23456789");
    cy.get(cesc2("#/short_cr")).should("have.text", "1.23");
    cy.get(cesc2("#/def_sr")).should("have.text", "NaN");
    cy.get(cesc2("#/short_sr")).should("have.text", "NaN");

    cy.get(cesc2("#/def") + " textarea")
      .type("{enter}", { force: true })
      .blur();
    cy.get(cesc2("#/short") + " textarea")
      .type("{enter}", { force: true })
      .blur();

    cy.get(cesc2("#/short_sr")).should("contain.text", "1.23");

    cy.get(cesc2("#/def_cr")).should("have.text", "1.23456789");
    cy.get(cesc2("#/short_cr")).should("have.text", "1.23");
    cy.get(cesc2("#/def_sr")).should("have.text", "1.23456789");
    cy.get(cesc2("#/short_sr")).should("have.text", "1.23");
  });
});
