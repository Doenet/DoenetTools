(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[4,0],{

/***/ 554:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DoenetRenderer; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var DoenetRenderer = /*#__PURE__*/function (_Component) {
  _inherits(DoenetRenderer, _Component);

  var _super = _createSuper(DoenetRenderer);

  function DoenetRenderer(props) {
    var _this;

    _classCallCheck(this, DoenetRenderer);

    _this = _super.call(this, props);
    _this.addChildren = _this.addChildren.bind(_assertThisInitialized(_this));
    _this.removeChildren = _this.removeChildren.bind(_assertThisInitialized(_this));
    _this.swapChildren = _this.swapChildren.bind(_assertThisInitialized(_this));
    _this.update = _this.update.bind(_assertThisInitialized(_this));
    _this.childrenToCreate = props.componentInstructions.children;
    _this.componentName = props.componentInstructions.componentName;
    _this.actions = props.componentInstructions.actions; // This keeps the proxy in place so that state variables
    // aren't calculated unless asked for
    // Also means it will always have the new values when they are changed
    // so we don't have to pass them in on update

    _this.doenetSvData = props.componentInstructions.stateValues;
    props.rendererUpdateMethods[_this.componentName] = {
      update: _this.update,
      addChildren: _this.addChildren,
      removeChildren: _this.removeChildren,
      swapChildren: _this.swapChildren
    };

    if (_this.constructor.initializeChildrenOnConstruction) {
      _this.initializeChildren();
    }

    return _this;
  }

  _createClass(DoenetRenderer, [{
    key: "update",
    value: function update() {
      this.forceUpdate();
    }
  }, {
    key: "addChildren",
    value: function addChildren(instruction) {
      var childInstructions = this.childrenToCreate[instruction.indexForParent];
      var child = this.createChildFromInstructions(childInstructions);
      this.children.splice(instruction.indexForParent, 0, child);
      this.children = _toConsumableArray(this.children); // needed for React to recognize it's different

      this.forceUpdate();
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(instruction) {
      this.children.splice(instruction.firstIndexInParent, instruction.numberChildrenDeleted);
      this.children = _toConsumableArray(this.children); // needed for React to recognize it's different

      var _iterator = _createForOfIteratorHelper(instruction.deletedComponentNames),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var componentName = _step.value;
          delete this.props.rendererUpdateMethods[componentName];
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.forceUpdate();
    }
  }, {
    key: "swapChildren",
    value: function swapChildren(instruction) {
      var _ref = [this.children[instruction.index2], this.children[instruction.index1]];
      this.children[instruction.index1] = _ref[0];
      this.children[instruction.index2] = _ref[1];
      this.children = _toConsumableArray(this.children); // needed for React to recognize it's different

      this.forceUpdate();
    }
  }, {
    key: "initializeChildren",
    value: function initializeChildren() {
      this.children = [];

      var _iterator2 = _createForOfIteratorHelper(this.childrenToCreate),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var childInstructions = _step2.value;
          var child = this.createChildFromInstructions(childInstructions);
          this.children.push(child);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return this.children;
    }
  }, {
    key: "createChildFromInstructions",
    value: function createChildFromInstructions(childInstructions) {
      var propsForChild = {
        key: childInstructions.componentName,
        componentInstructions: childInstructions,
        rendererClasses: this.props.rendererClasses,
        rendererUpdateMethods: this.props.rendererUpdateMethods,
        flags: this.props.flags
      };

      if (this.doenetPropsForChildren) {
        Object.assign(propsForChild, this.doenetPropsForChildren);
      }

      var child = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(this.props.rendererClasses[childInstructions.rendererType], propsForChild);
      return child;
    }
  }]);

  return DoenetRenderer;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

_defineProperty(DoenetRenderer, "initializeChildrenOnConstruction", true);



/***/ }),

/***/ 559:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BezierCurve; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _DoenetRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(554);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var BezierCurve = /*#__PURE__*/function (_DoenetRenderer) {
  _inherits(BezierCurve, _DoenetRenderer);

  var _super = _createSuper(BezierCurve);

  function BezierCurve(props) {
    var _this;

    _classCallCheck(this, BezierCurve);

    _this = _super.call(this, props);
    _this.dragThroughPoint = _this.dragThroughPoint.bind(_assertThisInitialized(_this));
    _this.dragControlPoint = _this.dragControlPoint.bind(_assertThisInitialized(_this));
    _this.downThroughPoint = _this.downThroughPoint.bind(_assertThisInitialized(_this));
    _this.upThroughPoint = _this.upThroughPoint.bind(_assertThisInitialized(_this));
    _this.upBoard = _this.upBoard.bind(_assertThisInitialized(_this));
    _this.downOther = _this.downOther.bind(_assertThisInitialized(_this));
    _this.upOther = _this.upOther.bind(_assertThisInitialized(_this));

    if (props.board) {
      _this.createGraphicalObject();

      _this.doenetPropsForChildren = {
        board: _this.props.board
      };

      _this.initializeChildren();
    }

    return _this;
  }

  _createClass(BezierCurve, [{
    key: "createGraphicalObject",
    value: function createGraphicalObject() {
      var _this2 = this;

      if (this.doenetSvData.throughPointsNumeric.length < 2) {
        return;
      } //things to be passed to JSXGraph as attributes


      var curveAttributes = {
        name: this.doenetSvData.label,
        visible: !this.doenetSvData.hide,
        withLabel: this.doenetSvData.showLabel && this.doenetSvData.label !== "",
        fixed: true,
        layer: 10 * this.doenetSvData.layer + 5,
        strokeColor: this.doenetSvData.selectedStyle.markerColor,
        highlightStrokeColor: this.doenetSvData.selectedStyle.markerColor,
        strokeWidth: this.doenetSvData.selectedStyle.lineWidth,
        dash: styleToDash(this.doenetSvData.selectedStyle.lineStyle)
      };

      if (!this.doenetSvData.draggable) {
        curveAttributes.highlightStrokeWidth = this.doenetSvData.selectedStyle.lineWidth;
      }

      this.curveJXG = this.props.board.create('curve', [function (x) {
        return _this2.doenetSvData.f(x, 0);
      }, function (y) {
        return _this2.doenetSvData.f(y, 1);
      }, this.doenetSvData.parameterizationMin, this.doenetSvData.parameterizationMax], curveAttributes);
      this.startClickOnPoint = [];
      this.positionStartClick = [];
      this.props.board.on('up', this.upBoard);
      this.curveJXG.on('down', this.downOther);
      this.curveJXG.on('up', this.upOther);
      this.segmentAttributes = {
        visible: false,
        withLabel: false,
        fixed: true,
        strokeColor: 'lightgray',
        highlightStrokeColor: 'lightgray',
        layer: 10 * this.doenetSvData.layer + 7,
        strokeWidth: 1,
        highlightStrokeWidth: 1
      };
      this.throughPointAttributes = {
        visible: !this.doenetSvData.hide,
        withLabel: false,
        fixed: false,
        fillColor: 'none',
        strokeColor: 'none',
        highlightFillColor: 'lightgray',
        highlightStrokeColor: 'lightgray',
        strokeWidth: 1,
        highlightStrokeWidth: 1,
        layer: 10 * this.doenetSvData.layer + 7,
        size: 3
      };
      this.throughPointAlwaysVisible = {
        fillcolor: 'lightgray',
        strokecolor: 'lightgray'
      };
      this.throughPointHoverVisible = {
        fillcolor: 'none',
        strokecolor: 'none'
      };
      this.controlPointAttributes = {
        visible: false,
        withLabel: false,
        fixed: false,
        fillColor: 'gray',
        strokeColor: 'gray',
        highlightFillColor: 'gray',
        highlightStrokeColor: 'gray',
        strokeWidth: 1,
        highlightStrokeWidth: 1,
        layer: 10 * this.doenetSvData.layer + 8,
        size: 2
      };

      if (!this.doenetSvData.draggable) {
        return this.curveJXG;
      }

      this.createControls();
      this.props.board.updateRenderer();
      this.previousNumberOfPoints = this.doenetSvData.throughPointsNumeric.length;
      this.previousVectorControlDirections = _toConsumableArray(this.doenetSvData.vectorControlDirections);
      return this.curveJXG;
    }
  }, {
    key: "createControls",
    value: function createControls() {
      var _this3 = this;

      this.throughPointsJXG = [];
      this.controlPointsJXG = [];
      this.segmentsJXG = [];
      this.throughControlsVisible = []; // first through point has one control

      var tp = this.props.board.create('point', _toConsumableArray(this.doenetSvData.throughPointsNumeric[0]), this.throughPointAttributes);
      this.throughPointsJXG.push(tp);
      var cp = this.props.board.create('point', _toConsumableArray(this.doenetSvData.controlPointsNumeric[0][1]), this.controlPointAttributes);
      this.controlPointsJXG.push([null, cp]);
      var seg = this.props.board.create('segment', [tp, cp], this.segmentAttributes);
      this.segmentsJXG.push([null, seg]);
      this.throughControlsVisible.push(false);
      tp.on('drag', function (e) {
        return _this3.dragThroughPoint(0, e);
      });
      tp.on('down', function (e) {
        return _this3.downThroughPoint(0, e);
      });
      tp.on('up', function (e) {
        return _this3.upThroughPoint(0, e);
      });
      cp.on('drag', function (e) {
        return _this3.dragControlPoint(0, 1, e);
      });
      cp.on('down', this.downOther);
      seg.on('down', this.downOther);
      cp.on('up', this.upOther);
      seg.on('up', this.upOther);

      var _loop = function _loop(i) {
        // middle through points have two controls
        tp = _this3.props.board.create('point', _toConsumableArray(_this3.doenetSvData.throughPointsNumeric[i]), _this3.throughPointAttributes);

        _this3.throughPointsJXG.push(tp);

        var cp1 = _this3.props.board.create('point', _toConsumableArray(_this3.doenetSvData.controlPointsNumeric[i][0]), _this3.controlPointAttributes);

        var cp2 = _this3.props.board.create('point', _toConsumableArray(_this3.doenetSvData.controlPointsNumeric[i][1]), _this3.controlPointAttributes);

        _this3.controlPointsJXG.push([cp1, cp2]);

        var seg1 = _this3.props.board.create('segment', [tp, cp1], _this3.segmentAttributes);

        var seg2 = _this3.props.board.create('segment', [tp, cp2], _this3.segmentAttributes);

        _this3.segmentsJXG.push([seg1, seg2]);

        tp.on('drag', function (e) {
          return _this3.dragThroughPoint(i, e);
        });
        tp.on('down', function (e) {
          return _this3.downThroughPoint(i, e);
        });
        tp.on('up', function (e) {
          return _this3.upThroughPoint(i, e);
        });
        cp1.on('drag', function (e) {
          return _this3.dragControlPoint(i, 0, e);
        });
        cp2.on('drag', function (e) {
          return _this3.dragControlPoint(i, 1, e);
        });
        cp1.on('down', _this3.downOther);
        cp2.on('down', _this3.downOther);
        seg1.on('down', _this3.downOther);
        seg1.on('down', _this3.downOther);
        cp1.on('up', _this3.upOther);
        cp2.on('up', _this3.upOther);
        seg1.on('up', _this3.upOther);
        seg1.on('up', _this3.upOther);
      };

      for (var i = 1; i < this.doenetSvData.throughPointsNumeric.length - 1; i++) {
        _loop(i);
      } // last throughPoint has one control


      var n = this.doenetSvData.throughPointsNumeric.length - 1;
      tp = this.props.board.create('point', _toConsumableArray(this.doenetSvData.throughPointsNumeric[n]), this.throughPointAttributes);
      this.throughPointsJXG.push(tp);
      cp = this.props.board.create('point', _toConsumableArray(this.doenetSvData.controlPointsNumeric[n][0]), this.controlPointAttributes);
      this.controlPointsJXG.push([cp, null]);
      seg = this.props.board.create('segment', [tp, cp], this.segmentAttributes);
      this.segmentsJXG.push([seg, null]);
      tp.on('drag', function (e) {
        return _this3.dragThroughPoint(n, e);
      });
      tp.on('down', function (e) {
        return _this3.downThroughPoint(n, e);
      });
      tp.on('up', function (e) {
        return _this3.upThroughPoint(n, e);
      });
      cp.on('drag', function (e) {
        return _this3.dragControlPoint(n, 0, e);
      });
      cp.on('down', this.downOther);
      seg.on('down', this.downOther);
      cp.on('up', this.upOther);
      seg.on('up', this.upOther);
    }
  }, {
    key: "deleteControls",
    value: function deleteControls() {
      var _this4 = this;

      if (this.segmentsJXG) {
        this.segmentsJXG.forEach(function (x) {
          return x.forEach(function (y) {
            if (y) {
              _this4.props.board.removeObject(y);
            }
          });
        });
        delete this.segmentsJXG;
        this.controlPointsJXG.forEach(function (x) {
          return x.forEach(function (y) {
            if (y) {
              _this4.props.board.removeObject(y);
            }
          });
        });
        delete this.controlPointsJXG;
        this.throughPointsJXG.forEach(function (x) {
          return _this4.props.board.removeObject(x);
        });
        delete this.throughPointsJXG;
      }
    }
  }, {
    key: "deleteGraphicalObject",
    value: function deleteGraphicalObject() {
      this.props.board.removeObject(this.curveJXG);
      delete this.curveJXG;
      this.deleteControls();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.curveJXG) {
        this.deleteGraphicalObject();
      }
    }
  }, {
    key: "dragThroughPoint",
    value: function dragThroughPoint(i) {
      var tpcoords = [this.throughPointsJXG[i].X(), this.throughPointsJXG[i].Y()];
      this.actions.moveThroughPoint({
        throughPoint: tpcoords,
        throughPointInd: i
      });
    }
  }, {
    key: "dragControlPoint",
    value: function dragControlPoint(point, i) {
      // console.log(`drag control point ${point}, ${i}`)
      this.actions.moveControlVector({
        controlVector: [this.controlPointsJXG[point][i].X() - this.throughPointsJXG[point].X(), this.controlPointsJXG[point][i].Y() - this.throughPointsJXG[point].Y()],
        controlVectorInds: [point, i]
      });
    }
  }, {
    key: "makeThroughPointsAlwaysVisible",
    value: function makeThroughPointsAlwaysVisible() {
      var _iterator = _createForOfIteratorHelper(this.throughPointsJXG),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var point = _step.value;

          for (var attribute in this.throughPointAlwaysVisible) {
            point.visProp[attribute] = this.throughPointAlwaysVisible[attribute];
          }

          point.needsUpdate = true;
          point.update();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "makeThroughPointsHoverVisible",
    value: function makeThroughPointsHoverVisible() {
      var _iterator2 = _createForOfIteratorHelper(this.throughPointsJXG),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var point = _step2.value;

          for (var attribute in this.throughPointHoverVisible) {
            point.visProp[attribute] = this.throughPointHoverVisible[attribute];
          }

          point.needsUpdate = true;
          point.update();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "hideAllControls",
    value: function hideAllControls() {
      var _iterator3 = _createForOfIteratorHelper(this.controlPointsJXG),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var controlPair = _step3.value;

          var _iterator5 = _createForOfIteratorHelper(controlPair),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var cp = _step5.value;

              if (cp) {
                cp.visProp.visible = false;
                cp.needsUpdate = true;
                cp.update();
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      var _iterator4 = _createForOfIteratorHelper(this.segmentsJXG),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var segmentPair = _step4.value;

          var _iterator6 = _createForOfIteratorHelper(segmentPair),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var seg = _step6.value;

              if (seg) {
                seg.visProp.visible = false;
                seg.needsUpdate = true;
                seg.update();
              }
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "upBoard",
    value: function upBoard() {
      if (!this.doenetSvData.draggable) {
        return;
      }

      if (this.hitObject !== true) {
        this.makeThroughPointsHoverVisible();
        this.hideAllControls();
        this.props.board.updateRenderer();
      }

      this.hitObject = false;
    }
  }, {
    key: "downThroughPoint",
    value: function downThroughPoint(i, e) {
      // console.log(`down through point: ${i}`)
      this.hitObject = true;
      var recordClickStart = true;

      if (this.throughPointsJXG[i].getAttribute("fillcolor") !== this.throughPointAlwaysVisible.fillcolor) {
        recordClickStart = false;
      } // console.log(`recordClickStart ${recordClickStart}`)


      if (recordClickStart) {
        if (this.doenetSvData.vectorControlDirections[i] !== "none") {
          if (i === 0) {
            recordClickStart = this.controlPointsJXG[0][1].getAttribute("visible");
          } else {
            recordClickStart = this.controlPointsJXG[i][0].getAttribute("visible");
          }
        }
      } // console.log(`recordClickStart ${recordClickStart}`)


      if (recordClickStart) {
        this.startClickOnPoint[i] = Date.now();
      } // this.positionStartClick[i] = [this.throughPointsJXG[i].X(), this.throughPointsJXG[i].Y()];


      this.positionStartClick[i] = [e.clientX, e.clientY];
      this.makeThroughPointsAlwaysVisible();

      if (i > 0 && ["symmetric", "both", "previous"].includes(this.doenetSvData.vectorControlDirections[i])) {
        this.controlPointsJXG[i][0].visProp.visible = true;
        this.controlPointsJXG[i][0].needsUpdate = true;
        this.controlPointsJXG[i][0].update();
        this.segmentsJXG[i][0].visProp.visible = true;
        this.segmentsJXG[i][0].needsUpdate = true;
        this.segmentsJXG[i][0].update();
      }

      if (i < this.throughPointsJXG.length - 1 && ["symmetric", "both", "next"].includes(this.doenetSvData.vectorControlDirections[i])) {
        this.controlPointsJXG[i][1].visProp.visible = true;
        this.controlPointsJXG[i][1].needsUpdate = true;
        this.controlPointsJXG[i][1].update();
        this.segmentsJXG[i][1].visProp.visible = true;
        this.segmentsJXG[i][1].needsUpdate = true;
        this.segmentsJXG[i][1].update();
      }

      this.props.board.updateRenderer();
    }
  }, {
    key: "upThroughPoint",
    value: function upThroughPoint(i, e) {
      if (this.startClickOnPoint[i] === undefined || Date.now() - this.startClickOnPoint[i] > 1000 || this.positionStartClick[i] === undefined || this.positionStartClick[i][0] !== e.clientX || this.positionStartClick[i][1] !== e.clientY) {
        return;
      }

      this.startClickOnPoint[i] = undefined; // this.actions.togglePointControl(i);
    }
  }, {
    key: "downOther",
    value: function downOther() {
      if (!this.doenetSvData.draggable) {
        return;
      }

      this.hitObject = true;
    }
  }, {
    key: "upOther",
    value: function upOther() {
      if (!this.doenetSvData.draggable) {
        return;
      }

      this.makeThroughPointsAlwaysVisible();
      this.props.board.updateRenderer();
    }
  }, {
    key: "update",
    value: function update(_ref) {
      var _this5 = this;

      var sourceOfUpdate = _ref.sourceOfUpdate;

      // console.log('update beziercurve')
      // console.log(JSON.parse(JSON.stringify(this.doenetSvData)))
      if (!this.props.board) {
        this.forceUpdate();
        return;
      }

      if (this.curveJXG === undefined) {
        return this.createGraphicalObject();
      }

      if (this.doenetSvData.throughPointsNumeric.length < 2) {
        this.deleteGraphicalObject();
        return;
      }

      if (this.props.board.updateQuality === this.props.board.BOARD_QUALITY_LOW) {
        this.props.board.itemsRenderedLowQuality[this._key] = this.curveJXG;
      }

      var visible = !this.doenetSvData.hide;
      this.curveJXG.name = this.doenetSvData.label;
      this.curveJXG.visProp["visible"] = visible;
      this.curveJXG.visPropCalc["visible"] = visible;

      this.curveJXG.X = function (x) {
        return _this5.doenetSvData.f(x, 0);
      };

      this.curveJXG.Y = function (y) {
        return _this5.doenetSvData.f(y, 1);
      };

      this.curveJXG.minX = function () {
        return _this5.doenetSvData.parameterizationMin;
      };

      this.curveJXG.maxX = function () {
        return _this5.doenetSvData.parameterizationMax;
      };

      this.curveJXG.needsUpdate = true;
      this.curveJXG.updateCurve();

      if (this.curveJXG.hasLabel) {
        this.curveJXG.label.needsUpdate = true;
        this.curveJXG.label.visPropCalc.visible = this.doenetSvData.showLabel && this.doenetSvData.label !== "";
        this.curveJXG.label.update();
      }

      if (!this.doenetSvData.draggable) {
        if (this.segmentsJXG) {
          this.deleteControls();
        }

        this.props.board.updateRenderer();
        return;
      }

      if (!this.segmentsJXG) {
        this.createControls();
        this.previousNumberOfPoints = this.doenetSvData.throughPointsNumeric.length;
        this.previousVectorControlDirections = _toConsumableArray(this.doenetSvData.vectorControlDirections);
        this.props.board.updateRenderer();
        return;
      } // TODO: convert this for changing vectorControlDirections
      // for(let i in this.pointCurrentlyControlled) {
      //   if(this.pointCurrentlyControlled[i] !== originalPointCurrentlyControlled[i]) {
      //     let newVis = (this.pointCurrentlyControlled[i] === true);
      //     if(i>0) {
      //       this.controlPointsJXG[2*i-1].visProp.visible = newVis;
      //       this.controlPointsJXG[2*i-1].needsUpdate = true;
      //       this.controlPointsJXG[2*i-1].update();
      //       this.segmentsJXG[2*i-1].visProp.visible = newVis;
      //       this.segmentsJXG[2*i-1].needsUpdate = true;
      //       this.segmentsJXG[2*i-1].update();
      //     }
      //     if(i < this.throughPointsJXG.length-1) {
      //       this.controlPointsJXG[2*i].visProp.visible = newVis;
      //       this.controlPointsJXG[2*i].needsUpdate = true;
      //       this.controlPointsJXG[2*i].update();
      //       this.segmentsJXG[2*i].visProp.visible = newVis;
      //       this.segmentsJXG[2*i].needsUpdate = true;
      //       this.segmentsJXG[2*i].update();
      //     }
      //   }
      // }
      // add or delete segments and points if number changed


      if (this.doenetSvData.throughPointsNumeric.length > this.previousNumberOfPoints) {
        var _loop2 = function _loop2(i) {
          // add second control point for previous point
          var cp2 = _this5.props.board.create('point', _toConsumableArray(_this5.doenetSvData.controlPointsNumeric[i][1]), _this5.controlPointAttributes);

          _this5.controlPointsJXG[i - 1][1] = cp2;
          var prevtp = _this5.throughPointsJXG[i - 1];

          var seg2 = _this5.props.board.create('segment', [prevtp, cp2], _this5.segmentAttributes);

          _this5.segmentsJXG[i - 1][1] = seg2; // add point and its first control

          var tp = _this5.props.board.create('point', _toConsumableArray(_this5.doenetSvData.throughPointsNumeric[i]), _this5.throughPointAttributes);

          _this5.throughPointsJXG.push(tp);

          var cp1 = _this5.props.board.create('point', _toConsumableArray(_this5.doenetSvData.controlPointsNumeric[i][0]), _this5.controlPointAttributes);

          _this5.controlPointsJXG.push([cp1, null]);

          var seg1 = _this5.props.board.create('segment', [tp, cp1], _this5.segmentAttributes);

          _this5.segmentsJXG.push([seg1, null]);

          cp1.visProp.visible = false;
          seg1.visProp.visible = false;
          cp2.visProp.visible = false;
          seg2.visProp.visible = false;
          cp2.on('drag', function (e) {
            return _this5.dragControlPoint(i - 1, 1, e);
          });
          tp.on('drag', function (e) {
            return _this5.dragThroughpoint(i, e);
          });
          tp.on('down', function (e) {
            return _this5.downThroughpoint(i, e);
          });
          tp.on('up', function (e) {
            return _this5.upThroughpoint(i, e);
          });
          cp1.on('drag', function (e) {
            return _this5.dragControlPoint(i, 0, e);
          });
          cp1.on('down', _this5.downOther);
          seg1.on('down', _this5.downOther);
          cp1.on('up', _this5.upOther);
          seg1.on('up', _this5.upOther);
          cp2.on('down', _this5.downOther);
          seg2.on('down', _this5.downOther);
          cp2.on('up', _this5.upOther);
          seg2.on('up', _this5.upOther);
        };

        for (var i = this.previousNumberOfPoints; i < this.doenetSvData.throughPointsNumeric.length; i++) {
          _loop2(i);
        }
      } else if (this.doenetSvData.throughPointsNumeric.length < this.previousNumberOfPoints) {
        for (var _i = this.previousNumberOfPoints - 1; _i >= this.doenetSvData.throughPointsNumeric.length; _i--) {
          this.props.board.removeObject(this.segmentsJXG[_i][0]);
          this.segmentsJXG.pop();
          this.props.board.removeObject(this.segmentsJXG[_i - 1][1]);
          this.segmentsJXG[_i - 1][1] = null;
          this.props.board.removeObject(this.controlPointsJXG[_i][0]);
          this.controlPointsJXG.pop();
          this.props.board.removeObject(this.controlPointsJXG[_i - 1][1]);
          this.controlPointsJXG[_i - 1][1] = null;
          this.props.board.removeObject(this.throughPointsJXG.pop());
        }
      } // move old points


      var nOld = Math.min(this.doenetSvData.throughPointsNumeric.length, this.previousNumberOfPoints);
      this.throughPointsJXG[0].coords.setCoordinates(JXG.COORDS_BY_USER, _toConsumableArray(this.doenetSvData.throughPointsNumeric[0]));
      this.throughPointsJXG[0].needsUpdate = true;
      this.throughPointsJXG[0].update();

      for (var _i2 = 1; _i2 < nOld; _i2++) {
        this.throughPointsJXG[_i2].coords.setCoordinates(JXG.COORDS_BY_USER, _toConsumableArray(this.doenetSvData.throughPointsNumeric[_i2]));

        this.throughPointsJXG[_i2].needsUpdate = true;

        this.throughPointsJXG[_i2].update();

        this.controlPointsJXG[_i2][0].coords.setCoordinates(JXG.COORDS_BY_USER, _toConsumableArray(this.doenetSvData.controlPointsNumeric[_i2][0]));

        this.controlPointsJXG[_i2][0].needsUpdate = true;

        this.controlPointsJXG[_i2][0].update();

        this.segmentsJXG[_i2][0].needsUpdate = true;

        this.segmentsJXG[_i2][0].update();

        this.controlPointsJXG[_i2 - 1][1].coords.setCoordinates(JXG.COORDS_BY_USER, _toConsumableArray(this.doenetSvData.controlPointsNumeric[_i2 - 1][1]));

        this.controlPointsJXG[_i2 - 1][1].needsUpdate = true;

        this.controlPointsJXG[_i2 - 1][1].update();

        this.segmentsJXG[_i2 - 1][1].needsUpdate = true;

        this.segmentsJXG[_i2 - 1][1].update();
      }

      for (var _i3 = 0; _i3 < this.doenetSvData.throughPointsNumeric.length; _i3++) {
        this.throughPointsJXG[_i3].visProp["visible"] = !this.doenetSvData.hide;
        this.throughPointsJXG[_i3].visPropCalc["visible"] = !this.doenetSvData.hide;
      }

      if (this.componentName in sourceOfUpdate.sourceInformation) {
        var ind = sourceOfUpdate.sourceInformation.throughPointMoved;

        if (ind !== undefined) {
          this.props.board.updateInfobox(this.throughPointsJXG[ind]);
        } else {
          ind = sourceOfUpdate.sourceInformation.controlVectorMoved;

          if (ind !== undefined) {
            this.props.board.updateInfobox(this.controlPointsJXG[ind[0]][ind[1]]);
          }
        }
      }

      this.previousNumberOfPoints = this.doenetSvData.throughPointsNumeric.length;
      this.previousVectorControlDirections = _toConsumableArray(this.doenetSvData.vectorControlDirections);
      this.props.board.updateRenderer();
    }
  }, {
    key: "render",
    value: function render() {
      if (this.doenetSvData.hide) {
        return null;
      }

      if (this.props.board) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", {
          name: this.componentName
        }));
      } // don't think we want to return anything if not in board


      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", {
        name: this.componentName
      }));
    }
  }]);

  return BezierCurve;
}(_DoenetRenderer__WEBPACK_IMPORTED_MODULE_1__["default"]);

_defineProperty(BezierCurve, "initializeChildrenOnConstruction", false);



function styleToDash(style) {
  if (style === "solid") {
    return 0;
  } else if (style === "dashed") {
    return 2;
  } else if (style === "dotted") {
    return 1;
  } else {
    return 0;
  }
}

/***/ })

}]);