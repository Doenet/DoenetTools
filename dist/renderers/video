(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[52,2],{

/***/ 493:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DoenetRenderer; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);









function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var DoenetRenderer = /*#__PURE__*/function (_Component) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default()(DoenetRenderer, _Component);

  var _super = _createSuper(DoenetRenderer);

  function DoenetRenderer(props) {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, DoenetRenderer);

    _this = _super.call(this, props);
    _this.addChildren = _this.addChildren.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this));
    _this.removeChildren = _this.removeChildren.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this));
    _this.swapChildren = _this.swapChildren.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this));
    _this.update = _this.update.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this));
    _this.childrenToCreate = props.componentInstructions.children;
    _this.componentName = props.componentInstructions.componentName;
    _this.actions = props.componentInstructions.actions; // This keeps the proxy in place so that state variables
    // aren't calculated unless asked for
    // Also means it will always have the new values when they are changed
    // so we don't have to pass them in on update

    _this.doenetSvData = props.componentInstructions.stateValues;
    props.rendererUpdateMethods[_this.componentName] = {
      update: _this.update,
      addChildren: _this.addChildren,
      removeChildren: _this.removeChildren,
      swapChildren: _this.swapChildren
    };

    if (_this.constructor.initializeChildrenOnConstruction) {
      _this.initializeChildren();
    }

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(DoenetRenderer, [{
    key: "update",
    value: function update() {
      this.forceUpdate();
    }
  }, {
    key: "addChildren",
    value: function addChildren(instruction) {
      var childInstructions = this.childrenToCreate[instruction.indexForParent];
      var child = this.createChildFromInstructions(childInstructions);
      this.children.splice(instruction.indexForParent, 0, child);
      this.children = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(this.children); // needed for React to recognize it's different

      this.forceUpdate();
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(instruction) {
      this.children.splice(instruction.firstIndexInParent, instruction.numberChildrenDeleted);
      this.children = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(this.children); // needed for React to recognize it's different

      var _iterator = _createForOfIteratorHelper(instruction.deletedComponentNames),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var componentName = _step.value;
          delete this.props.rendererUpdateMethods[componentName];
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.forceUpdate();
    }
  }, {
    key: "swapChildren",
    value: function swapChildren(instruction) {
      var _ref = [this.children[instruction.index2], this.children[instruction.index1]];
      this.children[instruction.index1] = _ref[0];
      this.children[instruction.index2] = _ref[1];
      this.children = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(this.children); // needed for React to recognize it's different

      this.forceUpdate();
    }
  }, {
    key: "initializeChildren",
    value: function initializeChildren() {
      this.children = [];

      var _iterator2 = _createForOfIteratorHelper(this.childrenToCreate),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var childInstructions = _step2.value;
          var child = this.createChildFromInstructions(childInstructions);
          this.children.push(child);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return this.children;
    }
  }, {
    key: "createChildFromInstructions",
    value: function createChildFromInstructions(childInstructions) {
      var propsForChild = {
        key: childInstructions.componentName,
        componentInstructions: childInstructions,
        rendererClasses: this.props.rendererClasses,
        rendererUpdateMethods: this.props.rendererUpdateMethods,
        flags: this.props.flags
      };

      if (this.doenetPropsForChildren) {
        Object.assign(propsForChild, this.doenetPropsForChildren);
      }

      var child = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8___default.a.createElement(this.props.rendererClasses[childInstructions.rendererType], propsForChild);
      return child;
    }
  }]);

  return DoenetRenderer;
}(react__WEBPACK_IMPORTED_MODULE_8__["Component"]);

_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(DoenetRenderer, "initializeChildrenOnConstruction", true);



/***/ }),

/***/ 543:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Video; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _DoenetRenderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(493);
/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(993);
/* harmony import */ var cssesc__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(cssesc__WEBPACK_IMPORTED_MODULE_8__);







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// youtube player code based on Ximera youtube player
// https://github.com/XimeraProject/server
// https://github.com/XimeraProject/server/blob/master/public/javascripts/youtube.js




var Video = /*#__PURE__*/function (_DoenetRenderer) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Video, _DoenetRenderer);

  var _super = _createSuper(Video);

  function Video(props) {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Video);

    _this = _super.call(this, props);
    _this.onPlayerReady = _this.onPlayerReady.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default()(_this));
    _this.onPlayerStateChange = _this.onPlayerStateChange.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default()(_this));
    _this.onPlaybackRateChange = _this.onPlaybackRateChange.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2___default()(_this));
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(Video, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.doenetSvData.youtube) {
        var cName = cssesc__WEBPACK_IMPORTED_MODULE_8___default()(this.componentName);
        this.player = new window.YT.Player(cName, {
          videoId: this.doenetSvData.youtube,
          width: this.doenetSvData.width,
          height: this.doenetSvData.height,
          playerVars: {
            autoplay: 0,
            controls: 1,
            modestbranding: 1,
            rel: 0,
            showinfo: 0
          },
          events: {
            'onReady': this.onPlayerReady,
            'onStateChange': this.onPlayerStateChange,
            'onPlaybackRateChange': this.onPlaybackRateChange
          }
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (this.doenetSvData.hidden) {
        return null;
      }

      if (this.doenetSvData.youtube) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_6___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement("a", {
          name: this.componentName
        }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement("div", {
          className: "video",
          id: this.componentName
        }));
      } else if (this.doenetSvData.source) {
        var extension = this.doenetSvData.source.split('/').pop().split('.').pop();
        var type;

        if (extension === "ogg") {
          type = "video/ogg";
        } else if (extension === "webm") {
          type = "video/webm";
        } else if (extension === "mp4") {
          type = "video/mp4";
        } else {
          console.warn("Haven't implemented video for any extension other than .ogg, .webm, .mp4");
        }

        if (type) {
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_6___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement("a", {
            name: this.componentName
          }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement("video", {
            className: "video",
            id: this.componentName,
            style: {
              objectFit: "fill"
            },
            controls: true,
            width: this.doenetSvData.width,
            height: this.doenetSvData.height
          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement("source", {
            src: this.doenetSvData.source,
            type: type
          }), "Your browser does not support the <video> tag."));
        } else {
          return null;
        }
      }

      console.warn("No video returned youtube or no valid sources specified");
      return null;
    }
  }, {
    key: "onPlayerReady",
    value: function onPlayerReady() {
      var player = this.player;
      var renderer = this;
      player.setPlaybackQuality("hd720"); // To correctly capture the "watched" events, we need to know the last time
      // of the player before the user skips to a new spot
      // Since the callbacks only give the time after a skip,
      // we poll the player for the current time every 200 ms
      // to record the last time before a skip

      window.setInterval(function () {
        var newTime = player.getCurrentTime();
        var timeInterval; // if previously skipped a time (because the jump was too large)
        // we need to calculate the interval from that skipped time

        if (renderer.skippedCurrentTime) {
          timeInterval = newTime - renderer.skippedCurrentTime;
        } else {
          timeInterval = newTime - renderer.currentTime;
        } // We are polling every 200 ms,
        // hence if a jump was larger than a second (or negative),
        // we guess that a portion of the video was skipped
        // so don't update the current time for one cycle
        // (which is typically long enough for the state change listener
        // to be able to grab the current time to determine
        // the end of the watched segment)


        if (!(renderer.currentTime >= 0) || timeInterval > 0 && timeInterval < 1) {
          renderer.currentTime = newTime;
          renderer.skippedCurrentTime = null;
        } else {
          // jump was negative or longer than a second
          renderer.skippedCurrentTime = newTime;
        }
      }, 200);
    }
  }, {
    key: "onPlayerStateChange",
    value: function onPlayerStateChange(event) {
      var lastPlayerState = this.lastPlayerState;
      var renderer = this;
      var player = this.player;
      var duration = player.getDuration(); // console.log(`on player state change: ${event.data}`)

      switch (event.data) {
        case window.YT.PlayerState.PLAYING:
          if (this.lastEventState !== event.data) {
            var newTime = player.getCurrentTime();

            if (this.lastEventState === window.YT.PlayerState.PAUSED) {
              var timeSincePaused = newTime - this.lastPausedTime; // if the time has gone backward or move ahead more than a half-second,
              // we consider that a portion of the video was skipped
              // (When video is paused and immediately restarted, the time
              // skips forward a small amount, but less than a half-second)

              if (timeSincePaused < 0 || timeSincePaused > 0.5) {
                // console.log(`recording video skipped ${this.lastPausedTime}, ${newTime}`)
                this.actions.recordVideoSkipped({
                  beginTime: this.lastPausedTime,
                  endTime: newTime,
                  duration: duration
                });
              }
            }

            this.lastPlayedTime = newTime;
            var rate = player.getPlaybackRate();
            this.rates = [{
              startingPoint: newTime,
              rate: rate
            }];
            this.currentTime = NaN; // console.log(`recording that video started at ${this.lastPlayedTime} at rate ${rate}`)

            this.actions.recordVideoStarted({
              beginTime: player.getCurrentTime(),
              duration: duration,
              rate: rate
            });
            this.lastEventState = event.data;
          }

          break;

        case window.YT.PlayerState.PAUSED:
          var timer = setTimeout(function () {
            var currentTime = player.getCurrentTime();

            if (renderer.lastEventState === window.YT.PlayerState.PLAYING) {
              // console.log(`recording video watched ${renderer.lastPlayedTime}, ${currentTime}`);
              renderer.rates[renderer.rates.length - 1].endingPoint = currentTime;
              renderer.actions.recordVideoWatched({
                beginTime: renderer.lastPlayedTime,
                endTime: currentTime,
                duration: duration,
                rates: renderer.rates
              });
            } // console.log(`recording that video paused ${currentTime}`)


            renderer.actions.recordVideoPaused({
              endTime: currentTime,
              duration: duration
            });
            renderer.currentTime = NaN;
            renderer.lastEventState = event.data;
            renderer.lastPausedTime = currentTime;
          }, 250);
          this.timer = timer;
          break;

        case window.YT.PlayerState.BUFFERING:
          clearTimeout(this.timer);

          if (lastPlayerState !== window.YT.PlayerState.UNSTARTED && Number.isFinite(this.currentTime)) {
            var _newTime = player.getCurrentTime(); // console.log(`recording video watched ${this.lastPlayedTime}, ${this.currentTime}`);


            this.rates[this.rates.length - 1].endingPoint = this.currentTime;
            this.actions.recordVideoWatched({
              beginTime: this.lastPlayedTime,
              endTime: this.currentTime,
              duration: duration,
              rates: this.rates
            }); // console.log(`recording video skipped ${this.currentTime}, ${newTime}`)

            this.actions.recordVideoSkipped({
              beginTime: this.currentTime,
              endTime: _newTime,
              duration: duration
            });
            this.currentTime = NaN; // videoWatched(player, container, container.data('lastPlayedTime'), container.data('currentTime'));
            // videoSkipped(player, container, container.data('currentTime'), player.getCurrentTime());

            this.lastEventState = event.data;
          }

          break;

        case window.YT.PlayerState.ENDED:
          // BADBAD: We're treating ENDED as though it meant the user
          // completed the video, even thought it
          // doesn't necessarily mean the learner watched ALL the video
          // console.log(`recording video watched ${this.lastPlayedTime}, ${player.getCurrentTime()}`);
          this.rates[this.rates.length - 1].endingPoint = player.getCurrentTime();
          this.actions.recordVideoWatched({
            beginTime: this.lastPlayedTime,
            endTime: player.getCurrentTime(),
            duration: duration,
            rates: this.rates
          }); // console.log(`recording video ended`)

          this.actions.recordVideoCompleted({
            duration: duration
          });
          this.currentTime = NaN;
          this.lastEventState = event.data;
          break;

        case window.YT.PlayerState.UNSTARTED:
          break;
      }

      this.lastPlayerState = event.data;
    }
  }, {
    key: "onPlaybackRateChange",
    value: function onPlaybackRateChange(event) {
      this.rates[this.rates.length - 1].endingPoint = this.currentTime;
      this.rates.push({
        startingPoint: this.currentTime,
        rate: event.data
      });
    }
  }]);

  return Video;
}(_DoenetRenderer__WEBPACK_IMPORTED_MODULE_7__["default"]);



/***/ }),

/***/ 993:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! http://mths.be/cssesc v0.1.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports =  true && exports;

	// Detect free variable `module`
	var freeModule =  true && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var merge = function(options, defaults) {
		if (!options) {
			return defaults;
		}
		var key;
		var result = {};
		for (key in defaults) {
			// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
			// only recognized option names are used
			result[key] = hasOwnProperty.call(options, key)
				? options[key]
				: defaults[key];
		}
		return result;
	};

	/*--------------------------------------------------------------------------*/

	var regexAnySingleEscape = /[\x20-\x2C\x2E\x2F\x3B-\x40\x5B-\x5E\x60\x7B-\x7E]/;
	var regexSingleEscape = /[\x20\x21\x23-\x26\x28-\x2C\x2E\x2F\x3B-\x40\x5B\x5D\x5E\x60\x7B-\x7E]/;
	var regexAlwaysEscape = /['"\\]/;
	var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

	// http://mathiasbynens.be/notes/css-escapes#css
	var cssesc = function(string, options) {

		// Handle options
		options = merge(options, cssesc.options);
		if (options.quotes != 'single' && options.quotes != 'double') {
			options.quotes = 'single';
		}
		var quote = options.quotes == 'double' ? '"' : '\'';
		var isIdentifier = options.isIdentifier;

		var firstChar = string.charAt(0);
		var output = '';
		var counter = 0;
		var length = string.length;
		var value;
		var character;
		var codePoint;
		var extra; // used for potential low surrogates

		while (counter < length) {
			character = string.charAt(counter++);
			codePoint = character.charCodeAt();
			// if it’s not a printable ASCII character
			if (codePoint < 0x20 || codePoint > 0x7E) {
				if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // next character is low surrogate
						codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						counter--;
					}
				}
				value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
			} else {
				if (options.escapeEverything) {
					if (regexAnySingleEscape.test(character)) {
						value = '\\' + character;
					} else {
						value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
					}
				// `:` can be escaped as `\:`, but that fails in IE < 8
				} else if (/[\t\n\f\r\x0B:]/.test(character)) {
					if (!isIdentifier && character == ':') {
						value = character;
					} else {
						value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
					}
				} else if (
					character == '\\' ||
					(
						!isIdentifier &&
						(
							(character == '"' && quote == character) ||
							(character == '\'' && quote == character)
						)
					) ||
					(isIdentifier && regexSingleEscape.test(character))
				) {
					value = '\\' + character;
				} else {
					value = character;
				}
			}
			output += value;
		}

		if (isIdentifier) {
			if (/^_/.test(output)) {
				// Prevent IE6 from ignoring the rule altogether (in case this is for an
				// identifier used as a selector)
				output = '\\_' + output.slice(1);
			} else if (/^-[-\d]/.test(output)) {
				output = '\\-' + output.slice(1);
			} else if (/\d/.test(firstChar)) {
				output = '\\3' + firstChar + ' ' + output.slice(1);
			}
		}

		// Remove spaces after `\HEX` escapes that are not followed by a hex digit,
		// since they’re redundant. Note that this is only possible if the escape
		// sequence isn’t preceded by an odd number of backslashes.
		output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
			if ($1 && $1.length % 2) {
				// it’s not safe to remove the space, so don’t
				return $0;
			}
			// strip the space
			return ($1 || '') + $2;
		});

		if (!isIdentifier && options.wrap) {
			return quote + output + quote;
		}
		return output;
	};

	// Expose default options (so they can be overridden globally)
	cssesc.options = {
		'escapeEverything': false,
		'isIdentifier': false,
		'quotes': 'single',
		'wrap': false
	};

	cssesc.version = '0.1.0';

	/*--------------------------------------------------------------------------*/

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return cssesc;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(45)(module), __webpack_require__(34)))

/***/ })

}]);