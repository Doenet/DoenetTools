import { r as react } from '../common/index-61a7c514.js';
import { r as reactDom } from '../common/index-f174fb43.js';
import { a as arrayMethodIsStrict, _ as _export, b as arrayIncludes, e as engineUserAgent, g as global_1, c as engineIsNode, f as functionBindContext, d as fails, h as documentCreateElement, i as html$2, j as internalMetadata, k as isObject$2, l as freezing, o as objectSetPrototypeOf, m as fixRegexpWellKnownSymbolLogic, r as requireObjectCoercible, n as anObject, p as regexpExecAbstract, q as advanceStringIndex, t as toLength, s as toIndexedObject, u as toInteger, v as addToUnscopables, w as arrayIteration, x as ownKeys$g, y as createProperty, z as descriptors, A as objectGetOwnPropertyDescriptor, B as collection$1, C as collectionWeak } from '../common/es.string.ends-with-34d86b94.js';
import { c as createCommonjsModule$1, a as commonjsGlobal, b as commonjsRequire } from '../common/_commonjsHelpers-b3efd043.js';

/* eslint-disable es/no-array-prototype-indexof -- required for testing */

var $indexOf = arrayIncludes.indexOf;


var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('indexOf');

// `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof
_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var slice = [].slice;
var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

var wrap = function (scheduler) {
  return function (handler, timeout /* , ...arguments */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : undefined;
    return scheduler(boundArgs ? function () {
      // eslint-disable-next-line no-new-func -- spec requirement
      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
    } : handler, timeout);
  };
};

// ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
_export({ global: true, bind: true, forced: MSIE }, {
  // `setTimeout` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
  setTimeout: wrap(global_1.setTimeout),
  // `setInterval` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
  setInterval: wrap(global_1.setInterval)
});

var engineIsIos = /(?:iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

var location$1 = global_1.location;
var set = global_1.setImmediate;
var clear = global_1.clearImmediate;
var process = global_1.process;
var MessageChannel = global_1.MessageChannel;
var Dispatch = global_1.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins -- safe
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global_1.postMessage(id + '', location$1.protocol + '//' + location$1.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func -- spec requirement
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (engineIsNode) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !engineIsIos) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = functionBindContext(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global_1.addEventListener &&
    typeof postMessage == 'function' &&
    !global_1.importScripts &&
    location$1 && location$1.protocol !== 'file:' &&
    !fails(post)
  ) {
    defer = post;
    global_1.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
    defer = function (id) {
      html$2.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
        html$2.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

var task = {
  set: set,
  clear: clear
};

var FORCED = !global_1.setImmediate || !global_1.clearImmediate;

// http://w3c.github.io/setImmediate/
_export({ global: true, bind: true, enumerable: true, forced: FORCED }, {
  // `setImmediate` method
  // http://w3c.github.io/setImmediate/#si-setImmediate
  setImmediate: task.set,
  // `clearImmediate` method
  // http://w3c.github.io/setImmediate/#si-clearImmediate
  clearImmediate: task.clear
});

function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var lastTime = 0;
var vendors = ["ms", "moz", "webkit", "o"];
var _requestAnimationFrame = window.requestAnimationFrame;
var _cancelAnimationFrame = window.cancelAnimationFrame;
for (var x = 0; x < vendors.length && !_requestAnimationFrame; ++x) {
  _requestAnimationFrame = window["".concat(vendors[x], "RequestAnimationFrame")];
  _cancelAnimationFrame = window["".concat(vendors[x], "CancelAnimationFrame")] || window["".concat(vendors[x], "CancelRequestAnimationFrame")];
}
if (!_requestAnimationFrame) {
  _requestAnimationFrame = function _requestAnimationFrame2(callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function() {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}
if (!_cancelAnimationFrame) {
  _cancelAnimationFrame = function _cancelAnimationFrame2(id) {
    clearTimeout(id);
  };
}
function requestAnimationFrame(callback) {
  return _requestAnimationFrame.call(window, callback);
}
function isClassListSupported() {
  return !!document.documentElement.classList;
}
function isTextContentSupported() {
  return !!document.createTextNode("test").textContent;
}
function isGetComputedStyleSupported() {
  return !!window.getComputedStyle;
}
function cancelAnimationFrame(id) {
  _cancelAnimationFrame.call(window, id);
}
function isTouchSupported() {
  return "ontouchstart" in window;
}
var _hasCaptionProblem;
function detectCaptionProblem() {
  var TABLE = document.createElement("TABLE");
  TABLE.style.borderSpacing = "0";
  TABLE.style.borderWidth = "0";
  TABLE.style.padding = "0";
  var TBODY = document.createElement("TBODY");
  TABLE.appendChild(TBODY);
  TBODY.appendChild(document.createElement("TR"));
  TBODY.firstChild.appendChild(document.createElement("TD"));
  TBODY.firstChild.firstChild.innerHTML = "<tr><td>t<br>t</td></tr>";
  var CAPTION = document.createElement("CAPTION");
  CAPTION.innerHTML = "c<br>c<br>c<br>c";
  CAPTION.style.padding = "0";
  CAPTION.style.margin = "0";
  TABLE.insertBefore(CAPTION, TBODY);
  document.body.appendChild(TABLE);
  _hasCaptionProblem = TABLE.offsetHeight < 2 * TABLE.lastChild.offsetHeight;
  document.body.removeChild(TABLE);
}
function hasCaptionProblem() {
  if (_hasCaptionProblem === void 0) {
    detectCaptionProblem();
  }
  return _hasCaptionProblem;
}
var comparisonFunction;
function getComparisonFunction(language) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (comparisonFunction) {
    return comparisonFunction;
  }
  if ((typeof Intl === "undefined" ? "undefined" : _typeof(Intl)) === "object") {
    comparisonFunction = new Intl.Collator(language, options).compare;
  } else if (typeof String.prototype.localeCompare === "function") {
    comparisonFunction = function comparisonFunction2(a, b) {
      return "".concat(a).localeCompare(b);
    };
  } else {
    comparisonFunction = function comparisonFunction2(a, b) {
      if (a === b) {
        return 0;
      }
      return a > b ? -1 : 1;
    };
  }
  return comparisonFunction;
}
var passiveSupported;
function isPassiveEventSupported() {
  if (passiveSupported !== void 0) {
    return passiveSupported;
  }
  try {
    var options = {
      get passive() {
        passiveSupported = true;
      }
    };
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
  return passiveSupported;
}

var featureHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  requestAnimationFrame: requestAnimationFrame,
  isClassListSupported: isClassListSupported,
  isTextContentSupported: isTextContentSupported,
  isGetComputedStyleSupported: isGetComputedStyleSupported,
  cancelAnimationFrame: cancelAnimationFrame,
  isTouchSupported: isTouchSupported,
  hasCaptionProblem: hasCaptionProblem,
  getComparisonFunction: getComparisonFunction,
  isPassiveEventSupported: isPassiveEventSupported
});

function to2dArray(arr) {
  var ilen = arr.length;
  var i = 0;
  while (i < ilen) {
    arr[i] = [arr[i]];
    i += 1;
  }
}
function extendArray(arr, extension) {
  var ilen = extension.length;
  var i = 0;
  while (i < ilen) {
    arr.push(extension[i]);
    i += 1;
  }
}
function pivot(arr) {
  var pivotedArr = [];
  if (!arr || arr.length === 0 || !arr[0] || arr[0].length === 0) {
    return pivotedArr;
  }
  var rowCount = arr.length;
  var colCount = arr[0].length;
  for (var i = 0; i < rowCount; i++) {
    for (var j = 0; j < colCount; j++) {
      if (!pivotedArr[j]) {
        pivotedArr[j] = [];
      }
      pivotedArr[j][i] = arr[i][j];
    }
  }
  return pivotedArr;
}
function arrayReduce(array, iteratee, accumulator, initFromArray) {
  var index = -1;
  var iterable = array;
  var result = accumulator;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  if (initFromArray && length) {
    index += 1;
    result = iterable[index];
  }
  index += 1;
  while (index < length) {
    result = iteratee(result, iterable[index], index, iterable);
    index += 1;
  }
  return result;
}
function arrayFilter(array, predicate) {
  var index = 0;
  var iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  var result = [];
  var resIndex = -1;
  while (index < length) {
    var value = iterable[index];
    if (predicate(value, index, iterable)) {
      resIndex += 1;
      result[resIndex] = value;
    }
    index += 1;
  }
  return result;
}
function arrayMap(array, iteratee) {
  var index = 0;
  var iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  var result = [];
  var resIndex = -1;
  while (index < length) {
    var value = iterable[index];
    resIndex += 1;
    result[resIndex] = iteratee(value, index, iterable);
    index += 1;
  }
  return result;
}
function arrayEach(array, iteratee) {
  var index = 0;
  var iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  while (index < length) {
    if (iteratee(iterable[index], index, iterable) === false) {
      break;
    }
    index += 1;
  }
  return array;
}
function arraySum(array) {
  return arrayReduce(array, function(a, b) {
    return a + b;
  }, 0);
}
function arrayMax(array) {
  return arrayReduce(array, function(a, b) {
    return a > b ? a : b;
  }, Array.isArray(array) ? array[0] : void 0);
}
function arrayMin(array) {
  return arrayReduce(array, function(a, b) {
    return a < b ? a : b;
  }, Array.isArray(array) ? array[0] : void 0);
}
function arrayAvg(array) {
  if (!array.length) {
    return 0;
  }
  return arraySum(array) / array.length;
}
function arrayFlatten(array) {
  return arrayReduce(array, function(initial, value) {
    return initial.concat(Array.isArray(value) ? arrayFlatten(value) : value);
  }, []);
}
function arrayUnique(array) {
  var unique = [];
  arrayEach(array, function(value) {
    if (unique.indexOf(value) === -1) {
      unique.push(value);
    }
  });
  return unique;
}
function getDifferenceOfArrays() {
  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
    arrays[_key] = arguments[_key];
  }
  var _ref = [].concat(arrays), first = _ref[0], rest = _ref.slice(1);
  var filteredFirstArray = first;
  arrayEach(rest, function(array) {
    filteredFirstArray = filteredFirstArray.filter(function(value) {
      return !array.includes(value);
    });
  });
  return filteredFirstArray;
}
function getIntersectionOfArrays() {
  for (var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    arrays[_key2] = arguments[_key2];
  }
  var _ref2 = [].concat(arrays), first = _ref2[0], rest = _ref2.slice(1);
  var filteredFirstArray = first;
  arrayEach(rest, function(array) {
    filteredFirstArray = filteredFirstArray.filter(function(value) {
      return array.includes(value);
    });
  });
  return filteredFirstArray;
}
function getUnionOfArrays() {
  for (var _len3 = arguments.length, arrays = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    arrays[_key3] = arguments[_key3];
  }
  var _ref3 = [].concat(arrays), first = _ref3[0], rest = _ref3.slice(1);
  var set = new Set(first);
  arrayEach(rest, function(array) {
    arrayEach(array, function(value) {
      if (!set.has(value)) {
        set.add(value);
      }
    });
  });
  return Array.from(set);
}
function stringToArray(value) {
  var delimiter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
  return value.split(delimiter);
}

var arrayHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  to2dArray: to2dArray,
  extendArray: extendArray,
  pivot: pivot,
  arrayReduce: arrayReduce,
  arrayFilter: arrayFilter,
  arrayMap: arrayMap,
  arrayEach: arrayEach,
  arraySum: arraySum,
  arrayMax: arrayMax,
  arrayMin: arrayMin,
  arrayAvg: arrayAvg,
  arrayFlatten: arrayFlatten,
  arrayUnique: arrayUnique,
  getDifferenceOfArrays: getDifferenceOfArrays,
  getIntersectionOfArrays: getIntersectionOfArrays,
  getUnionOfArrays: getUnionOfArrays,
  stringToArray: stringToArray
});

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function duckSchema(object) {
  var schema;
  if (Array.isArray(object)) {
    schema = [];
  } else {
    schema = {};
    objectEach(object, function(value, key) {
      if (key === "__children") {
        return;
      }
      if (value && _typeof$1(value) === "object" && !Array.isArray(value)) {
        schema[key] = duckSchema(value);
      } else if (Array.isArray(value)) {
        if (value.length && _typeof$1(value[0]) === "object" && !Array.isArray(value[0])) {
          schema[key] = [duckSchema(value[0])];
        } else {
          schema[key] = [];
        }
      } else {
        schema[key] = null;
      }
    });
  }
  return schema;
}
function inherit(Child, Parent) {
  Parent.prototype.constructor = Parent;
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;
  return Child;
}
function extend(target, extension, writableKeys) {
  var hasWritableKeys = Array.isArray(writableKeys);
  objectEach(extension, function(value, key) {
    if (hasWritableKeys === false || writableKeys.includes(key)) {
      target[key] = value;
    }
  });
  return target;
}
function deepExtend(target, extension) {
  objectEach(extension, function(value, key) {
    if (extension[key] && _typeof$1(extension[key]) === "object") {
      if (!target[key]) {
        if (Array.isArray(extension[key])) {
          target[key] = [];
        } else if (Object.prototype.toString.call(extension[key]) === "[object Date]") {
          target[key] = extension[key];
        } else {
          target[key] = {};
        }
      }
      deepExtend(target[key], extension[key]);
    } else {
      target[key] = extension[key];
    }
  });
}
function deepClone(obj) {
  if (_typeof$1(obj) === "object") {
    return JSON.parse(JSON.stringify(obj));
  }
  return obj;
}
function clone(object) {
  var result = {};
  objectEach(object, function(value, key) {
    result[key] = value;
  });
  return result;
}
function mixin(Base) {
  if (!Base.MIXINS) {
    Base.MIXINS = [];
  }
  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    mixins[_key - 1] = arguments[_key];
  }
  arrayEach(mixins, function(mixinItem) {
    Base.MIXINS.push(mixinItem.MIXIN_NAME);
    objectEach(mixinItem, function(value, key) {
      if (Base.prototype[key] !== void 0) {
        throw new Error("Mixin conflict. Property '".concat(key, "' already exist and cannot be overwritten."));
      }
      if (typeof value === "function") {
        Base.prototype[key] = value;
      } else {
        var getter = function _getter(property, initialValue) {
          var propertyName = "_".concat(property);
          var initValue = function initValue2(newValue) {
            var result = newValue;
            if (Array.isArray(result) || isObject(result)) {
              result = deepClone(result);
            }
            return result;
          };
          return function() {
            if (this[propertyName] === void 0) {
              this[propertyName] = initValue(initialValue);
            }
            return this[propertyName];
          };
        };
        var setter = function _setter(property) {
          var propertyName = "_".concat(property);
          return function(newValue) {
            this[propertyName] = newValue;
          };
        };
        Object.defineProperty(Base.prototype, key, {
          get: getter(key, value),
          set: setter(key),
          configurable: true
        });
      }
    });
  });
  return Base;
}
function isObjectEqual(object1, object2) {
  return JSON.stringify(object1) === JSON.stringify(object2);
}
function isObject(object) {
  return Object.prototype.toString.call(object) === "[object Object]";
}
function defineGetter(object, property, value, options) {
  options.value = value;
  options.writable = options.writable !== false;
  options.enumerable = options.enumerable !== false;
  options.configurable = options.configurable !== false;
  Object.defineProperty(object, property, options);
}
function objectEach(object, iteratee) {
  for (var key in object) {
    if (!object.hasOwnProperty || object.hasOwnProperty && Object.prototype.hasOwnProperty.call(object, key)) {
      if (iteratee(object[key], key, object) === false) {
        break;
      }
    }
  }
  return object;
}
function getProperty(object, name) {
  var names = name.split(".");
  var result = object;
  objectEach(names, function(nameItem) {
    result = result[nameItem];
    if (result === void 0) {
      result = void 0;
      return false;
    }
  });
  return result;
}
function setProperty(object, name, value) {
  var names = name.split(".");
  var workingObject = object;
  names.forEach(function(propName, index) {
    if (index !== names.length - 1) {
      if (!hasOwnProperty(workingObject, propName)) {
        workingObject[propName] = {};
      }
      workingObject = workingObject[propName];
    } else {
      workingObject[propName] = value;
    }
  });
}
function deepObjectSize(object) {
  if (!isObject(object)) {
    return 0;
  }
  var recursObjLen = function recursObjLen2(obj) {
    var result = 0;
    if (isObject(obj)) {
      objectEach(obj, function(value, key) {
        if (key === "__children") {
          return;
        }
        result += recursObjLen2(value);
      });
    } else {
      result += 1;
    }
    return result;
  };
  return recursObjLen(object);
}
function createObjectPropListener(defaultValue) {
  var _holder;
  var propertyToListen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "value";
  var privateProperty = "_".concat(propertyToListen);
  var holder = (_holder = {
    _touched: false
  }, _defineProperty(_holder, privateProperty, defaultValue), _defineProperty(_holder, "isTouched", function isTouched() {
    return this._touched;
  }), _holder);
  Object.defineProperty(holder, propertyToListen, {
    get: function get() {
      return this[privateProperty];
    },
    set: function set(value) {
      this._touched = true;
      this[privateProperty] = value;
    },
    enumerable: true,
    configurable: true
  });
  return holder;
}
function hasOwnProperty(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}

var objectHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  duckSchema: duckSchema,
  inherit: inherit,
  extend: extend,
  deepExtend: deepExtend,
  deepClone: deepClone,
  clone: clone,
  mixin: mixin,
  isObjectEqual: isObjectEqual,
  isObject: isObject,
  defineGetter: defineGetter,
  objectEach: objectEach,
  getProperty: getProperty,
  setProperty: setProperty,
  deepObjectSize: deepObjectSize,
  createObjectPropListener: createObjectPropListener,
  hasOwnProperty: hasOwnProperty
});

var tester = function tester2(testerFunc) {
  var result = {
    value: false
  };
  result.test = function(ua, vendor) {
    result.value = testerFunc(ua, vendor);
  };
  return result;
};
var browsers = {
  chrome: tester(function(ua, vendor) {
    return /Chrome/.test(ua) && /Google/.test(vendor);
  }),
  chromeWebKit: tester(function(ua) {
    return /CriOS/.test(ua);
  }),
  edge: tester(function(ua) {
    return /Edge/.test(ua);
  }),
  edgeWebKit: tester(function(ua) {
    return /EdgiOS/.test(ua);
  }),
  firefox: tester(function(ua) {
    return /Firefox/.test(ua);
  }),
  firefoxWebKit: tester(function(ua) {
    return /FxiOS/.test(ua);
  }),
  ie: tester(function(ua) {
    return /Trident/.test(ua);
  }),
  ie9: tester(function() {
    return !!document.documentMode;
  }),
  mobile: tester(function(ua) {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
  }),
  safari: tester(function(ua, vendor) {
    return /Safari/.test(ua) && /Apple Computer/.test(vendor);
  })
};
var platforms = {
  mac: tester(function(platform) {
    return /^Mac/.test(platform);
  }),
  win: tester(function(platform) {
    return /^Win/.test(platform);
  }),
  linux: tester(function(platform) {
    return /^Linux/.test(platform);
  }),
  ios: tester(function(ua) {
    return /iPhone|iPad|iPod/i.test(ua);
  })
};
function setBrowserMeta() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$userAgent = _ref.userAgent, userAgent = _ref$userAgent === void 0 ? navigator.userAgent : _ref$userAgent, _ref$vendor = _ref.vendor, vendor = _ref$vendor === void 0 ? navigator.vendor : _ref$vendor;
  objectEach(browsers, function(_ref2) {
    var test = _ref2.test;
    return void test(userAgent, vendor);
  });
}
function setPlatformMeta() {
  var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$platform = _ref3.platform, platform = _ref3$platform === void 0 ? navigator.platform : _ref3$platform;
  objectEach(platforms, function(_ref4) {
    var test = _ref4.test;
    return void test(platform);
  });
}
setBrowserMeta();
setPlatformMeta();
function isChrome() {
  return browsers.chrome.value;
}
function isChromeWebKit() {
  return browsers.chromeWebKit.value;
}
function isFirefox() {
  return browsers.firefox.value;
}
function isFirefoxWebKit() {
  return browsers.firefoxWebKit.value;
}
function isSafari() {
  return browsers.safari.value;
}
function isEdge() {
  return browsers.edge.value;
}
function isEdgeWebKit() {
  return browsers.edgeWebKit.value;
}
function isIE() {
  return browsers.ie.value;
}
function isIE9() {
  return browsers.ie9.value;
}
function isMSBrowser() {
  return browsers.ie.value || browsers.edge.value;
}
function isMobileBrowser() {
  return browsers.mobile.value;
}
function isIOS() {
  return platforms.ios.value;
}
function isIpadOS() {
  var _ref5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : navigator, maxTouchPoints = _ref5.maxTouchPoints;
  return maxTouchPoints > 2 && platforms.mac.value;
}
function isWindowsOS() {
  return platforms.win.value;
}
function isMacOS() {
  return platforms.mac.value;
}
function isLinuxOS() {
  return platforms.linux.value;
}

var browserHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setBrowserMeta: setBrowserMeta,
  setPlatformMeta: setPlatformMeta,
  isChrome: isChrome,
  isChromeWebKit: isChromeWebKit,
  isFirefox: isFirefox,
  isFirefoxWebKit: isFirefoxWebKit,
  isSafari: isSafari,
  isEdge: isEdge,
  isEdgeWebKit: isEdgeWebKit,
  isIE: isIE,
  isIE9: isIE9,
  isMSBrowser: isMSBrowser,
  isMobileBrowser: isMobileBrowser,
  isIOS: isIOS,
  isIpadOS: isIpadOS,
  isWindowsOS: isWindowsOS,
  isMacOS: isMacOS,
  isLinuxOS: isLinuxOS
});

/*! @license DOMPurify 2.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.0/LICENSE */

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var hasOwnProperty$1 = Object.hasOwnProperty,
    setPrototypeOf = Object.setPrototypeOf,
    isFrozen = Object.isFrozen,
    getPrototypeOf = Object.getPrototypeOf,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze,
    seal = Object.seal,
    create = Object.create; // eslint-disable-line import/no-mutable-exports

var _ref = typeof Reflect !== 'undefined' && Reflect,
    apply = _ref.apply,
    construct = _ref.construct;

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}

if (!seal) {
  seal = function seal(x) {
    return x;
  };
}

if (!construct) {
  construct = function construct(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
  };
}

var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);

var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);

var regExpTest = unapply(RegExp.prototype.test);

var typeErrorCreate = unconstruct(TypeError);

function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return apply(func, thisArg, args);
  };
}

function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return construct(func, args);
  };
}

/* Add properties to a lookup table */
function addToSet(set, array) {
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === 'string') {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}

/* Shallow clone an object */
function clone$1(object) {
  var newObject = create(null);

  var property = void 0;
  for (property in object) {
    if (apply(hasOwnProperty$1, object, [property])) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}

/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }

      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }

    object = getPrototypeOf(object);
  }

  function fallbackValue(element) {
    console.warn('fallback value for', element);
    return null;
  }

  return fallbackValue;
}

var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

// SVG
var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

var text = freeze(['#text']);

var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);

var _typeof$2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};

/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof$2(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }

  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix';
  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };

  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
  DOMPurify.version = '2.3.0';

  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;

    return DOMPurify;
  }

  var originalDocument = window.document;

  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      Text = window.Text,
      Comment = window.Comment,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes;


  var ElementPrototype = Element.prototype;

  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    var template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      createDocumentFragment = _document.createDocumentFragment,
      getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;


  var documentMode = {};
  try {
    documentMode = clone$1(document).documentMode ? document.documentMode : {};
  } catch (_) {}

  var hooks = {};

  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
      ERB_EXPR$$1 = ERB_EXPR,
      DATA_ATTR$$1 = DATA_ATTR,
      ARIA_ATTR$$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

  /* Allowed attribute names */
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  var FORBID_TAGS = null;

  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  var FORBID_ATTR = null;

  /* Decide if ARIA attributes are okay */
  var ALLOW_ARIA_ATTR = true;

  /* Decide if custom data attributes are okay */
  var ALLOW_DATA_ATTR = true;

  /* Decide if unknown protocols are okay */
  var ALLOW_UNKNOWN_PROTOCOLS = false;

  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  var SAFE_FOR_TEMPLATES = false;

  /* Decide if document with <html>... should be returned */
  var WHOLE_DOCUMENT = false;

  /* Track whether config is already set on this instance of DOMPurify. */
  var SET_CONFIG = false;

  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  var FORCE_BODY = false;

  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  var RETURN_DOM = false;

  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  var RETURN_DOM_FRAGMENT = false;

  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
   * `Node` is imported into the current `Document`. If this flag is not enabled the
   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
   * DOMPurify.
   *
   * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
   * might cause XSS from attacks hidden in closed shadowroots in case the browser
   * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
   */
  var RETURN_DOM_IMPORT = true;

  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  var RETURN_TRUSTED_TYPE = false;

  /* Output should be free from DOM clobbering attacks? */
  var SANITIZE_DOM = true;

  /* Keep element content when removing element? */
  var KEEP_CONTENT = true;

  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  var IN_PLACE = false;

  /* Allow usage of profiles like html, svg and mathMl */
  var USE_PROFILES = {};

  /* Tags to ignore content of when KEEP_CONTENT is true */
  var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

  /* Tags that are safe for data: URIs */
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

  /* Attributes safe for values like "javascript:" */
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);

  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;

  /* Keep a reference to config to pass to hooks */
  var CONFIG = null;

  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */

  var formElement = document.createElement('form');

  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity
  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }

    /* Shield configuration object from tampering */
    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof$2(cfg)) !== 'object') {
      cfg = {};
    }

    /* Shield configuration object from prototype pollution */
    cfg = clone$1(cfg);

    /* Set configuration parameters */
    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone$1(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone$1(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }

    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }

    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone$1(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone$1(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }

    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }

    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }

    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }

    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }

    CONFIG = cfg;
  };

  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);

  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

  /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  var _checkValidNamespace = function _checkValidNamespace(element) {
    var parent = getParentNode(element);

    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: 'template'
      };
    }

    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);

    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }

      // The only way to switch from MathML to SVG is via
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }

      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }

    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }

      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }

      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }

    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      // Certain elements are allowed in both SVG and HTML
      // namespace. We need to specify them explicitly
      // so that they don't get erronously deleted from
      // HTML namespace.
      var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }

    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG or MathML). Return false just in case.
    return false;
  };

  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
  var _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_) {
        node.remove();
      }
    }
  };

  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */
  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name);

    // We void attribute values for unremovable "is"" attributes
    if (name === 'is' && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };

  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */
  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc = void 0;
    var leadingWhitespace = void 0;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }

    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
      } catch (_) {}
    }

    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }

    var body = doc.body || doc.documentElement;

    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }

    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }

    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };

  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */
  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };

  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */
  var _isClobbered = function _isClobbered(elm) {
    if (elm instanceof Text || elm instanceof Comment) {
      return false;
    }

    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {
      return true;
    }

    return false;
  };

  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */
  var _isNode = function _isNode(object) {
    return (typeof Node === 'undefined' ? 'undefined' : _typeof$2(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof$2(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
  };

  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */
  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    arrayForEach(hooks[entryPoint], function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };

  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */
  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content = void 0;

    /* Execute a hook if present */
    _executeHook('beforeSanitizeElements', currentNode, null);

    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Check if tagname contains Unicode */
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Now let's check the element's type and name */
    var tagName = stringToLowerCase(currentNode.nodeName);

    /* Execute a hook if present */
    _executeHook('uponSanitizeElement', currentNode, {
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });

    /* Detect mXSS attempts abusing namespace confusion */
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

        if (childNodes && parentNode) {
          var childCount = childNodes.length;

          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }

      _forceRemove(currentNode);
      return true;
    }

    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
      content = stringReplace(content, ERB_EXPR$$1, ' ');
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeElements', currentNode, null);

    return false;
  };

  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }

    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      return false;

      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
      return false;
    }

    return true;
  };

  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */
  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    /* Execute a hook if present */
    _executeHook('beforeSanitizeAttributes', currentNode, null);

    var attributes = currentNode.attributes;

    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return;
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;

    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;

      value = stringTrim(attr.value);
      lcName = stringToLowerCase(name);

      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }

      /* Remove attribute */
      _removeAttribute(name, currentNode);

      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }

      /* Work around a security issue in jQuery 3.0 */
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
        value = stringReplace(value, ERB_EXPR$$1, ' ');
      }

      /* Is `value` valid for this attribute? */
      var lcTag = currentNode.nodeName.toLowerCase();
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }

      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }

        arrayPop(DOMPurify.removed);
      } catch (_) {}
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeAttributes', currentNode, null);
  };

  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */
  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);

    /* Execute a hook if present */
    _executeHook('beforeSanitizeShadowDOM', fragment, null);

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null);

      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }

      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(shadowNode);
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };

  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }

    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // eslint-disable-next-line no-negated-condition
      if (typeof dirty.toString !== 'function') {
        throw typeErrorCreate('toString is not a function');
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      }
    }

    /* Check we can run. Otherwise fall back or ignore */
    if (!DOMPurify.isSupported) {
      if (_typeof$2(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
        if (typeof dirty === 'string') {
          return window.toStaticHTML(dirty);
        }

        if (_isNode(dirty)) {
          return window.toStaticHTML(dirty.outerHTML);
        }
      }

      return dirty;
    }

    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }

    /* Clean up removed elements */
    DOMPurify.removed = [];

    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }

    if (IN_PLACE) ; else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }

      /* Initialize the document to work on */
      body = _initDocument(dirty);

      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : emptyHTML;
      }
    }

    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }

    /* Get node iterator */
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }

      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }

      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(currentNode);

      oldNode = currentNode;
    }

    oldNode = null;

    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }

    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (RETURN_DOM_IMPORT) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
    }

    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };

  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };

  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };

  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = stringToLowerCase(tag);
    var lcName = stringToLowerCase(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };

  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };

  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   */
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };

  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };

  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var purify = createDOMPurify();

var onFreeze = internalMetadata.onFreeze;

// eslint-disable-next-line es/no-object-freeze -- safe
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { $freeze(1); });

// `Object.freeze` method
// https://tc39.es/ecma262/#sec-object.freeze
_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !freezing }, {
  freeze: function freeze(it) {
    return $freeze && isObject$2(it) ? $freeze(onFreeze(it)) : it;
  }
});

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject$1(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend$1(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend$1(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend$1(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set$1 (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend$1({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject$1(parentConfig[prop]) && isObject$1(childConfig[prop])) {
                res[prop] = {};
                extend$1(res[prop], parentConfig[prop]);
                extend$1(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject$1(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend$1({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$2(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$2 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date;
    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);
        if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
    } else {
        date = new Date(y, m, d, h, M, s, ms);
    }

    return date;
}

function createUTCDate (y) {
    var date;
    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments);
        // preserve leap years using a full 400 year cycle, then reset
        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
    } else {
        date = new Date(Date.UTC.apply(null, arguments));
    }

    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 6th is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES
function shiftWeekdays (ws, n) {
    return ws.slice(n, 7).concat(ws.slice(0, n));
}

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    var weekdays = isArray(this._weekdays) ? this._weekdays :
        this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
    return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
        : (m) ? weekdays[m.day()] : weekdays;
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
        : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
        : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour they want. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return globalLocale;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
        else {
            if ((typeof console !==  'undefined') && console.warn) {
                //warn user if arguments are passed but the locale could not be set
                console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
            }
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var locale, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                locale = loadLocale(config.parentLocale);
                if (locale != null) {
                    parentConfig = locale._config;
                } else {
                    if (!localeFamilies[config.parentLocale]) {
                        localeFamilies[config.parentLocale] = [];
                    }
                    localeFamilies[config.parentLocale].push({
                        name: name,
                        config: config
                    });
                    return null;
                }
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, tmpLocale, parentConfig = baseConfig;
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from beginning of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to beginning of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend$1(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject$1(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject$1(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$2(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone$2 () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units) || 'millisecond';
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units) || 'millisecond';
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    var localFrom = isMoment(from) ? from : createLocal(from),
        localTo = isMoment(to) ? to : createLocal(to);
    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
    }
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units) || 'millisecond';
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString(keepOffset) {
    if (!this.isValid()) {
        return null;
    }
    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
            return this.toDate().toISOString();
        } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
    }
    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

var MS_PER_SECOND = 1000;
var MS_PER_MINUTE = 60 * MS_PER_SECOND;
var MS_PER_HOUR = 60 * MS_PER_MINUTE;
var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

// actual modulo - handles negative numbers (for dates before 1970):
function mod$1(dividend, divisor) {
    return (dividend % divisor + divisor) % divisor;
}

function localStartOfDate(y, m, d) {
    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
        return new Date(y, m, d).valueOf();
    }
}

function utcStartOfDate(y, m, d) {
    // Date.UTC remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
        return Date.UTC(y, m, d);
    }
}

function startOf (units) {
    var time;
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
    }

    var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

    switch (units) {
        case 'year':
            time = startOfDate(this.year(), 0, 1);
            break;
        case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
        case 'month':
            time = startOfDate(this.year(), this.month(), 1);
            break;
        case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
        case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
        case 'day':
        case 'date':
            time = startOfDate(this.year(), this.month(), this.date());
            break;
        case 'hour':
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
        case 'minute':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
        case 'second':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
    }

    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
}

function endOf (units) {
    var time;
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
    }

    var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

    switch (units) {
        case 'year':
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
        case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
        case 'month':
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
        case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
        case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
        case 'day':
        case 'date':
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
        case 'hour':
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
        case 'minute':
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
        case 'second':
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
    }

    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend$1({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIORITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone$2;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set$1;

proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports

hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        switch (units) {
            case 'month':   return months;
            case 'quarter': return months / 3;
            case 'year':    return months / 12;
        }
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asQuarters     = makeAs('Q');
var asYears        = makeAs('y');

function clone$3 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asQuarters     = asQuarters;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$3;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

//! moment.js

hooks.version = '2.24.0';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

// currently HTML5 input type only supports 24-hour formats
hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',                             // <input type="date" />
    TIME: 'HH:mm',                                  // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
    WEEK: 'GGGG-[W]WW',                             // <input type="week" />
    MONTH: 'YYYY-MM'                                // <input type="month" />
};

function toSingleLine(strings) {
  for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    expressions[_key - 1] = arguments[_key];
  }
  var result = arrayReduce(strings, function(previousValue, currentValue, index) {
    var valueWithoutWhiteSpaces = currentValue.replace(/\r?\n\s*/g, "");
    var expressionForIndex = expressions[index] ? expressions[index] : "";
    return previousValue + valueWithoutWhiteSpaces + expressionForIndex;
  }, "");
  return result.trim();
}

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function stringify(value) {
  var result;
  switch (_typeof$3(value)) {
    case "string":
    case "number":
      result = "".concat(value);
      break;
    case "object":
      result = value === null ? "" : value.toString();
      break;
    case "undefined":
      result = "";
      break;
    default:
      result = value.toString();
      break;
  }
  return result;
}
function isDefined(variable) {
  return typeof variable !== "undefined";
}
function isUndefined$1(variable) {
  return typeof variable === "undefined";
}
function isEmpty(variable) {
  return variable === null || variable === "" || isUndefined$1(variable);
}
function isRegExp(variable) {
  return Object.prototype.toString.call(variable) === "[object RegExp]";
}
var _m = "length";
var _hd = function _hd2(v) {
  return parseInt(v, 16);
};
var _pi = function _pi2(v) {
  return parseInt(v, 10);
};
var _ss = function _ss2(v, s, l) {
  return v["substr"](s, l);
};
var _cp = function _cp2(v) {
  return v["codePointAt"](0) - 65;
};
var _norm = function _norm2(v) {
  return "".concat(v).replace(/\-/g, "");
};
var _extractTime = function _extractTime2(v) {
  return _hd(_ss(_norm(v), _hd("12"), _cp("F"))) / (_hd(_ss(_norm(v), _cp("B"), ~~![][_m])) || 9);
};
var _ignored = function _ignored2() {
  return typeof location !== "undefined" && /^([a-z0-9\-]+\.)?\x68\x61\x6E\x64\x73\x6F\x6E\x74\x61\x62\x6C\x65\x2E\x63\x6F\x6D$/i.test(location.host);
};
var _notified = false;
var consoleMessages = {
  invalid: function invalid() {
    return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    The license key for Handsontable is invalid. \n    If you need any help, contact us at support@handsontable.com."], ["\n    The license key for Handsontable is invalid.\\x20\n    If you need any help, contact us at support@handsontable.com."])));
  },
  expired: function expired(_ref) {
    var keyValidityDate = _ref.keyValidityDate, hotVersion = _ref.hotVersion;
    return toSingleLine(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n    The license key for Handsontable expired on ", ", and is not valid for the installed \n    version ", ". Renew your license key at handsontable.com or downgrade to a version released prior \n    to ", ". If you need any help, contact us at sales@handsontable.com."], ["\n    The license key for Handsontable expired on ", ", and is not valid for the installed\\x20\n    version ", ". Renew your license key at handsontable.com or downgrade to a version released prior\\x20\n    to ", ". If you need any help, contact us at sales@handsontable.com."])), keyValidityDate, hotVersion, keyValidityDate);
  },
  missing: function missing() {
    return toSingleLine(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n    The license key for Handsontable is missing. Use your purchased key to activate the product. \n    Alternatively, you can activate Handsontable to use for non-commercial purposes by \n    passing the key: 'non-commercial-and-evaluation'. If you need any help, contact \n    us at support@handsontable.com."], ["\n    The license key for Handsontable is missing. Use your purchased key to activate the product.\\x20\n    Alternatively, you can activate Handsontable to use for non-commercial purposes by\\x20\n    passing the key: 'non-commercial-and-evaluation'. If you need any help, contact\\x20\n    us at support@handsontable.com."])));
  },
  non_commercial: function non_commercial() {
    return "";
  }
};
var domMessages = {
  invalid: function invalid2() {
    return toSingleLine(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(['\n    The license key for Handsontable is invalid. \n    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> on how to \n    install it properly or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.'], ['\n    The license key for Handsontable is invalid.\\x20\n    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> on how to\\x20\n    install it properly or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.'])));
  },
  expired: function expired2(_ref2) {
    var keyValidityDate = _ref2.keyValidityDate, hotVersion = _ref2.hotVersion;
    return toSingleLine(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n    The license key for Handsontable expired on ", ", and is not valid for the installed \n    version ", '. <a href="https://handsontable.com/pricing" target="_blank">Renew</a> your \n    license key or downgrade to a version released prior to ', '. If you need any \n    help, contact us at <a href="mailto:sales@handsontable.com">sales@handsontable.com</a>.'], ["\n    The license key for Handsontable expired on ", ", and is not valid for the installed\\x20\n    version ", '. <a href="https://handsontable.com/pricing" target="_blank">Renew</a> your\\x20\n    license key or downgrade to a version released prior to ', '. If you need any\\x20\n    help, contact us at <a href="mailto:sales@handsontable.com">sales@handsontable.com</a>.'])), keyValidityDate, hotVersion, keyValidityDate);
  },
  missing: function missing2() {
    return toSingleLine(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([`
    The license key for Handsontable is missing. Use your purchased key to activate the product. 
    Alternatively, you can activate Handsontable to use for non-commercial purposes by 
    passing the key: 'non-commercial-and-evaluation'. 
    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> about it in 
    the documentation or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.`], [`
    The license key for Handsontable is missing. Use your purchased key to activate the product.\\x20
    Alternatively, you can activate Handsontable to use for non-commercial purposes by\\x20
    passing the key: 'non-commercial-and-evaluation'.\\x20
    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> about it in\\x20
    the documentation or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.`])));
  },
  non_commercial: function non_commercial2() {
    return "";
  }
};
function _injectProductInfo(key, element) {
  var hasValidType = !isEmpty(key);
  var isNonCommercial = typeof key === "string" && key.toLowerCase() === "non-commercial-and-evaluation";
  var hotVersion = "9.0.1";
  var keyValidityDate;
  var consoleMessageState = "invalid";
  var domMessageState = "invalid";
  key = _norm(key || "");
  var schemaValidity = _checkKeySchema(key);
  if (hasValidType || isNonCommercial || schemaValidity) {
    if (schemaValidity) {
      var releaseDate = hooks("17/06/2021", "DD/MM/YYYY");
      var releaseDays = Math.floor(releaseDate.toDate().getTime() / 864e5);
      var keyValidityDays = _extractTime(key);
      keyValidityDate = hooks((keyValidityDays + 1) * 864e5, "x").format("MMMM DD, YYYY");
      if (releaseDays > keyValidityDays) {
        var daysAfterRelease = hooks().diff(releaseDate, "days");
        consoleMessageState = daysAfterRelease <= 1 ? "valid" : "expired";
        domMessageState = daysAfterRelease <= 15 ? "valid" : "expired";
      } else {
        consoleMessageState = "valid";
        domMessageState = "valid";
      }
    } else if (isNonCommercial) {
      consoleMessageState = "non_commercial";
      domMessageState = "valid";
    } else {
      consoleMessageState = "invalid";
      domMessageState = "invalid";
    }
  } else {
    consoleMessageState = "missing";
    domMessageState = "missing";
  }
  if (_ignored()) {
    consoleMessageState = "valid";
    domMessageState = "valid";
  }
  if (!_notified && consoleMessageState !== "valid") {
    var message = consoleMessages[consoleMessageState]({
      keyValidityDate,
      hotVersion
    });
    if (message) {
      console[consoleMessageState === "non_commercial" ? "info" : "warn"](consoleMessages[consoleMessageState]({
        keyValidityDate,
        hotVersion
      }));
    }
    _notified = true;
  }
  if (domMessageState !== "valid" && element.parentNode) {
    var _message = domMessages[domMessageState]({
      keyValidityDate,
      hotVersion
    });
    if (_message) {
      var messageNode = document.createElement("div");
      messageNode.id = "hot-display-license-info";
      messageNode.innerHTML = domMessages[domMessageState]({
        keyValidityDate,
        hotVersion
      });
      element.parentNode.insertBefore(messageNode, element.nextSibling);
    }
  }
}
function _checkKeySchema(v) {
  var z = [][_m];
  var p = z;
  if (v[_m] !== _cp("Z")) {
    return false;
  }
  for (var c = "", i = "B<H4P+".split(""), j = _cp(i.shift()); j; j = _cp(i.shift() || "A")) {
    --j < ""[_m] ? p = p | (_pi("".concat(_pi(_hd(c) + (_hd(_ss(v, Math.abs(j), 2)) + []).padStart(2, "0")))) % 97 || 2) >> 1 : c = _ss(v, j, !j ? 6 : i[_m] === 1 ? 9 : 8);
  }
  return p === z;
}

var mixedHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  stringify: stringify,
  isDefined: isDefined,
  isUndefined: isUndefined$1,
  isEmpty: isEmpty,
  isRegExp: isRegExp,
  _injectProductInfo: _injectProductInfo
});

function toUpperCaseFirst(string) {
  return string[0].toUpperCase() + string.substr(1);
}
function equalsIgnoreCase() {
  var unique = [];
  for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
    strings[_key] = arguments[_key];
  }
  var length = strings.length;
  while (length) {
    length -= 1;
    var string = stringify(strings[length]).toLowerCase();
    if (unique.indexOf(string) === -1) {
      unique.push(string);
    }
  }
  return unique.length === 1;
}
function randomString() {
  function s4() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return s4() + s4() + s4() + s4();
}
function isPercentValue(value) {
  return /^([0-9][0-9]?%$)|(^100%$)/.test(value);
}
function substitute(template) {
  var variables = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return "".concat(template).replace(/(?:\\)?\[([^[\]]+)]/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.substr(1, match.length - 1);
    }
    return variables[name] === void 0 ? "" : variables[name];
  });
}
function stripTags(string) {
  return sanitize("".concat(string), {
    ALLOWED_TAGS: []
  });
}
function sanitize(string, options) {
  return purify.sanitize(string, options);
}

var stringHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  toUpperCaseFirst: toUpperCaseFirst,
  equalsIgnoreCase: equalsIgnoreCase,
  randomString: randomString,
  isPercentValue: isPercentValue,
  substitute: substitute,
  stripTags: stripTags,
  sanitize: sanitize
});

function _toConsumableArray$2(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function getParent(element) {
  var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var iteration = -1;
  var parent = null;
  var elementToCheck = element;
  while (elementToCheck !== null) {
    if (iteration === level) {
      parent = elementToCheck;
      break;
    }
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      iteration += 1;
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return parent;
}
function getFrameElement(frame) {
  return Object.getPrototypeOf(frame.parent) && frame.frameElement;
}
function getParentWindow(frame) {
  return getFrameElement(frame) && frame.parent;
}
function hasAccessToParentWindow(frame) {
  return !!Object.getPrototypeOf(frame.parent);
}
function closest(element) {
  var nodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var until = arguments.length > 2 ? arguments[2] : void 0;
  var _Node = Node, ELEMENT_NODE = _Node.ELEMENT_NODE, DOCUMENT_FRAGMENT_NODE = _Node.DOCUMENT_FRAGMENT_NODE;
  var elementToCheck = element;
  while (elementToCheck !== null && elementToCheck !== void 0 && elementToCheck !== until) {
    var _elementToCheck = elementToCheck, nodeType = _elementToCheck.nodeType, nodeName = _elementToCheck.nodeName;
    if (nodeType === ELEMENT_NODE && (nodes.includes(nodeName) || nodes.includes(elementToCheck))) {
      return elementToCheck;
    }
    var _elementToCheck2 = elementToCheck, host = _elementToCheck2.host;
    if (host && nodeType === DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return null;
}
function closestDown(element, nodes, until) {
  var matched = [];
  var elementToCheck = element;
  while (elementToCheck) {
    elementToCheck = closest(elementToCheck, nodes, until);
    if (!elementToCheck || until && !until.contains(elementToCheck)) {
      break;
    }
    matched.push(elementToCheck);
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  var length = matched.length;
  return length ? matched[length - 1] : null;
}
function isChildOf(child, parent) {
  var node = child.parentNode;
  var queriedParents = [];
  if (typeof parent === "string") {
    if (child.defaultView) {
      queriedParents = Array.prototype.slice.call(child.querySelectorAll(parent), 0);
    } else {
      queriedParents = Array.prototype.slice.call(child.ownerDocument.querySelectorAll(parent), 0);
    }
  } else {
    queriedParents.push(parent);
  }
  while (node !== null) {
    if (queriedParents.indexOf(node) > -1) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
function index(element) {
  var i = 0;
  var elementToCheck = element;
  if (elementToCheck.previousSibling) {
    while (elementToCheck = elementToCheck.previousSibling) {
      i += 1;
    }
  }
  return i;
}
function overlayContainsElement(overlayType, element, root) {
  var overlayElement = root.parentElement.querySelector(".ht_clone_".concat(overlayType));
  return overlayElement ? overlayElement.contains(element) : null;
}
var _hasClass;
var _addClass;
var _removeClass;
function filterEmptyClassNames(classNames) {
  if (!classNames || !classNames.length) {
    return [];
  }
  return classNames.filter(function(x) {
    return !!x;
  });
}
if (isClassListSupported()) {
  var isSupportMultipleClassesArg = function isSupportMultipleClassesArg2(rootDocument) {
    var element = rootDocument.createElement("div");
    element.classList.add("test", "test2");
    return element.classList.contains("test2");
  };
  _hasClass = function _hasClass2(element, className) {
    if (element.classList === void 0 || typeof className !== "string" || className === "") {
      return false;
    }
    return element.classList.contains(className);
  };
  _addClass = function _addClass2(element, classes) {
    var rootDocument = element.ownerDocument;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    if (className.length > 0) {
      if (isSupportMultipleClassesArg(rootDocument)) {
        var _element$classList;
        (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray$2(className));
      } else {
        var len = 0;
        while (className && className[len]) {
          element.classList.add(className[len]);
          len += 1;
        }
      }
    }
  };
  _removeClass = function _removeClass2(element, classes) {
    var rootDocument = element.ownerDocument;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    if (className.length > 0) {
      if (isSupportMultipleClassesArg(rootDocument)) {
        var _element$classList2;
        (_element$classList2 = element.classList).remove.apply(_element$classList2, _toConsumableArray$2(className));
      } else {
        var len = 0;
        while (className && className[len]) {
          element.classList.remove(className[len]);
          len += 1;
        }
      }
    }
  };
} else {
  var createClassNameRegExp = function createClassNameRegExp2(className) {
    return new RegExp("(\\s|^)".concat(className, "(\\s|$)"));
  };
  _hasClass = function _hasClass2(element, className) {
    return element.className !== void 0 && createClassNameRegExp(className).test(element.className);
  };
  _addClass = function _addClass2(element, classes) {
    var _className = element.className;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    if (_className === "") {
      _className = className.join(" ");
    } else {
      for (var len = 0; len < className.length; len++) {
        if (className[len] && !createClassNameRegExp(className[len]).test(_className)) {
          _className += " ".concat(className[len]);
        }
      }
    }
    element.className = _className;
  };
  _removeClass = function _removeClass2(element, classes) {
    var len = 0;
    var _className = element.className;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    while (className && className[len]) {
      _className = _className.replace(createClassNameRegExp(className[len]), " ").trim();
      len += 1;
    }
    if (element.className !== _className) {
      element.className = _className;
    }
  };
}
function hasClass(element, className) {
  return _hasClass(element, className);
}
function addClass(element, className) {
  _addClass(element, className);
}
function removeClass(element, className) {
  _removeClass(element, className);
}
function removeTextNodes(element) {
  if (element.nodeType === 3) {
    element.parentNode.removeChild(element);
  } else if (["TABLE", "THEAD", "TBODY", "TFOOT", "TR"].indexOf(element.nodeName) > -1) {
    var childs = element.childNodes;
    for (var i = childs.length - 1; i >= 0; i--) {
      removeTextNodes(childs[i]);
    }
  }
}
function empty(element) {
  var child;
  while (child = element.lastChild) {
    element.removeChild(child);
  }
}
var HTML_CHARACTERS = /(<(.*)>|&(.*);)/;
function fastInnerHTML(element, content) {
  var sanitizeContent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (HTML_CHARACTERS.test(content)) {
    element.innerHTML = sanitizeContent ? sanitize(content) : content;
  } else {
    fastInnerText(element, content);
  }
}
function fastInnerText(element, content) {
  var child = element.firstChild;
  if (child && child.nodeType === 3 && child.nextSibling === null) {
    if (isTextContentSupported) {
      child.textContent = content;
    } else {
      child.data = content;
    }
  } else {
    empty(element);
    element.appendChild(element.ownerDocument.createTextNode(content));
  }
}
function isVisible(element) {
  var documentElement = element.ownerDocument.documentElement;
  var next = element;
  while (next !== documentElement) {
    if (next === null) {
      return false;
    } else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      if (next.host) {
        if (next.host.impl) {
          return isVisible(next.host.impl);
        } else if (next.host) {
          return isVisible(next.host);
        }
        throw new Error("Lost in Web Components world");
      } else {
        return false;
      }
    } else if (next.style && next.style.display === "none") {
      return false;
    }
    next = next.parentNode;
  }
  return true;
}
function offset$1(element) {
  var rootDocument = element.ownerDocument;
  var rootWindow = rootDocument.defaultView;
  var documentElement = rootDocument.documentElement;
  var elementToCheck = element;
  var offsetLeft;
  var offsetTop;
  var lastElem;
  var box;
  if (hasCaptionProblem() && elementToCheck.firstChild && elementToCheck.firstChild.nodeName === "CAPTION") {
    box = elementToCheck.getBoundingClientRect();
    return {
      top: box.top + (rootWindow.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
      left: box.left + (rootWindow.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)
    };
  }
  offsetLeft = elementToCheck.offsetLeft;
  offsetTop = elementToCheck.offsetTop;
  lastElem = elementToCheck;
  while (elementToCheck = elementToCheck.offsetParent) {
    if (elementToCheck === rootDocument.body) {
      break;
    }
    offsetLeft += elementToCheck.offsetLeft;
    offsetTop += elementToCheck.offsetTop;
    lastElem = elementToCheck;
  }
  if (lastElem && lastElem.style.position === "fixed") {
    offsetLeft += rootWindow.pageXOffset || documentElement.scrollLeft;
    offsetTop += rootWindow.pageYOffset || documentElement.scrollTop;
  }
  return {
    left: offsetLeft,
    top: offsetTop
  };
}
function getWindowScrollTop() {
  var rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  var res = rootWindow.scrollY;
  if (res === void 0) {
    res = rootWindow.document.documentElement.scrollTop;
  }
  return res;
}
function getWindowScrollLeft() {
  var rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  var res = rootWindow.scrollX;
  if (res === void 0) {
    res = rootWindow.document.documentElement.scrollLeft;
  }
  return res;
}
function getScrollTop(element) {
  var rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
  if (element === rootWindow) {
    return getWindowScrollTop(rootWindow);
  }
  return element.scrollTop;
}
function getScrollLeft(element) {
  var rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
  if (element === rootWindow) {
    return getWindowScrollLeft(rootWindow);
  }
  return element.scrollLeft;
}
function getScrollableElement(element) {
  var rootDocument = element.ownerDocument;
  var rootWindow = rootDocument ? rootDocument.defaultView : void 0;
  if (!rootDocument) {
    rootDocument = element.document ? element.document : element;
    rootWindow = rootDocument.defaultView;
  }
  var props = ["auto", "scroll"];
  var supportedGetComputedStyle = isGetComputedStyleSupported();
  var el = element.parentNode;
  while (el && el.style && rootDocument.body !== el) {
    var _el$style = el.style, overflow = _el$style.overflow, overflowX = _el$style.overflowX, overflowY = _el$style.overflowY;
    if ([overflow, overflowX, overflowY].includes("scroll")) {
      return el;
    } else if (supportedGetComputedStyle) {
      var _rootWindow$getComput = rootWindow.getComputedStyle(el);
      overflow = _rootWindow$getComput.overflow;
      overflowX = _rootWindow$getComput.overflowX;
      overflowY = _rootWindow$getComput.overflowY;
      if (props.includes(overflow) || props.includes(overflowX) || props.includes(overflowY)) {
        return el;
      }
    }
    if (el.clientHeight <= el.scrollHeight + 1 && (props.includes(overflowY) || props.includes(overflow))) {
      return el;
    }
    if (el.clientWidth <= el.scrollWidth + 1 && (props.includes(overflowX) || props.includes(overflow))) {
      return el;
    }
    el = el.parentNode;
  }
  return rootWindow;
}
function getTrimmingContainer(base) {
  var rootDocument = base.ownerDocument;
  var rootWindow = rootDocument.defaultView;
  var el = base.parentNode;
  while (el && el.style && rootDocument.body !== el) {
    if (el.style.overflow !== "visible" && el.style.overflow !== "") {
      return el;
    }
    var computedStyle = getComputedStyle(el, rootWindow);
    var allowedProperties = ["scroll", "hidden", "auto"];
    var property = computedStyle.getPropertyValue("overflow");
    var propertyY = computedStyle.getPropertyValue("overflow-y");
    var propertyX = computedStyle.getPropertyValue("overflow-x");
    if (allowedProperties.includes(property) || allowedProperties.includes(propertyY) || allowedProperties.includes(propertyX)) {
      return el;
    }
    el = el.parentNode;
  }
  return rootWindow;
}
function getStyle(element, prop) {
  var rootWindow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : window;
  if (!element) {
    return;
  } else if (element === rootWindow) {
    if (prop === "width") {
      return "".concat(rootWindow.innerWidth, "px");
    } else if (prop === "height") {
      return "".concat(rootWindow.innerHeight, "px");
    }
    return;
  }
  var styleProp = element.style[prop];
  if (styleProp !== "" && styleProp !== void 0) {
    return styleProp;
  }
  var computedStyle = getComputedStyle(element, rootWindow);
  if (computedStyle[prop] !== "" && computedStyle[prop] !== void 0) {
    return computedStyle[prop];
  }
}
function matchesCSSRules(element, rule) {
  var selectorText = rule.selectorText;
  var result = false;
  if (rule.type === CSSRule.STYLE_RULE && selectorText) {
    if (element.msMatchesSelector) {
      result = element.msMatchesSelector(selectorText);
    } else if (element.matches) {
      result = element.matches(selectorText);
    }
  }
  return result;
}
function getComputedStyle(element) {
  var rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
  return element.currentStyle || rootWindow.getComputedStyle(element);
}
function outerWidth(element) {
  return Math.ceil(element.getBoundingClientRect().width);
}
function outerHeight(element) {
  if (hasCaptionProblem() && element.firstChild && element.firstChild.nodeName === "CAPTION") {
    return element.offsetHeight + element.firstChild.offsetHeight;
  }
  return element.offsetHeight;
}
function innerHeight(element) {
  return element.clientHeight || element.innerHeight;
}
function innerWidth(element) {
  return element.clientWidth || element.innerWidth;
}
function addEvent(element, event, callback) {
  element.addEventListener(event, callback, false);
}
function removeEvent(element, event, callback) {
  element.removeEventListener(event, callback, false);
}
function getCaretPosition(el) {
  var rootDocument = el.ownerDocument;
  if (el.selectionStart) {
    return el.selectionStart;
  } else if (rootDocument.selection) {
    el.focus();
    var r = rootDocument.selection.createRange();
    if (r === null) {
      return 0;
    }
    var re = el.createTextRange();
    var rc = re.duplicate();
    re.moveToBookmark(r.getBookmark());
    rc.setEndPoint("EndToStart", re);
    return rc.text.length;
  }
  return 0;
}
function getSelectionEndPosition(el) {
  var rootDocument = el.ownerDocument;
  if (el.selectionEnd) {
    return el.selectionEnd;
  } else if (rootDocument.selection) {
    var r = rootDocument.selection.createRange();
    if (r === null) {
      return 0;
    }
    var re = el.createTextRange();
    return re.text.indexOf(r.text) + r.text.length;
  }
  return 0;
}
function getSelectionText() {
  var rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  var rootDocument = rootWindow.document;
  var text = "";
  if (rootWindow.getSelection) {
    text = rootWindow.getSelection().toString();
  } else if (rootDocument.selection && rootDocument.selection.type !== "Control") {
    text = rootDocument.selection.createRange().text;
  }
  return text;
}
function clearTextSelection() {
  var rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  var rootDocument = rootWindow.document;
  if (rootWindow.getSelection) {
    if (rootWindow.getSelection().empty) {
      rootWindow.getSelection().empty();
    } else if (rootWindow.getSelection().removeAllRanges) {
      rootWindow.getSelection().removeAllRanges();
    }
  } else if (rootDocument.selection) {
    rootDocument.selection.empty();
  }
}
function setCaretPosition(element, pos, endPos) {
  if (endPos === void 0) {
    endPos = pos;
  }
  if (element.setSelectionRange) {
    element.focus();
    try {
      element.setSelectionRange(pos, endPos);
    } catch (err) {
      var elementParent = element.parentNode;
      var parentDisplayValue = elementParent.style.display;
      elementParent.style.display = "block";
      element.setSelectionRange(pos, endPos);
      elementParent.style.display = parentDisplayValue;
    }
  }
}
var cachedScrollbarWidth;
function walkontableCalculateScrollbarWidth() {
  var rootDocument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
  var inner = rootDocument.createElement("div");
  inner.style.height = "200px";
  inner.style.width = "100%";
  var outer = rootDocument.createElement("div");
  outer.style.boxSizing = "content-box";
  outer.style.height = "150px";
  outer.style.left = "0px";
  outer.style.overflow = "hidden";
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.width = "200px";
  outer.style.visibility = "hidden";
  outer.appendChild(inner);
  (rootDocument.body || rootDocument.documentElement).appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  var w2 = inner.offsetWidth;
  if (w1 === w2) {
    w2 = outer.clientWidth;
  }
  (rootDocument.body || rootDocument.documentElement).removeChild(outer);
  return w1 - w2;
}
function getScrollbarWidth() {
  var rootDocument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
  if (cachedScrollbarWidth === void 0) {
    cachedScrollbarWidth = walkontableCalculateScrollbarWidth(rootDocument);
  }
  return cachedScrollbarWidth;
}
function hasVerticalScrollbar(element) {
  return element.offsetWidth !== element.clientWidth;
}
function hasHorizontalScrollbar(element) {
  return element.offsetHeight !== element.clientHeight;
}
function setOverlayPosition(overlayElem, left, top) {
  if (isIE9()) {
    overlayElem.style.top = top;
    overlayElem.style.left = left;
  } else if (isSafari()) {
    overlayElem.style["-webkit-transform"] = "translate3d(".concat(left, ",").concat(top, ",0)");
    overlayElem.style["-webkit-transform"] = "translate3d(".concat(left, ",").concat(top, ",0)");
  } else {
    overlayElem.style.transform = "translate3d(".concat(left, ",").concat(top, ",0)");
  }
}
function getCssTransform(element) {
  var transform;
  if (element.style.transform && (transform = element.style.transform) !== "") {
    return ["transform", transform];
  } else if (element.style["-webkit-transform"] && (transform = element.style["-webkit-transform"]) !== "") {
    return ["-webkit-transform", transform];
  }
  return -1;
}
function resetCssTransform(element) {
  if (element.style.transform && element.style.transform !== "") {
    element.style.transform = "";
  } else if (element.style["-webkit-transform"] && element.style["-webkit-transform"] !== "") {
    element.style["-webkit-transform"] = "";
  }
}
function isInput(element) {
  var inputs = ["INPUT", "SELECT", "TEXTAREA"];
  return element && (inputs.indexOf(element.nodeName) > -1 || element.contentEditable === "true");
}
function isOutsideInput(element) {
  return isInput(element) && element.hasAttribute("data-hot-input") === false;
}
function selectElementIfAllowed(element) {
  var activeElement = element.ownerDocument.activeElement;
  if (!isOutsideInput(activeElement)) {
    element.select();
  }
}
function isDetached(element) {
  return !element.parentNode;
}

var domHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getParent: getParent,
  getFrameElement: getFrameElement,
  getParentWindow: getParentWindow,
  hasAccessToParentWindow: hasAccessToParentWindow,
  closest: closest,
  closestDown: closestDown,
  isChildOf: isChildOf,
  index: index,
  overlayContainsElement: overlayContainsElement,
  hasClass: hasClass,
  addClass: addClass,
  removeClass: removeClass,
  removeTextNodes: removeTextNodes,
  empty: empty,
  HTML_CHARACTERS: HTML_CHARACTERS,
  fastInnerHTML: fastInnerHTML,
  fastInnerText: fastInnerText,
  isVisible: isVisible,
  offset: offset$1,
  getWindowScrollTop: getWindowScrollTop,
  getWindowScrollLeft: getWindowScrollLeft,
  getScrollTop: getScrollTop,
  getScrollLeft: getScrollLeft,
  getScrollableElement: getScrollableElement,
  getTrimmingContainer: getTrimmingContainer,
  getStyle: getStyle,
  matchesCSSRules: matchesCSSRules,
  getComputedStyle: getComputedStyle,
  outerWidth: outerWidth,
  outerHeight: outerHeight,
  innerHeight: innerHeight,
  innerWidth: innerWidth,
  addEvent: addEvent,
  removeEvent: removeEvent,
  getCaretPosition: getCaretPosition,
  getSelectionEndPosition: getSelectionEndPosition,
  getSelectionText: getSelectionText,
  clearTextSelection: clearTextSelection,
  setCaretPosition: setCaretPosition,
  getScrollbarWidth: getScrollbarWidth,
  hasVerticalScrollbar: hasVerticalScrollbar,
  hasHorizontalScrollbar: hasHorizontalScrollbar,
  setOverlayPosition: setOverlayPosition,
  getCssTransform: getCssTransform,
  resetCssTransform: resetCssTransform,
  isInput: isInput,
  isOutsideInput: isOutsideInput,
  selectElementIfAllowed: selectElementIfAllowed,
  isDetached: isDetached
});

function isFunction$1(func) {
  return typeof func === "function";
}
function throttle(func) {
  var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  var lastCalled = 0;
  var result = {
    lastCallThrottled: true
  };
  var lastTimer = null;
  function _throttle() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var stamp = Date.now();
    var needCall = false;
    result.lastCallThrottled = true;
    if (!lastCalled) {
      lastCalled = stamp;
      needCall = true;
    }
    var remaining = wait - (stamp - lastCalled);
    if (needCall) {
      result.lastCallThrottled = false;
      func.apply(this, args);
    } else {
      if (lastTimer) {
        clearTimeout(lastTimer);
      }
      lastTimer = setTimeout(function() {
        result.lastCallThrottled = false;
        func.apply(_this, args);
        lastCalled = 0;
        lastTimer = void 0;
      }, remaining);
    }
    return result;
  }
  return _throttle;
}
function throttleAfterHits(func) {
  var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  var hits = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
  var funcThrottle = throttle(func, wait);
  var remainHits = hits;
  function _clearHits() {
    remainHits = hits;
  }
  function _throttleAfterHits() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (remainHits) {
      remainHits -= 1;
      return func.apply(this, args);
    }
    return funcThrottle.apply(this, args);
  }
  _throttleAfterHits.clearHits = _clearHits;
  return _throttleAfterHits;
}
function debounce(func) {
  var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  var lastTimer = null;
  var result;
  function _debounce() {
    var _this2 = this;
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    if (lastTimer) {
      clearTimeout(lastTimer);
    }
    lastTimer = setTimeout(function() {
      result = func.apply(_this2, args);
    }, wait);
    return result;
  }
  return _debounce;
}
function pipe() {
  for (var _len4 = arguments.length, functions = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    functions[_key4] = arguments[_key4];
  }
  var firstFunc = functions[0], restFunc = functions.slice(1);
  return function _pipe() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return arrayReduce(restFunc, function(acc, fn) {
      return fn(acc);
    }, firstFunc.apply(this, args));
  };
}
function partial(func) {
  for (var _len6 = arguments.length, params = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    params[_key6 - 1] = arguments[_key6];
  }
  return function _partial() {
    for (var _len7 = arguments.length, restParams = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      restParams[_key7] = arguments[_key7];
    }
    return func.apply(this, params.concat(restParams));
  };
}
function curry(func) {
  var argsLength = func.length;
  function given(argsSoFar) {
    return function _curry() {
      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        params[_key8] = arguments[_key8];
      }
      var passedArgsSoFar = argsSoFar.concat(params);
      var result;
      if (passedArgsSoFar.length >= argsLength) {
        result = func.apply(this, passedArgsSoFar);
      } else {
        result = given(passedArgsSoFar);
      }
      return result;
    };
  }
  return given([]);
}
function curryRight(func) {
  var argsLength = func.length;
  function given(argsSoFar) {
    return function _curry() {
      for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        params[_key9] = arguments[_key9];
      }
      var passedArgsSoFar = argsSoFar.concat(params.reverse());
      var result;
      if (passedArgsSoFar.length >= argsLength) {
        result = func.apply(this, passedArgsSoFar);
      } else {
        result = given(passedArgsSoFar);
      }
      return result;
    };
  }
  return given([]);
}

var functionHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isFunction: isFunction$1,
  throttle: throttle,
  throttleAfterHits: throttleAfterHits,
  debounce: debounce,
  pipe: pipe,
  partial: partial,
  curry: curry,
  curryRight: curryRight
});

var RENDER_TYPE = 1;
var FULLY_VISIBLE_TYPE = 2;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var privatePool = new WeakMap();
var ViewportColumnsCalculator = /* @__PURE__ */ function() {
  function ViewportColumnsCalculator2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, viewportSize = _ref.viewportSize, scrollOffset = _ref.scrollOffset, totalItems = _ref.totalItems, itemSizeFn = _ref.itemSizeFn, overrideFn = _ref.overrideFn, calculationType = _ref.calculationType, stretchMode = _ref.stretchMode, _ref$stretchingItemWi = _ref.stretchingItemWidthFn, stretchingItemWidthFn = _ref$stretchingItemWi === void 0 ? function(width) {
      return width;
    } : _ref$stretchingItemWi;
    _classCallCheck(this, ViewportColumnsCalculator2);
    privatePool.set(this, {
      viewportWidth: viewportSize,
      scrollOffset,
      totalColumns: totalItems,
      columnWidthFn: itemSizeFn,
      overrideFn,
      calculationType,
      stretchingColumnWidthFn: stretchingItemWidthFn
    });
    this.count = 0;
    this.startColumn = null;
    this.endColumn = null;
    this.startPosition = null;
    this.stretchAllRatio = 0;
    this.stretchLastWidth = 0;
    this.stretch = stretchMode;
    this.totalTargetWidth = 0;
    this.needVerifyLastColumnWidth = true;
    this.stretchAllColumnsWidth = [];
    this.calculate();
  }
  _createClass(ViewportColumnsCalculator2, [{
    key: "calculate",
    value: function calculate() {
      var sum = 0;
      var needReverse = true;
      var startPositions = [];
      var columnWidth;
      var priv = privatePool.get(this);
      var calculationType = priv.calculationType;
      var overrideFn = priv.overrideFn;
      var scrollOffset = priv.scrollOffset;
      var totalColumns = priv.totalColumns;
      var viewportWidth = priv.viewportWidth;
      for (var i = 0; i < totalColumns; i++) {
        columnWidth = this._getColumnWidth(i);
        if (sum <= scrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {
          this.startColumn = i;
        }
        var compensatedViewportWidth = scrollOffset > 0 ? viewportWidth + 1 : viewportWidth;
        if (sum >= scrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? columnWidth : 0) <= scrollOffset + compensatedViewportWidth) {
          if (this.startColumn === null || this.startColumn === void 0) {
            this.startColumn = i;
          }
          this.endColumn = i;
        }
        startPositions.push(sum);
        sum += columnWidth;
        if (calculationType !== FULLY_VISIBLE_TYPE) {
          this.endColumn = i;
        }
        if (sum >= scrollOffset + viewportWidth) {
          needReverse = false;
          break;
        }
      }
      if (this.endColumn === totalColumns - 1 && needReverse) {
        this.startColumn = this.endColumn;
        while (this.startColumn > 0) {
          var viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];
          if (viewportSum <= viewportWidth || calculationType !== FULLY_VISIBLE_TYPE) {
            this.startColumn -= 1;
          }
          if (viewportSum > viewportWidth) {
            break;
          }
        }
      }
      if (calculationType === RENDER_TYPE && this.startColumn !== null && overrideFn) {
        overrideFn(this);
      }
      this.startPosition = startPositions[this.startColumn];
      if (this.startPosition === void 0) {
        this.startPosition = null;
      }
      if (totalColumns < this.endColumn) {
        this.endColumn = totalColumns - 1;
      }
      if (this.startColumn !== null) {
        this.count = this.endColumn - this.startColumn + 1;
      }
    }
  }, {
    key: "refreshStretching",
    value: function refreshStretching(totalWidth) {
      if (this.stretch === "none") {
        return;
      }
      var totalColumnsWidth = totalWidth;
      this.totalTargetWidth = totalColumnsWidth;
      var priv = privatePool.get(this);
      var totalColumns = priv.totalColumns;
      var sumAll = 0;
      for (var i = 0; i < totalColumns; i++) {
        var columnWidth = this._getColumnWidth(i);
        var permanentColumnWidth = priv.stretchingColumnWidthFn(void 0, i);
        if (typeof permanentColumnWidth === "number") {
          totalColumnsWidth -= permanentColumnWidth;
        } else {
          sumAll += columnWidth;
        }
      }
      var remainingSize = totalColumnsWidth - sumAll;
      if (this.stretch === "all" && remainingSize > 0) {
        this.stretchAllRatio = totalColumnsWidth / sumAll;
        this.stretchAllColumnsWidth = [];
        this.needVerifyLastColumnWidth = true;
      } else if (this.stretch === "last" && totalColumnsWidth !== Infinity) {
        var _columnWidth = this._getColumnWidth(totalColumns - 1);
        var lastColumnWidth = remainingSize + _columnWidth;
        this.stretchLastWidth = lastColumnWidth >= 0 ? lastColumnWidth : _columnWidth;
      }
    }
  }, {
    key: "getStretchedColumnWidth",
    value: function getStretchedColumnWidth(column, baseWidth) {
      var result = null;
      if (this.stretch === "all" && this.stretchAllRatio !== 0) {
        result = this._getStretchedAllColumnWidth(column, baseWidth);
      } else if (this.stretch === "last" && this.stretchLastWidth !== 0) {
        result = this._getStretchedLastColumnWidth(column);
      }
      return result;
    }
  }, {
    key: "_getStretchedAllColumnWidth",
    value: function _getStretchedAllColumnWidth(column, baseWidth) {
      var sumRatioWidth = 0;
      var priv = privatePool.get(this);
      var totalColumns = priv.totalColumns;
      if (!this.stretchAllColumnsWidth[column]) {
        var stretchedWidth = Math.round(baseWidth * this.stretchAllRatio);
        var newStretchedWidth = priv.stretchingColumnWidthFn(stretchedWidth, column);
        if (newStretchedWidth === void 0) {
          this.stretchAllColumnsWidth[column] = stretchedWidth;
        } else {
          this.stretchAllColumnsWidth[column] = isNaN(newStretchedWidth) ? this._getColumnWidth(column) : newStretchedWidth;
        }
      }
      if (this.stretchAllColumnsWidth.length === totalColumns && this.needVerifyLastColumnWidth) {
        this.needVerifyLastColumnWidth = false;
        for (var i = 0; i < this.stretchAllColumnsWidth.length; i++) {
          sumRatioWidth += this.stretchAllColumnsWidth[i];
        }
        if (sumRatioWidth !== this.totalTargetWidth) {
          this.stretchAllColumnsWidth[this.stretchAllColumnsWidth.length - 1] += this.totalTargetWidth - sumRatioWidth;
        }
      }
      return this.stretchAllColumnsWidth[column];
    }
  }, {
    key: "_getStretchedLastColumnWidth",
    value: function _getStretchedLastColumnWidth(column) {
      var priv = privatePool.get(this);
      var totalColumns = priv.totalColumns;
      if (column === totalColumns - 1) {
        return this.stretchLastWidth;
      }
      return null;
    }
  }, {
    key: "_getColumnWidth",
    value: function _getColumnWidth(column) {
      var width = privatePool.get(this).columnWidthFn(column);
      if (isNaN(width)) {
        width = ViewportColumnsCalculator2.DEFAULT_WIDTH;
      }
      return width;
    }
  }], [{
    key: "DEFAULT_WIDTH",
    get: function get() {
      return 50;
    }
  }]);
  return ViewportColumnsCalculator2;
}();

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
var privatePool$1 = new WeakMap();
var ViewportRowsCalculator = /* @__PURE__ */ function() {
  function ViewportRowsCalculator2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, viewportSize = _ref.viewportSize, scrollOffset = _ref.scrollOffset, totalItems = _ref.totalItems, itemSizeFn = _ref.itemSizeFn, overrideFn = _ref.overrideFn, calculationType = _ref.calculationType, scrollbarHeight = _ref.scrollbarHeight;
    _classCallCheck$1(this, ViewportRowsCalculator2);
    privatePool$1.set(this, {
      viewportHeight: viewportSize,
      scrollOffset,
      totalRows: totalItems,
      rowHeightFn: itemSizeFn,
      overrideFn,
      calculationType,
      horizontalScrollbarHeight: scrollbarHeight
    });
    this.count = 0;
    this.startRow = null;
    this.endRow = null;
    this.startPosition = null;
    this.calculate();
  }
  _createClass$1(ViewportRowsCalculator2, [{
    key: "calculate",
    value: function calculate() {
      var sum = 0;
      var needReverse = true;
      var startPositions = [];
      var priv = privatePool$1.get(this);
      var calculationType = priv.calculationType;
      var overrideFn = priv.overrideFn;
      var rowHeightFn = priv.rowHeightFn;
      var scrollOffset = priv.scrollOffset;
      var totalRows = priv.totalRows;
      var viewportHeight = priv.viewportHeight;
      var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;
      var rowHeight;
      for (var i = 0; i < totalRows; i++) {
        rowHeight = rowHeightFn(i);
        if (isNaN(rowHeight)) {
          rowHeight = ViewportRowsCalculator2.DEFAULT_HEIGHT;
        }
        if (sum <= scrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {
          this.startRow = i;
        }
        if (sum >= scrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? rowHeight : 0) <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
          if (this.startRow === null) {
            this.startRow = i;
          }
          this.endRow = i;
        }
        startPositions.push(sum);
        sum += rowHeight;
        if (calculationType !== FULLY_VISIBLE_TYPE) {
          this.endRow = i;
        }
        if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
          needReverse = false;
          break;
        }
      }
      if (this.endRow === totalRows - 1 && needReverse) {
        this.startRow = this.endRow;
        while (this.startRow > 0) {
          var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];
          if (viewportSum <= viewportHeight - horizontalScrollbarHeight || calculationType !== FULLY_VISIBLE_TYPE) {
            this.startRow -= 1;
          }
          if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {
            break;
          }
        }
      }
      if (calculationType === RENDER_TYPE && this.startRow !== null && overrideFn) {
        overrideFn(this);
      }
      this.startPosition = startPositions[this.startRow];
      if (this.startPosition === void 0) {
        this.startPosition = null;
      }
      if (totalRows < this.endRow) {
        this.endRow = totalRows - 1;
      }
      if (this.startRow !== null) {
        this.count = this.endRow - this.startRow + 1;
      }
    }
  }], [{
    key: "DEFAULT_HEIGHT",
    get: function get() {
      return 23;
    }
  }]);
  return ViewportRowsCalculator2;
}();

function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
var CellCoords = /* @__PURE__ */ function() {
  function CellCoords2(row, column) {
    _classCallCheck$2(this, CellCoords2);
    this.row = null;
    this.col = null;
    if (typeof row !== "undefined" && typeof column !== "undefined") {
      this.row = row;
      this.col = column;
    }
  }
  _createClass$2(CellCoords2, [{
    key: "isValid",
    value: function isValid(wot) {
      if (this.row < 0 || this.col < 0) {
        return false;
      }
      if (this.row >= wot.getSetting("totalRows") || this.col >= wot.getSetting("totalColumns")) {
        return false;
      }
      return true;
    }
  }, {
    key: "isEqual",
    value: function isEqual(cellCoords) {
      if (cellCoords === this) {
        return true;
      }
      return this.row === cellCoords.row && this.col === cellCoords.col;
    }
  }, {
    key: "isSouthEastOf",
    value: function isSouthEastOf(testedCoords) {
      return this.row >= testedCoords.row && this.col >= testedCoords.col;
    }
  }, {
    key: "isNorthWestOf",
    value: function isNorthWestOf(testedCoords) {
      return this.row <= testedCoords.row && this.col <= testedCoords.col;
    }
  }, {
    key: "isSouthWestOf",
    value: function isSouthWestOf(testedCoords) {
      return this.row >= testedCoords.row && this.col <= testedCoords.col;
    }
  }, {
    key: "isNorthEastOf",
    value: function isNorthEastOf(testedCoords) {
      return this.row <= testedCoords.row && this.col >= testedCoords.col;
    }
  }, {
    key: "normalize",
    value: function normalize() {
      this.row = this.row === null ? this.row : Math.max(this.row, 0);
      this.col = this.col === null ? this.col : Math.max(this.col, 0);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new CellCoords2(this.row, this.col);
    }
  }, {
    key: "toObject",
    value: function toObject() {
      return {
        row: this.row,
        col: this.col
      };
    }
  }]);
  return CellCoords2;
}();

function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
var CellRange = /* @__PURE__ */ function() {
  function CellRange2(highlight) {
    var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : highlight;
    var to = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : highlight;
    _classCallCheck$3(this, CellRange2);
    this.highlight = highlight.clone().normalize();
    this.from = from.clone();
    this.to = to.clone();
  }
  _createClass$3(CellRange2, [{
    key: "setHighlight",
    value: function setHighlight(coords) {
      this.highlight = coords.clone().normalize();
      return this;
    }
  }, {
    key: "setFrom",
    value: function setFrom(coords) {
      this.from = coords.clone();
      return this;
    }
  }, {
    key: "setTo",
    value: function setTo(coords) {
      this.to = coords.clone();
      return this;
    }
  }, {
    key: "isValid",
    value: function isValid(wot) {
      return this.from.isValid(wot) && this.to.isValid(wot);
    }
  }, {
    key: "isSingle",
    value: function isSingle() {
      return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;
    }
  }, {
    key: "getOuterHeight",
    value: function getOuterHeight() {
      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;
    }
  }, {
    key: "getOuterWidth",
    value: function getOuterWidth() {
      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      var fromRow = Math.max(this.from.row, 0);
      var toRow = Math.max(this.to.row, 0);
      return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      var fromCol = Math.max(this.from.col, 0);
      var toCol = Math.max(this.to.col, 0);
      return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;
    }
  }, {
    key: "includes",
    value: function includes(cellCoords) {
      var row = cellCoords.row, col = cellCoords.col;
      var topLeft = this.getOuterTopLeftCorner();
      var bottomRight = this.getOuterBottomRightCorner();
      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;
    }
  }, {
    key: "includesRange",
    value: function includesRange(cellRange) {
      return this.includes(cellRange.getOuterTopLeftCorner()) && this.includes(cellRange.getOuterBottomRightCorner());
    }
  }, {
    key: "isEqual",
    value: function isEqual(cellRange) {
      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);
    }
  }, {
    key: "overlaps",
    value: function overlaps(cellRange) {
      return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());
    }
  }, {
    key: "isSouthEastOf",
    value: function isSouthEastOf(cellRange) {
      return this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || this.getOuterBottomRightCorner().isSouthEastOf(cellRange);
    }
  }, {
    key: "isNorthWestOf",
    value: function isNorthWestOf(cellRange) {
      return this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || this.getOuterBottomRightCorner().isNorthWestOf(cellRange);
    }
  }, {
    key: "isOverlappingHorizontally",
    value: function isOverlappingHorizontally(cellRange) {
      return this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col || this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col && this.getOuterTopLeftCorner().col >= cellRange.getOuterTopLeftCorner().col;
    }
  }, {
    key: "isOverlappingVertically",
    value: function isOverlappingVertically(cellRange) {
      return this.getOuterBottomRightCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomRightCorner().row <= cellRange.getOuterBottomRightCorner().row || this.getOuterTopRightCorner().row <= cellRange.getOuterBottomRightCorner().row && this.getOuterTopRightCorner().row >= cellRange.getOuterTopRightCorner().row;
    }
  }, {
    key: "expand",
    value: function expand(cellCoords) {
      var topLeft = this.getOuterTopLeftCorner();
      var bottomRight = this.getOuterBottomRightCorner();
      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {
        this.from = new CellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));
        this.to = new CellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));
        return true;
      }
      return false;
    }
  }, {
    key: "expandByRange",
    value: function expandByRange(expandingRange) {
      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {
        return false;
      }
      var topLeft = this.getOuterTopLeftCorner();
      var bottomRight = this.getOuterBottomRightCorner();
      var initialDirection = this.getDirection();
      var expandingTopLeft = expandingRange.getOuterTopLeftCorner();
      var expandingBottomRight = expandingRange.getOuterBottomRightCorner();
      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);
      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);
      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);
      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);
      var finalFrom = new CellCoords(resultTopRow, resultTopCol);
      var finalTo = new CellCoords(resultBottomRow, resultBottomCol);
      this.from = finalFrom;
      this.to = finalTo;
      this.setDirection(initialDirection);
      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === "N-S") {
        this.flipDirectionVertically();
      }
      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === "W-E") {
        this.flipDirectionHorizontally();
      }
      return true;
    }
  }, {
    key: "getDirection",
    value: function getDirection() {
      if (this.from.isNorthWestOf(this.to)) {
        return "NW-SE";
      } else if (this.from.isNorthEastOf(this.to)) {
        return "NE-SW";
      } else if (this.from.isSouthEastOf(this.to)) {
        return "SE-NW";
      } else if (this.from.isSouthWestOf(this.to)) {
        return "SW-NE";
      }
    }
  }, {
    key: "setDirection",
    value: function setDirection(direction) {
      switch (direction) {
        case "NW-SE":
          var _ref = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];
          this.from = _ref[0];
          this.to = _ref[1];
          break;
        case "NE-SW":
          var _ref2 = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];
          this.from = _ref2[0];
          this.to = _ref2[1];
          break;
        case "SE-NW":
          var _ref3 = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];
          this.from = _ref3[0];
          this.to = _ref3[1];
          break;
        case "SW-NE":
          var _ref4 = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];
          this.from = _ref4[0];
          this.to = _ref4[1];
          break;
      }
    }
  }, {
    key: "getVerticalDirection",
    value: function getVerticalDirection() {
      return ["NE-SW", "NW-SE"].indexOf(this.getDirection()) > -1 ? "N-S" : "S-N";
    }
  }, {
    key: "getHorizontalDirection",
    value: function getHorizontalDirection() {
      return ["NW-SE", "SW-NE"].indexOf(this.getDirection()) > -1 ? "W-E" : "E-W";
    }
  }, {
    key: "flipDirectionVertically",
    value: function flipDirectionVertically() {
      var direction = this.getDirection();
      switch (direction) {
        case "NW-SE":
          this.setDirection("SW-NE");
          break;
        case "NE-SW":
          this.setDirection("SE-NW");
          break;
        case "SE-NW":
          this.setDirection("NE-SW");
          break;
        case "SW-NE":
          this.setDirection("NW-SE");
          break;
      }
    }
  }, {
    key: "flipDirectionHorizontally",
    value: function flipDirectionHorizontally() {
      var direction = this.getDirection();
      switch (direction) {
        case "NW-SE":
          this.setDirection("NE-SW");
          break;
        case "NE-SW":
          this.setDirection("NW-SE");
          break;
        case "SE-NW":
          this.setDirection("SW-NE");
          break;
        case "SW-NE":
          this.setDirection("SE-NW");
          break;
      }
    }
  }, {
    key: "getTopLeftCorner",
    value: function getTopLeftCorner() {
      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();
    }
  }, {
    key: "getBottomRightCorner",
    value: function getBottomRightCorner() {
      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();
    }
  }, {
    key: "getTopRightCorner",
    value: function getTopRightCorner() {
      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();
    }
  }, {
    key: "getBottomLeftCorner",
    value: function getBottomLeftCorner() {
      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();
    }
  }, {
    key: "getOuterTopLeftCorner",
    value: function getOuterTopLeftCorner() {
      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
    }
  }, {
    key: "getOuterBottomRightCorner",
    value: function getOuterBottomRightCorner() {
      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
    }
  }, {
    key: "getOuterTopRightCorner",
    value: function getOuterTopRightCorner() {
      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
    }
  }, {
    key: "getOuterBottomLeftCorner",
    value: function getOuterBottomLeftCorner() {
      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
    }
  }, {
    key: "isCorner",
    value: function isCorner(coords, expandedRange) {
      if (expandedRange && expandedRange.includes(coords) && (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col)))) {
        return true;
      }
      return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());
    }
  }, {
    key: "getOppositeCorner",
    value: function getOppositeCorner(coords, expandedRange) {
      if (!(coords instanceof CellCoords)) {
        return false;
      }
      if (expandedRange) {
        if (expandedRange.includes(coords)) {
          if (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col))) {
            return this.getOuterBottomRightCorner();
          }
          if (this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col))) {
            return this.getOuterBottomLeftCorner();
          }
          if (this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col))) {
            return this.getOuterTopRightCorner();
          }
          if (this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col))) {
            return this.getOuterTopLeftCorner();
          }
        }
      }
      if (coords.isEqual(this.getOuterBottomRightCorner())) {
        return this.getOuterTopLeftCorner();
      } else if (coords.isEqual(this.getOuterTopLeftCorner())) {
        return this.getOuterBottomRightCorner();
      } else if (coords.isEqual(this.getOuterTopRightCorner())) {
        return this.getOuterBottomLeftCorner();
      } else if (coords.isEqual(this.getOuterBottomLeftCorner())) {
        return this.getOuterTopRightCorner();
      }
    }
  }, {
    key: "getBordersSharedWith",
    value: function getBordersSharedWith(range) {
      if (!this.includesRange(range)) {
        return [];
      }
      var thisBorders = {
        top: Math.min(this.from.row, this.to.row),
        bottom: Math.max(this.from.row, this.to.row),
        left: Math.min(this.from.col, this.to.col),
        right: Math.max(this.from.col, this.to.col)
      };
      var rangeBorders = {
        top: Math.min(range.from.row, range.to.row),
        bottom: Math.max(range.from.row, range.to.row),
        left: Math.min(range.from.col, range.to.col),
        right: Math.max(range.from.col, range.to.col)
      };
      var result = [];
      if (thisBorders.top === rangeBorders.top) {
        result.push("top");
      }
      if (thisBorders.right === rangeBorders.right) {
        result.push("right");
      }
      if (thisBorders.bottom === rangeBorders.bottom) {
        result.push("bottom");
      }
      if (thisBorders.left === rangeBorders.left) {
        result.push("left");
      }
      return result;
    }
  }, {
    key: "getInner",
    value: function getInner() {
      var topLeft = this.getOuterTopLeftCorner();
      var bottomRight = this.getOuterBottomRightCorner();
      var out = [];
      for (var r = topLeft.row; r <= bottomRight.row; r++) {
        for (var c = topLeft.col; c <= bottomRight.col; c++) {
          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {
            out.push(new CellCoords(r, c));
          }
        }
      }
      return out;
    }
  }, {
    key: "getAll",
    value: function getAll() {
      var topLeft = this.getOuterTopLeftCorner();
      var bottomRight = this.getOuterBottomRightCorner();
      var out = [];
      for (var r = topLeft.row; r <= bottomRight.row; r++) {
        for (var c = topLeft.col; c <= bottomRight.col; c++) {
          if (topLeft.row === r && topLeft.col === c) {
            out.push(topLeft);
          } else if (bottomRight.row === r && bottomRight.col === c) {
            out.push(bottomRight);
          } else {
            out.push(new CellCoords(r, c));
          }
        }
      }
      return out;
    }
  }, {
    key: "forAll",
    value: function forAll(callback) {
      var topLeft = this.getOuterTopLeftCorner();
      var bottomRight = this.getOuterBottomRightCorner();
      for (var r = topLeft.row; r <= bottomRight.row; r++) {
        for (var c = topLeft.col; c <= bottomRight.col; c++) {
          var breakIteration = callback(r, c);
          if (breakIteration === false) {
            return;
          }
        }
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new CellRange2(this.highlight, this.from, this.to);
    }
  }, {
    key: "toObject",
    value: function toObject() {
      return {
        from: this.from.toObject(),
        to: this.to.toObject()
      };
    }
  }]);
  return CellRange2;
}();

function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
var ColumnFilter = /* @__PURE__ */ function() {
  function ColumnFilter2(offset, total, countTH) {
    _classCallCheck$4(this, ColumnFilter2);
    this.offset = offset;
    this.total = total;
    this.countTH = countTH;
  }
  _createClass$4(ColumnFilter2, [{
    key: "offsetted",
    value: function offsetted(index) {
      return index + this.offset;
    }
  }, {
    key: "unOffsetted",
    value: function unOffsetted(index) {
      return index - this.offset;
    }
  }, {
    key: "renderedToSource",
    value: function renderedToSource(index) {
      return this.offsetted(index);
    }
  }, {
    key: "sourceToRendered",
    value: function sourceToRendered(index) {
      return this.unOffsetted(index);
    }
  }, {
    key: "offsettedTH",
    value: function offsettedTH(index) {
      return index - this.countTH;
    }
  }, {
    key: "unOffsettedTH",
    value: function unOffsettedTH(index) {
      return index + this.countTH;
    }
  }, {
    key: "visibleRowHeadedColumnToSourceColumn",
    value: function visibleRowHeadedColumnToSourceColumn(index) {
      return this.renderedToSource(this.offsettedTH(index));
    }
  }, {
    key: "sourceColumnToVisibleRowHeadedColumn",
    value: function sourceColumnToVisibleRowHeadedColumn(index) {
      return this.unOffsettedTH(this.sourceToRendered(index));
    }
  }]);
  return ColumnFilter2;
}();

function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  return Constructor;
}
var RowFilter = /* @__PURE__ */ function() {
  function RowFilter2(offset, total, countTH) {
    _classCallCheck$5(this, RowFilter2);
    this.offset = offset;
    this.total = total;
    this.countTH = countTH;
  }
  _createClass$5(RowFilter2, [{
    key: "offsetted",
    value: function offsetted(index) {
      return index + this.offset;
    }
  }, {
    key: "unOffsetted",
    value: function unOffsetted(index) {
      return index - this.offset;
    }
  }, {
    key: "renderedToSource",
    value: function renderedToSource(index) {
      return this.offsetted(index);
    }
  }, {
    key: "sourceToRendered",
    value: function sourceToRendered(index) {
      return this.unOffsetted(index);
    }
  }, {
    key: "offsettedTH",
    value: function offsettedTH(index) {
      return index - this.countTH;
    }
  }, {
    key: "unOffsettedTH",
    value: function unOffsettedTH(index) {
      return index + this.countTH;
    }
  }, {
    key: "visibleColHeadedRowToSourceRow",
    value: function visibleColHeadedRowToSourceRow(index) {
      return this.renderedToSource(this.offsettedTH(index));
    }
  }, {
    key: "sourceRowToVisibleColHeadedRow",
    value: function sourceRowToVisibleColHeadedRow(index) {
      return this.unOffsettedTH(this.sourceToRendered(index));
    }
  }]);
  return RowFilter2;
}();

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
_export({ target: 'Object', stat: true }, {
  setPrototypeOf: objectSetPrototypeOf
});

var WORKING_SPACE_ALL = 0;
var WORKING_SPACE_TOP = 1;
var WORKING_SPACE_BOTTOM = 2;

function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$6(Constructor, staticProps);
  return Constructor;
}
var ViewSize = /* @__PURE__ */ function() {
  function ViewSize2() {
    _classCallCheck$6(this, ViewSize2);
    this.currentSize = 0;
    this.nextSize = 0;
    this.currentOffset = 0;
    this.nextOffset = 0;
  }
  _createClass$6(ViewSize2, [{
    key: "setSize",
    value: function setSize(size) {
      this.currentSize = this.nextSize;
      this.nextSize = size;
    }
  }, {
    key: "setOffset",
    value: function setOffset(offset) {
      this.currentOffset = this.nextOffset;
      this.nextOffset = offset;
    }
  }]);
  return ViewSize2;
}();

function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$7(Constructor, staticProps);
  return Constructor;
}
var ViewSizeSet = /* @__PURE__ */ function() {
  function ViewSizeSet2() {
    _classCallCheck$7(this, ViewSizeSet2);
    this.size = new ViewSize();
    this.workingSpace = WORKING_SPACE_ALL;
    this.sharedSize = null;
  }
  _createClass$7(ViewSizeSet2, [{
    key: "setSize",
    value: function setSize(size) {
      this.size.setSize(size);
    }
  }, {
    key: "setOffset",
    value: function setOffset(offset) {
      this.size.setOffset(offset);
    }
  }, {
    key: "getViewSize",
    value: function getViewSize() {
      return this.size;
    }
  }, {
    key: "isShared",
    value: function isShared() {
      return this.sharedSize instanceof ViewSize;
    }
  }, {
    key: "isPlaceOn",
    value: function isPlaceOn(workingSpace) {
      return this.workingSpace === workingSpace;
    }
  }, {
    key: "append",
    value: function append(viewSize) {
      this.workingSpace = WORKING_SPACE_TOP;
      viewSize.workingSpace = WORKING_SPACE_BOTTOM;
      this.sharedSize = viewSize.getViewSize();
    }
  }, {
    key: "prepend",
    value: function prepend(viewSize) {
      this.workingSpace = WORKING_SPACE_BOTTOM;
      viewSize.workingSpace = WORKING_SPACE_TOP;
      this.sharedSize = viewSize.getViewSize();
    }
  }]);
  return ViewSizeSet2;
}();

function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$8(Constructor, staticProps);
  return Constructor;
}
var OrderView = /* @__PURE__ */ function() {
  function OrderView2(rootNode, nodesPool, childNodeType) {
    _classCallCheck$8(this, OrderView2);
    this.rootNode = rootNode;
    this.nodesPool = nodesPool;
    this.sizeSet = new ViewSizeSet();
    this.childNodeType = childNodeType.toUpperCase();
    this.visualIndex = 0;
    this.collectedNodes = [];
  }
  _createClass$8(OrderView2, [{
    key: "setSize",
    value: function setSize(size) {
      this.sizeSet.setSize(size);
      return this;
    }
  }, {
    key: "setOffset",
    value: function setOffset(offset) {
      this.sizeSet.setOffset(offset);
      return this;
    }
  }, {
    key: "isSharedViewSet",
    value: function isSharedViewSet() {
      return this.sizeSet.isShared();
    }
  }, {
    key: "getNode",
    value: function getNode(visualIndex) {
      return visualIndex < this.collectedNodes.length ? this.collectedNodes[visualIndex] : null;
    }
  }, {
    key: "getCurrentNode",
    value: function getCurrentNode() {
      var length = this.collectedNodes.length;
      return length > 0 ? this.collectedNodes[length - 1] : null;
    }
  }, {
    key: "getRenderedChildCount",
    value: function getRenderedChildCount() {
      var rootNode = this.rootNode, sizeSet = this.sizeSet;
      var childElementCount = 0;
      if (this.isSharedViewSet()) {
        var element = rootNode.firstElementChild;
        while (element) {
          if (element.tagName === this.childNodeType) {
            childElementCount += 1;
          } else if (sizeSet.isPlaceOn(WORKING_SPACE_TOP)) {
            break;
          }
          element = element.nextElementSibling;
        }
      } else {
        childElementCount = rootNode.childElementCount;
      }
      return childElementCount;
    }
  }, {
    key: "start",
    value: function start() {
      this.collectedNodes.length = 0;
      this.visualIndex = 0;
      var rootNode = this.rootNode, sizeSet = this.sizeSet;
      var isShared = this.isSharedViewSet();
      var _sizeSet$getViewSize = sizeSet.getViewSize(), nextSize = _sizeSet$getViewSize.nextSize;
      var childElementCount = this.getRenderedChildCount();
      while (childElementCount < nextSize) {
        var newNode = this.nodesPool();
        if (!isShared || isShared && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {
          rootNode.appendChild(newNode);
        } else {
          rootNode.insertBefore(newNode, rootNode.firstChild);
        }
        childElementCount += 1;
      }
      var isSharedPlacedOnTop = isShared && sizeSet.isPlaceOn(WORKING_SPACE_TOP);
      while (childElementCount > nextSize) {
        rootNode.removeChild(isSharedPlacedOnTop ? rootNode.firstChild : rootNode.lastChild);
        childElementCount -= 1;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var rootNode = this.rootNode, sizeSet = this.sizeSet;
      var visualIndex = this.visualIndex;
      if (this.isSharedViewSet() && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {
        visualIndex += sizeSet.sharedSize.nextSize;
      }
      var node = rootNode.childNodes[visualIndex];
      if (node.tagName !== this.childNodeType) {
        var newNode = this.nodesPool();
        rootNode.replaceChild(newNode, node);
        node = newNode;
      }
      this.collectedNodes.push(node);
      this.visualIndex += 1;
    }
  }, {
    key: "end",
    value: function end() {
    }
  }]);
  return OrderView2;
}();

function _typeof$4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$4 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$9(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var SharedOrderView = /* @__PURE__ */ function(_OrderView) {
  _inherits(SharedOrderView2, _OrderView);
  var _super = _createSuper(SharedOrderView2);
  function SharedOrderView2() {
    _classCallCheck$9(this, SharedOrderView2);
    return _super.apply(this, arguments);
  }
  _createClass$9(SharedOrderView2, [{
    key: "prependView",
    value: function prependView(orderView) {
      this.sizeSet.prepend(orderView.sizeSet);
      orderView.sizeSet.append(this.sizeSet);
      return this;
    }
  }, {
    key: "appendView",
    value: function appendView(orderView) {
      this.sizeSet.append(orderView.sizeSet);
      orderView.sizeSet.prepend(this.sizeSet);
      return this;
    }
  }]);
  return SharedOrderView2;
}(OrderView);

function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$a(Constructor, staticProps);
  return Constructor;
}
var NodesPool = /* @__PURE__ */ function() {
  function NodesPool2(nodeType) {
    _classCallCheck$a(this, NodesPool2);
    this.nodeType = nodeType.toUpperCase();
  }
  _createClass$a(NodesPool2, [{
    key: "setRootDocument",
    value: function setRootDocument(rootDocument) {
      this.rootDocument = rootDocument;
    }
  }, {
    key: "obtain",
    value: function obtain() {
      return this.rootDocument.createElement(this.nodeType);
    }
  }]);
  return NodesPool2;
}();

function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$b(Constructor, staticProps);
  return Constructor;
}
var BaseRenderer = /* @__PURE__ */ function() {
  function BaseRenderer2(nodeType, rootNode) {
    _classCallCheck$b(this, BaseRenderer2);
    this.nodesPool = typeof nodeType === "string" ? new NodesPool(nodeType) : null;
    this.nodeType = nodeType;
    this.rootNode = rootNode;
    this.table = null;
    this.renderedNodes = 0;
  }
  _createClass$b(BaseRenderer2, [{
    key: "setTable",
    value: function setTable(table) {
      if (this.nodesPool) {
        this.nodesPool.setRootDocument(table.rootDocument);
      }
      this.table = table;
    }
  }, {
    key: "adjust",
    value: function adjust() {
    }
  }, {
    key: "render",
    value: function render() {
    }
  }]);
  return BaseRenderer2;
}();

function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$c(Constructor, staticProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1(o, p);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self);
}
function _assertThisInitialized$1(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
var RowHeadersRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$1(RowHeadersRenderer2, _BaseRenderer);
  var _super = _createSuper$1(RowHeadersRenderer2);
  function RowHeadersRenderer2() {
    var _this;
    _classCallCheck$c(this, RowHeadersRenderer2);
    _this = _super.call(this, "TH");
    _this.orderViews = new WeakMap();
    _this.sourceRowIndex = 0;
    return _this;
  }
  _createClass$c(RowHeadersRenderer2, [{
    key: "obtainOrderView",
    value: function obtainOrderView(rootNode) {
      var _this2 = this;
      var orderView;
      if (this.orderViews.has(rootNode)) {
        orderView = this.orderViews.get(rootNode);
      } else {
        orderView = new SharedOrderView(rootNode, function(sourceColumnIndex) {
          return _this2.nodesPool.obtain(_this2.sourceRowIndex, sourceColumnIndex);
        }, this.nodeType);
        this.orderViews.set(rootNode, orderView);
      }
      return orderView;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$table = this.table, rowsToRender = _this$table.rowsToRender, rowHeaderFunctions = _this$table.rowHeaderFunctions, rowHeadersCount = _this$table.rowHeadersCount, rows = _this$table.rows, cells = _this$table.cells;
      for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        var sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);
        var TR = rows.getRenderedNode(visibleRowIndex);
        this.sourceRowIndex = sourceRowIndex;
        var orderView = this.obtainOrderView(TR);
        var cellsView = cells.obtainOrderView(TR);
        orderView.appendView(cellsView).setSize(rowHeadersCount).setOffset(this.table.renderedColumnToSource(0)).start();
        for (var visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
          orderView.render();
          var TH = orderView.getCurrentNode();
          TH.className = "";
          TH.removeAttribute("style");
          rowHeaderFunctions[visibleColumnIndex](sourceRowIndex, TH, visibleColumnIndex);
        }
        orderView.end();
      }
    }
  }]);
  return RowHeadersRenderer2;
}(BaseRenderer);

function _typeof$6(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$6 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$6 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$6(obj);
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$d(Constructor, staticProps);
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$2(o, p);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self);
}
function _assertThisInitialized$2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
var ColumnHeadersRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$2(ColumnHeadersRenderer2, _BaseRenderer);
  var _super = _createSuper$2(ColumnHeadersRenderer2);
  function ColumnHeadersRenderer2(rootNode) {
    _classCallCheck$d(this, ColumnHeadersRenderer2);
    return _super.call(this, null, rootNode);
  }
  _createClass$d(ColumnHeadersRenderer2, [{
    key: "adjust",
    value: function adjust() {
      var _this$table = this.table, columnHeadersCount = _this$table.columnHeadersCount, rowHeadersCount = _this$table.rowHeadersCount;
      var TR = this.rootNode.firstChild;
      if (columnHeadersCount) {
        var columnsToRender = this.table.columnsToRender;
        var allColumnsToRender = columnsToRender + rowHeadersCount;
        for (var i = 0, len = columnHeadersCount; i < len; i++) {
          TR = this.rootNode.childNodes[i];
          if (!TR) {
            TR = this.table.rootDocument.createElement("tr");
            this.rootNode.appendChild(TR);
          }
          this.renderedNodes = TR.childNodes.length;
          while (this.renderedNodes < allColumnsToRender) {
            TR.appendChild(this.table.rootDocument.createElement("th"));
            this.renderedNodes += 1;
          }
          while (this.renderedNodes > allColumnsToRender) {
            TR.removeChild(TR.lastChild);
            this.renderedNodes -= 1;
          }
        }
        var theadChildrenLength = this.rootNode.childNodes.length;
        if (theadChildrenLength > columnHeadersCount) {
          for (var _i = columnHeadersCount; _i < theadChildrenLength; _i++) {
            this.rootNode.removeChild(this.rootNode.lastChild);
          }
        }
      } else if (TR) {
        empty(TR);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var columnHeadersCount = this.table.columnHeadersCount;
      for (var rowHeaderIndex = 0; rowHeaderIndex < columnHeadersCount; rowHeaderIndex += 1) {
        var _this$table2 = this.table, columnHeaderFunctions = _this$table2.columnHeaderFunctions, columnsToRender = _this$table2.columnsToRender, rowHeadersCount = _this$table2.rowHeadersCount;
        var TR = this.rootNode.childNodes[rowHeaderIndex];
        for (var renderedColumnIndex = -1 * rowHeadersCount; renderedColumnIndex < columnsToRender; renderedColumnIndex += 1) {
          var sourceColumnIndex = this.table.renderedColumnToSource(renderedColumnIndex);
          var TH = TR.childNodes[renderedColumnIndex + rowHeadersCount];
          TH.className = "";
          TH.removeAttribute("style");
          columnHeaderFunctions[rowHeaderIndex](sourceColumnIndex, TH, rowHeaderIndex);
        }
      }
    }
  }]);
  return ColumnHeadersRenderer2;
}(BaseRenderer);

function _typeof$7(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$7 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$7 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$7(obj);
}
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$e(Constructor, staticProps);
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$3(o, p);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$3(self);
}
function _assertThisInitialized$3(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
var ColGroupRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$3(ColGroupRenderer2, _BaseRenderer);
  var _super = _createSuper$3(ColGroupRenderer2);
  function ColGroupRenderer2(rootNode) {
    _classCallCheck$e(this, ColGroupRenderer2);
    return _super.call(this, null, rootNode);
  }
  _createClass$e(ColGroupRenderer2, [{
    key: "adjust",
    value: function adjust() {
      var _this$table = this.table, columnsToRender = _this$table.columnsToRender, rowHeadersCount = _this$table.rowHeadersCount;
      var allColumnsToRender = columnsToRender + rowHeadersCount;
      while (this.renderedNodes < allColumnsToRender) {
        this.rootNode.appendChild(this.table.rootDocument.createElement("col"));
        this.renderedNodes += 1;
      }
      while (this.renderedNodes > allColumnsToRender) {
        this.rootNode.removeChild(this.rootNode.lastChild);
        this.renderedNodes -= 1;
      }
    }
  }, {
    key: "render",
    value: function render() {
      this.adjust();
      var _this$table2 = this.table, columnsToRender = _this$table2.columnsToRender, rowHeadersCount = _this$table2.rowHeadersCount;
      for (var visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
        var sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
        var width = this.table.columnUtils.getHeaderWidth(sourceColumnIndex);
        this.rootNode.childNodes[visibleColumnIndex].style.width = "".concat(width, "px");
      }
      for (var _visibleColumnIndex = 0; _visibleColumnIndex < columnsToRender; _visibleColumnIndex++) {
        var _sourceColumnIndex = this.table.renderedColumnToSource(_visibleColumnIndex);
        var _width = this.table.columnUtils.getStretchedColumnWidth(_sourceColumnIndex);
        this.rootNode.childNodes[_visibleColumnIndex + rowHeadersCount].style.width = "".concat(_width, "px");
      }
      var firstChild = this.rootNode.firstChild;
      if (firstChild) {
        addClass(firstChild, "rowHeader");
      }
    }
  }]);
  return ColGroupRenderer2;
}(BaseRenderer);

function warn$1() {
  if (isDefined(console)) {
    var _console2;
    (_console2 = console).warn.apply(_console2, arguments);
  }
}
function error() {
  if (isDefined(console)) {
    var _console4;
    (_console4 = console).error.apply(_console4, arguments);
  }
}

function _typeof$8(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$8 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$8 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$8(obj);
}
var _templateObject$1;
function _taggedTemplateLiteral$1(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$f(Constructor, staticProps);
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$4(o, p);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self, call) {
  if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$4(self);
}
function _assertThisInitialized$4(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
var performanceWarningAppeared = false;
var RowsRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$4(RowsRenderer2, _BaseRenderer);
  var _super = _createSuper$4(RowsRenderer2);
  function RowsRenderer2(rootNode) {
    var _this;
    _classCallCheck$f(this, RowsRenderer2);
    _this = _super.call(this, "TR", rootNode);
    _this.orderView = new OrderView(rootNode, function(sourceRowIndex) {
      return _this.nodesPool.obtain(sourceRowIndex);
    }, _this.nodeType);
    return _this;
  }
  _createClass$f(RowsRenderer2, [{
    key: "getRenderedNode",
    value: function getRenderedNode(visualIndex) {
      return this.orderView.getNode(visualIndex);
    }
  }, {
    key: "render",
    value: function render() {
      var rowsToRender = this.table.rowsToRender;
      if (!performanceWarningAppeared && rowsToRender > 1e3) {
        performanceWarningAppeared = true;
        warn$1(toSingleLine(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral$1(['Performance tip: Handsontable rendered more than 1000 visible rows. Consider limiting \n        the number of rendered rows by specifying the table height and/or turning off the "renderAllRows" option.'], ['Performance tip: Handsontable rendered more than 1000 visible rows. Consider limiting\\x20\n        the number of rendered rows by specifying the table height and/or turning off the "renderAllRows" option.']))));
      }
      this.orderView.setSize(rowsToRender).setOffset(this.table.renderedRowToSource(0)).start();
      for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        this.orderView.render();
      }
      this.orderView.end();
    }
  }]);
  return RowsRenderer2;
}(BaseRenderer);

function _typeof$9(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$9 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$9 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$9(obj);
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$g(Constructor, staticProps);
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$5(o, p);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self, call) {
  if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$5(self);
}
function _assertThisInitialized$5(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$5(o);
}
var CellsRenderer = /* @__PURE__ */ function(_BaseRenderer) {
  _inherits$5(CellsRenderer2, _BaseRenderer);
  var _super = _createSuper$5(CellsRenderer2);
  function CellsRenderer2() {
    var _this;
    _classCallCheck$g(this, CellsRenderer2);
    _this = _super.call(this, "TD");
    _this.orderViews = new WeakMap();
    _this.sourceRowIndex = 0;
    return _this;
  }
  _createClass$g(CellsRenderer2, [{
    key: "obtainOrderView",
    value: function obtainOrderView(rootNode) {
      var _this2 = this;
      var orderView;
      if (this.orderViews.has(rootNode)) {
        orderView = this.orderViews.get(rootNode);
      } else {
        orderView = new SharedOrderView(rootNode, function(sourceColumnIndex) {
          return _this2.nodesPool.obtain(_this2.sourceRowIndex, sourceColumnIndex);
        }, this.nodeType);
        this.orderViews.set(rootNode, orderView);
      }
      return orderView;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$table = this.table, rowsToRender = _this$table.rowsToRender, columnsToRender = _this$table.columnsToRender, rows = _this$table.rows, rowHeaders = _this$table.rowHeaders;
      for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        var sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);
        var TR = rows.getRenderedNode(visibleRowIndex);
        this.sourceRowIndex = sourceRowIndex;
        var orderView = this.obtainOrderView(TR);
        var rowHeadersView = rowHeaders.obtainOrderView(TR);
        orderView.prependView(rowHeadersView).setSize(columnsToRender).setOffset(this.table.renderedColumnToSource(0)).start();
        for (var visibleColumnIndex = 0; visibleColumnIndex < columnsToRender; visibleColumnIndex++) {
          orderView.render();
          var TD = orderView.getCurrentNode();
          var sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
          if (!hasClass(TD, "hide")) {
            TD.className = "";
          }
          TD.removeAttribute("style");
          this.table.cellRenderer(sourceRowIndex, sourceColumnIndex, TD);
        }
        orderView.end();
      }
    }
  }]);
  return CellsRenderer2;
}(BaseRenderer);

function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$h(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$h(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$h(Constructor, staticProps);
  return Constructor;
}
var TableRenderer = /* @__PURE__ */ function() {
  function TableRenderer2(rootNode) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, cellRenderer = _ref.cellRenderer;
    _classCallCheck$h(this, TableRenderer2);
    this.rootNode = rootNode;
    this.rootDocument = this.rootNode.ownerDocument;
    this.rowHeaders = null;
    this.columnHeaders = null;
    this.colGroup = null;
    this.rows = null;
    this.cells = null;
    this.rowFilter = null;
    this.columnFilter = null;
    this.rowUtils = null;
    this.columnUtils = null;
    this.rowsToRender = 0;
    this.columnsToRender = 0;
    this.rowHeaderFunctions = [];
    this.rowHeadersCount = 0;
    this.columnHeaderFunctions = [];
    this.columnHeadersCount = 0;
    this.cellRenderer = cellRenderer;
  }
  _createClass$h(TableRenderer2, [{
    key: "setAxisUtils",
    value: function setAxisUtils(rowUtils, columnUtils) {
      this.rowUtils = rowUtils;
      this.columnUtils = columnUtils;
    }
  }, {
    key: "setViewportSize",
    value: function setViewportSize(rowsCount, columnsCount) {
      this.rowsToRender = rowsCount;
      this.columnsToRender = columnsCount;
    }
  }, {
    key: "setFilters",
    value: function setFilters(rowFilter, columnFilter) {
      this.rowFilter = rowFilter;
      this.columnFilter = columnFilter;
    }
  }, {
    key: "setHeaderContentRenderers",
    value: function setHeaderContentRenderers(rowHeaders, columnHeaders) {
      this.rowHeaderFunctions = rowHeaders;
      this.rowHeadersCount = rowHeaders.length;
      this.columnHeaderFunctions = columnHeaders;
      this.columnHeadersCount = columnHeaders.length;
    }
  }, {
    key: "setRenderers",
    value: function setRenderers() {
      var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, rowHeaders = _ref2.rowHeaders, columnHeaders = _ref2.columnHeaders, colGroup = _ref2.colGroup, rows = _ref2.rows, cells = _ref2.cells;
      rowHeaders.setTable(this);
      columnHeaders.setTable(this);
      colGroup.setTable(this);
      rows.setTable(this);
      cells.setTable(this);
      this.rowHeaders = rowHeaders;
      this.columnHeaders = columnHeaders;
      this.colGroup = colGroup;
      this.rows = rows;
      this.cells = cells;
    }
  }, {
    key: "renderedRowToSource",
    value: function renderedRowToSource(rowIndex) {
      return this.rowFilter.renderedToSource(rowIndex);
    }
  }, {
    key: "renderedColumnToSource",
    value: function renderedColumnToSource(columnIndex) {
      return this.columnFilter.renderedToSource(columnIndex);
    }
  }, {
    key: "render",
    value: function render() {
      this.colGroup.adjust();
      this.columnHeaders.adjust();
      this.rows.adjust();
      this.rowHeaders.adjust();
      this.columnHeaders.render();
      this.rows.render();
      this.rowHeaders.render();
      this.cells.render();
      this.columnUtils.calculateWidths();
      this.colGroup.render();
      var rowsToRender = this.rowsToRender, rows = this.rows;
      for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        var TR = rows.getRenderedNode(visibleRowIndex);
        if (TR.firstChild) {
          var sourceRowIndex = this.renderedRowToSource(visibleRowIndex);
          var rowHeight = this.rowUtils.getHeight(sourceRowIndex);
          if (rowHeight) {
            TR.firstChild.style.height = "".concat(rowHeight - 1, "px");
          } else {
            TR.firstChild.style.height = "";
          }
        }
      }
    }
  }]);
  return TableRenderer2;
}();

function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$i(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$i(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$i(Constructor, staticProps);
  return Constructor;
}
var Renderer = /* @__PURE__ */ function() {
  function Renderer2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, TABLE = _ref.TABLE, THEAD = _ref.THEAD, COLGROUP = _ref.COLGROUP, TBODY = _ref.TBODY, rowUtils = _ref.rowUtils, columnUtils = _ref.columnUtils, cellRenderer = _ref.cellRenderer;
    _classCallCheck$i(this, Renderer2);
    this.renderer = new TableRenderer(TABLE, {
      cellRenderer
    });
    this.renderer.setRenderers({
      rowHeaders: new RowHeadersRenderer(),
      columnHeaders: new ColumnHeadersRenderer(THEAD),
      colGroup: new ColGroupRenderer(COLGROUP),
      rows: new RowsRenderer(TBODY),
      cells: new CellsRenderer()
    });
    this.renderer.setAxisUtils(rowUtils, columnUtils);
  }
  _createClass$i(Renderer2, [{
    key: "setFilters",
    value: function setFilters(rowFilter, columnFilter) {
      this.renderer.setFilters(rowFilter, columnFilter);
      return this;
    }
  }, {
    key: "setViewportSize",
    value: function setViewportSize(rowsCount, columnsCount) {
      this.renderer.setViewportSize(rowsCount, columnsCount);
      return this;
    }
  }, {
    key: "setHeaderContentRenderers",
    value: function setHeaderContentRenderers(rowHeaders, columnHeaders) {
      this.renderer.setHeaderContentRenderers(rowHeaders, columnHeaders);
      return this;
    }
  }, {
    key: "adjust",
    value: function adjust() {
      this.renderer.adjust();
    }
  }, {
    key: "render",
    value: function render() {
      this.renderer.render();
    }
  }]);
  return Renderer2;
}();

function _typeof$a(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$a = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$a = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$a(obj);
}
function _classCallCheck$j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$j(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$j(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$j(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$j(Constructor, staticProps);
  return Constructor;
}
var ColumnUtils = /* @__PURE__ */ function() {
  function ColumnUtils2(wot) {
    _classCallCheck$j(this, ColumnUtils2);
    this.wot = wot;
    this.headerWidths = new Map();
  }
  _createClass$j(ColumnUtils2, [{
    key: "getWidth",
    value: function getWidth(sourceIndex) {
      var width = this.wot.wtSettings.settings.columnWidth;
      if (typeof width === "function") {
        width = width(sourceIndex);
      } else if (_typeof$a(width) === "object") {
        width = width[sourceIndex];
      }
      return width || this.wot.wtSettings.settings.defaultColumnWidth;
    }
  }, {
    key: "getStretchedColumnWidth",
    value: function getStretchedColumnWidth(sourceIndex) {
      var columnWidth = this.getWidth(sourceIndex);
      var calculator = this.wot.wtViewport.columnsRenderCalculator;
      var width = columnWidth !== null && columnWidth !== void 0 ? columnWidth : this.wot.wtSettings.settings.defaultColumnWidth;
      if (calculator) {
        var stretchedWidth = calculator.getStretchedColumnWidth(sourceIndex, width);
        if (stretchedWidth) {
          width = stretchedWidth;
        }
      }
      return width;
    }
  }, {
    key: "getHeaderHeight",
    value: function getHeaderHeight(level) {
      var height = this.wot.wtSettings.settings.defaultRowHeight;
      var oversizedHeight = this.wot.wtViewport.oversizedColumnHeaders[level];
      if (oversizedHeight !== void 0) {
        height = height ? Math.max(height, oversizedHeight) : oversizedHeight;
      }
      return height;
    }
  }, {
    key: "getHeaderWidth",
    value: function getHeaderWidth(sourceIndex) {
      return this.headerWidths.get(this.wot.wtTable.columnFilter.sourceToRendered(sourceIndex));
    }
  }, {
    key: "calculateWidths",
    value: function calculateWidths() {
      var wot = this.wot;
      var wtTable = wot.wtTable, wtViewport = wot.wtViewport, cloneSource = wot.cloneSource;
      var mainHolder = cloneSource ? cloneSource.wtTable.holder : wtTable.holder;
      var scrollbarCompensation = mainHolder.offsetHeight < mainHolder.scrollHeight ? getScrollbarWidth() : 0;
      var rowHeaderWidthSetting = wot.getSetting("rowHeaderWidth");
      wtViewport.columnsRenderCalculator.refreshStretching(wtViewport.getViewportWidth() - scrollbarCompensation);
      rowHeaderWidthSetting = wot.getSetting("onModifyRowHeaderWidth", rowHeaderWidthSetting);
      if (rowHeaderWidthSetting !== null && rowHeaderWidthSetting !== void 0) {
        var rowHeadersCount = wot.getSetting("rowHeaders").length;
        var defaultColumnWidth = wot.getSetting("defaultColumnWidth");
        for (var visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
          var width = Array.isArray(rowHeaderWidthSetting) ? rowHeaderWidthSetting[visibleColumnIndex] : rowHeaderWidthSetting;
          width = width === null || width === void 0 ? defaultColumnWidth : width;
          this.headerWidths.set(visibleColumnIndex, width);
        }
      }
    }
  }]);
  return ColumnUtils2;
}();

function _classCallCheck$k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$k(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$k(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$k(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$k(Constructor, staticProps);
  return Constructor;
}
var RowUtils = /* @__PURE__ */ function() {
  function RowUtils2(wot) {
    _classCallCheck$k(this, RowUtils2);
    this.wot = wot;
  }
  _createClass$k(RowUtils2, [{
    key: "getHeight",
    value: function getHeight(sourceIndex) {
      var height = this.wot.wtSettings.settings.rowHeight(sourceIndex);
      var oversizedHeight = this.wot.wtViewport.oversizedRows[sourceIndex];
      if (oversizedHeight !== void 0) {
        height = height === void 0 ? oversizedHeight : Math.max(height, oversizedHeight);
      }
      return height;
    }
  }]);
  return RowUtils2;
}();

var CLONE_TOP = "top";
var CLONE_BOTTOM = "bottom";
var CLONE_LEFT = "left";
var CLONE_TOP_LEFT_CORNER = "top_left_corner";
var CLONE_BOTTOM_LEFT_CORNER = "bottom_left_corner";
var CLONE_TYPES = [CLONE_TOP, CLONE_BOTTOM, CLONE_LEFT, CLONE_TOP_LEFT_CORNER, CLONE_BOTTOM_LEFT_CORNER];

var registeredOverlays = {};
function registerOverlayOnce(overlayClass) {
  var overlayName = overlayClass.OVERLAY_NAME;
  if (CLONE_TYPES.indexOf(overlayName) === -1) {
    throw new Error("Unsupported overlay (".concat(overlayName, ")."));
  }
  if (!hasOverlay(overlayName)) {
    registeredOverlays[overlayName] = overlayClass;
  }
}
function createOverlay(type, wot) {
  return new registeredOverlays[type](wot);
}
function hasOverlay(type) {
  return registeredOverlays[type] !== void 0;
}
function isOverlayTypeOf(overlay, type) {
  if (!overlay || !registeredOverlays[type]) {
    return false;
  }
  return overlay instanceof registeredOverlays[type];
}

function _toConsumableArray$3(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$l(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$l(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$l(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$l(Constructor, staticProps);
  return Constructor;
}
var Table = /* @__PURE__ */ function() {
  function Table2(wotInstance, table) {
    var _this = this;
    _classCallCheck$l(this, Table2);
    this.isMaster = !wotInstance.cloneOverlay;
    this.wot = wotInstance;
    this.instance = this.wot;
    this.TABLE = table;
    this.TBODY = null;
    this.THEAD = null;
    this.COLGROUP = null;
    this.tableOffset = 0;
    this.holderOffset = 0;
    this.hasTableHeight = true;
    this.hasTableWidth = true;
    this.isTableVisible = false;
    removeTextNodes(this.TABLE);
    this.spreader = this.createSpreader(this.TABLE);
    this.hider = this.createHider(this.spreader);
    this.holder = this.createHolder(this.hider);
    this.wtRootElement = this.holder.parentNode;
    if (this.isMaster) {
      this.alignOverlaysWithTrimmingContainer();
    }
    this.fixTableDomTree();
    this.rowFilter = null;
    this.columnFilter = null;
    this.correctHeaderWidth = false;
    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth;
    this.wot.wtSettings.settings.rowHeaderWidth = function() {
      return _this._modifyRowHeaderWidth(origRowHeaderWidth);
    };
    this.rowUtils = new RowUtils(this.wot);
    this.columnUtils = new ColumnUtils(this.wot);
    this.tableRenderer = new Renderer({
      TABLE: this.TABLE,
      THEAD: this.THEAD,
      COLGROUP: this.COLGROUP,
      TBODY: this.TBODY,
      rowUtils: this.rowUtils,
      columnUtils: this.columnUtils,
      cellRenderer: this.wot.wtSettings.settings.cellRenderer
    });
  }
  _createClass$l(Table2, [{
    key: "is",
    value: function is(overlayTypeName) {
      return isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);
    }
  }, {
    key: "fixTableDomTree",
    value: function fixTableDomTree() {
      var rootDocument = this.wot.rootDocument;
      this.TBODY = this.TABLE.querySelector("tbody");
      if (!this.TBODY) {
        this.TBODY = rootDocument.createElement("tbody");
        this.TABLE.appendChild(this.TBODY);
      }
      this.THEAD = this.TABLE.querySelector("thead");
      if (!this.THEAD) {
        this.THEAD = rootDocument.createElement("thead");
        this.TABLE.insertBefore(this.THEAD, this.TBODY);
      }
      this.COLGROUP = this.TABLE.querySelector("colgroup");
      if (!this.COLGROUP) {
        this.COLGROUP = rootDocument.createElement("colgroup");
        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
      }
      if (this.wot.getSetting("columnHeaders").length && !this.THEAD.childNodes.length) {
        this.THEAD.appendChild(rootDocument.createElement("TR"));
      }
    }
  }, {
    key: "createSpreader",
    value: function createSpreader(table) {
      var parent = table.parentNode;
      var spreader;
      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, "wtHolder")) {
        spreader = this.wot.rootDocument.createElement("div");
        spreader.className = "wtSpreader";
        if (parent) {
          parent.insertBefore(spreader, table);
        }
        spreader.appendChild(table);
      }
      spreader.style.position = "relative";
      return spreader;
    }
  }, {
    key: "createHider",
    value: function createHider(spreader) {
      var parent = spreader.parentNode;
      var hider;
      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, "wtHolder")) {
        hider = this.wot.rootDocument.createElement("div");
        hider.className = "wtHider";
        if (parent) {
          parent.insertBefore(hider, spreader);
        }
        hider.appendChild(spreader);
      }
      return hider;
    }
  }, {
    key: "createHolder",
    value: function createHolder(hider) {
      var parent = hider.parentNode;
      var holder;
      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, "wtHolder")) {
        holder = this.wot.rootDocument.createElement("div");
        holder.style.position = "relative";
        holder.className = "wtHolder";
        if (parent) {
          parent.insertBefore(holder, hider);
        }
        if (this.isMaster) {
          holder.parentNode.className += "ht_master handsontable";
        }
        holder.appendChild(hider);
      }
      return holder;
    }
  }, {
    key: "draw",
    value: function draw() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var wot = this.wot;
      var wtOverlays = wot.wtOverlays, wtViewport = wot.wtViewport;
      var totalRows = wot.getSetting("totalRows");
      var totalColumns = wot.getSetting("totalColumns");
      var rowHeaders = wot.getSetting("rowHeaders");
      var rowHeadersCount = rowHeaders.length;
      var columnHeaders = wot.getSetting("columnHeaders");
      var columnHeadersCount = columnHeaders.length;
      var syncScroll = false;
      var runFastDraw = fastDraw;
      if (this.isMaster) {
        this.holderOffset = offset$1(this.holder);
        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);
        if (rowHeadersCount && !wot.getSetting("fixedColumnsLeft")) {
          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();
          var previousState = this.correctHeaderWidth;
          this.correctHeaderWidth = leftScrollPos > 0;
          if (previousState !== this.correctHeaderWidth) {
            runFastDraw = false;
          }
        }
      }
      if (this.isMaster) {
        syncScroll = wtOverlays.prepareOverlays();
      }
      if (runFastDraw) {
        if (this.isMaster) {
          wtViewport.createVisibleCalculators();
        }
        if (wtOverlays) {
          wtOverlays.refresh(true);
        }
      } else {
        if (this.isMaster) {
          this.tableOffset = offset$1(this.TABLE);
        } else {
          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;
        }
        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;
        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;
        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);
        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);
        var performRedraw = true;
        if (this.isMaster) {
          this.alignOverlaysWithTrimmingContainer();
          var skipRender = {};
          this.wot.getSetting("beforeDraw", true, skipRender);
          performRedraw = skipRender.skipRender !== true;
        }
        if (performRedraw) {
          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);
          if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_LEFT_CORNER)) {
            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);
          }
          this.resetOversizedRows();
          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();
          var workspaceWidth;
          if (this.isMaster) {
            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();
            this.wot.wtViewport.containerWidth = null;
            this.markOversizedColumnHeaders();
          }
          this.adjustColumnHeaderHeights();
          if (this.isMaster || this.is(CLONE_BOTTOM)) {
            this.markOversizedRows();
          }
          if (this.isMaster) {
            this.wot.wtViewport.createVisibleCalculators();
            this.wot.wtOverlays.refresh(false);
            this.wot.wtOverlays.applyToDOM();
            var hiderWidth = outerWidth(this.hider);
            var tableWidth = outerWidth(this.TABLE);
            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {
              this.columnUtils.calculateWidths();
              this.tableRenderer.renderer.colGroup.render();
            }
            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {
              this.wot.wtViewport.containerWidth = null;
              this.columnUtils.calculateWidths();
              this.tableRenderer.renderer.colGroup.render();
            }
            this.wot.getSetting("onDraw", true);
          } else if (this.is(CLONE_BOTTOM)) {
            this.wot.cloneSource.wtOverlays.adjustElementsSize();
          }
        }
      }
      if (this.isMaster) {
        var positionChanged = wtOverlays.topOverlay.resetFixedPosition();
        if (wtOverlays.bottomOverlay.clone) {
          positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;
        }
        positionChanged = wtOverlays.leftOverlay.resetFixedPosition() || positionChanged;
        if (wtOverlays.topLeftCornerOverlay) {
          wtOverlays.topLeftCornerOverlay.resetFixedPosition();
        }
        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {
          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();
        }
        if (positionChanged) {
          wtOverlays.refreshAll();
          wtOverlays.adjustElementsSize();
        }
      }
      this.refreshSelections(runFastDraw);
      if (syncScroll) {
        wtOverlays.syncScrollWithMaster();
      }
      wot.drawn = true;
      return this;
    }
  }, {
    key: "markIfOversizedColumnHeader",
    value: function markIfOversizedColumnHeader(col) {
      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);
      var level = this.wot.getSetting("columnHeaders").length;
      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
      var previousColHeaderHeight;
      var currentHeader;
      var currentHeaderHeight;
      var columnHeaderHeightSetting = this.wot.getSetting("columnHeaderHeight") || [];
      while (level) {
        level -= 1;
        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);
        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);
        if (!currentHeader) {
          continue;
        }
        currentHeaderHeight = innerHeight(currentHeader);
        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {
          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;
        }
        if (Array.isArray(columnHeaderHeightSetting)) {
          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {
            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];
          }
        } else if (!isNaN(columnHeaderHeightSetting)) {
          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;
        }
        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {
          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;
        }
      }
    }
  }, {
    key: "adjustColumnHeaderHeights",
    value: function adjustColumnHeaderHeights() {
      var wot = this.wot;
      var children = wot.wtTable.THEAD.childNodes;
      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;
      var columnHeaders = wot.getSetting("columnHeaders");
      for (var i = 0, len = columnHeaders.length; i < len; i++) {
        if (oversizedColumnHeaders[i]) {
          if (!children[i] || children[i].childNodes.length === 0) {
            return;
          }
          children[i].childNodes[0].style.height = "".concat(oversizedColumnHeaders[i], "px");
        }
      }
    }
  }, {
    key: "resetOversizedRows",
    value: function resetOversizedRows() {
      var wot = this.wot;
      if (!this.isMaster && !this.is(CLONE_BOTTOM)) {
        return;
      }
      if (!wot.getSetting("externalRowCalculator")) {
        var rowsToRender = this.getRenderedRowsCount();
        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);
          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {
            wot.wtViewport.oversizedRows[sourceRow] = void 0;
          }
        }
      }
    }
  }, {
    key: "removeClassFromCells",
    value: function removeClassFromCells(className) {
      var nodes = this.TABLE.querySelectorAll(".".concat(className));
      for (var i = 0, len = nodes.length; i < len; i++) {
        removeClass(nodes[i], className);
      }
    }
  }, {
    key: "refreshSelections",
    value: function refreshSelections(fastDraw) {
      var wot = this.wot;
      if (!wot.selections) {
        return;
      }
      var highlights = Array.from(wot.selections);
      var len = highlights.length;
      if (fastDraw) {
        var classesToRemove = [];
        for (var i = 0; i < len; i++) {
          var _highlights$i$setting = highlights[i].settings, highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName, highlightRowClassName = _highlights$i$setting.highlightRowClassName, highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;
          var classNames = highlights[i].classNames;
          var classNamesLength = classNames.length;
          for (var j = 0; j < classNamesLength; j++) {
            if (!classesToRemove.includes(classNames[j])) {
              classesToRemove.push(classNames[j]);
            }
          }
          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {
            classesToRemove.push(highlightHeaderClassName);
          }
          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {
            classesToRemove.push(highlightRowClassName);
          }
          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {
            classesToRemove.push(highlightColumnClassName);
          }
        }
        var additionalClassesToRemove = wot.getSetting("onBeforeRemoveCellClassNames");
        if (Array.isArray(additionalClassesToRemove)) {
          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {
            classesToRemove.push(additionalClassesToRemove[_i]);
          }
        }
        var classesToRemoveLength = classesToRemove.length;
        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {
          this.removeClassFromCells(classesToRemove[_i2]);
        }
      }
      for (var _i3 = 0; _i3 < len; _i3++) {
        highlights[_i3].draw(wot, fastDraw);
      }
    }
  }, {
    key: "getCell",
    value: function getCell(coords) {
      var row = coords.row;
      var column = coords.col;
      var hookResult = this.wot.getSetting("onModifyGetCellCoords", row, column);
      if (hookResult && Array.isArray(hookResult)) {
        var _hookResult = _slicedToArray(hookResult, 2);
        row = _hookResult[0];
        column = _hookResult[1];
      }
      if (this.isRowBeforeRenderedRows(row)) {
        return -1;
      } else if (this.isRowAfterRenderedRows(row)) {
        return -2;
      } else if (this.isColumnBeforeRenderedColumns(column)) {
        return -3;
      } else if (this.isColumnAfterRenderedColumns(column)) {
        return -4;
      }
      var TR;
      if (row < 0) {
        TR = this.THEAD.childNodes[this.rowFilter.sourceRowToVisibleColHeadedRow(row)];
      } else {
        TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
      }
      if (!TR && row >= 0) {
        throw new Error("TR was expected to be rendered but is not");
      }
      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];
      if (!TD && column >= 0) {
        throw new Error("TD or TH was expected to be rendered but is not");
      }
      return TD;
    }
  }, {
    key: "getColumnHeader",
    value: function getColumnHeader(col) {
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var TR = this.THEAD.childNodes[level];
      return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
    }
  }, {
    key: "getColumnHeaders",
    value: function getColumnHeaders(column) {
      var THs = [];
      var visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);
      this.THEAD.childNodes.forEach(function(TR) {
        var TH = TR.childNodes[visibleColumn];
        if (TH) {
          THs.push(TH);
        }
      });
      return THs;
    }
  }, {
    key: "getRowHeader",
    value: function getRowHeader(row) {
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
        return;
      }
      var rowHeadersCount = this.wot.getSetting("rowHeaders").length;
      if (level >= rowHeadersCount) {
        return;
      }
      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
      return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];
    }
  }, {
    key: "getRowHeaders",
    value: function getRowHeaders(row) {
      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
        return [];
      }
      var THs = [];
      var rowHeadersCount = this.wot.getSetting("rowHeaders").length;
      for (var renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {
        var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
        var TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];
        if (TH) {
          THs.push(TH);
        }
      }
      return THs;
    }
  }, {
    key: "getCoords",
    value: function getCoords(TD) {
      var cellElement = TD;
      if (cellElement.nodeName !== "TD" && cellElement.nodeName !== "TH") {
        cellElement = closest(cellElement, ["TD", "TH"]);
      }
      if (cellElement === null) {
        return null;
      }
      var TR = cellElement.parentNode;
      var CONTAINER = TR.parentNode;
      var row = index(TR);
      var col = cellElement.cellIndex;
      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {
        if (CONTAINER.nodeName === "THEAD") {
          row -= CONTAINER.childNodes.length;
        }
      } else if (overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {
        var totalRows = this.wot.getSetting("totalRows");
        row = totalRows - CONTAINER.childNodes.length + row;
      } else if (CONTAINER === this.THEAD) {
        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
      } else {
        row = this.rowFilter.renderedToSource(row);
      }
      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_LEFT, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {
        col = this.columnFilter.offsettedTH(col);
      } else {
        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);
      }
      return new CellCoords(row, col);
    }
  }, {
    key: "markOversizedRows",
    value: function markOversizedRows() {
      if (this.wot.getSetting("externalRowCalculator")) {
        return;
      }
      var rowCount = this.TBODY.childNodes.length;
      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;
      var actualTableHeight = innerHeight(this.TBODY) - 1;
      var previousRowHeight;
      var rowInnerHeight;
      var sourceRowIndex;
      var currentTr;
      var rowHeader;
      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting("fixedRowsBottom")) {
        return;
      }
      while (rowCount) {
        rowCount -= 1;
        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);
        previousRowHeight = this.getRowHeight(sourceRowIndex);
        currentTr = this.getTrForRow(sourceRowIndex);
        rowHeader = currentTr.querySelector("th");
        if (rowHeader) {
          rowInnerHeight = innerHeight(rowHeader);
        } else {
          rowInnerHeight = innerHeight(currentTr) - 1;
        }
        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {
          rowInnerHeight += 1;
          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;
        }
      }
    }
  }, {
    key: "getTrForRow",
    value: function getTrForRow(row) {
      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
    }
  }, {
    key: "isColumnHeaderRendered",
    value: function isColumnHeaderRendered(column) {
      if (column >= 0) {
        return false;
      }
      var rowHeaders = this.wot.getSetting("rowHeaders");
      var rowHeadersCount = rowHeaders.length;
      return Math.abs(column) <= rowHeadersCount;
    }
  }, {
    key: "isRowHeaderRendered",
    value: function isRowHeaderRendered(row) {
      if (row >= 0) {
        return false;
      }
      var columnHeaders = this.wot.getSetting("columnHeaders");
      var columnHeadersCount = columnHeaders.length;
      return Math.abs(row) <= columnHeadersCount;
    }
  }, {
    key: "isRowBeforeRenderedRows",
    value: function isRowBeforeRenderedRows(row) {
      var first = this.getFirstRenderedRow();
      if (row < 0 && first <= 0) {
        return !this.isRowHeaderRendered(row);
      }
      return row < first;
    }
  }, {
    key: "isRowAfterRenderedRows",
    value: function isRowAfterRenderedRows(row) {
      return row > this.getLastRenderedRow();
    }
  }, {
    key: "isColumnBeforeRenderedColumns",
    value: function isColumnBeforeRenderedColumns(column) {
      var first = this.getFirstRenderedColumn();
      if (column < 0 && first <= 0) {
        return !this.isColumnHeaderRendered(column);
      }
      return column < first;
    }
  }, {
    key: "isColumnAfterRenderedColumns",
    value: function isColumnAfterRenderedColumns(column) {
      return this.columnFilter && column > this.getLastRenderedColumn();
    }
  }, {
    key: "isColumnAfterViewport",
    value: function isColumnAfterViewport(column) {
      return this.columnFilter && column > this.getLastVisibleColumn();
    }
  }, {
    key: "isRowAfterViewport",
    value: function isRowAfterViewport(row) {
      return this.rowFilter && row > this.getLastVisibleRow();
    }
  }, {
    key: "isColumnBeforeViewport",
    value: function isColumnBeforeViewport(column) {
      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;
    }
  }, {
    key: "isLastRowFullyVisible",
    value: function isLastRowFullyVisible() {
      return this.getLastVisibleRow() === this.getLastRenderedRow();
    }
  }, {
    key: "isLastColumnFullyVisible",
    value: function isLastColumnFullyVisible() {
      return this.getLastVisibleColumn() === this.getLastRenderedColumn();
    }
  }, {
    key: "allRowsInViewport",
    value: function allRowsInViewport() {
      return this.wot.getSetting("totalRows") === this.getVisibleRowsCount();
    }
  }, {
    key: "allColumnsInViewport",
    value: function allColumnsInViewport() {
      return this.wot.getSetting("totalColumns") === this.getVisibleColumnsCount();
    }
  }, {
    key: "getRowHeight",
    value: function getRowHeight(sourceRow) {
      return this.rowUtils.getHeight(sourceRow);
    }
  }, {
    key: "getColumnHeaderHeight",
    value: function getColumnHeaderHeight(level) {
      return this.columnUtils.getHeaderHeight(level);
    }
  }, {
    key: "getColumnWidth",
    value: function getColumnWidth(sourceColumn) {
      return this.columnUtils.getWidth(sourceColumn);
    }
  }, {
    key: "getStretchedColumnWidth",
    value: function getStretchedColumnWidth(sourceColumn) {
      return this.columnUtils.getStretchedColumnWidth(sourceColumn);
    }
  }, {
    key: "hasDefinedSize",
    value: function hasDefinedSize() {
      return this.hasTableHeight && this.hasTableWidth;
    }
  }, {
    key: "isVisible",
    value: function isVisible$1() {
      return isVisible(this.TABLE);
    }
  }, {
    key: "_modifyRowHeaderWidth",
    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {
      var widths = isFunction$1(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;
      if (Array.isArray(widths)) {
        widths = _toConsumableArray$3(widths);
        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);
      } else {
        widths = this._correctRowHeaderWidth(widths);
      }
      return widths;
    }
  }, {
    key: "_correctRowHeaderWidth",
    value: function _correctRowHeaderWidth(width) {
      var rowHeaderWidth = width;
      if (typeof width !== "number") {
        rowHeaderWidth = this.wot.getSetting("defaultColumnWidth");
      }
      if (this.correctHeaderWidth) {
        rowHeaderWidth += 1;
      }
      return rowHeaderWidth;
    }
  }]);
  return Table2;
}();

var MIXIN_NAME = "calculatedRows";
var calculatedRows = {
  getFirstRenderedRow: function getFirstRenderedRow() {
    var startRow = this.wot.wtViewport.rowsRenderCalculator.startRow;
    if (startRow === null) {
      return -1;
    }
    return startRow;
  },
  getFirstVisibleRow: function getFirstVisibleRow() {
    var startRow = this.wot.wtViewport.rowsVisibleCalculator.startRow;
    if (startRow === null) {
      return -1;
    }
    return startRow;
  },
  getLastRenderedRow: function getLastRenderedRow() {
    var endRow = this.wot.wtViewport.rowsRenderCalculator.endRow;
    if (endRow === null) {
      return -1;
    }
    return endRow;
  },
  getLastVisibleRow: function getLastVisibleRow() {
    var endRow = this.wot.wtViewport.rowsVisibleCalculator.endRow;
    if (endRow === null) {
      return -1;
    }
    return endRow;
  },
  getRenderedRowsCount: function getRenderedRowsCount() {
    return this.wot.wtViewport.rowsRenderCalculator.count;
  },
  getVisibleRowsCount: function getVisibleRowsCount() {
    return this.wot.wtViewport.rowsVisibleCalculator.count;
  }
};
defineGetter(calculatedRows, "MIXIN_NAME", MIXIN_NAME, {
  writable: false,
  enumerable: false
});

var MIXIN_NAME$1 = "calculatedColumns";
var calculatedColumns = {
  getFirstRenderedColumn: function getFirstRenderedColumn() {
    var startColumn = this.wot.wtViewport.columnsRenderCalculator.startColumn;
    if (startColumn === null) {
      return -1;
    }
    return startColumn;
  },
  getFirstVisibleColumn: function getFirstVisibleColumn() {
    var startColumn = this.wot.wtViewport.columnsVisibleCalculator.startColumn;
    if (startColumn === null) {
      return -1;
    }
    return startColumn;
  },
  getLastRenderedColumn: function getLastRenderedColumn() {
    var endColumn = this.wot.wtViewport.columnsRenderCalculator.endColumn;
    if (endColumn === null) {
      return -1;
    }
    return endColumn;
  },
  getLastVisibleColumn: function getLastVisibleColumn() {
    var endColumn = this.wot.wtViewport.columnsVisibleCalculator.endColumn;
    if (endColumn === null) {
      return -1;
    }
    return endColumn;
  },
  getRenderedColumnsCount: function getRenderedColumnsCount() {
    return this.wot.wtViewport.columnsRenderCalculator.count;
  },
  getVisibleColumnsCount: function getVisibleColumnsCount() {
    return this.wot.wtViewport.columnsVisibleCalculator.count;
  }
};
defineGetter(calculatedColumns, "MIXIN_NAME", MIXIN_NAME$1, {
  writable: false,
  enumerable: false
});

function _typeof$b(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$b = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$b = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$b(obj);
}
function _classCallCheck$m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$m(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$m(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$m(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$m(Constructor, staticProps);
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o, p) {
  _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$6(o, p);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self, call) {
  if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$6(self);
}
function _assertThisInitialized$6(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$6(o) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$6(o);
}
var MasterTable = /* @__PURE__ */ function(_Table) {
  _inherits$6(MasterTable2, _Table);
  var _super = _createSuper$6(MasterTable2);
  function MasterTable2() {
    _classCallCheck$m(this, MasterTable2);
    return _super.apply(this, arguments);
  }
  _createClass$m(MasterTable2, [{
    key: "alignOverlaysWithTrimmingContainer",
    value: function alignOverlaysWithTrimmingContainer() {
      var trimmingElement = getTrimmingContainer(this.wtRootElement);
      var rootWindow = this.wot.rootWindow;
      if (trimmingElement === rootWindow) {
        var preventOverflow = this.wot.getSetting("preventOverflow");
        if (!preventOverflow) {
          this.holder.style.overflow = "visible";
          this.wtRootElement.style.overflow = "visible";
        }
      } else {
        var trimmingElementParent = trimmingElement.parentElement;
        var trimmingHeight = getStyle(trimmingElement, "height", rootWindow);
        var trimmingOverflow = getStyle(trimmingElement, "overflow", rootWindow);
        var holderStyle = this.holder.style;
        var scrollWidth = trimmingElement.scrollWidth, scrollHeight = trimmingElement.scrollHeight;
        var _trimmingElement$getB = trimmingElement.getBoundingClientRect(), width = _trimmingElement$getB.width, height = _trimmingElement$getB.height;
        var overflow = ["auto", "hidden", "scroll"];
        if (trimmingElementParent && overflow.includes(trimmingOverflow)) {
          var cloneNode = trimmingElement.cloneNode(false);
          cloneNode.style.overflow = "auto";
          if (trimmingElement.nextElementSibling) {
            trimmingElementParent.insertBefore(cloneNode, trimmingElement.nextElementSibling);
          } else {
            trimmingElementParent.appendChild(cloneNode);
          }
          var cloneHeight = parseInt(getComputedStyle(cloneNode, rootWindow).height, 10);
          trimmingElementParent.removeChild(cloneNode);
          if (cloneHeight === 0) {
            height = 0;
          }
        }
        height = Math.min(height, scrollHeight);
        holderStyle.height = trimmingHeight === "auto" ? "auto" : "".concat(height, "px");
        width = Math.min(width, scrollWidth);
        holderStyle.width = "".concat(width, "px");
        holderStyle.overflow = "";
        this.hasTableHeight = holderStyle.height === "auto" ? true : height > 0;
        this.hasTableWidth = width > 0;
      }
      this.isTableVisible = isVisible(this.TABLE);
    }
  }, {
    key: "markOversizedColumnHeaders",
    value: function markOversizedColumnHeaders() {
      var wot = this.wot;
      var overlayName = wot.getOverlayName();
      var columnHeaders = wot.getSetting("columnHeaders");
      var columnHeadersCount = columnHeaders.length;
      if (columnHeadersCount && !wot.wtViewport.hasOversizedColumnHeadersMarked[overlayName]) {
        var rowHeaders = wot.getSetting("rowHeaders");
        var rowHeaderCount = rowHeaders.length;
        var columnCount = this.getRenderedColumnsCount();
        for (var i = 0; i < columnHeadersCount; i++) {
          for (var renderedColumnIndex = -1 * rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
            this.markIfOversizedColumnHeader(renderedColumnIndex);
          }
        }
        wot.wtViewport.hasOversizedColumnHeadersMarked[overlayName] = true;
      }
    }
  }]);
  return MasterTable2;
}(Table);
mixin(MasterTable, calculatedRows);
mixin(MasterTable, calculatedColumns);

var MIXIN_NAME$2 = "stickyRowsBottom";
var stickyRowsBottom = {
  getFirstRenderedRow: function getFirstRenderedRow() {
    var totalRows = this.wot.getSetting("totalRows");
    var fixedRowsBottom = this.wot.getSetting("fixedRowsBottom");
    var index = totalRows - fixedRowsBottom;
    if (totalRows === 0 || fixedRowsBottom === 0) {
      return -1;
    }
    if (index < 0) {
      return 0;
    }
    return index;
  },
  getFirstVisibleRow: function getFirstVisibleRow() {
    return this.getFirstRenderedRow();
  },
  getLastRenderedRow: function getLastRenderedRow() {
    return this.wot.getSetting("totalRows") - 1;
  },
  getLastVisibleRow: function getLastVisibleRow() {
    return this.getLastRenderedRow();
  },
  getRenderedRowsCount: function getRenderedRowsCount() {
    var totalRows = this.wot.getSetting("totalRows");
    return Math.min(this.wot.getSetting("fixedRowsBottom"), totalRows);
  },
  getVisibleRowsCount: function getVisibleRowsCount() {
    return this.getRenderedRowsCount();
  }
};
defineGetter(stickyRowsBottom, "MIXIN_NAME", MIXIN_NAME$2, {
  writable: false,
  enumerable: false
});

var MIXIN_NAME$3 = "stickyColumnsLeft";
var stickyColumnsLeft = {
  getFirstRenderedColumn: function getFirstRenderedColumn() {
    var totalColumns = this.wot.getSetting("totalColumns");
    if (totalColumns === 0) {
      return -1;
    }
    return 0;
  },
  getFirstVisibleColumn: function getFirstVisibleColumn() {
    return this.getFirstRenderedColumn();
  },
  getLastRenderedColumn: function getLastRenderedColumn() {
    return this.getRenderedColumnsCount() - 1;
  },
  getLastVisibleColumn: function getLastVisibleColumn() {
    return this.getLastRenderedColumn();
  },
  getRenderedColumnsCount: function getRenderedColumnsCount() {
    var totalColumns = this.wot.getSetting("totalColumns");
    return Math.min(this.wot.getSetting("fixedColumnsLeft"), totalColumns);
  },
  getVisibleColumnsCount: function getVisibleColumnsCount() {
    return this.getRenderedColumnsCount();
  }
};
defineGetter(stickyColumnsLeft, "MIXIN_NAME", MIXIN_NAME$3, {
  writable: false,
  enumerable: false
});

function _typeof$c(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$c = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$c = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$c(obj);
}
function _classCallCheck$n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o, p) {
  _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$7(o, p);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result);
  };
}
function _possibleConstructorReturn$7(self, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$7(self);
}
function _assertThisInitialized$7(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$7(o) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$7(o);
}
var BottomLeftCornerOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$7(BottomLeftCornerOverlayTable2, _Table);
  var _super = _createSuper$7(BottomLeftCornerOverlayTable2);
  function BottomLeftCornerOverlayTable2() {
    _classCallCheck$n(this, BottomLeftCornerOverlayTable2);
    return _super.apply(this, arguments);
  }
  return BottomLeftCornerOverlayTable2;
}(Table);
mixin(BottomLeftCornerOverlayTable, stickyRowsBottom);
mixin(BottomLeftCornerOverlayTable, stickyColumnsLeft);

function stopImmediatePropagation(event) {
  event.isImmediatePropagationEnabled = false;
  event.cancelBubble = true;
}
function isImmediatePropagationStopped(event) {
  return event.isImmediatePropagationEnabled === false;
}
function isRightClick(event) {
  return event.button === 2;
}
function isLeftClick(event) {
  return event.button === 0;
}

var domEventHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  stopImmediatePropagation: stopImmediatePropagation,
  isImmediatePropagationStopped: isImmediatePropagationStopped,
  isRightClick: isRightClick,
  isLeftClick: isLeftClick
});

function _classCallCheck$o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$n(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$n(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$n(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$n(Constructor, staticProps);
  return Constructor;
}
var listenersCounter = 0;
var EventManager = /* @__PURE__ */ function() {
  function EventManager2() {
    var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    _classCallCheck$o(this, EventManager2);
    this.context = context || this;
    if (!this.context.eventListeners) {
      this.context.eventListeners = [];
    }
  }
  _createClass$n(EventManager2, [{
    key: "addEventListener",
    value: function addEventListener(element, eventName, callback) {
      var _this = this;
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      function callbackProxy(event) {
        callback.call(this, extendEvent(event));
      }
      if (typeof options !== "boolean" && !isPassiveEventSupported()) {
        options = false;
      }
      this.context.eventListeners.push({
        element,
        event: eventName,
        callback,
        callbackProxy,
        options,
        eventManager: this
      });
      element.addEventListener(eventName, callbackProxy, options);
      listenersCounter += 1;
      return function() {
        _this.removeEventListener(element, eventName, callback);
      };
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(element, eventName, callback) {
      var onlyOwnEvents = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var len = this.context.eventListeners.length;
      var tmpEvent;
      while (len) {
        len -= 1;
        tmpEvent = this.context.eventListeners[len];
        if (tmpEvent.event === eventName && tmpEvent.element === element) {
          if (callback && callback !== tmpEvent.callback) {
            continue;
          }
          if (onlyOwnEvents && tmpEvent.eventManager !== this) {
            continue;
          }
          this.context.eventListeners.splice(len, 1);
          tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, tmpEvent.options);
          listenersCounter -= 1;
        }
      }
    }
  }, {
    key: "clearEvents",
    value: function clearEvents() {
      var onlyOwnEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!this.context) {
        return;
      }
      var len = this.context.eventListeners.length;
      while (len) {
        len -= 1;
        var event = this.context.eventListeners[len];
        if (event) {
          this.removeEventListener(event.element, event.event, event.callback, onlyOwnEvents);
        }
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.clearEvents();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clearEvents();
      this.context = null;
    }
  }, {
    key: "destroyWithOwnEventsOnly",
    value: function destroyWithOwnEventsOnly() {
      this.clearEvents(true);
      this.context = null;
    }
  }, {
    key: "fireEvent",
    value: function fireEvent(element, eventName) {
      var rootDocument = element.document;
      var rootWindow = element;
      if (!rootDocument) {
        rootDocument = element.ownerDocument ? element.ownerDocument : element;
        rootWindow = rootDocument.defaultView;
      }
      var options = {
        bubbles: true,
        cancelable: eventName !== "mousemove",
        view: rootWindow,
        detail: 0,
        screenX: 0,
        screenY: 0,
        clientX: 1,
        clientY: 1,
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        metaKey: false,
        button: 0,
        relatedTarget: void 0
      };
      var event;
      if (rootDocument.createEvent) {
        event = rootDocument.createEvent("MouseEvents");
        event.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button,  rootDocument.body.parentNode);
      } else {
        event = rootDocument.createEventObject();
      }
      if (element.dispatchEvent) {
        element.dispatchEvent(event);
      } else {
        element.fireEvent("on".concat(eventName), event);
      }
    }
  }]);
  return EventManager2;
}();
function extendEvent(event) {
  var nativeStopImmediatePropagation = event.stopImmediatePropagation;
  event.stopImmediatePropagation = function() {
    nativeStopImmediatePropagation.apply(this);
    stopImmediatePropagation(this);
  };
  return event;
}
function getListenersCounter() {
  return listenersCounter;
}

function _classCallCheck$p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$o(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$o(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$o(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$o(Constructor, staticProps);
  return Constructor;
}
var Overlay = /* @__PURE__ */ function() {
  function Overlay2(wotInstance) {
    _classCallCheck$p(this, Overlay2);
    defineGetter(this, "wot", wotInstance, {
      writable: false
    });
    var _this$wot$wtTable = this.wot.wtTable, TABLE = _this$wot$wtTable.TABLE, hider = _this$wot$wtTable.hider, spreader = _this$wot$wtTable.spreader, holder = _this$wot$wtTable.holder, wtRootElement = _this$wot$wtTable.wtRootElement;
    this.instance = this.wot;
    this.type = "";
    this.mainTableScrollableElement = null;
    this.TABLE = TABLE;
    this.hider = hider;
    this.spreader = spreader;
    this.holder = holder;
    this.wtRootElement = wtRootElement;
    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
    this.updateStateOfRendering();
  }
  _createClass$o(Overlay2, [{
    key: "updateStateOfRendering",
    value: function updateStateOfRendering() {
      var previousState = this.needFullRender;
      this.needFullRender = this.shouldBeRendered();
      var changed = previousState !== this.needFullRender;
      if (changed && !this.needFullRender) {
        this.reset();
      }
      return changed;
    }
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return true;
    }
  }, {
    key: "updateTrimmingContainer",
    value: function updateTrimmingContainer() {
      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
    }
  }, {
    key: "updateMainScrollableElement",
    value: function updateMainScrollableElement() {
      var _this$wot = this.wot, wtTable = _this$wot.wtTable, rootWindow = _this$wot.rootWindow;
      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue("overflow") === "hidden") {
        this.mainTableScrollableElement = this.wot.wtTable.holder;
      } else {
        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);
      }
    }
  }, {
    key: "getRelativeCellPosition",
    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {
      if (this.clone.wtTable.holder.contains(element) === false) {
        warn$1("The provided element is not a child of the ".concat(this.type, " overlay"));
        return;
      }
      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;
      var fixedColumn = columnIndex < this.wot.getSetting("fixedColumnsLeft");
      var fixedRowTop = rowIndex < this.wot.getSetting("fixedRowsTop");
      var fixedRowBottom = rowIndex >= this.wot.getSetting("totalRows") - this.wot.getSetting("fixedRowsBottom");
      var spreaderOffset = {
        left: this.clone.wtTable.spreader.offsetLeft,
        top: this.clone.wtTable.spreader.offsetTop
      };
      var elementOffset = {
        left: element.offsetLeft,
        top: element.offsetTop
      };
      var offsetObject = null;
      if (windowScroll) {
        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);
      } else {
        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);
      }
      return offsetObject;
    }
  }, {
    key: "getRelativeCellPositionWithinWindow",
    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {
      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();
      var horizontalOffset = 0;
      var verticalOffset = 0;
      if (!onFixedColumn) {
        horizontalOffset = spreaderOffset.left;
      } else {
        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;
      }
      if (onFixedRowTop) {
        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();
        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;
      } else {
        verticalOffset = spreaderOffset.top;
      }
      return {
        left: elementOffset.left + horizontalOffset,
        top: elementOffset.top + verticalOffset
      };
    }
  }, {
    key: "getRelativeCellPositionWithinHolder",
    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {
      var tableScrollPosition = {
        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),
        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()
      };
      var horizontalOffset = 0;
      var verticalOffset = 0;
      if (!onFixedColumn) {
        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;
      }
      if (onFixedRowBottom) {
        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();
        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();
        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;
      } else if (!onFixedRowTop) {
        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;
      }
      return {
        left: elementOffset.left - horizontalOffset,
        top: elementOffset.top - verticalOffset
      };
    }
  }, {
    key: "makeClone",
    value: function makeClone(direction) {
      if (CLONE_TYPES.indexOf(direction) === -1) {
        throw new Error('Clone type "'.concat(direction, '" is not supported.'));
      }
      var _this$wot2 = this.wot, wtTable = _this$wot2.wtTable, rootDocument = _this$wot2.rootDocument, rootWindow = _this$wot2.rootWindow;
      var clone = rootDocument.createElement("DIV");
      var clonedTable = rootDocument.createElement("TABLE");
      var tableParent = wtTable.wtRootElement.parentNode;
      clone.className = "ht_clone_".concat(direction, " handsontable");
      clone.style.position = "absolute";
      clone.style.top = 0;
      clone.style.left = 0;
      clone.style.overflow = "visible";
      clonedTable.className = wtTable.TABLE.className;
      clone.appendChild(clonedTable);
      this.type = direction;
      tableParent.appendChild(clone);
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (preventOverflow === true || preventOverflow === "horizontal" && this.type === CLONE_TOP || preventOverflow === "vertical" && this.type === CLONE_LEFT) {
        this.mainTableScrollableElement = rootWindow;
      } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue("overflow") === "hidden") {
        this.mainTableScrollableElement = wtTable.holder;
      } else {
        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);
      }
      return new this.wot.constructor({
        cloneSource: this.wot,
        cloneOverlay: this,
        table: clonedTable
      });
    }
  }, {
    key: "refresh",
    value: function refresh() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var nextCycleRenderFlag = this.shouldBeRendered();
      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {
        this.clone.draw(fastDraw);
      }
      this.needFullRender = nextCycleRenderFlag;
    }
  }, {
    key: "reset",
    value: function reset() {
      if (!this.clone) {
        return;
      }
      var holder = this.clone.wtTable.holder;
      var hider = this.clone.wtTable.hider;
      var holderStyle = holder.style;
      var hidderStyle = hider.style;
      var rootStyle = holder.parentNode.style;
      arrayEach([holderStyle, hidderStyle, rootStyle], function(style) {
        style.width = "";
        style.height = "";
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      new EventManager(this.clone).destroy();
    }
  }]);
  return Overlay2;
}();

function _typeof$d(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$d = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$d = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$d(obj);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$8()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$8(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _classCallCheck$q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$p(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$p(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$p(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$p(Constructor, staticProps);
  return Constructor;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o, p) {
  _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$8(o, p);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result);
  };
}
function _possibleConstructorReturn$8(self, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$8(self);
}
function _assertThisInitialized$8(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$8(o) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$8(o);
}
var BottomLeftCornerOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$8(BottomLeftCornerOverlay2, _Overlay);
  var _super = _createSuper$8(BottomLeftCornerOverlay2);
  function BottomLeftCornerOverlay2(wotInstance) {
    var _this;
    _classCallCheck$q(this, BottomLeftCornerOverlay2);
    _this = _super.call(this, wotInstance);
    _this.clone = _this.makeClone(CLONE_BOTTOM_LEFT_CORNER);
    return _this;
  }
  _createClass$p(BottomLeftCornerOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct(BottomLeftCornerOverlayTable, args);
    }
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      var wot = this.wot;
      return wot.getSetting("shouldRenderBottomOverlay") && wot.getSetting("shouldRenderLeftOverlay");
    }
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      var wot = this.wot;
      this.updateTrimmingContainer();
      if (!wot.wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      overlayRoot.style.top = "";
      if (this.trimmingContainer === wot.rootWindow) {
        var _this$wot = this.wot, rootDocument = _this$wot.rootDocument, wtTable = _this$wot.wtTable;
        var hiderRect = wtTable.hider.getBoundingClientRect();
        var bottom = Math.ceil(hiderRect.bottom);
        var left = Math.ceil(hiderRect.left);
        var bodyHeight = rootDocument.documentElement.clientHeight;
        var finalLeft;
        var finalBottom;
        if (left < 0) {
          finalLeft = -left;
        } else {
          finalLeft = 0;
        }
        if (bottom > bodyHeight) {
          finalBottom = bottom - bodyHeight;
        } else {
          finalBottom = 0;
        }
        finalBottom += "px";
        finalLeft += "px";
        overlayRoot.style.left = finalLeft;
        overlayRoot.style.bottom = finalBottom;
      } else {
        resetCssTransform(overlayRoot);
        this.repositionOverlay();
      }
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      var tableWidth = outerWidth(this.clone.wtTable.TABLE);
      if (!this.wot.wtTable.hasDefinedSize()) {
        tableHeight = 0;
      }
      overlayRoot.style.height = "".concat(tableHeight, "px");
      overlayRoot.style.width = "".concat(tableWidth, "px");
      return false;
    }
  }, {
    key: "repositionOverlay",
    value: function repositionOverlay() {
      var _this$wot2 = this.wot, wtTable = _this$wot2.wtTable, rootDocument = _this$wot2.rootDocument;
      var cloneRoot = this.clone.wtTable.holder.parentNode;
      var scrollbarWidth = getScrollbarWidth(rootDocument);
      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {
        scrollbarWidth = 0;
      }
      cloneRoot.style.bottom = "".concat(scrollbarWidth, "px");
    }
  }], [{
    key: "OVERLAY_NAME",
    get: function get() {
      return CLONE_BOTTOM_LEFT_CORNER;
    }
  }]);
  return BottomLeftCornerOverlay2;
}(Overlay);

function _typeof$e(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$e = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$e = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$e(obj);
}
function _classCallCheck$r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o, p) {
  _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$9(o, p);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result);
  };
}
function _possibleConstructorReturn$9(self, call) {
  if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$9(self);
}
function _assertThisInitialized$9(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$9(o) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$9(o);
}
var BottomOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$9(BottomOverlayTable2, _Table);
  var _super = _createSuper$9(BottomOverlayTable2);
  function BottomOverlayTable2() {
    _classCallCheck$r(this, BottomOverlayTable2);
    return _super.apply(this, arguments);
  }
  return BottomOverlayTable2;
}(Table);
mixin(BottomOverlayTable, stickyRowsBottom);
mixin(BottomOverlayTable, calculatedColumns);

function _typeof$f(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$f = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$f = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$f(obj);
}
function _construct$1(Parent, args, Class) {
  if (_isNativeReflectConstruct$a()) {
    _construct$1 = Reflect.construct;
  } else {
    _construct$1 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$a(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$1.apply(null, arguments);
}
function _classCallCheck$s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$q(Constructor, staticProps);
  return Constructor;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o, p) {
  _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$a(o, p);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self, call) {
  if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$a(self);
}
function _assertThisInitialized$a(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$a(o) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$a(o);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var BottomOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$a(BottomOverlay2, _Overlay);
  var _super = _createSuper$a(BottomOverlay2);
  function BottomOverlay2(wotInstance) {
    var _this;
    _classCallCheck$s(this, BottomOverlay2);
    _this = _super.call(this, wotInstance);
    _defineProperty$1(_assertThisInitialized$a(_this), "cachedFixedRowsBottom", -1);
    _this.clone = _this.makeClone(CLONE_BOTTOM);
    _this.cachedFixedRowsBottom = _this.wot.getSetting("fixedRowsBottom");
    return _this;
  }
  _createClass$q(BottomOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct$1(BottomOverlayTable, args);
    }
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wot.getSetting("shouldRenderBottomOverlay");
    }
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      overlayRoot.style.top = "";
      var headerPosition = 0;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer === this.wot.rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
        var _this$wot = this.wot, rootDocument = _this$wot.rootDocument, wtTable = _this$wot.wtTable;
        var hiderRect = wtTable.hider.getBoundingClientRect();
        var bottom = Math.ceil(hiderRect.bottom);
        var bodyHeight = rootDocument.documentElement.clientHeight;
        var finalLeft;
        var finalBottom;
        finalLeft = wtTable.hider.style.left;
        finalLeft = finalLeft === "" ? 0 : finalLeft;
        if (bottom > bodyHeight) {
          finalBottom = bottom - bodyHeight;
        } else {
          finalBottom = 0;
        }
        headerPosition = finalBottom;
        finalBottom += "px";
        overlayRoot.style.left = finalLeft;
        overlayRoot.style.bottom = finalBottom;
      } else {
        headerPosition = this.getScrollPosition();
        this.repositionOverlay();
      }
      var positionChanged = this.adjustHeaderBordersPosition(headerPosition);
      this.adjustElementsSize();
      return positionChanged;
    }
  }, {
    key: "repositionOverlay",
    value: function repositionOverlay() {
      var _this$wot2 = this.wot, wtTable = _this$wot2.wtTable, rootDocument = _this$wot2.rootDocument;
      var cloneRoot = this.clone.wtTable.holder.parentNode;
      var scrollbarWidth = getScrollbarWidth(rootDocument);
      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {
        scrollbarWidth = 0;
      }
      cloneRoot.style.bottom = "".concat(scrollbarWidth, "px");
    }
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(pos) {
      var rootWindow = this.wot.rootWindow;
      var result = false;
      if (this.mainTableScrollableElement === rootWindow) {
        rootWindow.scrollTo(getWindowScrollLeft(rootWindow), pos);
        result = true;
      } else if (this.mainTableScrollableElement.scrollTop !== pos) {
        this.mainTableScrollableElement.scrollTop = pos;
        result = true;
      }
      return result;
    }
  }, {
    key: "onScroll",
    value: function onScroll() {
      this.wot.getSetting("onScrollHorizontally");
    }
  }, {
    key: "sumCellSizes",
    value: function sumCellSizes(from, to) {
      var _this$wot3 = this.wot, wtTable = _this$wot3.wtTable, wtSettings = _this$wot3.wtSettings;
      var defaultRowHeight = wtSettings.settings.defaultRowHeight;
      var row = from;
      var sum = 0;
      while (row < to) {
        var height = wtTable.getRowHeight(row);
        sum += height === void 0 ? defaultRowHeight : height;
        row += 1;
      }
      return sum;
    }
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.updateTrimmingContainer();
      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildrenSize();
      }
    }
  }, {
    key: "adjustRootElementSize",
    value: function adjustRootElementSize() {
      var _this$wot4 = this.wot, wtTable = _this$wot4.wtTable, wtViewport = _this$wot4.wtViewport, rootWindow = _this$wot4.rootWindow;
      var scrollbarWidth = getScrollbarWidth(this.wot.rootDocument);
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer !== rootWindow || preventOverflow === "horizontal") {
        var width = wtViewport.getWorkspaceWidth();
        if (this.wot.wtOverlays.hasScrollbarRight) {
          width -= scrollbarWidth;
        }
        width = Math.min(width, wtTable.wtRootElement.scrollWidth);
        overlayRootStyle.width = "".concat(width, "px");
      } else {
        overlayRootStyle.width = "";
      }
      this.clone.wtTable.holder.style.width = overlayRootStyle.width;
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      if (!this.wot.wtTable.hasDefinedSize()) {
        tableHeight = 0;
      }
      overlayRootStyle.height = "".concat(tableHeight, "px");
    }
  }, {
    key: "adjustRootChildrenSize",
    value: function adjustRootChildrenSize() {
      var holder = this.clone.wtTable.holder;
      this.clone.wtTable.hider.style.width = this.hider.style.width;
      holder.style.width = holder.parentNode.style.width;
      holder.style.height = holder.parentNode.style.height;
    }
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var total = this.wot.getSetting("totalRows");
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
        this.spreader.style.top = "".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, "px");
      } else if (total === 0) {
        this.spreader.style.top = "0";
      } else {
        throw new Error("Incorrect value of the rowsRenderCalculator");
      }
      this.spreader.style.bottom = "";
      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }
  }, {
    key: "syncOverlayOffset",
    value: function syncOverlayOffset() {
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
        this.clone.wtTable.spreader.style.left = "".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, "px");
      } else {
        this.clone.wtTable.spreader.style.left = "";
      }
    }
  }, {
    key: "scrollTo",
    value: function scrollTo(sourceRow, bottomEdge) {
      var newY = this.getTableParentOffset();
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var scrollbarCompensation = 0;
      if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
        scrollbarCompensation = getScrollbarWidth(this.wot.rootDocument);
      }
      if (bottomEdge) {
        newY += this.sumCellSizes(0, sourceRow + 1);
        newY -= this.wot.wtViewport.getViewportHeight();
        newY += 1;
      } else {
        newY += this.sumCellSizes(this.wot.getSetting("fixedRowsBottom"), sourceRow);
      }
      newY += scrollbarCompensation;
      this.setScrollPosition(newY);
    }
  }, {
    key: "getTableParentOffset",
    value: function getTableParentOffset() {
      if (this.mainTableScrollableElement === this.wot.rootWindow) {
        return this.wot.wtTable.holderOffset.top;
      }
      return 0;
    }
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return getScrollTop(this.mainTableScrollableElement, this.wot.rootWindow);
    }
  }, {
    key: "adjustHeaderBordersPosition",
    value: function adjustHeaderBordersPosition(position) {
      var fixedRowsBottom = this.wot.getSetting("fixedRowsBottom");
      var areFixedRowsBottomChanged = this.cachedFixedRowsBottom !== fixedRowsBottom;
      var columnHeaders = this.wot.getSetting("columnHeaders");
      var positionChanged = false;
      if ((areFixedRowsBottomChanged || fixedRowsBottom === 0) && columnHeaders.length > 0) {
        var masterParent = this.wot.wtTable.holder.parentNode;
        var previousState = hasClass(masterParent, "innerBorderBottom");
        this.cachedFixedRowsBottom = this.wot.getSetting("fixedRowsBottom");
        if (position || this.wot.getSetting("totalRows") === 0) {
          addClass(masterParent, "innerBorderBottom");
          positionChanged = !previousState;
        } else {
          removeClass(masterParent, "innerBorderBottom");
          positionChanged = previousState;
        }
      }
      return positionChanged;
    }
  }], [{
    key: "OVERLAY_NAME",
    get: function get() {
      return CLONE_BOTTOM;
    }
  }]);
  return BottomOverlay2;
}(Overlay);

function _typeof$g(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$g = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$g = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$g(obj);
}
function _classCallCheck$t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o, p) {
  _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$b(o, p);
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _possibleConstructorReturn$b(self, call) {
  if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$b(self);
}
function _assertThisInitialized$b(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$b(o) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$b(o);
}
var LeftOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$b(LeftOverlayTable2, _Table);
  var _super = _createSuper$b(LeftOverlayTable2);
  function LeftOverlayTable2() {
    _classCallCheck$t(this, LeftOverlayTable2);
    return _super.apply(this, arguments);
  }
  return LeftOverlayTable2;
}(Table);
mixin(LeftOverlayTable, calculatedRows);
mixin(LeftOverlayTable, stickyColumnsLeft);

function _typeof$h(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$h = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$h = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$h(obj);
}
function _construct$2(Parent, args, Class) {
  if (_isNativeReflectConstruct$c()) {
    _construct$2 = Reflect.construct;
  } else {
    _construct$2 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$c(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$2.apply(null, arguments);
}
function _classCallCheck$u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$r(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$r(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$r(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$r(Constructor, staticProps);
  return Constructor;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o, p) {
  _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$c(o, p);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$c(this, result);
  };
}
function _possibleConstructorReturn$c(self, call) {
  if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$c(self);
}
function _assertThisInitialized$c(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$c(o) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$c(o);
}
var LeftOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$c(LeftOverlay2, _Overlay);
  var _super = _createSuper$c(LeftOverlay2);
  function LeftOverlay2(wotInstance) {
    var _this;
    _classCallCheck$u(this, LeftOverlay2);
    _this = _super.call(this, wotInstance);
    _this.clone = _this.makeClone(CLONE_LEFT);
    return _this;
  }
  _createClass$r(LeftOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct$2(LeftOverlayTable, args);
    }
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wot.getSetting("shouldRenderLeftOverlay");
    }
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      var wtTable = this.wot.wtTable;
      if (!this.needFullRender || !wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var headerPosition = 0;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer === this.wot.rootWindow && (!preventOverflow || preventOverflow !== "horizontal")) {
        var hiderRect = wtTable.hider.getBoundingClientRect();
        var left = Math.ceil(hiderRect.left);
        var right = Math.ceil(hiderRect.right);
        var finalLeft;
        var finalTop;
        finalTop = wtTable.hider.style.top;
        finalTop = finalTop === "" ? 0 : finalTop;
        if (left < 0 && right - overlayRoot.offsetWidth > 0) {
          finalLeft = -left;
        } else {
          finalLeft = 0;
        }
        headerPosition = finalLeft;
        finalLeft += "px";
        setOverlayPosition(overlayRoot, finalLeft, finalTop);
      } else {
        headerPosition = this.getScrollPosition();
        resetCssTransform(overlayRoot);
      }
      var positionChanged = this.adjustHeaderBordersPosition(headerPosition);
      this.adjustElementsSize();
      return positionChanged;
    }
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(pos) {
      var rootWindow = this.wot.rootWindow;
      var result = false;
      if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {
        rootWindow.scrollTo(pos, getWindowScrollTop(rootWindow));
        result = true;
      } else if (this.mainTableScrollableElement.scrollLeft !== pos) {
        this.mainTableScrollableElement.scrollLeft = pos;
        result = true;
      }
      return result;
    }
  }, {
    key: "onScroll",
    value: function onScroll() {
      this.wot.getSetting("onScrollVertically");
    }
  }, {
    key: "sumCellSizes",
    value: function sumCellSizes(from, to) {
      var defaultColumnWidth = this.wot.wtSettings.defaultColumnWidth;
      var column = from;
      var sum = 0;
      while (column < to) {
        sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;
        column += 1;
      }
      return sum;
    }
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.updateTrimmingContainer();
      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildrenSize();
      }
    }
  }, {
    key: "adjustRootElementSize",
    value: function adjustRootElementSize() {
      var _this$wot = this.wot, wtTable = _this$wot.wtTable, rootDocument = _this$wot.rootDocument, rootWindow = _this$wot.rootWindow;
      var scrollbarHeight = getScrollbarWidth(rootDocument);
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer !== rootWindow || preventOverflow === "vertical") {
        var height = this.wot.wtViewport.getWorkspaceHeight();
        if (this.wot.wtOverlays.hasScrollbarBottom) {
          height -= scrollbarHeight;
        }
        height = Math.min(height, wtTable.wtRootElement.scrollHeight);
        overlayRootStyle.height = "".concat(height, "px");
      } else {
        overlayRootStyle.height = "";
      }
      this.clone.wtTable.holder.style.height = overlayRootStyle.height;
      var tableWidth = outerWidth(this.clone.wtTable.TABLE);
      overlayRootStyle.width = "".concat(tableWidth, "px");
    }
  }, {
    key: "adjustRootChildrenSize",
    value: function adjustRootChildrenSize() {
      var _selections$getCell$g;
      var holder = this.clone.wtTable.holder;
      var selections = this.wot.selections;
      var selectionCornerOffset = Math.abs((_selections$getCell$g = selections === null || selections === void 0 ? void 0 : selections.getCell().getBorder(this.wot).cornerCenterPointOffset) !== null && _selections$getCell$g !== void 0 ? _selections$getCell$g : 0);
      this.clone.wtTable.hider.style.height = this.hider.style.height;
      holder.style.height = holder.parentNode.style.height;
      holder.style.width = "".concat(parseInt(holder.parentNode.style.width, 10) + selectionCornerOffset, "px");
    }
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var total = this.wot.getSetting("totalColumns");
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
        this.spreader.style.left = "".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, "px");
      } else if (total === 0) {
        this.spreader.style.left = "0";
      } else {
        throw new Error("Incorrect value of the columnsRenderCalculator");
      }
      this.spreader.style.right = "";
      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }
  }, {
    key: "syncOverlayOffset",
    value: function syncOverlayOffset() {
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
        this.clone.wtTable.spreader.style.top = "".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, "px");
      } else {
        this.clone.wtTable.spreader.style.top = "";
      }
    }
  }, {
    key: "scrollTo",
    value: function scrollTo(sourceCol, beyondRendered) {
      var newX = this.getTableParentOffset();
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var scrollbarCompensation = 0;
      if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {
        scrollbarCompensation = getScrollbarWidth(this.wot.rootDocument);
      }
      if (beyondRendered) {
        newX += this.sumCellSizes(0, sourceCol + 1);
        newX -= this.wot.wtViewport.getViewportWidth();
      } else {
        newX += this.sumCellSizes(this.wot.getSetting("fixedColumnsLeft"), sourceCol);
      }
      newX += scrollbarCompensation;
      return this.setScrollPosition(newX);
    }
  }, {
    key: "getTableParentOffset",
    value: function getTableParentOffset() {
      var preventOverflow = this.wot.getSetting("preventOverflow");
      var offset = 0;
      if (!preventOverflow && this.trimmingContainer === this.wot.rootWindow) {
        offset = this.wot.wtTable.holderOffset.left;
      }
      return offset;
    }
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return getScrollLeft(this.mainTableScrollableElement, this.wot.rootWindow);
    }
  }, {
    key: "adjustHeaderBordersPosition",
    value: function adjustHeaderBordersPosition(position) {
      var masterParent = this.wot.wtTable.holder.parentNode;
      var rowHeaders = this.wot.getSetting("rowHeaders");
      var fixedColumnsLeft = this.wot.getSetting("fixedColumnsLeft");
      var totalRows = this.wot.getSetting("totalRows");
      if (totalRows) {
        removeClass(masterParent, "emptyRows");
      } else {
        addClass(masterParent, "emptyRows");
      }
      var positionChanged = false;
      if (fixedColumnsLeft && !rowHeaders.length) {
        addClass(masterParent, "innerBorderLeft");
      } else if (!fixedColumnsLeft && rowHeaders.length) {
        var previousState = hasClass(masterParent, "innerBorderLeft");
        if (position) {
          addClass(masterParent, "innerBorderLeft");
          positionChanged = !previousState;
        } else {
          removeClass(masterParent, "innerBorderLeft");
          positionChanged = previousState;
        }
      }
      return positionChanged;
    }
  }], [{
    key: "OVERLAY_NAME",
    get: function get() {
      return CLONE_LEFT;
    }
  }]);
  return LeftOverlay2;
}(Overlay);

var MIXIN_NAME$4 = "stickyRowsTop";
var stickyRowsTop = {
  getFirstRenderedRow: function getFirstRenderedRow() {
    var totalRows = this.wot.getSetting("totalRows");
    if (totalRows === 0) {
      return -1;
    }
    return 0;
  },
  getFirstVisibleRow: function getFirstVisibleRow() {
    return this.getFirstRenderedRow();
  },
  getLastRenderedRow: function getLastRenderedRow() {
    return this.getRenderedRowsCount() - 1;
  },
  getLastVisibleRow: function getLastVisibleRow() {
    return this.getLastRenderedRow();
  },
  getRenderedRowsCount: function getRenderedRowsCount() {
    var totalRows = this.wot.getSetting("totalRows");
    return Math.min(this.wot.getSetting("fixedRowsTop"), totalRows);
  },
  getVisibleRowsCount: function getVisibleRowsCount() {
    return this.getRenderedRowsCount();
  }
};
defineGetter(stickyRowsTop, "MIXIN_NAME", MIXIN_NAME$4, {
  writable: false,
  enumerable: false
});

function _typeof$i(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$i = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$i = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$i(obj);
}
function _classCallCheck$v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o, p) {
  _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$d(o, p);
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$d(this, result);
  };
}
function _possibleConstructorReturn$d(self, call) {
  if (call && (_typeof$i(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$d(self);
}
function _assertThisInitialized$d(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$d(o) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$d(o);
}
var TopLeftCornerOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$d(TopLeftCornerOverlayTable2, _Table);
  var _super = _createSuper$d(TopLeftCornerOverlayTable2);
  function TopLeftCornerOverlayTable2() {
    _classCallCheck$v(this, TopLeftCornerOverlayTable2);
    return _super.apply(this, arguments);
  }
  return TopLeftCornerOverlayTable2;
}(Table);
mixin(TopLeftCornerOverlayTable, stickyRowsTop);
mixin(TopLeftCornerOverlayTable, stickyColumnsLeft);

function _typeof$j(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$j = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$j = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$j(obj);
}
function _construct$3(Parent, args, Class) {
  if (_isNativeReflectConstruct$e()) {
    _construct$3 = Reflect.construct;
  } else {
    _construct$3 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$e(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$3.apply(null, arguments);
}
function _classCallCheck$w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$s(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$s(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$s(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$s(Constructor, staticProps);
  return Constructor;
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o, p) {
  _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$e(o, p);
}
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$e(this, result);
  };
}
function _possibleConstructorReturn$e(self, call) {
  if (call && (_typeof$j(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$e(self);
}
function _assertThisInitialized$e(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$e(o) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$e(o);
}
var TopLeftCornerOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$e(TopLeftCornerOverlay2, _Overlay);
  var _super = _createSuper$e(TopLeftCornerOverlay2);
  function TopLeftCornerOverlay2(wotInstance) {
    var _this;
    _classCallCheck$w(this, TopLeftCornerOverlay2);
    _this = _super.call(this, wotInstance);
    _this.clone = _this.makeClone(CLONE_TOP_LEFT_CORNER);
    return _this;
  }
  _createClass$s(TopLeftCornerOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct$3(TopLeftCornerOverlayTable, args);
    }
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      var wot = this.wot;
      return wot.getSetting("shouldRenderTopOverlay") && wot.getSetting("shouldRenderLeftOverlay");
    }
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      this.updateTrimmingContainer();
      if (!this.wot.wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer === this.wot.rootWindow) {
        var wtTable = this.wot.wtTable;
        var hiderRect = wtTable.hider.getBoundingClientRect();
        var top = Math.ceil(hiderRect.top);
        var left = Math.ceil(hiderRect.left);
        var bottom = Math.ceil(hiderRect.bottom);
        var right = Math.ceil(hiderRect.right);
        var finalLeft = "0";
        var finalTop = "0";
        if (!preventOverflow || preventOverflow === "vertical") {
          if (left < 0 && right - overlayRoot.offsetWidth > 0) {
            finalLeft = "".concat(-left, "px");
          }
        }
        if (!preventOverflow || preventOverflow === "horizontal") {
          if (top < 0 && bottom - overlayRoot.offsetHeight > 0) {
            finalTop = "".concat(-top, "px");
          }
        }
        setOverlayPosition(overlayRoot, finalLeft, finalTop);
      } else {
        resetCssTransform(overlayRoot);
      }
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      var tableWidth = outerWidth(this.clone.wtTable.TABLE);
      if (!this.wot.wtTable.hasDefinedSize()) {
        tableHeight = 0;
      }
      overlayRoot.style.height = "".concat(tableHeight, "px");
      overlayRoot.style.width = "".concat(tableWidth, "px");
      return false;
    }
  }], [{
    key: "OVERLAY_NAME",
    get: function get() {
      return CLONE_TOP_LEFT_CORNER;
    }
  }]);
  return TopLeftCornerOverlay2;
}(Overlay);

function _typeof$k(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$k = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$k = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$k(obj);
}
function _classCallCheck$x(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$f(subClass, superClass);
}
function _setPrototypeOf$f(o, p) {
  _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$f(o, p);
}
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$f(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$f(this, result);
  };
}
function _possibleConstructorReturn$f(self, call) {
  if (call && (_typeof$k(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$f(self);
}
function _assertThisInitialized$f(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$f(o) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$f(o);
}
var TopOverlayTable = /* @__PURE__ */ function(_Table) {
  _inherits$f(TopOverlayTable2, _Table);
  var _super = _createSuper$f(TopOverlayTable2);
  function TopOverlayTable2() {
    _classCallCheck$x(this, TopOverlayTable2);
    return _super.apply(this, arguments);
  }
  return TopOverlayTable2;
}(Table);
mixin(TopOverlayTable, stickyRowsTop);
mixin(TopOverlayTable, calculatedColumns);

function _typeof$l(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$l = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$l = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$l(obj);
}
function _construct$4(Parent, args, Class) {
  if (_isNativeReflectConstruct$g()) {
    _construct$4 = Reflect.construct;
  } else {
    _construct$4 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$g(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$4.apply(null, arguments);
}
function _classCallCheck$y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$t(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$t(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$t(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$t(Constructor, staticProps);
  return Constructor;
}
function _inherits$g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$g(subClass, superClass);
}
function _setPrototypeOf$g(o, p) {
  _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$g(o, p);
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$g(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$g(this, result);
  };
}
function _possibleConstructorReturn$g(self, call) {
  if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$g(self);
}
function _assertThisInitialized$g(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$g(o) {
  _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$g(o);
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var TopOverlay = /* @__PURE__ */ function(_Overlay) {
  _inherits$g(TopOverlay2, _Overlay);
  var _super = _createSuper$g(TopOverlay2);
  function TopOverlay2(wotInstance) {
    var _this;
    _classCallCheck$y(this, TopOverlay2);
    _this = _super.call(this, wotInstance);
    _defineProperty$2(_assertThisInitialized$g(_this), "cachedFixedRowsTop", -1);
    _this.clone = _this.makeClone(CLONE_TOP);
    _this.cachedFixedRowsTop = _this.wot.getSetting("fixedRowsTop");
    return _this;
  }
  _createClass$t(TopOverlay2, [{
    key: "createTable",
    value: function createTable() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _construct$4(TopOverlayTable, args);
    }
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wot.getSetting("shouldRenderTopOverlay");
    }
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      var headerPosition = 0;
      var skipInnerBorderAdjusting = false;
      if (this.trimmingContainer === this.wot.rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
        var wtTable = this.wot.wtTable;
        var hiderRect = wtTable.hider.getBoundingClientRect();
        var top = Math.ceil(hiderRect.top);
        var bottom = Math.ceil(hiderRect.bottom);
        var rootHeight = overlayRoot.offsetHeight;
        skipInnerBorderAdjusting = bottom === rootHeight;
        var finalLeft;
        var finalTop;
        finalLeft = wtTable.hider.style.left;
        finalLeft = finalLeft === "" ? 0 : finalLeft;
        if (top < 0 && bottom - rootHeight > 0) {
          finalTop = -top;
        } else {
          finalTop = 0;
        }
        headerPosition = finalTop;
        finalTop += "px";
        setOverlayPosition(overlayRoot, finalLeft, finalTop);
      } else {
        headerPosition = this.getScrollPosition();
        resetCssTransform(overlayRoot);
      }
      var positionChanged = this.adjustHeaderBordersPosition(headerPosition, skipInnerBorderAdjusting);
      this.adjustElementsSize();
      return positionChanged;
    }
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(pos) {
      var rootWindow = this.wot.rootWindow;
      var result = false;
      if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollY !== pos) {
        rootWindow.scrollTo(getWindowScrollLeft(rootWindow), pos);
        result = true;
      } else if (this.mainTableScrollableElement.scrollTop !== pos) {
        this.mainTableScrollableElement.scrollTop = pos;
        result = true;
      }
      return result;
    }
  }, {
    key: "onScroll",
    value: function onScroll() {
      this.wot.getSetting("onScrollHorizontally");
    }
  }, {
    key: "sumCellSizes",
    value: function sumCellSizes(from, to) {
      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
      var row = from;
      var sum = 0;
      while (row < to) {
        var height = this.wot.wtTable.getRowHeight(row);
        sum += height === void 0 ? defaultRowHeight : height;
        row += 1;
      }
      return sum;
    }
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.updateTrimmingContainer();
      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildrenSize();
      }
    }
  }, {
    key: "adjustRootElementSize",
    value: function adjustRootElementSize() {
      var _this$wot = this.wot, wtTable = _this$wot.wtTable, rootDocument = _this$wot.rootDocument, rootWindow = _this$wot.rootWindow;
      var scrollbarWidth = getScrollbarWidth(rootDocument);
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer !== rootWindow || preventOverflow === "horizontal") {
        var width = this.wot.wtViewport.getWorkspaceWidth();
        if (this.wot.wtOverlays.hasScrollbarRight) {
          width -= scrollbarWidth;
        }
        width = Math.min(width, wtTable.wtRootElement.scrollWidth);
        overlayRootStyle.width = "".concat(width, "px");
      } else {
        overlayRootStyle.width = "";
      }
      this.clone.wtTable.holder.style.width = overlayRootStyle.width;
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      if (!this.wot.wtTable.hasDefinedSize()) {
        tableHeight = 0;
      }
      overlayRootStyle.height = "".concat(tableHeight, "px");
    }
  }, {
    key: "adjustRootChildrenSize",
    value: function adjustRootChildrenSize() {
      var _selections$getCell$g;
      var holder = this.clone.wtTable.holder;
      var selections = this.wot.selections;
      var selectionCornerOffset = Math.abs((_selections$getCell$g = selections === null || selections === void 0 ? void 0 : selections.getCell().getBorder(this.wot).cornerCenterPointOffset) !== null && _selections$getCell$g !== void 0 ? _selections$getCell$g : 0);
      this.clone.wtTable.hider.style.width = this.hider.style.width;
      holder.style.width = holder.parentNode.style.width;
      holder.style.height = "".concat(parseInt(holder.parentNode.style.height, 10) + selectionCornerOffset, "px");
    }
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var total = this.wot.getSetting("totalRows");
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
        this.spreader.style.top = "".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, "px");
      } else if (total === 0) {
        this.spreader.style.top = "0";
      } else {
        throw new Error("Incorrect value of the rowsRenderCalculator");
      }
      this.spreader.style.bottom = "";
      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }
  }, {
    key: "syncOverlayOffset",
    value: function syncOverlayOffset() {
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
        this.clone.wtTable.spreader.style.left = "".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, "px");
      } else {
        this.clone.wtTable.spreader.style.left = "";
      }
    }
  }, {
    key: "scrollTo",
    value: function scrollTo(sourceRow, bottomEdge) {
      var wot = this.wot;
      var sourceInstance = wot.cloneSource ? wot.cloneSource : wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var newY = this.getTableParentOffset();
      var scrollbarCompensation = 0;
      if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
        scrollbarCompensation = getScrollbarWidth(wot.rootDocument);
      }
      if (bottomEdge) {
        var fixedRowsBottom = wot.getSetting("fixedRowsBottom");
        var totalRows = wot.getSetting("totalRows");
        newY += this.sumCellSizes(0, sourceRow + 1);
        newY -= wot.wtViewport.getViewportHeight() - this.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
        newY += 1;
      } else {
        newY += this.sumCellSizes(wot.getSetting("fixedRowsTop"), sourceRow);
      }
      newY += scrollbarCompensation;
      return this.setScrollPosition(newY);
    }
  }, {
    key: "getTableParentOffset",
    value: function getTableParentOffset() {
      if (this.mainTableScrollableElement === this.wot.rootWindow) {
        return this.wot.wtTable.holderOffset.top;
      }
      return 0;
    }
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return getScrollTop(this.mainTableScrollableElement, this.wot.rootWindow);
    }
  }, {
    key: "adjustHeaderBordersPosition",
    value: function adjustHeaderBordersPosition(position) {
      var skipInnerBorderAdjusting = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var masterParent = this.wot.wtTable.holder.parentNode;
      var totalColumns = this.wot.getSetting("totalColumns");
      if (totalColumns) {
        removeClass(masterParent, "emptyColumns");
      } else {
        addClass(masterParent, "emptyColumns");
      }
      var positionChanged = false;
      if (!skipInnerBorderAdjusting) {
        var fixedRowsTop = this.wot.getSetting("fixedRowsTop");
        var areFixedRowsTopChanged = this.cachedFixedRowsTop !== fixedRowsTop;
        var columnHeaders = this.wot.getSetting("columnHeaders");
        if ((areFixedRowsTopChanged || fixedRowsTop === 0) && columnHeaders.length > 0) {
          var previousState = hasClass(masterParent, "innerBorderTop");
          this.cachedFixedRowsTop = this.wot.getSetting("fixedRowsTop");
          if (position || this.wot.getSetting("totalRows") === 0) {
            addClass(masterParent, "innerBorderTop");
            positionChanged = !previousState;
          } else {
            removeClass(masterParent, "innerBorderTop");
            positionChanged = previousState;
          }
        }
      }
      if (this.wot.getSetting("rowHeaders").length === 0) {
        var secondHeaderCell = this.clone.wtTable.THEAD.querySelectorAll("th:nth-of-type(2)");
        if (secondHeaderCell) {
          for (var i = 0; i < secondHeaderCell.length; i++) {
            secondHeaderCell[i].style["border-left-width"] = 0;
          }
        }
      }
      return positionChanged;
    }
  }], [{
    key: "OVERLAY_NAME",
    get: function get() {
      return CLONE_TOP;
    }
  }]);
  return TopOverlay2;
}(Overlay);

function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$u(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$u(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$u(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$u(Constructor, staticProps);
  return Constructor;
}
var Border = /* @__PURE__ */ function() {
  function Border2(wotInstance, settings) {
    _classCallCheck$z(this, Border2);
    if (!settings) {
      return;
    }
    this.eventManager = new EventManager(wotInstance);
    this.instance = wotInstance;
    this.wot = wotInstance;
    this.settings = settings;
    this.mouseDown = false;
    this.main = null;
    this.top = null;
    this.left = null;
    this.bottom = null;
    this.right = null;
    this.topStyle = null;
    this.leftStyle = null;
    this.bottomStyle = null;
    this.rightStyle = null;
    this.cornerDefaultStyle = {
      width: "6px",
      height: "6px",
      borderWidth: "1px",
      borderStyle: "solid",
      borderColor: "#FFF"
    };
    this.cornerCenterPointOffset = -(parseInt(this.cornerDefaultStyle.width, 10) / 2);
    this.corner = null;
    this.cornerStyle = null;
    this.createBorders(settings);
    this.registerListeners();
  }
  _createClass$u(Border2, [{
    key: "registerListeners",
    value: function registerListeners() {
      var _this2 = this;
      var documentBody = this.wot.rootDocument.body;
      this.eventManager.addEventListener(documentBody, "mousedown", function() {
        return _this2.onMouseDown();
      });
      this.eventManager.addEventListener(documentBody, "mouseup", function() {
        return _this2.onMouseUp();
      });
      var _loop = function _loop2(c2, len2) {
        var element = _this2.main.childNodes[c2];
        _this2.eventManager.addEventListener(element, "mouseenter", function(event) {
          return _this2.onMouseEnter(event, _this2.main.childNodes[c2]);
        });
      };
      for (var c = 0, len = this.main.childNodes.length; c < len; c++) {
        _loop(c);
      }
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown() {
      this.mouseDown = true;
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp() {
      this.mouseDown = false;
    }
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(event, parentElement) {
      if (!this.mouseDown || !this.wot.getSetting("hideBorderOnMouseDownOver")) {
        return;
      }
      event.preventDefault();
      stopImmediatePropagation(event);
      var _this = this;
      var documentBody = this.wot.rootDocument.body;
      var bounds = parentElement.getBoundingClientRect();
      parentElement.style.display = "none";
      function isOutside(mouseEvent) {
        if (mouseEvent.clientY < Math.floor(bounds.top)) {
          return true;
        }
        if (mouseEvent.clientY > Math.ceil(bounds.top + bounds.height)) {
          return true;
        }
        if (mouseEvent.clientX < Math.floor(bounds.left)) {
          return true;
        }
        if (mouseEvent.clientX > Math.ceil(bounds.left + bounds.width)) {
          return true;
        }
      }
      function handler(handlerEvent) {
        if (isOutside(handlerEvent)) {
          _this.eventManager.removeEventListener(documentBody, "mousemove", handler);
          parentElement.style.display = "block";
        }
      }
      this.eventManager.addEventListener(documentBody, "mousemove", handler);
    }
  }, {
    key: "createBorders",
    value: function createBorders(settings) {
      var rootDocument = this.wot.rootDocument;
      this.main = rootDocument.createElement("div");
      var borderDivs = ["top", "left", "bottom", "right", "corner"];
      var style = this.main.style;
      style.position = "absolute";
      style.top = 0;
      style.left = 0;
      for (var i = 0; i < 5; i++) {
        var position = borderDivs[i];
        var div = rootDocument.createElement("div");
        div.className = "wtBorder ".concat(this.settings.className || "");
        if (this.settings[position] && this.settings[position].hide) {
          div.className += " hidden";
        }
        style = div.style;
        style.backgroundColor = this.settings[position] && this.settings[position].color ? this.settings[position].color : settings.border.color;
        style.height = this.settings[position] && this.settings[position].width ? "".concat(this.settings[position].width, "px") : "".concat(settings.border.width, "px");
        style.width = this.settings[position] && this.settings[position].width ? "".concat(this.settings[position].width, "px") : "".concat(settings.border.width, "px");
        this.main.appendChild(div);
      }
      this.top = this.main.childNodes[0];
      this.left = this.main.childNodes[1];
      this.bottom = this.main.childNodes[2];
      this.right = this.main.childNodes[3];
      this.topStyle = this.top.style;
      this.leftStyle = this.left.style;
      this.bottomStyle = this.bottom.style;
      this.rightStyle = this.right.style;
      this.corner = this.main.childNodes[4];
      this.corner.className += " corner";
      this.cornerStyle = this.corner.style;
      this.cornerStyle.width = this.cornerDefaultStyle.width;
      this.cornerStyle.height = this.cornerDefaultStyle.height;
      this.cornerStyle.border = [this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(" ");
      if (isMobileBrowser()) {
        this.createMultipleSelectorHandles();
      }
      this.disappear();
      var wtTable = this.wot.wtTable;
      var bordersHolder = wtTable.bordersHolder;
      if (!bordersHolder) {
        bordersHolder = rootDocument.createElement("div");
        bordersHolder.className = "htBorders";
        wtTable.bordersHolder = bordersHolder;
        wtTable.spreader.appendChild(bordersHolder);
      }
      bordersHolder.appendChild(this.main);
    }
  }, {
    key: "createMultipleSelectorHandles",
    value: function createMultipleSelectorHandles() {
      var _this3 = this;
      var rootDocument = this.wot.rootDocument;
      this.selectionHandles = {
        topLeft: rootDocument.createElement("DIV"),
        topLeftHitArea: rootDocument.createElement("DIV"),
        bottomRight: rootDocument.createElement("DIV"),
        bottomRightHitArea: rootDocument.createElement("DIV")
      };
      var width = 10;
      var hitAreaWidth = 40;
      this.selectionHandles.topLeft.className = "topLeftSelectionHandle";
      this.selectionHandles.topLeftHitArea.className = "topLeftSelectionHandle-HitArea";
      this.selectionHandles.bottomRight.className = "bottomRightSelectionHandle";
      this.selectionHandles.bottomRightHitArea.className = "bottomRightSelectionHandle-HitArea";
      this.selectionHandles.styles = {
        topLeft: this.selectionHandles.topLeft.style,
        topLeftHitArea: this.selectionHandles.topLeftHitArea.style,
        bottomRight: this.selectionHandles.bottomRight.style,
        bottomRightHitArea: this.selectionHandles.bottomRightHitArea.style
      };
      var hitAreaStyle = {
        position: "absolute",
        height: "".concat(hitAreaWidth, "px"),
        width: "".concat(hitAreaWidth, "px"),
        "border-radius": "".concat(parseInt(hitAreaWidth / 1.5, 10), "px")
      };
      objectEach(hitAreaStyle, function(value, key) {
        _this3.selectionHandles.styles.bottomRightHitArea[key] = value;
        _this3.selectionHandles.styles.topLeftHitArea[key] = value;
      });
      var handleStyle = {
        position: "absolute",
        height: "".concat(width, "px"),
        width: "".concat(width, "px"),
        "border-radius": "".concat(parseInt(width / 1.5, 10), "px"),
        background: "#F5F5FF",
        border: "1px solid #4285c8"
      };
      objectEach(handleStyle, function(value, key) {
        _this3.selectionHandles.styles.bottomRight[key] = value;
        _this3.selectionHandles.styles.topLeft[key] = value;
      });
      this.main.appendChild(this.selectionHandles.topLeft);
      this.main.appendChild(this.selectionHandles.bottomRight);
      this.main.appendChild(this.selectionHandles.topLeftHitArea);
      this.main.appendChild(this.selectionHandles.bottomRightHitArea);
    }
  }, {
    key: "isPartRange",
    value: function isPartRange(row, col) {
      var areaSelection = this.wot.selections.createOrGetArea();
      if (areaSelection.cellRange) {
        if (row !== areaSelection.cellRange.to.row || col !== areaSelection.cellRange.to.col) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "updateMultipleSelectionHandlesPosition",
    value: function updateMultipleSelectionHandlesPosition(row, col, top, left, width, height) {
      var handleWidth = parseInt(this.selectionHandles.styles.topLeft.width, 10);
      var hitAreaWidth = parseInt(this.selectionHandles.styles.topLeftHitArea.width, 10);
      this.selectionHandles.styles.topLeft.top = "".concat(parseInt(top - handleWidth, 10), "px");
      this.selectionHandles.styles.topLeft.left = "".concat(parseInt(left - handleWidth, 10), "px");
      this.selectionHandles.styles.topLeftHitArea.top = "".concat(parseInt(top - hitAreaWidth / 4 * 3, 10), "px");
      this.selectionHandles.styles.topLeftHitArea.left = "".concat(parseInt(left - hitAreaWidth / 4 * 3, 10), "px");
      this.selectionHandles.styles.bottomRight.top = "".concat(parseInt(top + height, 10), "px");
      this.selectionHandles.styles.bottomRight.left = "".concat(parseInt(left + width, 10), "px");
      this.selectionHandles.styles.bottomRightHitArea.top = "".concat(parseInt(top + height - hitAreaWidth / 4, 10), "px");
      this.selectionHandles.styles.bottomRightHitArea.left = "".concat(parseInt(left + width - hitAreaWidth / 4, 10), "px");
      if (this.settings.border.cornerVisible && this.settings.border.cornerVisible()) {
        this.selectionHandles.styles.topLeft.display = "block";
        this.selectionHandles.styles.topLeftHitArea.display = "block";
        if (this.isPartRange(row, col)) {
          this.selectionHandles.styles.bottomRight.display = "none";
          this.selectionHandles.styles.bottomRightHitArea.display = "none";
        } else {
          this.selectionHandles.styles.bottomRight.display = "block";
          this.selectionHandles.styles.bottomRightHitArea.display = "block";
        }
      } else {
        this.selectionHandles.styles.topLeft.display = "none";
        this.selectionHandles.styles.bottomRight.display = "none";
        this.selectionHandles.styles.topLeftHitArea.display = "none";
        this.selectionHandles.styles.bottomRightHitArea.display = "none";
      }
      if (row === this.wot.wtSettings.getSetting("fixedRowsTop") || col === this.wot.wtSettings.getSetting("fixedColumnsLeft")) {
        this.selectionHandles.styles.topLeft.zIndex = "9999";
        this.selectionHandles.styles.topLeftHitArea.zIndex = "9999";
      } else {
        this.selectionHandles.styles.topLeft.zIndex = "";
        this.selectionHandles.styles.topLeftHitArea.zIndex = "";
      }
    }
  }, {
    key: "appear",
    value: function appear(corners) {
      if (this.disabled) {
        return;
      }
      var _this$wot = this.wot, wtTable = _this$wot.wtTable, rootDocument = _this$wot.rootDocument, rootWindow = _this$wot.rootWindow;
      var fromRow;
      var toRow;
      var fromColumn;
      var toColumn;
      var rowHeader;
      var columnHeader;
      var rowsCount = wtTable.getRenderedRowsCount();
      for (var i = 0; i < rowsCount; i += 1) {
        var s = wtTable.rowFilter.renderedToSource(i);
        if (s >= corners[0] && s <= corners[2]) {
          fromRow = s;
          rowHeader = corners[0];
          break;
        }
      }
      for (var _i = rowsCount - 1; _i >= 0; _i -= 1) {
        var _s = wtTable.rowFilter.renderedToSource(_i);
        if (_s >= corners[0] && _s <= corners[2]) {
          toRow = _s;
          break;
        }
      }
      var columnsCount = wtTable.getRenderedColumnsCount();
      for (var _i2 = 0; _i2 < columnsCount; _i2 += 1) {
        var _s2 = wtTable.columnFilter.renderedToSource(_i2);
        if (_s2 >= corners[1] && _s2 <= corners[3]) {
          fromColumn = _s2;
          columnHeader = corners[1];
          break;
        }
      }
      for (var _i3 = columnsCount - 1; _i3 >= 0; _i3 -= 1) {
        var _s3 = wtTable.columnFilter.renderedToSource(_i3);
        if (_s3 >= corners[1] && _s3 <= corners[3]) {
          toColumn = _s3;
          break;
        }
      }
      if (fromRow === void 0 || fromColumn === void 0) {
        this.disappear();
        return;
      }
      var fromTD = wtTable.getCell(new CellCoords(fromRow, fromColumn));
      var isMultiple = fromRow !== toRow || fromColumn !== toColumn;
      var toTD = isMultiple ? wtTable.getCell(new CellCoords(toRow, toColumn)) : fromTD;
      var fromOffset = offset$1(fromTD);
      var toOffset = isMultiple ? offset$1(toTD) : fromOffset;
      var containerOffset = offset$1(wtTable.TABLE);
      var minTop = fromOffset.top;
      var minLeft = fromOffset.left;
      var left = minLeft - containerOffset.left - 1;
      var width = toOffset.left + outerWidth(toTD) - minLeft;
      if (this.isEntireColumnSelected(fromRow, toRow)) {
        var modifiedValues = this.getDimensionsFromHeader("columns", fromColumn, toColumn, rowHeader, containerOffset);
        var fromTH = null;
        if (modifiedValues) {
          var _modifiedValues = _slicedToArray$1(modifiedValues, 3);
          fromTH = _modifiedValues[0];
          left = _modifiedValues[1];
          width = _modifiedValues[2];
        }
        if (fromTH) {
          fromTD = fromTH;
        }
      }
      var top = minTop - containerOffset.top - 1;
      var height = toOffset.top + outerHeight(toTD) - minTop;
      if (this.isEntireRowSelected(fromColumn, toColumn)) {
        var _modifiedValues2 = this.getDimensionsFromHeader("rows", fromRow, toRow, columnHeader, containerOffset);
        var _fromTH = null;
        if (_modifiedValues2) {
          var _modifiedValues3 = _slicedToArray$1(_modifiedValues2, 3);
          _fromTH = _modifiedValues3[0];
          top = _modifiedValues3[1];
          height = _modifiedValues3[2];
        }
        if (_fromTH) {
          fromTD = _fromTH;
        }
      }
      var style = getComputedStyle(fromTD, rootWindow);
      if (parseInt(style.borderTopWidth, 10) > 0) {
        top += 1;
        height = height > 0 ? height - 1 : 0;
      }
      if (parseInt(style.borderLeftWidth, 10) > 0) {
        left += 1;
        width = width > 0 ? width - 1 : 0;
      }
      this.topStyle.top = "".concat(top, "px");
      this.topStyle.left = "".concat(left, "px");
      this.topStyle.width = "".concat(width, "px");
      this.topStyle.display = "block";
      this.leftStyle.top = "".concat(top, "px");
      this.leftStyle.left = "".concat(left, "px");
      this.leftStyle.height = "".concat(height, "px");
      this.leftStyle.display = "block";
      var delta = Math.floor(this.settings.border.width / 2);
      this.bottomStyle.top = "".concat(top + height - delta, "px");
      this.bottomStyle.left = "".concat(left, "px");
      this.bottomStyle.width = "".concat(width, "px");
      this.bottomStyle.display = "block";
      this.rightStyle.top = "".concat(top, "px");
      this.rightStyle.left = "".concat(left + width - delta, "px");
      this.rightStyle.height = "".concat(height + 1, "px");
      this.rightStyle.display = "block";
      var cornerVisibleSetting = this.settings.border.cornerVisible;
      cornerVisibleSetting = typeof cornerVisibleSetting === "function" ? cornerVisibleSetting(this.settings.layerLevel) : cornerVisibleSetting;
      var hookResult = this.wot.getSetting("onModifyGetCellCoords", toRow, toColumn);
      var checkRow = toRow, checkCol = toColumn;
      if (hookResult && Array.isArray(hookResult)) {
        var _hookResult = _slicedToArray$1(hookResult, 4);
        checkRow = _hookResult[2];
        checkCol = _hookResult[3];
      }
      if (isMobileBrowser() || !cornerVisibleSetting || this.isPartRange(checkRow, checkCol)) {
        this.cornerStyle.display = "none";
      } else {
        this.cornerStyle.top = "".concat(top + height + this.cornerCenterPointOffset - 1, "px");
        this.cornerStyle.left = "".concat(left + width + this.cornerCenterPointOffset - 1, "px");
        this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;
        this.cornerStyle.width = this.cornerDefaultStyle.width;
        this.cornerStyle.display = "none";
        var trimmingContainer = getTrimmingContainer(wtTable.TABLE);
        var trimToWindow = trimmingContainer === rootWindow;
        if (trimToWindow) {
          trimmingContainer = rootDocument.documentElement;
        }
        if (toColumn === this.wot.getSetting("totalColumns") - 1) {
          var toTdOffsetLeft = trimToWindow ? toTD.getBoundingClientRect().left : toTD.offsetLeft;
          var cornerRightEdge = toTdOffsetLeft + outerWidth(toTD) + parseInt(this.cornerDefaultStyle.width, 10) / 2;
          var cornerOverlappingContainer = cornerRightEdge >= innerWidth(trimmingContainer);
          if (cornerOverlappingContainer) {
            this.cornerStyle.left = "".concat(Math.floor(left + width + this.cornerCenterPointOffset - parseInt(this.cornerDefaultStyle.width, 10) / 2), "px");
            this.cornerStyle.borderRightWidth = 0;
          }
        }
        if (toRow === this.wot.getSetting("totalRows") - 1) {
          var toTdOffsetTop = trimToWindow ? toTD.getBoundingClientRect().top : toTD.offsetTop;
          var cornerBottomEdge = toTdOffsetTop + outerHeight(toTD) + parseInt(this.cornerDefaultStyle.height, 10) / 2;
          var _cornerOverlappingContainer = cornerBottomEdge >= innerHeight(trimmingContainer);
          if (_cornerOverlappingContainer) {
            this.cornerStyle.top = "".concat(Math.floor(top + height + this.cornerCenterPointOffset - parseInt(this.cornerDefaultStyle.height, 10) / 2), "px");
            this.cornerStyle.borderBottomWidth = 0;
          }
        }
        this.cornerStyle.display = "block";
      }
      if (isMobileBrowser()) {
        this.updateMultipleSelectionHandlesPosition(toRow, toColumn, top, left, width, height);
      }
    }
  }, {
    key: "isEntireColumnSelected",
    value: function isEntireColumnSelected(startRowIndex, endRowIndex) {
      return startRowIndex === this.wot.wtTable.getFirstRenderedRow() && endRowIndex === this.wot.wtTable.getLastRenderedRow();
    }
  }, {
    key: "isEntireRowSelected",
    value: function isEntireRowSelected(startColumnIndex, endColumnIndex) {
      return startColumnIndex === this.wot.wtTable.getFirstRenderedColumn() && endColumnIndex === this.wot.wtTable.getLastRenderedColumn();
    }
  }, {
    key: "getDimensionsFromHeader",
    value: function getDimensionsFromHeader(direction, fromIndex, toIndex, headerIndex, containerOffset) {
      var wtTable = this.wot.wtTable;
      var rootHotElement = wtTable.wtRootElement.parentNode;
      var getHeaderFn = null;
      var dimensionFn = null;
      var entireSelectionClassname = null;
      var index = null;
      var dimension = null;
      var dimensionProperty = null;
      var startHeader = null;
      var endHeader = null;
      switch (direction) {
        case "rows":
          getHeaderFn = function getHeaderFn2() {
            return wtTable.getRowHeader.apply(wtTable, arguments);
          };
          dimensionFn = function dimensionFn2() {
            return outerHeight.apply(void 0, arguments);
          };
          entireSelectionClassname = "ht__selection--rows";
          dimensionProperty = "top";
          break;
        case "columns":
          getHeaderFn = function getHeaderFn2() {
            return wtTable.getColumnHeader.apply(wtTable, arguments);
          };
          dimensionFn = function dimensionFn2() {
            return outerWidth.apply(void 0, arguments);
          };
          entireSelectionClassname = "ht__selection--columns";
          dimensionProperty = "left";
          break;
      }
      if (rootHotElement.classList.contains(entireSelectionClassname)) {
        var columnHeaderLevelCount = this.wot.getSetting("columnHeaders").length;
        startHeader = getHeaderFn(fromIndex, columnHeaderLevelCount - headerIndex);
        endHeader = getHeaderFn(toIndex, columnHeaderLevelCount - headerIndex);
        if (!startHeader || !endHeader) {
          return false;
        }
        var startHeaderOffset = offset$1(startHeader);
        var endOffset = offset$1(endHeader);
        if (startHeader && endHeader) {
          index = startHeaderOffset[dimensionProperty] - containerOffset[dimensionProperty] - 1;
          dimension = endOffset[dimensionProperty] + dimensionFn(endHeader) - startHeaderOffset[dimensionProperty];
        }
        return [startHeader, index, dimension];
      }
      return false;
    }
  }, {
    key: "changeBorderStyle",
    value: function changeBorderStyle(borderElement, border) {
      var style = this[borderElement].style;
      var borderStyle = border[borderElement];
      if (!borderStyle || borderStyle.hide) {
        addClass(this[borderElement], "hidden");
      } else {
        if (hasClass(this[borderElement], "hidden")) {
          removeClass(this[borderElement], "hidden");
        }
        style.backgroundColor = borderStyle.color;
        if (borderElement === "top" || borderElement === "bottom") {
          style.height = "".concat(borderStyle.width, "px");
        }
        if (borderElement === "right" || borderElement === "left") {
          style.width = "".concat(borderStyle.width, "px");
        }
      }
    }
  }, {
    key: "changeBorderToDefaultStyle",
    value: function changeBorderToDefaultStyle(position) {
      var defaultBorder = {
        width: 1,
        color: "#000"
      };
      var style = this[position].style;
      style.backgroundColor = defaultBorder.color;
      style.width = "".concat(defaultBorder.width, "px");
      style.height = "".concat(defaultBorder.width, "px");
    }
  }, {
    key: "toggleHiddenClass",
    value: function toggleHiddenClass(borderElement, remove) {
      this.changeBorderToDefaultStyle(borderElement);
      if (remove) {
        addClass(this[borderElement], "hidden");
      } else {
        removeClass(this[borderElement], "hidden");
      }
    }
  }, {
    key: "disappear",
    value: function disappear() {
      this.topStyle.display = "none";
      this.leftStyle.display = "none";
      this.bottomStyle.display = "none";
      this.rightStyle.display = "none";
      this.cornerStyle.display = "none";
      if (isMobileBrowser()) {
        this.selectionHandles.styles.topLeft.display = "none";
        this.selectionHandles.styles.bottomRight.display = "none";
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.eventManager.destroyWithOwnEventsOnly();
      this.main.parentNode.removeChild(this.main);
    }
  }]);
  return Border2;
}();

function _classCallCheck$A(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$v(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$v(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$v(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$v(Constructor, staticProps);
  return Constructor;
}
var privatePool$2 = new WeakMap();
var Event$1 = /* @__PURE__ */ function() {
  function Event2(instance) {
    _classCallCheck$A(this, Event2);
    this.instance = instance;
    this.eventManager = new EventManager(instance);
    privatePool$2.set(this, {
      selectedCellBeforeTouchEnd: void 0,
      dblClickTimeout: [null, null],
      dblClickOrigin: [null, null]
    });
    this.registerEvents();
  }
  _createClass$v(Event2, [{
    key: "registerEvents",
    value: function registerEvents() {
      var _this = this;
      this.eventManager.addEventListener(this.instance.wtTable.holder, "contextmenu", function(event) {
        return _this.onContextMenu(event);
      });
      this.eventManager.addEventListener(this.instance.wtTable.TABLE, "mouseover", function(event) {
        return _this.onMouseOver(event);
      });
      this.eventManager.addEventListener(this.instance.wtTable.TABLE, "mouseout", function(event) {
        return _this.onMouseOut(event);
      });
      var initTouchEvents = function initTouchEvents2() {
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "touchstart", function(event) {
          return _this.onTouchStart(event);
        });
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "touchend", function(event) {
          return _this.onTouchEnd(event);
        });
        if (!_this.instance.momentumScrolling) {
          _this.instance.momentumScrolling = {};
        }
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "scroll", function() {
          clearTimeout(_this.instance.momentumScrolling._timeout);
          if (!_this.instance.momentumScrolling.ongoing) {
            _this.instance.getSetting("onBeforeTouchScroll");
          }
          _this.instance.momentumScrolling.ongoing = true;
          _this.instance.momentumScrolling._timeout = setTimeout(function() {
            if (!_this.instance.touchApplied) {
              _this.instance.momentumScrolling.ongoing = false;
              _this.instance.getSetting("onAfterMomentumScroll");
            }
          }, 200);
        });
      };
      var initMouseEvents = function initMouseEvents2() {
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "mouseup", function(event) {
          return _this.onMouseUp(event);
        });
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "mousedown", function(event) {
          return _this.onMouseDown(event);
        });
      };
      if (isMobileBrowser()) {
        initTouchEvents();
      } else {
        if (isTouchSupported()) {
          initTouchEvents();
        }
        initMouseEvents();
      }
    }
  }, {
    key: "selectedCellWasTouched",
    value: function selectedCellWasTouched(touchTarget) {
      var priv = privatePool$2.get(this);
      var cellUnderFinger = this.parentCell(touchTarget);
      var coordsOfCellUnderFinger = cellUnderFinger.coords;
      if (priv.selectedCellBeforeTouchEnd && coordsOfCellUnderFinger) {
        var _ref = [coordsOfCellUnderFinger.row, priv.selectedCellBeforeTouchEnd.from.row], rowTouched = _ref[0], rowSelected = _ref[1];
        var _ref2 = [coordsOfCellUnderFinger.col, priv.selectedCellBeforeTouchEnd.from.col], colTouched = _ref2[0], colSelected = _ref2[1];
        return rowTouched === rowSelected && colTouched === colSelected;
      }
      return false;
    }
  }, {
    key: "parentCell",
    value: function parentCell(elem) {
      var cell = {};
      var TABLE = this.instance.wtTable.TABLE;
      var TD = closestDown(elem, ["TD", "TH"], TABLE);
      if (TD) {
        cell.coords = this.instance.wtTable.getCoords(TD);
        cell.TD = TD;
      } else if (hasClass(elem, "wtBorder") && hasClass(elem, "current")) {
        cell.coords = this.instance.selections.getCell().cellRange.highlight;
        cell.TD = this.instance.wtTable.getCell(cell.coords);
      } else if (hasClass(elem, "wtBorder") && hasClass(elem, "area")) {
        if (this.instance.selections.createOrGetArea().cellRange) {
          cell.coords = this.instance.selections.createOrGetArea().cellRange.to;
          cell.TD = this.instance.wtTable.getCell(cell.coords);
        }
      }
      return cell;
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      var priv = privatePool$2.get(this);
      var activeElement = this.instance.rootDocument.activeElement;
      var getParentNode = partial(getParent, event.target);
      var realTarget = event.target;
      if (realTarget === activeElement || getParentNode(0) === activeElement || getParentNode(1) === activeElement) {
        return;
      }
      var cell = this.parentCell(realTarget);
      if (hasClass(realTarget, "corner")) {
        this.instance.getSetting("onCellCornerMouseDown", event, realTarget);
      } else if (cell.TD && this.instance.hasSetting("onCellMouseDown")) {
        this.instance.getSetting("onCellMouseDown", event, cell.coords, cell.TD, this.instance);
      }
      if ((event.button === 0 || this.instance.touchApplied) && cell.TD) {
        priv.dblClickOrigin[0] = cell.TD;
        clearTimeout(priv.dblClickTimeout[0]);
        priv.dblClickTimeout[0] = setTimeout(function() {
          priv.dblClickOrigin[0] = null;
        }, 1e3);
      }
    }
  }, {
    key: "onContextMenu",
    value: function onContextMenu(event) {
      if (this.instance.hasSetting("onCellContextMenu")) {
        var cell = this.parentCell(event.target);
        if (cell.TD) {
          this.instance.getSetting("onCellContextMenu", event, cell.coords, cell.TD, this.instance);
        }
      }
    }
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event) {
      if (!this.instance.hasSetting("onCellMouseOver")) {
        return;
      }
      var table = this.instance.wtTable.TABLE;
      var td = closestDown(event.target, ["TD", "TH"], table);
      var mainWOT = this.instance.cloneSource || this.instance;
      if (td && td !== mainWOT.lastMouseOver && isChildOf(td, table)) {
        mainWOT.lastMouseOver = td;
        this.instance.getSetting("onCellMouseOver", event, this.instance.wtTable.getCoords(td), td, this.instance);
      }
    }
  }, {
    key: "onMouseOut",
    value: function onMouseOut(event) {
      if (!this.instance.hasSetting("onCellMouseOut")) {
        return;
      }
      var table = this.instance.wtTable.TABLE;
      var lastTD = closestDown(event.target, ["TD", "TH"], table);
      var nextTD = closestDown(event.relatedTarget, ["TD", "TH"], table);
      if (lastTD && lastTD !== nextTD && isChildOf(lastTD, table)) {
        this.instance.getSetting("onCellMouseOut", event, this.instance.wtTable.getCoords(lastTD), lastTD, this.instance);
      }
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(event) {
      var priv = privatePool$2.get(this);
      var cell = this.parentCell(event.target);
      if (cell.TD && this.instance.hasSetting("onCellMouseUp")) {
        this.instance.getSetting("onCellMouseUp", event, cell.coords, cell.TD, this.instance);
      }
      if (event.button !== 0 && !this.instance.touchApplied) {
        return;
      }
      if (cell.TD === priv.dblClickOrigin[0] && cell.TD === priv.dblClickOrigin[1]) {
        if (hasClass(event.target, "corner")) {
          this.instance.getSetting("onCellCornerDblClick", event, cell.coords, cell.TD, this.instance);
        } else {
          this.instance.getSetting("onCellDblClick", event, cell.coords, cell.TD, this.instance);
        }
        priv.dblClickOrigin[0] = null;
        priv.dblClickOrigin[1] = null;
      } else if (cell.TD === priv.dblClickOrigin[0]) {
        priv.dblClickOrigin[1] = cell.TD;
        clearTimeout(priv.dblClickTimeout[1]);
        priv.dblClickTimeout[1] = setTimeout(function() {
          priv.dblClickOrigin[1] = null;
        }, 500);
      }
    }
  }, {
    key: "onTouchStart",
    value: function onTouchStart(event) {
      var priv = privatePool$2.get(this);
      priv.selectedCellBeforeTouchEnd = this.instance.selections.getCell().cellRange;
      this.instance.touchApplied = true;
      this.onMouseDown(event);
    }
  }, {
    key: "onTouchEnd",
    value: function onTouchEnd(event) {
      var _this$parentCell;
      var target = event.target;
      var parentCellCoords = (_this$parentCell = this.parentCell(target)) === null || _this$parentCell === void 0 ? void 0 : _this$parentCell.coords;
      var isCellsRange = isDefined(parentCellCoords) && parentCellCoords.row >= 0 && parentCellCoords.col >= 0;
      var isEventCancelable = event.cancelable && isCellsRange && this.instance.getSetting("isDataViewInstance");
      if (isEventCancelable) {
        var interactiveElements = ["A", "BUTTON", "INPUT"];
        if (isIOS() && (isChromeWebKit() || isFirefoxWebKit()) && this.selectedCellWasTouched(target) && !interactiveElements.includes(target.tagName)) {
          event.preventDefault();
        } else if (!this.selectedCellWasTouched(target)) {
          event.preventDefault();
        }
      }
      this.onMouseUp(event);
      this.instance.touchApplied = false;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var priv = privatePool$2.get(this);
      clearTimeout(priv.dblClickTimeout[0]);
      clearTimeout(priv.dblClickTimeout[1]);
      this.eventManager.destroy();
    }
  }]);
  return Event2;
}();

var KEY_CODES = {
  MOUSE_LEFT: 1,
  MOUSE_RIGHT: 3,
  MOUSE_MIDDLE: 2,
  BACKSPACE: 8,
  COMMA: 188,
  INSERT: 45,
  DELETE: 46,
  END: 35,
  ENTER: 13,
  ESCAPE: 27,
  CONTROL: 17,
  COMMAND_LEFT: 91,
  COMMAND_RIGHT: 93,
  COMMAND_FIREFOX: 224,
  ALT: 18,
  HOME: 36,
  PAGE_DOWN: 34,
  PAGE_UP: 33,
  PERIOD: 190,
  SPACE: 32,
  SHIFT: 16,
  CAPS_LOCK: 20,
  TAB: 9,
  ARROW_RIGHT: 39,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_DOWN: 40,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  A: 65,
  C: 67,
  D: 68,
  F: 70,
  L: 76,
  O: 79,
  P: 80,
  S: 83,
  V: 86,
  X: 88
};
function isPrintableChar(keyCode) {
  return keyCode === 32 || keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222 || keyCode >= 226 || keyCode >= 65 && keyCode <= 90;
}
function isMetaKey(keyCode) {
  var metaKeys = [KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_UP, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_RIGHT, KEY_CODES.HOME, KEY_CODES.END, KEY_CODES.DELETE, KEY_CODES.BACKSPACE, KEY_CODES.F1, KEY_CODES.F2, KEY_CODES.F3, KEY_CODES.F4, KEY_CODES.F5, KEY_CODES.F6, KEY_CODES.F7, KEY_CODES.F8, KEY_CODES.F9, KEY_CODES.F10, KEY_CODES.F11, KEY_CODES.F12, KEY_CODES.TAB, KEY_CODES.PAGE_DOWN, KEY_CODES.PAGE_UP, KEY_CODES.ENTER, KEY_CODES.ESCAPE, KEY_CODES.SHIFT, KEY_CODES.CAPS_LOCK, KEY_CODES.ALT];
  return metaKeys.indexOf(keyCode) !== -1;
}
function isCtrlKey(keyCode) {
  var keys = [];
  if (navigator.platform.includes("Mac")) {
    keys.push(KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX);
  } else {
    keys.push(KEY_CODES.CONTROL);
  }
  return keys.includes(keyCode);
}
function isCtrlMetaKey(keyCode) {
  return [KEY_CODES.CONTROL, KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX].includes(keyCode);
}
function isKey(keyCode, baseCode) {
  var keys = baseCode.split("|");
  var result = false;
  arrayEach(keys, function(key) {
    if (keyCode === KEY_CODES[key]) {
      result = true;
      return false;
    }
  });
  return result;
}

var unicodeHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  KEY_CODES: KEY_CODES,
  isPrintableChar: isPrintableChar,
  isMetaKey: isMetaKey,
  isCtrlKey: isCtrlKey,
  isCtrlMetaKey: isCtrlMetaKey,
  isKey: isKey
});

function _classCallCheck$B(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$w(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$w(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$w(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$w(Constructor, staticProps);
  return Constructor;
}
registerOverlayOnce(BottomLeftCornerOverlay);
registerOverlayOnce(BottomOverlay);
registerOverlayOnce(LeftOverlay);
registerOverlayOnce(TopLeftCornerOverlay);
registerOverlayOnce(TopOverlay);
var Overlays = /* @__PURE__ */ function() {
  function Overlays2(wotInstance) {
    _classCallCheck$B(this, Overlays2);
    this.wot = wotInstance;
    var _this$wot = this.wot, rootDocument = _this$wot.rootDocument, rootWindow = _this$wot.rootWindow, wtTable = _this$wot.wtTable;
    var BODY_LINE_HEIGHT = parseInt(rootWindow.getComputedStyle(rootDocument.body).lineHeight, 10);
    var FALLBACK_BODY_LINE_HEIGHT = parseInt(rootWindow.getComputedStyle(rootDocument.body).fontSize, 10) * 1.2;
    this.instance = this.wot;
    this.eventManager = new EventManager(this.wot);
    this.scrollbarSize = getScrollbarWidth(rootDocument);
    this.wot.update("scrollbarWidth", this.scrollbarSize);
    this.wot.update("scrollbarHeight", this.scrollbarSize);
    var isOverflowHidden = rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue("overflow") === "hidden";
    this.scrollableElement = isOverflowHidden ? wtTable.holder : getScrollableElement(wtTable.TABLE);
    this.topOverlay = void 0;
    this.bottomOverlay = void 0;
    this.leftOverlay = void 0;
    this.topLeftCornerOverlay = void 0;
    this.bottomLeftCornerOverlay = void 0;
    this.prepareOverlays();
    this.hasScrollbarBottom = false;
    this.hasScrollbarRight = false;
    this.destroyed = false;
    this.keyPressed = false;
    this.spreaderLastSize = {
      width: null,
      height: null
    };
    this.verticalScrolling = false;
    this.horizontalScrolling = false;
    this.browserLineHeight = BODY_LINE_HEIGHT || FALLBACK_BODY_LINE_HEIGHT;
    this.registerListeners();
    this.lastScrollX = rootWindow.scrollX;
    this.lastScrollY = rootWindow.scrollY;
  }
  _createClass$w(Overlays2, [{
    key: "prepareOverlays",
    value: function prepareOverlays() {
      var syncScroll = false;
      if (this.topOverlay) {
        syncScroll = this.topOverlay.updateStateOfRendering() || syncScroll;
      } else {
        this.topOverlay = createOverlay(CLONE_TOP, this.wot);
      }
      if (!hasOverlay(CLONE_BOTTOM)) {
        this.bottomOverlay = {
          needFullRender: false,
          updateStateOfRendering: function updateStateOfRendering() {
            return false;
          }
        };
      }
      if (!hasOverlay(CLONE_BOTTOM_LEFT_CORNER)) {
        this.bottomLeftCornerOverlay = {
          needFullRender: false,
          updateStateOfRendering: function updateStateOfRendering() {
            return false;
          }
        };
      }
      if (this.bottomOverlay) {
        syncScroll = this.bottomOverlay.updateStateOfRendering() || syncScroll;
      } else {
        this.bottomOverlay = createOverlay(CLONE_BOTTOM, this.wot);
      }
      if (this.leftOverlay) {
        syncScroll = this.leftOverlay.updateStateOfRendering() || syncScroll;
      } else {
        this.leftOverlay = createOverlay(CLONE_LEFT, this.wot);
      }
      if (this.topOverlay.needFullRender && this.leftOverlay.needFullRender) {
        if (this.topLeftCornerOverlay) {
          syncScroll = this.topLeftCornerOverlay.updateStateOfRendering() || syncScroll;
        } else {
          this.topLeftCornerOverlay = createOverlay(CLONE_TOP_LEFT_CORNER, this.wot);
        }
      }
      if (this.bottomOverlay.needFullRender && this.leftOverlay.needFullRender) {
        if (this.bottomLeftCornerOverlay) {
          syncScroll = this.bottomLeftCornerOverlay.updateStateOfRendering() || syncScroll;
        } else {
          this.bottomLeftCornerOverlay = createOverlay(CLONE_BOTTOM_LEFT_CORNER, this.wot);
        }
      }
      return syncScroll;
    }
  }, {
    key: "refreshAll",
    value: function refreshAll() {
      if (!this.wot.drawn) {
        return;
      }
      if (!this.wot.wtTable.holder.parentNode) {
        this.destroy();
        return;
      }
      this.wot.draw(true);
      if (this.verticalScrolling) {
        this.leftOverlay.onScroll();
      }
      if (this.horizontalScrolling) {
        this.topOverlay.onScroll();
      }
      this.verticalScrolling = false;
      this.horizontalScrolling = false;
    }
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this = this;
      var _this$wot2 = this.wot, rootDocument = _this$wot2.rootDocument, rootWindow = _this$wot2.rootWindow;
      var topOverlayScrollableElement = this.topOverlay.mainTableScrollableElement;
      var leftOverlayScrollableElement = this.leftOverlay.mainTableScrollableElement;
      this.eventManager.addEventListener(rootDocument.documentElement, "keydown", function(event) {
        return _this.onKeyDown(event);
      });
      this.eventManager.addEventListener(rootDocument.documentElement, "keyup", function() {
        return _this.onKeyUp();
      });
      this.eventManager.addEventListener(rootDocument, "visibilitychange", function() {
        return _this.onKeyUp();
      });
      this.eventManager.addEventListener(topOverlayScrollableElement, "scroll", function(event) {
        return _this.onTableScroll(event);
      }, {
        passive: true
      });
      if (topOverlayScrollableElement !== leftOverlayScrollableElement) {
        this.eventManager.addEventListener(leftOverlayScrollableElement, "scroll", function(event) {
          return _this.onTableScroll(event);
        }, {
          passive: true
        });
      }
      var isHighPixelRatio = rootWindow.devicePixelRatio && rootWindow.devicePixelRatio > 1;
      var isScrollOnWindow = this.scrollableElement === rootWindow;
      var preventWheel = this.wot.wtSettings.getSetting("preventWheel");
      var wheelEventOptions = {
        passive: isScrollOnWindow
      };
      if (preventWheel || isHighPixelRatio || !isChrome()) {
        this.eventManager.addEventListener(this.wot.wtTable.wtRootElement, "wheel", function(event) {
          return _this.onCloneWheel(event, preventWheel);
        }, wheelEventOptions);
      }
      var overlays = [this.topOverlay, this.bottomOverlay, this.leftOverlay, this.topLeftCornerOverlay, this.bottomLeftCornerOverlay];
      overlays.forEach(function(overlay) {
        if (overlay && overlay.needFullRender) {
          var holder = overlay.clone.wtTable.holder;
          _this.eventManager.addEventListener(holder, "wheel", function(event) {
            return _this.onCloneWheel(event, preventWheel);
          }, wheelEventOptions);
        }
      });
      var resizeTimeout;
      this.eventManager.addEventListener(rootWindow, "resize", function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
          _this.wot.getSetting("onWindowResize");
        }, 200);
      });
    }
  }, {
    key: "deregisterListeners",
    value: function deregisterListeners() {
      this.eventManager.clearEvents(true);
    }
  }, {
    key: "onTableScroll",
    value: function onTableScroll(event) {
      var rootWindow = this.wot.rootWindow;
      var masterHorizontal = this.leftOverlay.mainTableScrollableElement;
      var masterVertical = this.topOverlay.mainTableScrollableElement;
      var target = event.target;
      if (this.keyPressed) {
        if (masterVertical !== rootWindow && target !== rootWindow && !event.target.contains(masterVertical) || masterHorizontal !== rootWindow && target !== rootWindow && !event.target.contains(masterHorizontal)) {
          return;
        }
      }
      this.syncScrollPositions(event);
    }
  }, {
    key: "onCloneWheel",
    value: function onCloneWheel(event, preventDefault) {
      var rootWindow = this.wot.rootWindow;
      var masterHorizontal = this.leftOverlay.mainTableScrollableElement;
      var masterVertical = this.topOverlay.mainTableScrollableElement;
      var target = event.target;
      var shouldNotWheelVertically = masterVertical !== rootWindow && target !== rootWindow && !target.contains(masterVertical);
      var shouldNotWheelHorizontally = masterHorizontal !== rootWindow && target !== rootWindow && !target.contains(masterHorizontal);
      if (this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally)) {
        return;
      }
      var isScrollPossible = this.translateMouseWheelToScroll(event);
      if (preventDefault || this.scrollableElement !== rootWindow && isScrollPossible) {
        event.preventDefault();
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      this.keyPressed = isKey(event.keyCode, "ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT");
    }
  }, {
    key: "onKeyUp",
    value: function onKeyUp() {
      this.keyPressed = false;
    }
  }, {
    key: "translateMouseWheelToScroll",
    value: function translateMouseWheelToScroll(event) {
      var browserLineHeight = this.browserLineHeight;
      var deltaY = isNaN(event.deltaY) ? -1 * event.wheelDeltaY : event.deltaY;
      var deltaX = isNaN(event.deltaX) ? -1 * event.wheelDeltaX : event.deltaX;
      if (event.deltaMode === 1) {
        deltaX += deltaX * browserLineHeight;
        deltaY += deltaY * browserLineHeight;
      }
      var isScrollVerticallyPossible = this.scrollVertically(deltaY);
      var isScrollHorizontallyPossible = this.scrollHorizontally(deltaX);
      return isScrollVerticallyPossible || isScrollHorizontallyPossible;
    }
  }, {
    key: "scrollVertically",
    value: function scrollVertically(delta) {
      var previousScroll = this.scrollableElement.scrollTop;
      this.scrollableElement.scrollTop += delta;
      return previousScroll !== this.scrollableElement.scrollTop;
    }
  }, {
    key: "scrollHorizontally",
    value: function scrollHorizontally(delta) {
      var previousScroll = this.scrollableElement.scrollLeft;
      this.scrollableElement.scrollLeft += delta;
      return previousScroll !== this.scrollableElement.scrollLeft;
    }
  }, {
    key: "syncScrollPositions",
    value: function syncScrollPositions() {
      if (this.destroyed) {
        return;
      }
      var rootWindow = this.wot.rootWindow;
      var topHolder = this.topOverlay.clone.wtTable.holder;
      var leftHolder = this.leftOverlay.clone.wtTable.holder;
      var _ref = [this.scrollableElement.scrollLeft, this.scrollableElement.scrollTop], scrollLeft = _ref[0], scrollTop = _ref[1];
      this.horizontalScrolling = topHolder.scrollLeft !== scrollLeft || this.lastScrollX !== rootWindow.scrollX;
      this.verticalScrolling = leftHolder.scrollTop !== scrollTop || this.lastScrollY !== rootWindow.scrollY;
      this.lastScrollX = rootWindow.scrollX;
      this.lastScrollY = rootWindow.scrollY;
      if (this.horizontalScrolling) {
        topHolder.scrollLeft = scrollLeft;
        var bottomHolder = this.bottomOverlay.needFullRender ? this.bottomOverlay.clone.wtTable.holder : null;
        if (bottomHolder) {
          bottomHolder.scrollLeft = scrollLeft;
        }
      }
      if (this.verticalScrolling) {
        leftHolder.scrollTop = scrollTop;
      }
      this.refreshAll();
    }
  }, {
    key: "syncScrollWithMaster",
    value: function syncScrollWithMaster() {
      var master = this.topOverlay.mainTableScrollableElement;
      var scrollLeft = master.scrollLeft, scrollTop = master.scrollTop;
      if (this.topOverlay.needFullRender) {
        this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;
      }
      if (this.bottomOverlay.needFullRender) {
        this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;
      }
      if (this.leftOverlay.needFullRender) {
        this.leftOverlay.clone.wtTable.holder.scrollTop = scrollTop;
      }
    }
  }, {
    key: "updateMainScrollableElements",
    value: function updateMainScrollableElements() {
      this.deregisterListeners();
      this.leftOverlay.updateMainScrollableElement();
      this.topOverlay.updateMainScrollableElement();
      if (this.bottomOverlay.needFullRender) {
        this.bottomOverlay.updateMainScrollableElement();
      }
      var _this$wot3 = this.wot, rootWindow = _this$wot3.rootWindow, wtTable = _this$wot3.wtTable;
      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue("overflow") === "hidden") {
        this.scrollableElement = wtTable.holder;
      } else {
        this.scrollableElement = getScrollableElement(wtTable.TABLE);
      }
      this.registerListeners();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.eventManager.destroy();
      this.topOverlay.destroy();
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.destroy();
      }
      this.leftOverlay.destroy();
      if (this.topLeftCornerOverlay) {
        this.topLeftCornerOverlay.destroy();
      }
      if (this.bottomLeftCornerOverlay && this.bottomLeftCornerOverlay.clone) {
        this.bottomLeftCornerOverlay.destroy();
      }
      this.destroyed = true;
    }
  }, {
    key: "refresh",
    value: function refresh() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var spreader = this.wot.wtTable.spreader;
      var width = spreader.clientWidth;
      var height = spreader.clientHeight;
      if (width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height) {
        this.spreaderLastSize.width = width;
        this.spreaderLastSize.height = height;
        this.adjustElementsSize();
      }
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.refresh(fastDraw);
      }
      this.leftOverlay.refresh(fastDraw);
      this.topOverlay.refresh(fastDraw);
      if (this.topLeftCornerOverlay) {
        this.topLeftCornerOverlay.refresh(fastDraw);
      }
      if (this.bottomLeftCornerOverlay && this.bottomLeftCornerOverlay.clone) {
        this.bottomLeftCornerOverlay.refresh(fastDraw);
      }
    }
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var _this$wot4 = this.wot, wtViewport = _this$wot4.wtViewport, wtTable = _this$wot4.wtTable;
      var totalColumns = this.wot.getSetting("totalColumns");
      var totalRows = this.wot.getSetting("totalRows");
      var headerRowSize = wtViewport.getRowHeaderWidth();
      var headerColumnSize = wtViewport.getColumnHeaderHeight();
      var hiderStyle = wtTable.hider.style;
      hiderStyle.width = "".concat(headerRowSize + this.leftOverlay.sumCellSizes(0, totalColumns), "px");
      hiderStyle.height = "".concat(headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1, "px");
      if (this.scrollbarSize > 0) {
        var _wtTable$wtRootElemen = wtTable.wtRootElement, rootElemScrollHeight = _wtTable$wtRootElemen.scrollHeight, rootElemScrollWidth = _wtTable$wtRootElemen.scrollWidth;
        var _wtTable$holder = wtTable.holder, holderScrollHeight = _wtTable$holder.scrollHeight, holderScrollWidth = _wtTable$holder.scrollWidth;
        this.hasScrollbarRight = rootElemScrollHeight < holderScrollHeight;
        this.hasScrollbarBottom = rootElemScrollWidth < holderScrollWidth;
        if (this.hasScrollbarRight && wtTable.hider.scrollWidth + this.scrollbarSize > rootElemScrollWidth) {
          this.hasScrollbarBottom = true;
        } else if (this.hasScrollbarBottom && wtTable.hider.scrollHeight + this.scrollbarSize > rootElemScrollHeight) {
          this.hasScrollbarRight = true;
        }
      }
      this.topOverlay.adjustElementsSize(force);
      this.leftOverlay.adjustElementsSize(force);
      this.bottomOverlay.adjustElementsSize(force);
    }
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var wtTable = this.wot.wtTable;
      if (!wtTable.isVisible()) {
        return;
      }
      this.topOverlay.applyToDOM();
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.applyToDOM();
      }
      this.leftOverlay.applyToDOM();
    }
  }, {
    key: "getParentOverlay",
    value: function getParentOverlay(element) {
      if (!element) {
        return null;
      }
      var overlays = [this.topOverlay, this.leftOverlay, this.bottomOverlay, this.topLeftCornerOverlay, this.bottomLeftCornerOverlay];
      var result = null;
      arrayEach(overlays, function(elem) {
        if (!elem) {
          return;
        }
        if (elem.clone && elem.clone.wtTable.TABLE.contains(element)) {
          result = elem.clone;
        }
      });
      return result;
    }
  }, {
    key: "syncOverlayTableClassNames",
    value: function syncOverlayTableClassNames() {
      var masterTable = this.instance.wtTable.TABLE;
      var overlays = [this.topOverlay, this.leftOverlay, this.bottomOverlay, this.topLeftCornerOverlay, this.bottomLeftCornerOverlay];
      arrayEach(overlays, function(elem) {
        if (!elem) {
          return;
        }
        elem.clone.wtTable.TABLE.className = masterTable.className;
      });
    }
  }]);
  return Overlays2;
}();

function _classCallCheck$C(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$x(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$x(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$x(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$x(Constructor, staticProps);
  return Constructor;
}
var Scroll = /* @__PURE__ */ function() {
  function Scroll2(wotInstance) {
    _classCallCheck$C(this, Scroll2);
    this.wot = wotInstance;
  }
  _createClass$x(Scroll2, [{
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      if (coords.col < 0 || coords.row < 0) {
        return false;
      }
      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);
      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);
      return scrolledHorizontally || scrolledVertically;
    }
  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      if (!this.wot.drawn) {
        return false;
      }
      var _this$_getVariables = this._getVariables(), fixedColumnsLeft = _this$_getVariables.fixedColumnsLeft, leftOverlay = _this$_getVariables.leftOverlay, totalColumns = _this$_getVariables.totalColumns;
      var result = false;
      if (column >= 0 && column <= Math.max(totalColumns - 1, 0)) {
        var firstVisibleColumn = this.getFirstVisibleColumn();
        var lastVisibleColumn = this.getLastVisibleColumn();
        if (column >= fixedColumnsLeft && firstVisibleColumn > -1 && (column < firstVisibleColumn || snapToLeft)) {
          result = leftOverlay.scrollTo(column);
        } else if (lastVisibleColumn === -1 || lastVisibleColumn > -1 && (column > lastVisibleColumn || snapToRight)) {
          result = leftOverlay.scrollTo(column, true);
        }
      }
      return result;
    }
  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      if (!this.wot.drawn) {
        return false;
      }
      var _this$_getVariables2 = this._getVariables(), fixedRowsBottom = _this$_getVariables2.fixedRowsBottom, fixedRowsTop = _this$_getVariables2.fixedRowsTop, topOverlay = _this$_getVariables2.topOverlay, totalRows = _this$_getVariables2.totalRows;
      var result = false;
      if (row >= 0 && row <= Math.max(totalRows - 1, 0)) {
        var firstVisibleRow = this.getFirstVisibleRow();
        var lastVisibleRow = this.getLastVisibleRow();
        if (row >= fixedRowsTop && firstVisibleRow > -1 && (row < firstVisibleRow || snapToTop)) {
          result = topOverlay.scrollTo(row);
        } else if (lastVisibleRow === -1 || lastVisibleRow > -1 && (row > lastVisibleRow && row < totalRows - fixedRowsBottom || snapToBottom)) {
          result = topOverlay.scrollTo(row, true);
        }
      }
      return result;
    }
  }, {
    key: "getFirstVisibleRow",
    value: function getFirstVisibleRow() {
      var _this$_getVariables3 = this._getVariables(), topOverlay = _this$_getVariables3.topOverlay, wtTable = _this$_getVariables3.wtTable, wtViewport = _this$_getVariables3.wtViewport, totalRows = _this$_getVariables3.totalRows, fixedRowsTop = _this$_getVariables3.fixedRowsTop;
      var rootWindow = this.wot.rootWindow;
      var firstVisibleRow = wtTable.getFirstVisibleRow();
      if (topOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = offset$1(wtTable.wtRootElement);
        var totalTableHeight = innerHeight(wtTable.hider);
        var windowHeight = innerHeight(rootWindow);
        var windowScrollTop = getScrollTop(rootWindow, rootWindow);
        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {
          var rowsHeight = wtViewport.getColumnHeaderHeight();
          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);
          for (var row = totalRows; row > 0; row--) {
            rowsHeight += topOverlay.sumCellSizes(row - 1, row);
            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {
              firstVisibleRow = row;
              break;
            }
          }
        }
      }
      return firstVisibleRow;
    }
  }, {
    key: "getLastVisibleRow",
    value: function getLastVisibleRow() {
      var _this$_getVariables4 = this._getVariables(), topOverlay = _this$_getVariables4.topOverlay, wtTable = _this$_getVariables4.wtTable, wtViewport = _this$_getVariables4.wtViewport, totalRows = _this$_getVariables4.totalRows;
      var rootWindow = this.wot.rootWindow;
      var lastVisibleRow = wtTable.getLastVisibleRow();
      if (topOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = offset$1(wtTable.wtRootElement);
        var windowScrollTop = getScrollTop(rootWindow, rootWindow);
        if (rootElementOffset.top > windowScrollTop) {
          var windowHeight = innerHeight(rootWindow);
          var rowsHeight = wtViewport.getColumnHeaderHeight();
          for (var row = 1; row <= totalRows; row++) {
            rowsHeight += topOverlay.sumCellSizes(row - 1, row);
            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {
              lastVisibleRow = row - 2;
              break;
            }
          }
        }
      }
      return lastVisibleRow;
    }
  }, {
    key: "getFirstVisibleColumn",
    value: function getFirstVisibleColumn() {
      var _this$_getVariables5 = this._getVariables(), leftOverlay = _this$_getVariables5.leftOverlay, wtTable = _this$_getVariables5.wtTable, wtViewport = _this$_getVariables5.wtViewport, totalColumns = _this$_getVariables5.totalColumns;
      var rootWindow = this.wot.rootWindow;
      var firstVisibleColumn = wtTable.getFirstVisibleColumn();
      if (leftOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = offset$1(wtTable.wtRootElement);
        var totalTableWidth = innerWidth(wtTable.hider);
        var windowWidth = innerWidth(rootWindow);
        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow);
        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {
          var columnsWidth = wtViewport.getRowHeaderWidth();
          for (var column = totalColumns; column > 0; column--) {
            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);
            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {
              firstVisibleColumn = column;
              break;
            }
          }
        }
      }
      return firstVisibleColumn;
    }
  }, {
    key: "getLastVisibleColumn",
    value: function getLastVisibleColumn() {
      var _this$_getVariables6 = this._getVariables(), leftOverlay = _this$_getVariables6.leftOverlay, wtTable = _this$_getVariables6.wtTable, wtViewport = _this$_getVariables6.wtViewport, totalColumns = _this$_getVariables6.totalColumns;
      var rootWindow = this.wot.rootWindow;
      var lastVisibleColumn = wtTable.getLastVisibleColumn();
      if (leftOverlay.mainTableScrollableElement === rootWindow) {
        var rootElementOffset = offset$1(wtTable.wtRootElement);
        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow);
        if (rootElementOffset.left > windowScrollLeft) {
          var windowWidth = innerWidth(rootWindow);
          var columnsWidth = wtViewport.getRowHeaderWidth();
          for (var column = 1; column <= totalColumns; column++) {
            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);
            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {
              lastVisibleColumn = column - 2;
              break;
            }
          }
        }
      }
      return lastVisibleColumn;
    }
  }, {
    key: "_getVariables",
    value: function _getVariables() {
      var wot = this.wot;
      var topOverlay = wot.wtOverlays.topOverlay;
      var leftOverlay = wot.wtOverlays.leftOverlay;
      var wtTable = wot.wtTable;
      var wtViewport = wot.wtViewport;
      var totalRows = wot.getSetting("totalRows");
      var totalColumns = wot.getSetting("totalColumns");
      var fixedRowsTop = wot.getSetting("fixedRowsTop");
      var fixedRowsBottom = wot.getSetting("fixedRowsBottom");
      var fixedColumnsLeft = wot.getSetting("fixedColumnsLeft");
      return {
        topOverlay,
        leftOverlay,
        wtTable,
        wtViewport,
        totalRows,
        totalColumns,
        fixedRowsTop,
        fixedRowsBottom,
        fixedColumnsLeft
      };
    }
  }]);
  return Scroll2;
}();

function _classCallCheck$D(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$y(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$y(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$y(Constructor, staticProps);
  return Constructor;
}
var Settings = /* @__PURE__ */ function() {
  function Settings2(wotInstance, settings) {
    var _this = this;
    _classCallCheck$D(this, Settings2);
    this.wot = wotInstance;
    this.instance = wotInstance;
    this.defaults = {
      table: void 0,
      isDataViewInstance: true,
      externalRowCalculator: false,
      stretchH: "none",
      currentRowClassName: null,
      currentColumnClassName: null,
      preventOverflow: function preventOverflow() {
        return false;
      },
      preventWheel: false,
      data: void 0,
      freezeOverlays: false,
      fixedColumnsLeft: 0,
      fixedRowsTop: 0,
      fixedRowsBottom: 0,
      shouldRenderLeftOverlay: function shouldRenderLeftOverlay() {
        return _this.getSetting("fixedColumnsLeft") > 0 || _this.getSetting("rowHeaders").length > 0;
      },
      shouldRenderTopOverlay: function shouldRenderTopOverlay() {
        return _this.getSetting("fixedRowsTop") > 0 || _this.getSetting("columnHeaders").length > 0;
      },
      shouldRenderBottomOverlay: function shouldRenderBottomOverlay() {
        return _this.getSetting("fixedRowsBottom") > 0;
      },
      minSpareRows: 0,
      rowHeaders: function rowHeaders() {
        return [];
      },
      columnHeaders: function columnHeaders() {
        return [];
      },
      totalRows: void 0,
      totalColumns: void 0,
      cellRenderer: function cellRenderer(row, column, TD) {
        var cellData = _this.getSetting("data", row, column);
        fastInnerText(TD, cellData === void 0 || cellData === null ? "" : cellData);
      },
      columnWidth: function columnWidth() {
      },
      rowHeight: function rowHeight() {
      },
      defaultRowHeight: 23,
      defaultColumnWidth: 50,
      selections: null,
      hideBorderOnMouseDownOver: false,
      viewportRowCalculatorOverride: null,
      viewportColumnCalculatorOverride: null,
      onCellMouseDown: null,
      onCellContextMenu: null,
      onCellMouseOver: null,
      onCellMouseOut: null,
      onCellMouseUp: null,
      onCellDblClick: null,
      onCellCornerMouseDown: null,
      onCellCornerDblClick: null,
      beforeDraw: null,
      onDraw: null,
      onBeforeRemoveCellClassNames: null,
      onAfterDrawSelection: null,
      onBeforeDrawBorders: null,
      onScrollVertically: null,
      onScrollHorizontally: null,
      onBeforeTouchScroll: null,
      onAfterMomentumScroll: null,
      onBeforeStretchingColumnWidth: function onBeforeStretchingColumnWidth(width) {
        return width;
      },
      onModifyRowHeaderWidth: null,
      onModifyGetCellCoords: null,
      onBeforeHighlightingRowHeader: function onBeforeHighlightingRowHeader(sourceRow) {
        return sourceRow;
      },
      onBeforeHighlightingColumnHeader: function onBeforeHighlightingColumnHeader(sourceCol) {
        return sourceCol;
      },
      onWindowResize: null,
      scrollbarWidth: 10,
      scrollbarHeight: 10,
      renderAllRows: false,
      groups: false,
      rowHeaderWidth: null,
      columnHeaderHeight: null,
      headerClassName: null
    };
    this.settings = {};
    objectEach(this.defaults, function(value, key) {
      if (settings[key] !== void 0) {
        _this.settings[key] = settings[key];
      } else if (value === void 0) {
        throw new Error('A required setting "'.concat(key, '" was not provided'));
      } else {
        _this.settings[key] = value;
      }
    });
  }
  _createClass$y(Settings2, [{
    key: "update",
    value: function update(settings, value) {
      var _this2 = this;
      if (value === void 0) {
        objectEach(settings, function(settingValue, key) {
          _this2.settings[key] = settingValue;
        });
      } else {
        this.settings[settings] = value;
      }
      return this.wot;
    }
  }, {
    key: "getSetting",
    value: function getSetting(key, param1, param2, param3, param4) {
      if (typeof this.settings[key] === "function") {
        return this.settings[key](param1, param2, param3, param4);
      } else if (param1 !== void 0 && Array.isArray(this.settings[key])) {
        return this.settings[key][param1];
      }
      return this.settings[key];
    }
  }, {
    key: "has",
    value: function has(key) {
      return !!this.settings[key];
    }
  }]);
  return Settings2;
}();

function _classCallCheck$E(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$z(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$z(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$z(Constructor, staticProps);
  return Constructor;
}
var Viewport = /* @__PURE__ */ function() {
  function Viewport2(wotInstance) {
    var _this = this;
    _classCallCheck$E(this, Viewport2);
    this.wot = wotInstance;
    this.instance = this.wot;
    this.oversizedRows = [];
    this.oversizedColumnHeaders = [];
    this.hasOversizedColumnHeadersMarked = {};
    this.clientHeight = 0;
    this.containerWidth = NaN;
    this.rowHeaderWidth = NaN;
    this.rowsVisibleCalculator = null;
    this.columnsVisibleCalculator = null;
    this.eventManager = new EventManager(this.wot);
    this.eventManager.addEventListener(this.wot.rootWindow, "resize", function() {
      _this.clientHeight = _this.getWorkspaceHeight();
    });
  }
  _createClass$z(Viewport2, [{
    key: "getWorkspaceHeight",
    value: function getWorkspaceHeight() {
      var currentDocument = this.wot.rootDocument;
      var trimmingContainer = this.instance.wtOverlays.topOverlay.trimmingContainer;
      var height = 0;
      if (trimmingContainer === this.wot.rootWindow) {
        height = currentDocument.documentElement.clientHeight;
      } else {
        var elemHeight = outerHeight(trimmingContainer);
        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;
      }
      return height;
    }
  }, {
    key: "getWorkspaceWidth",
    value: function getWorkspaceWidth() {
      var wot = this.wot;
      var rootDocument = wot.rootDocument, rootWindow = wot.rootWindow;
      var trimmingContainer = this.instance.wtOverlays.leftOverlay.trimmingContainer;
      var docOffsetWidth = rootDocument.documentElement.offsetWidth;
      var totalColumns = wot.getSetting("totalColumns");
      var preventOverflow = wot.getSetting("preventOverflow");
      var width;
      var overflow;
      if (preventOverflow) {
        return outerWidth(this.instance.wtTable.wtRootElement);
      }
      if (wot.getSetting("freezeOverlays")) {
        width = Math.min(docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
      } else {
        width = Math.min(this.getContainerFillWidth(), docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
      }
      if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {
        return rootDocument.documentElement.clientWidth;
      }
      if (trimmingContainer !== rootWindow) {
        overflow = getStyle(this.instance.wtOverlays.leftOverlay.trimmingContainer, "overflow", rootWindow);
        if (overflow === "scroll" || overflow === "hidden" || overflow === "auto") {
          return Math.max(width, trimmingContainer.clientWidth);
        }
      }
      var stretchSetting = wot.getSetting("stretchH");
      if (stretchSetting === "none" || !stretchSetting) {
        return Math.max(width, outerWidth(this.instance.wtTable.TABLE));
      }
      return width;
    }
  }, {
    key: "hasVerticalScroll",
    value: function hasVerticalScroll() {
      return this.getWorkspaceActualHeight() > this.getWorkspaceHeight();
    }
  }, {
    key: "hasHorizontalScroll",
    value: function hasHorizontalScroll() {
      return this.getWorkspaceActualWidth() > this.getWorkspaceWidth();
    }
  }, {
    key: "sumColumnWidths",
    value: function sumColumnWidths(from, length) {
      var wtTable = this.wot.wtTable;
      var sum = 0;
      var column = from;
      while (column < length) {
        sum += wtTable.getColumnWidth(column);
        column += 1;
      }
      return sum;
    }
  }, {
    key: "getContainerFillWidth",
    value: function getContainerFillWidth() {
      if (this.containerWidth) {
        return this.containerWidth;
      }
      var mainContainer = this.instance.wtTable.holder;
      var dummyElement = this.wot.rootDocument.createElement("div");
      dummyElement.style.width = "100%";
      dummyElement.style.height = "1px";
      mainContainer.appendChild(dummyElement);
      var fillWidth = dummyElement.offsetWidth;
      this.containerWidth = fillWidth;
      mainContainer.removeChild(dummyElement);
      return fillWidth;
    }
  }, {
    key: "getWorkspaceOffset",
    value: function getWorkspaceOffset() {
      return offset$1(this.wot.wtTable.TABLE);
    }
  }, {
    key: "getWorkspaceActualHeight",
    value: function getWorkspaceActualHeight() {
      return outerHeight(this.wot.wtTable.TABLE);
    }
  }, {
    key: "getWorkspaceActualWidth",
    value: function getWorkspaceActualWidth() {
      var wtTable = this.wot.wtTable;
      return outerWidth(wtTable.TABLE) || outerWidth(wtTable.TBODY) || outerWidth(wtTable.THEAD);
    }
  }, {
    key: "getColumnHeaderHeight",
    value: function getColumnHeaderHeight() {
      var columnHeaders = this.instance.getSetting("columnHeaders");
      if (!columnHeaders.length) {
        this.columnHeaderHeight = 0;
      } else if (isNaN(this.columnHeaderHeight)) {
        this.columnHeaderHeight = outerHeight(this.wot.wtTable.THEAD);
      }
      return this.columnHeaderHeight;
    }
  }, {
    key: "getViewportHeight",
    value: function getViewportHeight() {
      var containerHeight = this.getWorkspaceHeight();
      if (containerHeight === Infinity) {
        return containerHeight;
      }
      var columnHeaderHeight = this.getColumnHeaderHeight();
      if (columnHeaderHeight > 0) {
        containerHeight -= columnHeaderHeight;
      }
      return containerHeight;
    }
  }, {
    key: "getRowHeaderWidth",
    value: function getRowHeaderWidth() {
      var rowHeadersWidthSetting = this.instance.getSetting("rowHeaderWidth");
      var rowHeaders = this.instance.getSetting("rowHeaders");
      if (rowHeadersWidthSetting) {
        this.rowHeaderWidth = 0;
        for (var i = 0, len = rowHeaders.length; i < len; i++) {
          this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;
        }
      }
      if (this.wot.cloneSource) {
        return this.wot.cloneSource.wtViewport.getRowHeaderWidth();
      }
      if (isNaN(this.rowHeaderWidth)) {
        if (rowHeaders.length) {
          var TH = this.instance.wtTable.TABLE.querySelector("TH");
          this.rowHeaderWidth = 0;
          for (var _i = 0, _len = rowHeaders.length; _i < _len; _i++) {
            if (TH) {
              this.rowHeaderWidth += outerWidth(TH);
              TH = TH.nextSibling;
            } else {
              this.rowHeaderWidth += 50;
            }
          }
        } else {
          this.rowHeaderWidth = 0;
        }
      }
      this.rowHeaderWidth = this.instance.getSetting("onModifyRowHeaderWidth", this.rowHeaderWidth) || this.rowHeaderWidth;
      return this.rowHeaderWidth;
    }
  }, {
    key: "getViewportWidth",
    value: function getViewportWidth() {
      var containerWidth = this.getWorkspaceWidth();
      if (containerWidth === Infinity) {
        return containerWidth;
      }
      var rowHeaderWidth = this.getRowHeaderWidth();
      if (rowHeaderWidth > 0) {
        return containerWidth - rowHeaderWidth;
      }
      return containerWidth;
    }
  }, {
    key: "createRowsCalculator",
    value: function createRowsCalculator() {
      var calculationType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RENDER_TYPE;
      var wot = this.wot;
      var wtSettings = wot.wtSettings, wtOverlays = wot.wtOverlays, wtTable = wot.wtTable, rootDocument = wot.rootDocument;
      var height;
      var scrollbarHeight;
      var fixedRowsHeight;
      this.rowHeaderWidth = NaN;
      if (wtSettings.settings.renderAllRows && calculationType === RENDER_TYPE) {
        height = Infinity;
      } else {
        height = this.getViewportHeight();
      }
      var pos = wtOverlays.topOverlay.getScrollPosition() - wtOverlays.topOverlay.getTableParentOffset();
      if (pos < 0) {
        pos = 0;
      }
      var fixedRowsTop = wot.getSetting("fixedRowsTop");
      var fixedRowsBottom = wot.getSetting("fixedRowsBottom");
      var totalRows = wot.getSetting("totalRows");
      if (fixedRowsTop) {
        fixedRowsHeight = wtOverlays.topOverlay.sumCellSizes(0, fixedRowsTop);
        pos += fixedRowsHeight;
        height -= fixedRowsHeight;
      }
      if (fixedRowsBottom && wtOverlays.bottomOverlay.clone) {
        fixedRowsHeight = wtOverlays.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
        height -= fixedRowsHeight;
      }
      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {
        scrollbarHeight = 0;
      } else {
        scrollbarHeight = getScrollbarWidth(rootDocument);
      }
      return new ViewportRowsCalculator({
        viewportSize: height,
        scrollOffset: pos,
        totalItems: wot.getSetting("totalRows"),
        itemSizeFn: function itemSizeFn(sourceRow) {
          return wtTable.getRowHeight(sourceRow);
        },
        overrideFn: wtSettings.settings.viewportRowCalculatorOverride,
        calculationType,
        scrollbarHeight
      });
    }
  }, {
    key: "createColumnsCalculator",
    value: function createColumnsCalculator() {
      var calculationType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RENDER_TYPE;
      var wot = this.wot;
      var wtSettings = wot.wtSettings, wtOverlays = wot.wtOverlays, wtTable = wot.wtTable, rootDocument = wot.rootDocument;
      var width = this.getViewportWidth();
      var pos = wtOverlays.leftOverlay.getScrollPosition() - wtOverlays.leftOverlay.getTableParentOffset();
      this.columnHeaderHeight = NaN;
      if (pos < 0) {
        pos = 0;
      }
      var fixedColumnsLeft = wot.getSetting("fixedColumnsLeft");
      if (fixedColumnsLeft) {
        var fixedColumnsWidth = wtOverlays.leftOverlay.sumCellSizes(0, fixedColumnsLeft);
        pos += fixedColumnsWidth;
        width -= fixedColumnsWidth;
      }
      if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {
        width -= getScrollbarWidth(rootDocument);
      }
      return new ViewportColumnsCalculator({
        viewportSize: width,
        scrollOffset: pos,
        totalItems: wot.getSetting("totalColumns"),
        itemSizeFn: function itemSizeFn(sourceCol) {
          return wot.wtTable.getColumnWidth(sourceCol);
        },
        overrideFn: wtSettings.settings.viewportColumnCalculatorOverride,
        calculationType,
        stretchMode: wot.getSetting("stretchH"),
        stretchingItemWidthFn: function stretchingItemWidthFn(stretchedWidth, column) {
          return wot.getSetting("onBeforeStretchingColumnWidth", stretchedWidth, column);
        }
      });
    }
  }, {
    key: "createRenderCalculators",
    value: function createRenderCalculators() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var runFastDraw = fastDraw;
      if (runFastDraw) {
        var proposedRowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);
        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);
        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {
          runFastDraw = false;
        }
      }
      if (!runFastDraw) {
        this.rowsRenderCalculator = this.createRowsCalculator(RENDER_TYPE);
        this.columnsRenderCalculator = this.createColumnsCalculator(RENDER_TYPE);
      }
      this.rowsVisibleCalculator = null;
      this.columnsVisibleCalculator = null;
      return runFastDraw;
    }
  }, {
    key: "createVisibleCalculators",
    value: function createVisibleCalculators() {
      this.rowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);
      this.columnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);
    }
  }, {
    key: "areAllProposedVisibleRowsAlreadyRendered",
    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {
      if (!this.rowsVisibleCalculator) {
        return false;
      }
      var startRow = proposedRowsVisibleCalculator.startRow, endRow = proposedRowsVisibleCalculator.endRow;
      var _this$rowsRenderCalcu = this.rowsRenderCalculator, renderedStartRow = _this$rowsRenderCalcu.startRow, renderedEndRow = _this$rowsRenderCalcu.endRow;
      if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {
        return false;
      } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wot.getSetting("totalRows") - 1) {
        return false;
      }
      return true;
    }
  }, {
    key: "areAllProposedVisibleColumnsAlreadyRendered",
    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {
      if (!this.columnsVisibleCalculator) {
        return false;
      }
      var startColumn = proposedColumnsVisibleCalculator.startColumn, endColumn = proposedColumnsVisibleCalculator.endColumn;
      var _this$columnsRenderCa = this.columnsRenderCalculator, renderedStartColumn = _this$columnsRenderCa.startColumn, renderedEndColumn = _this$columnsRenderCa.endColumn;
      if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {
        return false;
      } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wot.getSetting("totalColumns") - 1) {
        return false;
      }
      return true;
    }
  }, {
    key: "resetHasOversizedColumnHeadersMarked",
    value: function resetHasOversizedColumnHeadersMarked() {
      objectEach(this.hasOversizedColumnHeadersMarked, function(value, key, object) {
        object[key] = void 0;
      });
    }
  }]);
  return Viewport2;
}();

function _classCallCheck$F(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$A(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$A(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$A(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$A(Constructor, staticProps);
  return Constructor;
}
var Walkontable = /* @__PURE__ */ function() {
  function Walkontable2(settings) {
    _classCallCheck$F(this, Walkontable2);
    var originalHeaders = [];
    this.guid = "wt_".concat(randomString());
    this.rootDocument = settings.table.ownerDocument;
    this.rootWindow = this.rootDocument.defaultView;
    if (settings.cloneSource) {
      this.cloneSource = settings.cloneSource;
      this.cloneOverlay = settings.cloneOverlay;
      this.wtSettings = settings.cloneSource.wtSettings;
      this.wtTable = this.cloneOverlay.createTable(this, settings.table);
      this.wtScroll = new Scroll(this);
      this.wtViewport = settings.cloneSource.wtViewport;
      this.wtEvent = new Event$1(this);
      this.selections = this.cloneSource.selections;
    } else {
      this.wtSettings = new Settings(this, settings);
      this.wtTable = new MasterTable(this, settings.table);
      this.wtScroll = new Scroll(this);
      this.wtViewport = new Viewport(this);
      this.wtEvent = new Event$1(this);
      this.selections = this.getSetting("selections");
      this.wtOverlays = new Overlays(this);
      this.exportSettingsAsClassNames();
    }
    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
      for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {
        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);
      }
      if (!this.getSetting("columnHeaders").length) {
        this.update("columnHeaders", [function(column, TH) {
          fastInnerText(TH, originalHeaders[column]);
        }]);
      }
    }
    this.drawn = false;
    this.drawInterrupted = false;
  }
  _createClass$A(Walkontable2, [{
    key: "draw",
    value: function draw() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.drawInterrupted = false;
      if (!fastDraw && !this.wtTable.isVisible()) {
        this.drawInterrupted = true;
      } else {
        this.wtTable.draw(fastDraw);
      }
      return this;
    }
  }, {
    key: "getCell",
    value: function getCell(coords) {
      var topmost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!topmost) {
        return this.wtTable.getCell(coords);
      }
      var totalRows = this.wtSettings.getSetting("totalRows");
      var fixedRowsTop = this.wtSettings.getSetting("fixedRowsTop");
      var fixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
      var fixedColumns = this.wtSettings.getSetting("fixedColumnsLeft");
      if (coords.row < fixedRowsTop && coords.col < fixedColumns) {
        return this.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell(coords);
      } else if (coords.row < fixedRowsTop) {
        return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);
      } else if (coords.col < fixedColumns && coords.row >= totalRows - fixedRowsBottom) {
        if (this.wtOverlays.bottomLeftCornerOverlay && this.wtOverlays.bottomLeftCornerOverlay.clone) {
          return this.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell(coords);
        }
      } else if (coords.col < fixedColumns) {
        return this.wtOverlays.leftOverlay.clone.wtTable.getCell(coords);
      } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {
        if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {
          return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);
        }
      }
      return this.wtTable.getCell(coords);
    }
  }, {
    key: "update",
    value: function update(settings, value) {
      return this.wtSettings.update(settings, value);
    }
  }, {
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      if (coords.col < 0 || coords.row < 0) {
        return false;
      }
      return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      if (column < 0) {
        return false;
      }
      return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);
    }
  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      if (row < 0) {
        return false;
      }
      return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);
    }
  }, {
    key: "getViewport",
    value: function getViewport() {
      return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];
    }
  }, {
    key: "getOverlayName",
    value: function getOverlayName() {
      return this.cloneOverlay ? this.cloneOverlay.type : "master";
    }
  }, {
    key: "exportSettingsAsClassNames",
    value: function exportSettingsAsClassNames() {
      var _this = this;
      var toExport = {
        rowHeaders: "htRowHeaders",
        columnHeaders: "htColumnHeaders"
      };
      var allClassNames = [];
      var newClassNames = [];
      objectEach(toExport, function(className, key) {
        if (_this.getSetting(key).length) {
          newClassNames.push(className);
        }
        allClassNames.push(className);
      });
      removeClass(this.wtTable.wtRootElement.parentNode, allClassNames);
      addClass(this.wtTable.wtRootElement.parentNode, newClassNames);
    }
  }, {
    key: "getSetting",
    value: function getSetting(key, param1, param2, param3, param4) {
      return this.wtSettings.getSetting(key, param1, param2, param3, param4);
    }
  }, {
    key: "hasSetting",
    value: function hasSetting(key) {
      return this.wtSettings.has(key);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.wtOverlays.destroy();
      this.wtEvent.destroy();
    }
  }]);
  return Walkontable2;
}();

function _slicedToArray$2(arr, i) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$2(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof$m(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$m = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$m = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$m(obj);
}
function _classCallCheck$G(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$B(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$B(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$B(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$B(Constructor, staticProps);
  return Constructor;
}
var Selection = /* @__PURE__ */ function() {
  function Selection2(settings, cellRange) {
    _classCallCheck$G(this, Selection2);
    this.settings = settings;
    this.cellRange = cellRange || null;
    this.instanceBorders = {};
    this.classNames = [this.settings.className];
    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);
  }
  _createClass$B(Selection2, [{
    key: "getBorder",
    value: function getBorder(wotInstance) {
      if (!this.instanceBorders[wotInstance.guid]) {
        this.instanceBorders[wotInstance.guid] = new Border(wotInstance, this.settings);
      }
      return this.instanceBorders[wotInstance.guid];
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.cellRange === null;
    }
  }, {
    key: "add",
    value: function add(coords) {
      if (this.isEmpty()) {
        this.cellRange = new CellRange(coords);
      } else {
        this.cellRange.expand(coords);
      }
      return this;
    }
  }, {
    key: "replace",
    value: function replace(oldCoords, newCoords) {
      if (!this.isEmpty()) {
        if (this.cellRange.from.isEqual(oldCoords)) {
          this.cellRange.from = newCoords;
          return true;
        }
        if (this.cellRange.to.isEqual(oldCoords)) {
          this.cellRange.to = newCoords;
          return true;
        }
      }
      return false;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.cellRange = null;
      return this;
    }
  }, {
    key: "getCorners",
    value: function getCorners() {
      var topLeft = this.cellRange.getOuterTopLeftCorner();
      var bottomRight = this.cellRange.getOuterBottomRightCorner();
      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];
    }
  }, {
    key: "addClassAtCoords",
    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {
      var markIntersections = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      var TD = wotInstance.wtTable.getCell(new CellCoords(sourceRow, sourceColumn));
      if (_typeof$m(TD) === "object") {
        var cellClassName = className;
        if (markIntersections) {
          cellClassName = this.classNameGenerator(TD);
          if (!this.classNames.includes(cellClassName)) {
            this.classNames.push(cellClassName);
          }
        }
        addClass(TD, cellClassName);
      }
      return this;
    }
  }, {
    key: "linearClassNameGenerator",
    value: function linearClassNameGenerator(baseClassName, layerLevelOwner) {
      return function calcClassName(element) {
        var previousIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
        if (layerLevelOwner === 0 || previousIndex === 0) {
          return baseClassName;
        }
        var index = previousIndex >= 0 ? previousIndex : layerLevelOwner;
        var className = baseClassName;
        index -= 1;
        var previousClassName = index === 0 ? baseClassName : "".concat(baseClassName, "-").concat(index);
        if (hasClass(element, previousClassName)) {
          var currentLayer = index + 1;
          className = "".concat(baseClassName, "-").concat(currentLayer);
        } else {
          className = calcClassName(element, index);
        }
        return className;
      };
    }
  }, {
    key: "draw",
    value: function draw(wotInstance) {
      if (this.isEmpty()) {
        if (this.settings.border) {
          this.getBorder(wotInstance).disappear();
        }
        return;
      }
      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();
      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();
      var corners = this.getCorners();
      var _corners = _slicedToArray$2(corners, 4), topRow = _corners[0], topColumn = _corners[1], bottomRow = _corners[2], bottomColumn = _corners[3];
      var _this$settings = this.settings, highlightHeaderClassName = _this$settings.highlightHeaderClassName, highlightColumnClassName = _this$settings.highlightColumnClassName, highlightRowClassName = _this$settings.highlightRowClassName, highlightOnlyClosestHeader = _this$settings.highlightOnlyClosestHeader, selectionType = _this$settings.selectionType;
      var isHeaderSelectionType = selectionType === void 0 || ["active-header", "header"].includes(selectionType);
      if (isHeaderSelectionType && topColumn !== null && bottomColumn !== null) {
        var selectionColumnCursor = 0;
        for (var column = 0; column < renderedColumns; column += 1) {
          var sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);
          if (sourceCol >= topColumn && sourceCol <= bottomColumn) {
            var THs = wotInstance.wtTable.getColumnHeaders(sourceCol);
            var closestHeaderLevel = THs.length - 1;
            if (highlightOnlyClosestHeader && THs.length > 1) {
              THs = [THs[closestHeaderLevel]];
            }
            for (var headerLevel = 0; headerLevel < THs.length; headerLevel += 1) {
              var newClasses = [];
              var TH = THs[headerLevel];
              if (highlightHeaderClassName) {
                newClasses.push(highlightHeaderClassName);
              }
              if (highlightColumnClassName) {
                newClasses.push(highlightColumnClassName);
              }
              headerLevel = highlightOnlyClosestHeader ? closestHeaderLevel : headerLevel;
              var newSourceCol = wotInstance.getSetting("onBeforeHighlightingColumnHeader", sourceCol, headerLevel, {
                selectionType,
                columnCursor: selectionColumnCursor,
                selectionWidth: bottomColumn - topColumn + 1,
                classNames: newClasses
              });
              if (newSourceCol !== sourceCol) {
                TH = wotInstance.wtTable.getColumnHeader(newSourceCol, headerLevel);
              }
              addClass(TH, newClasses);
            }
            selectionColumnCursor += 1;
          }
        }
      }
      if (topRow !== null && bottomRow !== null) {
        var selectionRowCursor = 0;
        for (var row = 0; row < renderedRows; row += 1) {
          var sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);
          if (isHeaderSelectionType && sourceRow >= topRow && sourceRow <= bottomRow) {
            var _THs = wotInstance.wtTable.getRowHeaders(sourceRow);
            var _closestHeaderLevel = _THs.length - 1;
            if (highlightOnlyClosestHeader && _THs.length > 1) {
              _THs = [_THs[_closestHeaderLevel]];
            }
            for (var _headerLevel = 0; _headerLevel < _THs.length; _headerLevel += 1) {
              var _newClasses = [];
              var _TH = _THs[_headerLevel];
              if (highlightHeaderClassName) {
                _newClasses.push(highlightHeaderClassName);
              }
              if (highlightRowClassName) {
                _newClasses.push(highlightRowClassName);
              }
              _headerLevel = highlightOnlyClosestHeader ? _closestHeaderLevel : _headerLevel;
              var newSourceRow = wotInstance.getSetting("onBeforeHighlightingRowHeader", sourceRow, _headerLevel, {
                selectionType,
                rowCursor: selectionRowCursor,
                selectionHeight: bottomRow - topRow + 1,
                classNames: _newClasses
              });
              if (newSourceRow !== sourceRow) {
                _TH = wotInstance.wtTable.getRowHeader(newSourceRow, _headerLevel);
              }
              addClass(_TH, _newClasses);
            }
            selectionRowCursor += 1;
          }
          if (topColumn !== null && bottomColumn !== null) {
            for (var _column = 0; _column < renderedColumns; _column += 1) {
              var _sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(_column);
              if (sourceRow >= topRow && sourceRow <= bottomRow && _sourceCol >= topColumn && _sourceCol <= bottomColumn) {
                if (this.settings.className) {
                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.className, this.settings.markIntersections);
                }
              } else if (sourceRow >= topRow && sourceRow <= bottomRow) {
                if (highlightRowClassName) {
                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, highlightRowClassName);
                }
              } else if (_sourceCol >= topColumn && _sourceCol <= bottomColumn) {
                if (highlightColumnClassName) {
                  this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, highlightColumnClassName);
                }
              }
              var additionalSelectionClass = wotInstance.getSetting("onAfterDrawSelection", sourceRow, _sourceCol, this.settings.layerLevel);
              if (typeof additionalSelectionClass === "string") {
                this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, additionalSelectionClass);
              }
            }
          }
        }
      }
      wotInstance.getSetting("onBeforeDrawBorders", corners, this.settings.className);
      if (this.settings.border) {
        this.getBorder(wotInstance).appear(corners);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      Object.values(this.instanceBorders).forEach(function(border) {
        return border.destroy();
      });
    }
  }]);
  return Selection2;
}();

var _templateObject$2;
function _classCallCheck$H(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$C(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$C(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$C(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$C(Constructor, staticProps);
  return Constructor;
}
function _taggedTemplateLiteral$2(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
var REGISTERED_HOOKS = [
  "afterCellMetaReset",
  "afterChange",
  "afterContextMenuDefaultOptions",
  "beforeContextMenuSetItems",
  "afterDropdownMenuDefaultOptions",
  "beforeDropdownMenuSetItems",
  "afterContextMenuHide",
  "beforeContextMenuShow",
  "afterContextMenuShow",
  "afterCopyLimit",
  "beforeCreateCol",
  "afterCreateCol",
  "beforeCreateRow",
  "afterCreateRow",
  "afterDeselect",
  "afterDestroy",
  "afterDocumentKeyDown",
  "afterDrawSelection",
  "beforeRemoveCellClassNames",
  "afterGetCellMeta",
  "afterGetColHeader",
  "afterGetRowHeader",
  "afterInit",
  "afterLoadData",
  "afterMomentumScroll",
  "afterOnCellCornerMouseDown",
  "afterOnCellCornerDblClick",
  "afterOnCellMouseDown",
  "afterOnCellMouseUp",
  "afterOnCellContextMenu",
  "afterOnCellMouseOver",
  "afterOnCellMouseOut",
  "afterRemoveCol",
  "afterRemoveRow",
  "afterRender",
  "beforeRenderer",
  "afterRenderer",
  "afterScrollHorizontally",
  "afterScrollVertically",
  "afterSelection",
  "afterSelectionByProp",
  "afterSelectionEnd",
  "afterSelectionEndByProp",
  "afterSetCellMeta",
  "afterRemoveCellMeta",
  "afterSetDataAtCell",
  "afterSetDataAtRowProp",
  "afterSetSourceDataAtCell",
  "afterUpdateSettings",
  "afterValidate",
  "beforeLanguageChange",
  "afterLanguageChange",
  "beforeAutofill",
  "afterAutofill",
  "beforeCellAlignment",
  "beforeChange",
  "beforeChangeRender",
  "beforeDrawBorders",
  "beforeGetCellMeta",
  "beforeRemoveCellMeta",
  "beforeInit",
  "beforeInitWalkontable",
  "beforeLoadData",
  "beforeKeyDown",
  "beforeOnCellMouseDown",
  "beforeOnCellMouseUp",
  "beforeOnCellContextMenu",
  "beforeOnCellMouseOver",
  "beforeOnCellMouseOut",
  "beforeRemoveCol",
  "beforeRemoveRow",
  "beforeRender",
  "beforeSetCellMeta",
  "beforeSetRangeStartOnly",
  "beforeSetRangeStart",
  "beforeSetRangeEnd",
  "beforeTouchScroll",
  "beforeValidate",
  "beforeValueRender",
  "construct",
  "init",
  "modifyColHeader",
  "modifyColWidth",
  "modifyRowHeader",
  "modifyRowHeight",
  "modifyData",
  "modifySourceData",
  "modifyRowData",
  "modifyGetCellCoords",
  "beforeHighlightingRowHeader",
  "beforeHighlightingColumnHeader",
  "persistentStateLoad",
  "persistentStateReset",
  "persistentStateSave",
  "beforeColumnSort",
  "afterColumnSort",
  "modifyAutofillRange",
  "modifyCopyableRange",
  "beforeCut",
  "afterCut",
  "beforeCopy",
  "afterCopy",
  "beforePaste",
  "afterPaste",
  "beforeColumnMove",
  "afterColumnMove",
  "beforeRowMove",
  "afterRowMove",
  "beforeColumnResize",
  "afterColumnResize",
  "beforeRowResize",
  "afterRowResize",
  "afterGetColumnHeaderRenderers",
  "afterGetRowHeaderRenderers",
  "beforeStretchingColumnWidth",
  "beforeFilter",
  "afterFilter",
  "afterFormulasValuesUpdate",
  "afterNamedExpressionAdded",
  "afterNamedExpressionRemoved",
  "afterSheetAdded",
  "afterSheetRenamed",
  "afterSheetRemoved",
  "modifyColumnHeaderHeight",
  "beforeUndo",
  "beforeUndoStackChange",
  "afterUndo",
  "afterUndoStackChange",
  "beforeRedo",
  "beforeRedoStackChange",
  "afterRedo",
  "afterRedoStackChange",
  "modifyRowHeaderWidth",
  "beforeAutofillInsidePopulate",
  "modifyTransformStart",
  "modifyTransformEnd",
  "afterModifyTransformStart",
  "afterModifyTransformEnd",
  "afterViewportRowCalculatorOverride",
  "afterViewportColumnCalculatorOverride",
  "afterPluginsInitialized",
  "beforeHideRows",
  "afterHideRows",
  "beforeUnhideRows",
  "afterUnhideRows",
  "beforeHideColumns",
  "afterHideColumns",
  "beforeUnhideColumns",
  "afterUnhideColumns",
  "beforeTrimRow",
  "afterTrimRow",
  "beforeUntrimRow",
  "afterUntrimRow",
  "beforeDropdownMenuShow",
  "afterDropdownMenuShow",
  "afterDropdownMenuHide",
  "beforeAddChild",
  "afterAddChild",
  "beforeDetachChild",
  "afterDetachChild",
  "afterBeginEditing",
  "beforeMergeCells",
  "afterMergeCells",
  "beforeUnmergeCells",
  "afterUnmergeCells",
  "afterListen",
  "afterUnlisten",
  "afterRefreshDimensions",
  "beforeRefreshDimensions",
  "beforeColumnCollapse",
  "afterColumnCollapse",
  "beforeColumnExpand",
  "afterColumnExpand",
  "modifyAutoColumnSizeSeed"
];
var REMOVED_MESSAGE = toSingleLine(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral$2(['The plugin hook "[hookName]" was removed in Handsontable [removedInVersion]. \n  Please consult release notes https://github.com/handsontable/handsontable/releases/tag/[removedInVersion] to \n  learn about the migration path.'], ['The plugin hook "[hookName]" was removed in Handsontable [removedInVersion].\\x20\n  Please consult release notes https://github.com/handsontable/handsontable/releases/tag/[removedInVersion] to\\x20\n  learn about the migration path.'])));
var REMOVED_HOOKS = new Map([["modifyRow", "8.0.0"], ["modifyCol", "8.0.0"], ["unmodifyRow", "8.0.0"], ["unmodifyCol", "8.0.0"], ["skipLengthCache", "8.0.0"], ["hiddenColumn", "8.0.0"], ["hiddenRow", "8.0.0"]]);
var DEPRECATED_HOOKS = new Map([["beforeAutofillInsidePopulate", 'The plugin hook "beforeAutofillInsidePopulate" is deprecated and will be removed in the next major release.']]);
var Hooks = /* @__PURE__ */ function() {
  function Hooks2() {
    _classCallCheck$H(this, Hooks2);
    this.globalBucket = this.createEmptyBucket();
  }
  _createClass$C(Hooks2, [{
    key: "createEmptyBucket",
    value: function createEmptyBucket() {
      var bucket = Object.create(null);
      arrayEach(REGISTERED_HOOKS, function(hook) {
        return bucket[hook] = [];
      });
      return bucket;
    }
  }, {
    key: "getBucket",
    value: function getBucket() {
      var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (context) {
        if (!context.pluginHookBucket) {
          context.pluginHookBucket = this.createEmptyBucket();
        }
        return context.pluginHookBucket;
      }
      return this.globalBucket;
    }
  }, {
    key: "add",
    value: function add(key, callback) {
      var _this = this;
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (Array.isArray(callback)) {
        arrayEach(callback, function(c) {
          return _this.add(key, c, context);
        });
      } else {
        if (REMOVED_HOOKS.has(key)) {
          warn$1(substitute(REMOVED_MESSAGE, {
            hookName: key,
            removedInVersion: REMOVED_HOOKS.get(key)
          }));
        }
        if (DEPRECATED_HOOKS.has(key)) {
          warn$1(DEPRECATED_HOOKS.get(key));
        }
        var bucket = this.getBucket(context);
        if (typeof bucket[key] === "undefined") {
          this.register(key);
          bucket[key] = [];
        }
        callback.skip = false;
        if (bucket[key].indexOf(callback) === -1) {
          var foundInitialHook = false;
          if (callback.initialHook) {
            arrayEach(bucket[key], function(cb, i) {
              if (cb.initialHook) {
                bucket[key][i] = callback;
                foundInitialHook = true;
                return false;
              }
            });
          }
          if (!foundInitialHook) {
            bucket[key].push(callback);
          }
        }
      }
      return this;
    }
  }, {
    key: "once",
    value: function once(key, callback) {
      var _this2 = this;
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (Array.isArray(callback)) {
        arrayEach(callback, function(c) {
          return _this2.once(key, c, context);
        });
      } else {
        callback.runOnce = true;
        this.add(key, callback, context);
      }
    }
  }, {
    key: "remove",
    value: function remove(key, callback) {
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var bucket = this.getBucket(context);
      if (typeof bucket[key] !== "undefined") {
        if (bucket[key].indexOf(callback) >= 0) {
          callback.skip = true;
          return true;
        }
      }
      return false;
    }
  }, {
    key: "has",
    value: function has(key) {
      var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var bucket = this.getBucket(context);
      return !!(bucket[key] !== void 0 && bucket[key].length);
    }
  }, {
    key: "run",
    value: function run(context, key, p1, p2, p3, p4, p5, p6) {
      {
        var globalHandlers = this.globalBucket[key];
        var length = globalHandlers ? globalHandlers.length : 0;
        var index = 0;
        if (length) {
          while (index < length) {
            if (!globalHandlers[index] || globalHandlers[index].skip) {
              index += 1;
              continue;
            }
            var res = globalHandlers[index].call(context, p1, p2, p3, p4, p5, p6);
            if (res !== void 0) {
              p1 = res;
            }
            if (globalHandlers[index] && globalHandlers[index].runOnce) {
              this.remove(key, globalHandlers[index]);
            }
            index += 1;
          }
        }
      }
      {
        var localHandlers = this.getBucket(context)[key];
        var _length = localHandlers ? localHandlers.length : 0;
        var _index = 0;
        if (_length) {
          while (_index < _length) {
            if (!localHandlers[_index] || localHandlers[_index].skip) {
              _index += 1;
              continue;
            }
            var _res = localHandlers[_index].call(context, p1, p2, p3, p4, p5, p6);
            if (_res !== void 0) {
              p1 = _res;
            }
            if (localHandlers[_index] && localHandlers[_index].runOnce) {
              this.remove(key, localHandlers[_index], context);
            }
            _index += 1;
          }
        }
      }
      return p1;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      objectEach(this.getBucket(context), function(value, key, bucket) {
        return bucket[key].length = 0;
      });
    }
  }, {
    key: "register",
    value: function register(key) {
      if (!this.isRegistered(key)) {
        REGISTERED_HOOKS.push(key);
      }
    }
  }, {
    key: "deregister",
    value: function deregister(key) {
      if (this.isRegistered(key)) {
        REGISTERED_HOOKS.splice(REGISTERED_HOOKS.indexOf(key), 1);
      }
    }
  }, {
    key: "isDeprecated",
    value: function isDeprecated(hookName) {
      return DEPRECATED_HOOKS.has(hookName) || REMOVED_HOOKS.has(hookName);
    }
  }, {
    key: "isRegistered",
    value: function isRegistered(hookName) {
      return REGISTERED_HOOKS.indexOf(hookName) >= 0;
    }
  }, {
    key: "getRegistered",
    value: function getRegistered() {
      return REGISTERED_HOOKS;
    }
  }], [{
    key: "getSingleton",
    value: function getSingleton() {
      return getGlobalSingleton();
    }
  }]);
  return Hooks2;
}();
var globalSingleton = new Hooks();
function getGlobalSingleton() {
  return globalSingleton;
}

function _toConsumableArray$4(arr) {
  return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$4(o, minLen);
}
function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$4(arr);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var collection = new Map();
function staticRegister() {
  var namespace = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "common";
  if (!collection.has(namespace)) {
    collection.set(namespace, new Map());
  }
  var subCollection = collection.get(namespace);
  function register(name, item) {
    subCollection.set(name, item);
  }
  function getItem(name) {
    return subCollection.get(name);
  }
  function hasItem(name) {
    return subCollection.has(name);
  }
  function getNames() {
    return _toConsumableArray$4(subCollection.keys());
  }
  function getValues() {
    return _toConsumableArray$4(subCollection.values());
  }
  return {
    register,
    getItem,
    hasItem,
    getNames,
    getValues
  };
}

var registeredEditorClasses = new WeakMap();
var _staticRegister = staticRegister("editors"), register = _staticRegister.register, getItem = _staticRegister.getItem, hasItem = _staticRegister.hasItem, getNames = _staticRegister.getNames;
function RegisteredEditor(editorClass) {
  var instances = {};
  var Clazz = editorClass;
  this.getConstructor = function() {
    return editorClass;
  };
  this.getInstance = function(hotInstance) {
    if (!(hotInstance.guid in instances)) {
      instances[hotInstance.guid] = new Clazz(hotInstance);
    }
    return instances[hotInstance.guid];
  };
  Hooks.getSingleton().add("afterDestroy", function() {
    instances[this.guid] = null;
  });
}
function _getEditorInstance(name, hotInstance) {
  var editor;
  if (typeof name === "function") {
    if (!registeredEditorClasses.get(name)) {
      _register(null, name);
    }
    editor = registeredEditorClasses.get(name);
  } else if (typeof name === "string") {
    editor = getItem(name);
  } else {
    throw Error('Only strings and functions can be passed as "editor" parameter');
  }
  if (!editor) {
    throw Error('No editor registered under name "'.concat(name, '"'));
  }
  return editor.getInstance(hotInstance);
}
function _getItem(name) {
  if (!hasItem(name)) {
    throw Error('No registered editor found under "'.concat(name, '" name'));
  }
  return getItem(name).getConstructor();
}
function _register(name, editorClass) {
  if (name && typeof name !== "string") {
    editorClass = name;
    name = editorClass.EDITOR_TYPE;
  }
  var editorWrapper = new RegisteredEditor(editorClass);
  if (typeof name === "string") {
    register(name, editorWrapper);
  }
  registeredEditorClasses.set(editorClass, editorWrapper);
}

var MIXIN_NAME$5 = "hooksRefRegisterer";
var hooksRefRegisterer = {
  _hooksStorage: Object.create(null),
  addHook: function addHook(key, callback) {
    if (!this._hooksStorage[key]) {
      this._hooksStorage[key] = [];
    }
    this.hot.addHook(key, callback);
    this._hooksStorage[key].push(callback);
    return this;
  },
  removeHooksByKey: function removeHooksByKey(key) {
    var _this = this;
    arrayEach(this._hooksStorage[key] || [], function(callback) {
      _this.hot.removeHook(key, callback);
    });
  },
  clearHooks: function clearHooks() {
    var _this2 = this;
    objectEach(this._hooksStorage, function(callbacks, name) {
      return _this2.removeHooksByKey(name);
    });
    this._hooksStorage = {};
  }
};
defineGetter(hooksRefRegisterer, "MIXIN_NAME", MIXIN_NAME$5, {
  writable: false,
  enumerable: false
});

function _typeof$n(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$n = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$n = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$n(obj);
}
function _slicedToArray$3(arr, i) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$5(arr, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$5(o, minLen);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$3(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _inherits$h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$h(subClass, superClass);
}
function _setPrototypeOf$h(o, p) {
  _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$h(o, p);
}
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$h(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$h(this, result);
  };
}
function _possibleConstructorReturn$h(self, call) {
  if (call && (_typeof$n(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$h(self);
}
function _assertThisInitialized$h(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$h(o) {
  _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$h(o);
}
function _classCallCheck$I(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$D(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$D(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$D(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$D(Constructor, staticProps);
  return Constructor;
}
var EDITOR_TYPE = "base";
var EDITOR_STATE = Object.freeze({
  VIRGIN: "STATE_VIRGIN",
  EDITING: "STATE_EDITING",
  WAITING: "STATE_WAITING",
  FINISHED: "STATE_FINISHED"
});
var BaseEditor = /* @__PURE__ */ function() {
  function BaseEditor2(instance) {
    _classCallCheck$I(this, BaseEditor2);
    this.hot = instance;
    this.instance = instance;
    this.state = EDITOR_STATE.VIRGIN;
    this._opened = false;
    this._fullEditMode = false;
    this._closeCallback = null;
    this.TD = null;
    this.row = null;
    this.col = null;
    this.prop = null;
    this.originalValue = null;
    this.cellProperties = null;
    this.init();
  }
  _createClass$D(BaseEditor2, [{
    key: "_fireCallbacks",
    value: function _fireCallbacks(result) {
      if (this._closeCallback) {
        this._closeCallback(result);
        this._closeCallback = null;
      }
    }
  }, {
    key: "init",
    value: function init() {
    }
  }, {
    key: "getValue",
    value: function getValue() {
      throw Error("Editor getValue() method unimplemented");
    }
  }, {
    key: "setValue",
    value: function setValue() {
      throw Error("Editor setValue() method unimplemented");
    }
  }, {
    key: "open",
    value: function open() {
      throw Error("Editor open() method unimplemented");
    }
  }, {
    key: "close",
    value: function close() {
      throw Error("Editor close() method unimplemented");
    }
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      this.TD = td;
      this.row = row;
      this.col = col;
      this.prop = prop;
      this.originalValue = value;
      this.cellProperties = cellProperties;
      this.state = EDITOR_STATE.VIRGIN;
    }
  }, {
    key: "extend",
    value: function extend() {
      return /* @__PURE__ */ function(_this$constructor) {
        _inherits$h(Editor, _this$constructor);
        var _super = _createSuper$h(Editor);
        function Editor() {
          _classCallCheck$I(this, Editor);
          return _super.apply(this, arguments);
        }
        return Editor;
      }(this.constructor);
    }
  }, {
    key: "saveValue",
    value: function saveValue(value, ctrlDown) {
      var visualRowFrom;
      var visualColumnFrom;
      var visualRowTo;
      var visualColumnTo;
      if (ctrlDown) {
        var selectedLast = this.hot.getSelectedLast();
        visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0);
        visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0);
        visualRowTo = Math.max(selectedLast[0], selectedLast[2]);
        visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);
      } else {
        var _ref = [this.row, this.col, null, null];
        visualRowFrom = _ref[0];
        visualColumnFrom = _ref[1];
        visualRowTo = _ref[2];
        visualColumnTo = _ref[3];
      }
      var modifiedCellCoords = this.hot.runHooks("modifyGetCellCoords", visualRowFrom, visualColumnFrom);
      if (Array.isArray(modifiedCellCoords)) {
        var _modifiedCellCoords = _slicedToArray$3(modifiedCellCoords, 2);
        visualRowFrom = _modifiedCellCoords[0];
        visualColumnFrom = _modifiedCellCoords[1];
      }
      this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, "edit");
    }
  }, {
    key: "beginEditing",
    value: function beginEditing(newInitialValue, event) {
      if (this.state !== EDITOR_STATE.VIRGIN) {
        return;
      }
      var hotInstance = this.hot;
      var renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);
      var renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);
      hotInstance.view.scrollViewport(new CellCoords(renderableRowIndex, renderableColumnIndex));
      this.state = EDITOR_STATE.EDITING;
      if (this.isInFullEditMode()) {
        var stringifiedInitialValue = typeof newInitialValue === "string" ? newInitialValue : stringify(this.originalValue);
        this.setValue(stringifiedInitialValue);
      }
      this.open(event);
      this._opened = true;
      this.focus();
      hotInstance.view.render();
      hotInstance.runHooks("afterBeginEditing", this.row, this.col);
    }
  }, {
    key: "finishEditing",
    value: function finishEditing(restoreOriginalValue, ctrlDown, callback) {
      var _this = this;
      var val;
      if (callback) {
        var previousCloseCallback = this._closeCallback;
        this._closeCallback = function(result) {
          if (previousCloseCallback) {
            previousCloseCallback(result);
          }
          callback(result);
          _this.hot.view.render();
        };
      }
      if (this.isWaiting()) {
        return;
      }
      if (this.state === EDITOR_STATE.VIRGIN) {
        this.hot._registerTimeout(function() {
          _this._fireCallbacks(true);
        });
        return;
      }
      if (this.state === EDITOR_STATE.EDITING) {
        if (restoreOriginalValue) {
          this.cancelChanges();
          this.hot.view.render();
          return;
        }
        var value = this.getValue();
        if (this.hot.getSettings().trimWhitespace) {
          val = [[typeof value === "string" ? String.prototype.trim.call(value || "") : value]];
        } else {
          val = [[value]];
        }
        this.state = EDITOR_STATE.WAITING;
        this.saveValue(val, ctrlDown);
        if (this.hot.getCellValidator(this.cellProperties)) {
          this.hot.addHookOnce("postAfterValidate", function(result) {
            _this.state = EDITOR_STATE.FINISHED;
            _this.discardEditor(result);
          });
        } else {
          this.state = EDITOR_STATE.FINISHED;
          this.discardEditor(true);
        }
      }
    }
  }, {
    key: "cancelChanges",
    value: function cancelChanges() {
      this.state = EDITOR_STATE.FINISHED;
      this.discardEditor();
    }
  }, {
    key: "discardEditor",
    value: function discardEditor(result) {
      if (this.state !== EDITOR_STATE.FINISHED) {
        return;
      }
      if (result === false && this.cellProperties.allowInvalid !== true) {
        this.hot.selectCell(this.row, this.col);
        this.focus();
        this.state = EDITOR_STATE.EDITING;
        this._fireCallbacks(false);
      } else {
        this.close();
        this._opened = false;
        this._fullEditMode = false;
        this.state = EDITOR_STATE.VIRGIN;
        this._fireCallbacks(true);
      }
    }
  }, {
    key: "enableFullEditMode",
    value: function enableFullEditMode() {
      this._fullEditMode = true;
    }
  }, {
    key: "isInFullEditMode",
    value: function isInFullEditMode() {
      return this._fullEditMode;
    }
  }, {
    key: "isOpened",
    value: function isOpened() {
      return this._opened;
    }
  }, {
    key: "isWaiting",
    value: function isWaiting() {
      return this.state === EDITOR_STATE.WAITING;
    }
  }, {
    key: "getEditedCellsLayerClass",
    value: function getEditedCellsLayerClass() {
      var editorSection = this.checkEditorSection();
      switch (editorSection) {
        case "right":
          return "ht_clone_right";
        case "left":
          return "ht_clone_left";
        case "bottom":
          return "ht_clone_bottom";
        case "bottom-right-corner":
          return "ht_clone_bottom_right_corner";
        case "bottom-left-corner":
          return "ht_clone_bottom_left_corner";
        case "top":
          return "ht_clone_top";
        case "top-right-corner":
          return "ht_clone_top_right_corner";
        case "top-left-corner":
          return "ht_clone_top_left_corner";
        default:
          return "ht_clone_master";
      }
    }
  }, {
    key: "getEditedCell",
    value: function getEditedCell() {
      return this.hot.getCell(this.row, this.col, true);
    }
  }, {
    key: "checkEditorSection",
    value: function checkEditorSection() {
      var totalRows = this.hot.countRows();
      var section = "";
      if (this.row < this.hot.getSettings().fixedRowsTop) {
        if (this.col < this.hot.getSettings().fixedColumnsLeft) {
          section = "top-left-corner";
        } else {
          section = "top";
        }
      } else if (this.hot.getSettings().fixedRowsBottom && this.row >= totalRows - this.hot.getSettings().fixedRowsBottom) {
        if (this.col < this.hot.getSettings().fixedColumnsLeft) {
          section = "bottom-left-corner";
        } else {
          section = "bottom";
        }
      } else if (this.col < this.hot.getSettings().fixedColumnsLeft) {
        section = "left";
      }
      return section;
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE;
    }
  }]);
  return BaseEditor2;
}();
mixin(BaseEditor, hooksRefRegisterer);

function _slicedToArray$4(arr, i) {
  return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$4(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$4(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$J(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$E(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$E(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$E(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$E(Constructor, staticProps);
  return Constructor;
}
var EditorManager = /* @__PURE__ */ function() {
  function EditorManager2(instance, tableMeta, selection) {
    var _this = this;
    _classCallCheck$J(this, EditorManager2);
    this.instance = instance;
    this.tableMeta = tableMeta;
    this.selection = selection;
    this.eventManager = new EventManager(instance);
    this.destroyed = false;
    this.lock = false;
    this.activeEditor = void 0;
    this.cellProperties = void 0;
    this.lastKeyCode = void 0;
    this.instance.addHook("afterDocumentKeyDown", function(event2) {
      return _this.onAfterDocumentKeyDown(event2);
    });
    var frame = this.instance.rootWindow;
    while (frame) {
      this.eventManager.addEventListener(frame.document.documentElement, "keydown", function(event2) {
        if (!_this.destroyed) {
          _this.instance.runHooks("afterDocumentKeyDown", event2);
        }
      });
      frame = getParentWindow(frame);
    }
    this.eventManager.addEventListener(this.instance.rootDocument.documentElement, "compositionstart", function(event2) {
      if (!_this.destroyed && _this.activeEditor && !_this.activeEditor.isOpened() && _this.instance.isListening()) {
        _this.openEditor("", event2);
      }
    });
    this.instance.view.wt.update("onCellDblClick", function(event2, coords, elem) {
      return _this.onCellDblClick(event2, coords, elem);
    });
  }
  _createClass$E(EditorManager2, [{
    key: "lockEditor",
    value: function lockEditor() {
      this.lock = true;
    }
  }, {
    key: "unlockEditor",
    value: function unlockEditor() {
      this.lock = false;
    }
  }, {
    key: "destroyEditor",
    value: function destroyEditor(revertOriginal) {
      if (!this.lock) {
        this.closeEditor(revertOriginal);
      }
    }
  }, {
    key: "getActiveEditor",
    value: function getActiveEditor() {
      return this.activeEditor;
    }
  }, {
    key: "prepareEditor",
    value: function prepareEditor() {
      var _this2 = this;
      if (this.lock) {
        return;
      }
      if (this.activeEditor && this.activeEditor.isWaiting()) {
        this.closeEditor(false, false, function(dataSaved) {
          if (dataSaved) {
            _this2.prepareEditor();
          }
        });
        return;
      }
      var _this$instance$select = this.instance.selection.selectedRange.current().highlight, row = _this$instance$select.row, col = _this$instance$select.col;
      var modifiedCellCoords = this.instance.runHooks("modifyGetCellCoords", row, col);
      var visualRowToCheck = row;
      var visualColumnToCheck = col;
      if (Array.isArray(modifiedCellCoords)) {
        var _modifiedCellCoords = _slicedToArray$4(modifiedCellCoords, 2);
        visualRowToCheck = _modifiedCellCoords[0];
        visualColumnToCheck = _modifiedCellCoords[1];
      }
      this.cellProperties = this.instance.getCellMeta(visualRowToCheck, visualColumnToCheck);
      var activeElement = this.instance.rootDocument.activeElement;
      if (activeElement) {
        activeElement.blur();
      }
      if (this.cellProperties.readOnly) {
        this.clearActiveEditor();
        return;
      }
      var editorClass = this.instance.getCellEditor(this.cellProperties);
      var td = this.instance.getCell(row, col, true);
      if (editorClass && td) {
        var prop = this.instance.colToProp(visualColumnToCheck);
        var originalValue = this.instance.getSourceDataAtCell(this.instance.toPhysicalRow(visualRowToCheck), visualColumnToCheck);
        this.activeEditor = _getEditorInstance(editorClass, this.instance);
        this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);
      } else {
        this.clearActiveEditor();
      }
    }
  }, {
    key: "isEditorOpened",
    value: function isEditorOpened() {
      return this.activeEditor && this.activeEditor.isOpened();
    }
  }, {
    key: "openEditor",
    value: function openEditor(newInitialValue, event2) {
      if (!this.activeEditor) {
        return;
      }
      this.activeEditor.beginEditing(newInitialValue, event2);
    }
  }, {
    key: "closeEditor",
    value: function closeEditor(restoreOriginalValue, isCtrlPressed, callback) {
      if (this.activeEditor) {
        this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);
      } else if (callback) {
        callback(false);
      }
    }
  }, {
    key: "closeEditorAndSaveChanges",
    value: function closeEditorAndSaveChanges(isCtrlPressed) {
      this.closeEditor(false, isCtrlPressed);
    }
  }, {
    key: "closeEditorAndRestoreOriginalValue",
    value: function closeEditorAndRestoreOriginalValue(isCtrlPressed) {
      this.closeEditor(true, isCtrlPressed);
    }
  }, {
    key: "clearActiveEditor",
    value: function clearActiveEditor() {
      this.activeEditor = void 0;
    }
  }, {
    key: "moveSelectionAfterEnter",
    value: function moveSelectionAfterEnter(isShiftPressed) {
      var enterMoves = typeof this.tableMeta.enterMoves === "function" ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves;
      if (isShiftPressed) {
        this.selection.transformStart(-enterMoves.row, -enterMoves.col);
      } else {
        this.selection.transformStart(enterMoves.row, enterMoves.col, true);
      }
    }
  }, {
    key: "moveSelectionUp",
    value: function moveSelectionUp(isShiftPressed) {
      if (isShiftPressed) {
        this.selection.transformEnd(-1, 0);
      } else {
        this.selection.transformStart(-1, 0);
      }
    }
  }, {
    key: "moveSelectionDown",
    value: function moveSelectionDown(isShiftPressed) {
      if (isShiftPressed) {
        this.selection.transformEnd(1, 0);
      } else {
        this.selection.transformStart(1, 0);
      }
    }
  }, {
    key: "moveSelectionRight",
    value: function moveSelectionRight(isShiftPressed) {
      if (isShiftPressed) {
        this.selection.transformEnd(0, 1);
      } else {
        this.selection.transformStart(0, 1);
      }
    }
  }, {
    key: "moveSelectionLeft",
    value: function moveSelectionLeft(isShiftPressed) {
      if (isShiftPressed) {
        this.selection.transformEnd(0, -1);
      } else {
        this.selection.transformStart(0, -1);
      }
    }
  }, {
    key: "onAfterDocumentKeyDown",
    value: function onAfterDocumentKeyDown(event2) {
      if (!this.instance.isListening()) {
        return;
      }
      this.instance.runHooks("beforeKeyDown", event2);
      if (this.destroyed || event2.keyCode === 229) {
        return;
      }
      if (isImmediatePropagationStopped(event2)) {
        return;
      }
      this.lastKeyCode = event2.keyCode;
      if (!this.selection.isSelected()) {
        return;
      }
      var isCtrlPressed = (event2.ctrlKey || event2.metaKey) && !event2.altKey;
      if (this.activeEditor && !this.activeEditor.isWaiting()) {
        if (!isMetaKey(event2.keyCode) && !isCtrlMetaKey(event2.keyCode) && !isCtrlPressed && !this.isEditorOpened()) {
          this.openEditor("", event2);
          return;
        }
      }
      var isShiftPressed = event2.shiftKey;
      var rangeModifier = isShiftPressed ? this.selection.setRangeEnd : this.selection.setRangeStart;
      var tabMoves;
      switch (event2.keyCode) {
        case KEY_CODES.A:
          if (!this.isEditorOpened() && isCtrlPressed) {
            this.instance.selectAll();
            event2.preventDefault();
            event2.stopPropagation();
          }
          break;
        case KEY_CODES.ARROW_UP:
          if (this.isEditorOpened() && !this.activeEditor.isWaiting()) {
            this.closeEditorAndSaveChanges(isCtrlPressed);
          }
          this.moveSelectionUp(isShiftPressed);
          event2.preventDefault();
          event2.stopPropagation();
          break;
        case KEY_CODES.ARROW_DOWN:
          if (this.isEditorOpened() && !this.activeEditor.isWaiting()) {
            this.closeEditorAndSaveChanges(isCtrlPressed);
          }
          this.moveSelectionDown(isShiftPressed);
          event2.preventDefault();
          event2.stopPropagation();
          break;
        case KEY_CODES.ARROW_RIGHT:
          if (this.isEditorOpened() && !this.activeEditor.isWaiting()) {
            this.closeEditorAndSaveChanges(isCtrlPressed);
          }
          this.moveSelectionRight(isShiftPressed);
          event2.preventDefault();
          event2.stopPropagation();
          break;
        case KEY_CODES.ARROW_LEFT:
          if (this.isEditorOpened() && !this.activeEditor.isWaiting()) {
            this.closeEditorAndSaveChanges(isCtrlPressed);
          }
          this.moveSelectionLeft(isShiftPressed);
          event2.preventDefault();
          event2.stopPropagation();
          break;
        case KEY_CODES.TAB:
          tabMoves = typeof this.tableMeta.tabMoves === "function" ? this.tableMeta.tabMoves(event2) : this.tableMeta.tabMoves;
          if (isShiftPressed) {
            this.selection.transformStart(-tabMoves.row, -tabMoves.col);
          } else {
            this.selection.transformStart(tabMoves.row, tabMoves.col, true);
          }
          event2.preventDefault();
          event2.stopPropagation();
          break;
        case KEY_CODES.BACKSPACE:
        case KEY_CODES.DELETE:
          this.instance.emptySelectedCells();
          this.prepareEditor();
          event2.preventDefault();
          break;
        case KEY_CODES.F2:
          if (this.activeEditor) {
            this.activeEditor.enableFullEditMode();
          }
          this.openEditor(null, event2);
          event2.preventDefault();
          break;
        case KEY_CODES.ENTER:
          if (this.isEditorOpened()) {
            if (this.activeEditor && this.activeEditor.state !== EDITOR_STATE.WAITING) {
              this.closeEditorAndSaveChanges(isCtrlPressed);
            }
            this.moveSelectionAfterEnter(isShiftPressed);
          } else if (this.instance.getSettings().enterBeginsEditing) {
            if (this.cellProperties.readOnly) {
              this.moveSelectionAfterEnter();
            } else if (this.activeEditor) {
              this.activeEditor.enableFullEditMode();
              this.openEditor(null, event2);
            }
          } else {
            this.moveSelectionAfterEnter(isShiftPressed);
          }
          event2.preventDefault();
          stopImmediatePropagation(event2);
          break;
        case KEY_CODES.ESCAPE:
          if (this.isEditorOpened()) {
            this.closeEditorAndRestoreOriginalValue(isCtrlPressed);
            this.activeEditor.focus();
          }
          event2.preventDefault();
          break;
        case KEY_CODES.HOME:
          if (event2.ctrlKey || event2.metaKey) {
            rangeModifier.call(this.selection, new CellCoords(this.instance.rowIndexMapper.getFirstNotHiddenIndex(0, 1), this.selection.selectedRange.current().from.col));
          } else {
            rangeModifier.call(this.selection, new CellCoords(this.selection.selectedRange.current().from.row, this.instance.columnIndexMapper.getFirstNotHiddenIndex(0, 1)));
          }
          event2.preventDefault();
          event2.stopPropagation();
          break;
        case KEY_CODES.END:
          if (event2.ctrlKey || event2.metaKey) {
            rangeModifier.call(this.selection, new CellCoords(this.instance.rowIndexMapper.getFirstNotHiddenIndex(this.instance.countRows() - 1, -1), this.selection.selectedRange.current().from.col));
          } else {
            rangeModifier.call(this.selection, new CellCoords(this.selection.selectedRange.current().from.row, this.instance.columnIndexMapper.getFirstNotHiddenIndex(this.instance.countCols() - 1, -1)));
          }
          event2.preventDefault();
          event2.stopPropagation();
          break;
        case KEY_CODES.PAGE_UP:
          this.selection.transformStart(-this.instance.countVisibleRows(), 0);
          event2.preventDefault();
          event2.stopPropagation();
          break;
        case KEY_CODES.PAGE_DOWN:
          this.selection.transformStart(this.instance.countVisibleRows(), 0);
          event2.preventDefault();
          event2.stopPropagation();
          break;
      }
    }
  }, {
    key: "onCellDblClick",
    value: function onCellDblClick(event2, coords, elem) {
      if (elem.nodeName === "TD") {
        if (this.activeEditor) {
          this.activeEditor.enableFullEditMode();
        }
        this.openEditor(null, event2);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.eventManager.destroy();
    }
  }]);
  return EditorManager2;
}();
var instances = new WeakMap();
EditorManager.getInstance = function(hotInstance, tableMeta, selection) {
  var editorManager = instances.get(hotInstance);
  if (!editorManager) {
    editorManager = new EditorManager(hotInstance, tableMeta, selection);
    instances.set(hotInstance, editorManager);
  }
  return editorManager;
};

// @@match logic
fixRegexpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function (string) {
      var res = maybeCallNative(nativeMatch, this, string);
      if (res.done) return res.value;

      var rx = anObject(this);
      var S = String(string);

      if (!rx.global) return regexpExecAbstract(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regexpExecAbstract(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

/* eslint-disable es/no-array-prototype-lastindexof -- safe */





var min$1 = Math.min;
var $lastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO$1 = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD$1 = arrayMethodIsStrict('lastIndexOf');
var FORCED$1 = NEGATIVE_ZERO$1 || !STRICT_METHOD$1;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
var arrayLastIndexOf = FORCED$1 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO$1) return $lastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min$1(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : $lastIndexOf;

// `Array.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
// eslint-disable-next-line es/no-array-prototype-lastindexof -- required for testing
_export({ target: 'Array', proto: true, forced: arrayLastIndexOf !== [].lastIndexOf }, {
  lastIndexOf: arrayLastIndexOf
});

var $findIndex = arrayIteration.findIndex;


var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
_export({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);

function _toConsumableArray$5(arr) {
  return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$7(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$7(o, minLen);
}
function _iterableToArray$3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$7(arr);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var ESCAPED_HTML_CHARS = {
  "&nbsp;": " ",
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">"
};
var regEscapedChars = new RegExp(Object.keys(ESCAPED_HTML_CHARS).map(function(key) {
  return "(".concat(key, ")");
}).join("|"), "gi");
function isHTMLTable(element) {
  return (element && element.nodeName || "") === "TABLE";
}
function instanceToHTML(instance) {
  var hasColumnHeaders = instance.hasColHeaders();
  var hasRowHeaders = instance.hasRowHeaders();
  var coords = [hasColumnHeaders ? -1 : 0, hasRowHeaders ? -1 : 0, instance.countRows() - 1, instance.countCols() - 1];
  var data = instance.getData.apply(instance, coords);
  var countRows = data.length;
  var countCols = countRows > 0 ? data[0].length : 0;
  var TABLE = ["<table>", "</table>"];
  var THEAD = hasColumnHeaders ? ["<thead>", "</thead>"] : [];
  var TBODY = ["<tbody>", "</tbody>"];
  var rowModifier = hasRowHeaders ? 1 : 0;
  var columnModifier = hasColumnHeaders ? 1 : 0;
  for (var row = 0; row < countRows; row += 1) {
    var isColumnHeadersRow = hasColumnHeaders && row === 0;
    var CELLS = [];
    for (var column = 0; column < countCols; column += 1) {
      var isRowHeadersColumn = !isColumnHeadersRow && hasRowHeaders && column === 0;
      var cell = "";
      if (isColumnHeadersRow) {
        cell = "<th>".concat(instance.getColHeader(column - rowModifier), "</th>");
      } else if (isRowHeadersColumn) {
        cell = "<th>".concat(instance.getRowHeader(row - columnModifier), "</th>");
      } else {
        var cellData = data[row][column];
        var _instance$getCellMeta = instance.getCellMeta(row - rowModifier, column - columnModifier), hidden = _instance$getCellMeta.hidden, rowspan = _instance$getCellMeta.rowspan, colspan = _instance$getCellMeta.colspan;
        if (!hidden) {
          var attrs = [];
          if (rowspan) {
            attrs.push('rowspan="'.concat(rowspan, '"'));
          }
          if (colspan) {
            attrs.push('colspan="'.concat(colspan, '"'));
          }
          if (isEmpty(cellData)) {
            cell = "<td ".concat(attrs.join(" "), "></td>");
          } else {
            var value = cellData.toString().replace("<", "&lt;").replace(">", "&gt;").replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, "<br>\r\n").replace(/\x20/gi, "&nbsp;").replace(/\t/gi, "&#9;");
            cell = "<td ".concat(attrs.join(" "), ">").concat(value, "</td>");
          }
        }
      }
      CELLS.push(cell);
    }
    var TR = ["<tr>"].concat(CELLS, ["</tr>"]).join("");
    if (isColumnHeadersRow) {
      THEAD.splice(1, 0, TR);
    } else {
      TBODY.splice(-1, 0, TR);
    }
  }
  TABLE.splice(1, 0, THEAD.join(""), TBODY.join(""));
  return TABLE.join("");
}
function _dataToHTML(input) {
  var inputLen = input.length;
  var result = ["<table>"];
  for (var row = 0; row < inputLen; row += 1) {
    var rowData = input[row];
    var columnsLen = rowData.length;
    var columnsResult = [];
    if (row === 0) {
      result.push("<tbody>");
    }
    for (var column = 0; column < columnsLen; column += 1) {
      var cellData = rowData[column];
      var parsedCellData = isEmpty(cellData) ? "" : cellData.toString().replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, "<br>\r\n").replace(/\x20/gi, "&nbsp;").replace(/\t/gi, "&#9;");
      columnsResult.push("<td>".concat(parsedCellData, "</td>"));
    }
    result.push.apply(result, ["<tr>"].concat(columnsResult, ["</tr>"]));
    if (row + 1 === inputLen) {
      result.push("</tbody>");
    }
  }
  result.push("</table>");
  return result.join("");
}
function htmlToGridSettings(element) {
  var rootDocument = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document;
  var settingsObj = {};
  var fragment = rootDocument.createDocumentFragment();
  var tempElem = rootDocument.createElement("div");
  fragment.appendChild(tempElem);
  var checkElement = element;
  if (typeof checkElement === "string") {
    var escapedAdjacentHTML = checkElement.replace(/<td\b[^>]*?>([\s\S]*?)<\/\s*td>/g, function(cellFragment) {
      var openingTag = cellFragment.match(/<td\b[^>]*?>/g)[0];
      var cellValue2 = cellFragment.substring(openingTag.length, cellFragment.lastIndexOf("<")).replace(/(<(?!br)([^>]+)>)/gi, "");
      var closingTag = "</td>";
      return "".concat(openingTag).concat(cellValue2).concat(closingTag);
    });
    tempElem.insertAdjacentHTML("afterbegin", "".concat(escapedAdjacentHTML));
    checkElement = tempElem.querySelector("table");
  }
  if (!checkElement || !isHTMLTable(checkElement)) {
    return;
  }
  var generator = tempElem.querySelector('meta[name$="enerator"]');
  var hasRowHeaders = checkElement.querySelector("tbody th") !== null;
  var trElement = checkElement.querySelector("tr");
  var countCols = !trElement ? 0 : Array.from(trElement.cells).reduce(function(cols, cell2) {
    return cols + cell2.colSpan;
  }, 0) - (hasRowHeaders ? 1 : 0);
  var fixedRowsBottom = checkElement.tFoot && Array.from(checkElement.tFoot.rows) || [];
  var fixedRowsTop = [];
  var hasColHeaders = false;
  var thRowsLen = 0;
  var countRows = 0;
  if (checkElement.tHead) {
    var thRows = Array.from(checkElement.tHead.rows).filter(function(tr2) {
      var isDataRow = tr2.querySelector("td") !== null;
      if (isDataRow) {
        fixedRowsTop.push(tr2);
      }
      return !isDataRow;
    });
    thRowsLen = thRows.length;
    hasColHeaders = thRowsLen > 0;
    if (thRowsLen > 1) {
      settingsObj.nestedHeaders = Array.from(thRows).reduce(function(rows, row2) {
        var headersRow = Array.from(row2.cells).reduce(function(headers, header, currentIndex) {
          if (hasRowHeaders && currentIndex === 0) {
            return headers;
          }
          var colspan2 = header.colSpan, innerHTML2 = header.innerHTML;
          var nextHeader = colspan2 > 1 ? {
            label: innerHTML2,
            colspan: colspan2
          } : innerHTML2;
          headers.push(nextHeader);
          return headers;
        }, []);
        rows.push(headersRow);
        return rows;
      }, []);
    } else if (hasColHeaders) {
      settingsObj.colHeaders = Array.from(thRows[0].children).reduce(function(headers, header, index) {
        if (hasRowHeaders && index === 0) {
          return headers;
        }
        headers.push(header.innerHTML);
        return headers;
      }, []);
    }
  }
  if (fixedRowsTop.length) {
    settingsObj.fixedRowsTop = fixedRowsTop.length;
  }
  if (fixedRowsBottom.length) {
    settingsObj.fixedRowsBottom = fixedRowsBottom.length;
  }
  var dataRows = [].concat(fixedRowsTop, _toConsumableArray$5(Array.from(checkElement.tBodies).reduce(function(sections, section) {
    sections.push.apply(sections, _toConsumableArray$5(Array.from(section.rows)));
    return sections;
  }, [])), _toConsumableArray$5(fixedRowsBottom));
  countRows = dataRows.length;
  var dataArr = new Array(countRows);
  for (var r = 0; r < countRows; r++) {
    dataArr[r] = new Array(countCols);
  }
  var mergeCells = [];
  var rowHeaders = [];
  for (var row = 0; row < countRows; row++) {
    var tr = dataRows[row];
    var cells = Array.from(tr.cells);
    var cellsLen = cells.length;
    for (var cellId = 0; cellId < cellsLen; cellId++) {
      var cell = cells[cellId];
      var nodeName = cell.nodeName, innerHTML = cell.innerHTML, rowspan = cell.rowSpan, colspan = cell.colSpan;
      var col = dataArr[row].findIndex(function(value) {
        return value === void 0;
      });
      if (nodeName === "TD") {
        if (rowspan > 1 || colspan > 1) {
          for (var rstart = row; rstart < row + rowspan; rstart++) {
            if (rstart < countRows) {
              for (var cstart = col; cstart < col + colspan; cstart++) {
                dataArr[rstart][cstart] = null;
              }
            }
          }
          var styleAttr = cell.getAttribute("style");
          var ignoreMerge = styleAttr && styleAttr.includes("mso-ignore:colspan");
          if (!ignoreMerge) {
            mergeCells.push({
              col,
              row,
              rowspan,
              colspan
            });
          }
        }
        var cellValue = "";
        if (generator && /excel/gi.test(generator.content)) {
          cellValue = innerHTML.replace(/[\r\n][\x20]{0,2}/g, " ").replace(/<br(\s*|\/)>[\r\n]?[\x20]{0,3}/gim, "\r\n");
        } else {
          cellValue = innerHTML.replace(/<br(\s*|\/)>[\r\n]?/gim, "\r\n");
        }
        dataArr[row][col] = cellValue.replace(regEscapedChars, function(match) {
          return ESCAPED_HTML_CHARS[match];
        });
      } else {
        rowHeaders.push(innerHTML);
      }
    }
  }
  if (mergeCells.length) {
    settingsObj.mergeCells = mergeCells;
  }
  if (rowHeaders.length) {
    settingsObj.rowHeaders = rowHeaders;
  }
  if (dataArr.length) {
    settingsObj.data = dataArr;
  }
  return settingsObj;
}

var parseTableHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  instanceToHTML: instanceToHTML,
  _dataToHTML: _dataToHTML,
  htmlToGridSettings: htmlToGridSettings
});

function _typeof$o(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$o = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$o = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$o(obj);
}
function isNumeric(value) {
  var t = _typeof$o(value);
  return t == "number" ? !isNaN(value) && isFinite(value) : t == "string" ? !value.length ? false : value.length == 1 ? /\d/.test(value) : /^\s*[+-]?\s*(?:(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/i.test(value) : t == "object" ? !!value && typeof value.valueOf() == "number" && !(value instanceof Date) : false;
}
function rangeEach(rangeFrom, rangeTo, iteratee) {
  var index = -1;
  if (typeof rangeTo === "function") {
    iteratee = rangeTo;
    rangeTo = rangeFrom;
  } else {
    index = rangeFrom - 1;
  }
  while (++index <= rangeTo) {
    if (iteratee(index) === false) {
      break;
    }
  }
}
function rangeEachReverse(rangeFrom, rangeTo, iteratee) {
  var index = rangeFrom + 1;
  if (typeof rangeTo === "function") {
    iteratee = rangeTo;
    rangeTo = 0;
  }
  while (--index >= rangeTo) {
    if (iteratee(index) === false) {
      break;
    }
  }
}
function valueAccordingPercent(value, percent) {
  percent = parseInt(percent.toString().replace("%", ""), 10);
  percent = parseInt(value * percent / 100, 10);
  return percent;
}

var numberHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isNumeric: isNumeric,
  rangeEach: rangeEach,
  rangeEachReverse: rangeEachReverse,
  valueAccordingPercent: valueAccordingPercent
});

function _toConsumableArray$6(arr) {
  return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$8(arr);
}
function _slicedToArray$5(arr, i) {
  return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$8(arr, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$8(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$8(o, minLen);
}
function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$5(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$5(arr) {
  if (Array.isArray(arr))
    return arr;
}
var ASC = "asc";
var DESC = "desc";
var ORDER_MAP = new Map([[ASC, [-1, 1]], [DESC, [1, -1]]]);
var DEFAULT_ERROR_PRIORITY_EXISTS = function DEFAULT_ERROR_PRIORITY_EXISTS2(priority) {
  return "The priority '".concat(priority, "' is already declared in a map.");
};
var DEFAULT_ERROR_PRIORITY_NAN = function DEFAULT_ERROR_PRIORITY_NAN2(priority) {
  return "The priority '".concat(priority, "' is not a number.");
};
function createPriorityMap() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, errorPriorityExists = _ref.errorPriorityExists, errorPriorityNaN = _ref.errorPriorityNaN;
  var priorityMap = new Map();
  errorPriorityExists = isFunction$1(errorPriorityExists) ? errorPriorityExists : DEFAULT_ERROR_PRIORITY_EXISTS;
  errorPriorityNaN = isFunction$1(errorPriorityNaN) ? errorPriorityNaN : DEFAULT_ERROR_PRIORITY_NAN;
  function addItem(priority, item) {
    if (!isNumeric(priority)) {
      throw new Error(errorPriorityNaN(priority));
    }
    if (priorityMap.has(priority)) {
      throw new Error(errorPriorityExists(priority));
    }
    priorityMap.set(priority, item);
  }
  function getItems() {
    var order = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ASC;
    var _ref2 = ORDER_MAP.get(order) || ORDER_MAP.get(ASC), _ref3 = _slicedToArray$5(_ref2, 2), left = _ref3[0], right = _ref3[1];
    return _toConsumableArray$6(priorityMap).sort(function(a, b) {
      return a[0] < b[0] ? left : right;
    }).map(function(item) {
      return item[1];
    });
  }
  return {
    addItem,
    getItems
  };
}

function _toConsumableArray$7(arr) {
  return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$5(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$5(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$9(arr);
}
function _slicedToArray$6(arr, i) {
  return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$9(arr, i) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$9(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$9(o, minLen);
}
function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$6(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$6(arr) {
  if (Array.isArray(arr))
    return arr;
}
var DEFAULT_ERROR_ID_EXISTS = function DEFAULT_ERROR_ID_EXISTS2(id) {
  return "The id '".concat(id, "' is already declared in a map.");
};
function createUniqueMap() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, errorIdExists = _ref.errorIdExists;
  var uniqueMap = new Map();
  errorIdExists = isFunction$1(errorIdExists) ? errorIdExists : DEFAULT_ERROR_ID_EXISTS;
  function addItem(id, item) {
    if (hasItem(id)) {
      throw new Error(errorIdExists(id));
    }
    uniqueMap.set(id, item);
  }
  function clear() {
    uniqueMap.clear();
  }
  function getId(item) {
    var _ref2 = getItems().find(function(_ref4) {
      var _ref5 = _slicedToArray$6(_ref4, 2), id = _ref5[0], element = _ref5[1];
      if (item === element) {
        return id;
      }
      return false;
    }) || [null], _ref3 = _slicedToArray$6(_ref2, 1), itemId = _ref3[0];
    return itemId;
  }
  function getItem(id) {
    return uniqueMap.get(id);
  }
  function getItems() {
    return _toConsumableArray$7(uniqueMap);
  }
  function hasItem(id) {
    return uniqueMap.has(id);
  }
  return {
    addItem,
    clear,
    getId,
    getItem,
    getItems,
    hasItem
  };
}

function _toConsumableArray$8(arr) {
  return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$a(arr) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$a(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$a(o, minLen);
}
function _iterableToArray$6(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$6(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$a(arr);
}
function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var DEFAULT_ERROR_ITEM_EXISTS = function DEFAULT_ERROR_ITEM_EXISTS2(item) {
  return "'".concat(item, "' value is already declared in a unique set.");
};
function createUniqueSet() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, errorItemExists = _ref.errorItemExists;
  var uniqueSet = new Set();
  errorItemExists = isFunction$1(errorItemExists) ? errorItemExists : DEFAULT_ERROR_ITEM_EXISTS;
  function addItem(item) {
    if (uniqueSet.has(item)) {
      throw new Error(errorItemExists(item));
    }
    uniqueSet.add(item);
  }
  function getItems() {
    return _toConsumableArray$8(uniqueSet);
  }
  return {
    addItem,
    getItems
  };
}

function _slicedToArray$7(arr, i) {
  return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$b(arr, i) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$7(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$7(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray$9(arr) {
  return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$b(arr) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$b(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$b(o, minLen);
}
function _iterableToArray$7(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$7(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$b(arr);
}
function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var ERROR_PLUGIN_REGISTERED = function ERROR_PLUGIN_REGISTERED2(pluginName) {
  return 'There is already registered "'.concat(pluginName, '" plugin.');
};
var ERROR_PRIORITY_REGISTERED = function ERROR_PRIORITY_REGISTERED2(priority) {
  return 'There is already registered plugin on priority "'.concat(priority, '".');
};
var ERROR_PRIORITY_NAN = function ERROR_PRIORITY_NAN2(priority) {
  return 'The priority "'.concat(priority, '" is not a number.');
};
var priorityPluginsQueue = createPriorityMap({
  errorPriorityExists: ERROR_PRIORITY_REGISTERED,
  errorPriorityNaN: ERROR_PRIORITY_NAN
});
var uniquePluginsQueue = createUniqueSet({
  errorItemExists: ERROR_PLUGIN_REGISTERED
});
var uniquePluginsList = createUniqueMap({
  errorIdExists: ERROR_PLUGIN_REGISTERED
});
function getPluginsNames() {
  return [].concat(_toConsumableArray$9(priorityPluginsQueue.getItems()), _toConsumableArray$9(uniquePluginsQueue.getItems()));
}
function getPlugin(pluginName) {
  var unifiedPluginName = toUpperCaseFirst(pluginName);
  return uniquePluginsList.getItem(unifiedPluginName);
}
function hasPlugin(pluginName) {
  return getPlugin(pluginName) ? true : false;
}
function registerPlugin(pluginName, pluginClass, priority) {
  var _unifyPluginArguments = unifyPluginArguments(pluginName, pluginClass, priority);
  var _unifyPluginArguments2 = _slicedToArray$7(_unifyPluginArguments, 3);
  pluginName = _unifyPluginArguments2[0];
  pluginClass = _unifyPluginArguments2[1];
  priority = _unifyPluginArguments2[2];
  if (getPlugin(pluginName) === void 0) {
    _registerPlugin(pluginName, pluginClass, priority);
  }
}
function _registerPlugin(pluginName, pluginClass, priority) {
  var unifiedPluginName = toUpperCaseFirst(pluginName);
  if (uniquePluginsList.hasItem(unifiedPluginName)) {
    throw new Error(ERROR_PLUGIN_REGISTERED(unifiedPluginName));
  }
  if (priority === void 0) {
    uniquePluginsQueue.addItem(unifiedPluginName);
  } else {
    priorityPluginsQueue.addItem(priority, unifiedPluginName);
  }
  uniquePluginsList.addItem(unifiedPluginName, pluginClass);
}
function unifyPluginArguments(pluginName, pluginClass, priority) {
  if (typeof pluginName === "function") {
    pluginClass = pluginName;
    pluginName = pluginClass.PLUGIN_KEY;
    priority = pluginClass.PLUGIN_PRIORITY;
  }
  return [pluginName, pluginClass, priority];
}

var _staticRegister$1 = staticRegister("renderers"), register$1 = _staticRegister$1.register, getItem$1 = _staticRegister$1.getItem, hasItem$1 = _staticRegister$1.hasItem, getNames$1 = _staticRegister$1.getNames;
function _getItem$1(name) {
  if (typeof name === "function") {
    return name;
  }
  if (!hasItem$1(name)) {
    throw Error('No registered renderer found under "'.concat(name, '" name'));
  }
  return getItem$1(name);
}
function _register$1(name, renderer) {
  if (typeof name !== "string") {
    renderer = name;
    name = renderer.RENDERER_TYPE;
  }
  register$1(name, renderer);
}

var _staticRegister$2 = staticRegister("validators"), register$2 = _staticRegister$2.register, getItem$2 = _staticRegister$2.getItem, hasItem$2 = _staticRegister$2.hasItem, getNames$2 = _staticRegister$2.getNames;
function _getItem$2(name) {
  if (typeof name === "function") {
    return name;
  }
  if (!hasItem$2(name)) {
    throw Error('No registered validator found under "'.concat(name, '" name'));
  }
  return getItem$2(name);
}
function _register$2(name, validator) {
  if (typeof name !== "string") {
    validator = name;
    name = validator.VALIDATOR_TYPE;
  }
  register$2(name, validator);
}

function mouseDown(_ref) {
  var isShiftKey = _ref.isShiftKey, isLeftClick = _ref.isLeftClick, isRightClick = _ref.isRightClick, coords = _ref.coords, selection = _ref.selection, controller = _ref.controller;
  var currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;
  var selectedCorner = selection.isSelectedByCorner();
  var selectedRow = selection.isSelectedByRowHeader();
  if (isShiftKey && currentSelection) {
    if (coords.row >= 0 && coords.col >= 0 && !controller.cells) {
      selection.setRangeEnd(coords);
    } else if ((selectedCorner || selectedRow) && coords.row >= 0 && coords.col >= 0 && !controller.cells) {
      selection.setRangeEnd(new CellCoords(coords.row, coords.col));
    } else if (selectedCorner && coords.row < 0 && !controller.column) {
      selection.setRangeEnd(new CellCoords(currentSelection.to.row, coords.col));
    } else if (selectedRow && coords.col < 0 && !controller.row) {
      selection.setRangeEnd(new CellCoords(coords.row, currentSelection.to.col));
    } else if ((!selectedCorner && !selectedRow && coords.col < 0 || selectedCorner && coords.col < 0) && !controller.row) {
      selection.selectRows(Math.max(currentSelection.from.row, 0), coords.row, coords.col);
    } else if ((!selectedCorner && !selectedRow && coords.row < 0 || selectedRow && coords.row < 0) && !controller.column) {
      selection.selectColumns(Math.max(currentSelection.from.col, 0), coords.col, coords.row);
    }
  } else {
    var allowRightClickSelection = !selection.inInSelection(coords);
    var performSelection = isLeftClick || isRightClick && allowRightClickSelection;
    if (coords.row < 0 && coords.col >= 0 && !controller.column) {
      if (performSelection) {
        selection.selectColumns(coords.col, coords.col, coords.row);
      }
    } else if (coords.col < 0 && coords.row >= 0 && !controller.row) {
      if (performSelection) {
        selection.selectRows(coords.row, coords.row, coords.col);
      }
    } else if (coords.col >= 0 && coords.row >= 0 && !controller.cells) {
      if (performSelection) {
        selection.setRangeStart(coords);
      }
    } else if (coords.col < 0 && coords.row < 0) {
      selection.selectAll(true, true);
    }
  }
}
function mouseOver(_ref2) {
  var isLeftClick = _ref2.isLeftClick, coords = _ref2.coords, selection = _ref2.selection, controller = _ref2.controller;
  if (!isLeftClick) {
    return;
  }
  var selectedRow = selection.isSelectedByRowHeader();
  var selectedColumn = selection.isSelectedByColumnHeader();
  var countCols = selection.tableProps.countCols();
  var countRows = selection.tableProps.countRows();
  if (selectedColumn && !controller.column) {
    selection.setRangeEnd(new CellCoords(countRows - 1, coords.col));
  } else if (selectedRow && !controller.row) {
    selection.setRangeEnd(new CellCoords(coords.row, countCols - 1));
  } else if (!controller.cell) {
    selection.setRangeEnd(coords);
  }
}
var handlers = new Map([["mousedown", mouseDown], ["mouseover", mouseOver], ["touchstart", mouseDown]]);
function handleMouseEvent(event, _ref3) {
  var coords = _ref3.coords, selection = _ref3.selection, controller = _ref3.controller;
  handlers.get(event.type)({
    coords,
    selection,
    controller,
    isShiftKey: event.shiftKey,
    isLeftClick: isLeftClick(event) || event.type === "touchstart",
    isRightClick: isRightClick(event)
  });
}

var holder = new WeakMap();
var rootInstanceSymbol = Symbol("rootInstance");
function registerAsRootInstance(object) {
  holder.set(object, true);
}
function hasValidParameter(rootSymbol) {
  return rootSymbol === rootInstanceSymbol;
}
function isRootInstance(object) {
  return holder.has(object);
}

function _slicedToArray$8(arr, i) {
  return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$c(arr, i) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$8(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$8(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _construct$5(Parent, args, Class) {
  if (_isNativeReflectConstruct$i()) {
    _construct$5 = Reflect.construct;
  } else {
    _construct$5 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$i(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$5.apply(null, arguments);
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _setPrototypeOf$i(o, p) {
  _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$i(o, p);
}
function _toConsumableArray$a(arr) {
  return _arrayWithoutHoles$8(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$c(arr) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$c(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$c(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$c(o, minLen);
}
function _iterableToArray$8(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$8(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$c(arr);
}
function _arrayLikeToArray$c(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$K(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$F(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$F(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$F(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$F(Constructor, staticProps);
  return Constructor;
}
var privatePool$3 = new WeakMap();
var TableView = /* @__PURE__ */ function() {
  function TableView2(instance) {
    _classCallCheck$K(this, TableView2);
    this.instance = instance;
    this.eventManager = new EventManager(instance);
    this.settings = instance.getSettings();
    this.THEAD = void 0;
    this.TBODY = void 0;
    this.wt = void 0;
    this.activeWt = void 0;
    this.postponedAdjustElementsSize = false;
    privatePool$3.set(this, {
      selectionMouseDown: false,
      mouseDown: void 0,
      table: void 0,
      lastWidth: 0,
      lastHeight: 0
    });
    this.createElements();
    this.registerEvents();
    this.initializeWalkontable();
  }
  _createClass$F(TableView2, [{
    key: "render",
    value: function render() {
      if (!this.instance.isRenderSuspended()) {
        if (this.postponedAdjustElementsSize) {
          this.postponedAdjustElementsSize = false;
          this.adjustElementsSize(true);
        }
        this.wt.draw(!this.instance.forceFullRender);
        this.instance.forceFullRender = false;
        this.instance.renderCall = false;
      }
    }
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (this.instance.isRenderSuspended()) {
        this.postponedAdjustElementsSize = true;
      } else {
        this.wt.wtOverlays.adjustElementsSize(force);
      }
    }
  }, {
    key: "getCellAtCoords",
    value: function getCellAtCoords(coords, topmost) {
      var td = this.wt.getCell(coords, topmost);
      if (td < 0) {
        return null;
      }
      return td;
    }
  }, {
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      return this.wt.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      return this.wt.scrollViewportHorizontally(column, snapToRight, snapToLeft);
    }
  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      return this.wt.scrollViewportVertically(row, snapToTop, snapToBottom);
    }
  }, {
    key: "createElements",
    value: function createElements() {
      var priv = privatePool$3.get(this);
      var _this$instance = this.instance, rootElement = _this$instance.rootElement, rootDocument = _this$instance.rootDocument;
      var originalStyle = rootElement.getAttribute("style");
      if (originalStyle) {
        rootElement.setAttribute("data-originalstyle", originalStyle);
      }
      addClass(rootElement, "handsontable");
      priv.table = rootDocument.createElement("TABLE");
      addClass(priv.table, "htCore");
      if (this.instance.getSettings().tableClassName) {
        addClass(priv.table, this.instance.getSettings().tableClassName);
      }
      this.THEAD = rootDocument.createElement("THEAD");
      priv.table.appendChild(this.THEAD);
      this.TBODY = rootDocument.createElement("TBODY");
      priv.table.appendChild(this.TBODY);
      this.instance.table = priv.table;
      this.instance.container.insertBefore(priv.table, this.instance.container.firstChild);
    }
  }, {
    key: "registerEvents",
    value: function registerEvents() {
      var _this = this;
      var priv = privatePool$3.get(this);
      var _this$instance2 = this.instance, rootElement = _this$instance2.rootElement, rootDocument = _this$instance2.rootDocument, selection = _this$instance2.selection;
      var documentElement = rootDocument.documentElement;
      this.eventManager.addEventListener(rootElement, "mousedown", function(event) {
        priv.selectionMouseDown = true;
        if (!_this.isTextSelectionAllowed(event.target)) {
          var rootWindow = _this.instance.rootWindow;
          clearTextSelection(rootWindow);
          event.preventDefault();
          rootWindow.focus();
        }
      });
      this.eventManager.addEventListener(rootElement, "mouseup", function() {
        priv.selectionMouseDown = false;
      });
      this.eventManager.addEventListener(rootElement, "mousemove", function(event) {
        if (priv.selectionMouseDown && !_this.isTextSelectionAllowed(event.target)) {
          if (_this.settings.fragmentSelection) {
            clearTextSelection(_this.instance.rootWindow);
          }
          event.preventDefault();
        }
      });
      this.eventManager.addEventListener(documentElement, "keyup", function(event) {
        if (selection.isInProgress() && !event.shiftKey) {
          selection.finish();
        }
      });
      this.eventManager.addEventListener(documentElement, "mouseup", function(event) {
        if (selection.isInProgress() && isLeftClick(event)) {
          selection.finish();
        }
        priv.mouseDown = false;
        if (isOutsideInput(rootDocument.activeElement) || !selection.isSelected() && !selection.isSelectedByAnyHeader() && !rootElement.contains(event.target) && !isRightClick(event)) {
          _this.instance.unlisten();
        }
      });
      this.eventManager.addEventListener(documentElement, "contextmenu", function(event) {
        if (selection.isInProgress() && isRightClick(event)) {
          selection.finish();
          priv.mouseDown = false;
        }
      });
      this.eventManager.addEventListener(documentElement, "touchend", function() {
        if (selection.isInProgress()) {
          selection.finish();
        }
        priv.mouseDown = false;
      });
      this.eventManager.addEventListener(documentElement, "mousedown", function(event) {
        var originalTarget = event.target;
        var eventX = event.x || event.clientX;
        var eventY = event.y || event.clientY;
        var next = event.target;
        if (priv.mouseDown || !rootElement || !_this.instance.view) {
          return;
        }
        var holder = _this.instance.view.wt.wtTable.holder;
        if (next === holder) {
          var scrollbarWidth = getScrollbarWidth(rootDocument);
          if (rootDocument.elementFromPoint(eventX + scrollbarWidth, eventY) !== holder || rootDocument.elementFromPoint(eventX, eventY + scrollbarWidth) !== holder) {
            return;
          }
        } else {
          while (next !== documentElement) {
            if (next === null) {
              if (event.isTargetWebComponent) {
                break;
              }
              return;
            }
            if (next === rootElement) {
              return;
            }
            next = next.parentNode;
          }
        }
        var outsideClickDeselects = typeof _this.settings.outsideClickDeselects === "function" ? _this.settings.outsideClickDeselects(originalTarget) : _this.settings.outsideClickDeselects;
        if (outsideClickDeselects) {
          _this.instance.deselectCell();
        } else {
          _this.instance.destroyEditor(false, false);
        }
      });
      this.eventManager.addEventListener(priv.table, "selectstart", function(event) {
        if (_this.settings.fragmentSelection || isInput(event.target)) {
          return;
        }
        event.preventDefault();
      });
    }
  }, {
    key: "translateFromRenderableToVisualCoords",
    value: function translateFromRenderableToVisualCoords(_ref) {
      var row = _ref.row, col = _ref.col;
      return _construct$5(CellCoords, _toConsumableArray$a(this.translateFromRenderableToVisualIndex(row, col)));
    }
  }, {
    key: "translateFromRenderableToVisualIndex",
    value: function translateFromRenderableToVisualIndex(renderableRow, renderableColumn) {
      var visualRow = renderableRow >= 0 ? this.instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow;
      var visualColumn = renderableColumn >= 0 ? this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn;
      if (visualRow === null) {
        visualRow = renderableRow;
      }
      if (visualColumn === null) {
        visualColumn = renderableColumn;
      }
      return [visualRow, visualColumn];
    }
  }, {
    key: "countRenderableIndexes",
    value: function countRenderableIndexes(indexMapper, maxElements) {
      var consideredElements = Math.min(indexMapper.getNotTrimmedIndexesLength(), maxElements);
      var firstNotHiddenIndex = indexMapper.getFirstNotHiddenIndex(consideredElements - 1, -1);
      if (firstNotHiddenIndex === null) {
        return 0;
      }
      return indexMapper.getRenderableFromVisualIndex(firstNotHiddenIndex) + 1;
    }
  }, {
    key: "countRenderableColumns",
    value: function countRenderableColumns() {
      return this.countRenderableIndexes(this.instance.columnIndexMapper, this.settings.maxCols);
    }
  }, {
    key: "countRenderableRows",
    value: function countRenderableRows() {
      return this.countRenderableIndexes(this.instance.rowIndexMapper, this.settings.maxRows);
    }
  }, {
    key: "countNotHiddenRowIndexes",
    value: function countNotHiddenRowIndexes(visualIndex, incrementBy) {
      return this.countNotHiddenIndexes(visualIndex, incrementBy, this.instance.rowIndexMapper, this.countRenderableRows());
    }
  }, {
    key: "countNotHiddenColumnIndexes",
    value: function countNotHiddenColumnIndexes(visualIndex, incrementBy) {
      return this.countNotHiddenIndexes(visualIndex, incrementBy, this.instance.columnIndexMapper, this.countRenderableColumns());
    }
  }, {
    key: "countNotHiddenIndexes",
    value: function countNotHiddenIndexes(visualIndex, incrementBy, indexMapper, renderableIndexesCount) {
      if (isNaN(visualIndex) || visualIndex < 0) {
        return 0;
      }
      var firstVisibleIndex = indexMapper.getFirstNotHiddenIndex(visualIndex, incrementBy);
      var renderableIndex = indexMapper.getRenderableFromVisualIndex(firstVisibleIndex);
      if (!Number.isInteger(renderableIndex)) {
        return 0;
      }
      var notHiddenIndexes = 0;
      if (incrementBy < 0) {
        notHiddenIndexes = renderableIndex + 1;
      } else if (incrementBy > 0) {
        notHiddenIndexes = renderableIndexesCount - renderableIndex;
      }
      return notHiddenIndexes;
    }
  }, {
    key: "initializeWalkontable",
    value: function initializeWalkontable() {
      var _this2 = this;
      var priv = privatePool$3.get(this);
      var walkontableConfig = {
        externalRowCalculator: this.instance.getPlugin("autoRowSize") && this.instance.getPlugin("autoRowSize").isEnabled(),
        table: priv.table,
        isDataViewInstance: function isDataViewInstance() {
          return isRootInstance(_this2.instance);
        },
        preventOverflow: function preventOverflow() {
          return _this2.settings.preventOverflow;
        },
        preventWheel: function preventWheel() {
          return _this2.settings.preventWheel;
        },
        stretchH: function stretchH() {
          return _this2.settings.stretchH;
        },
        data: function data(renderableRow, renderableColumn) {
          var _this2$instance;
          return (_this2$instance = _this2.instance).getDataAtCell.apply(_this2$instance, _toConsumableArray$a(_this2.translateFromRenderableToVisualIndex(renderableRow, renderableColumn)));
        },
        totalRows: function totalRows() {
          return _this2.countRenderableRows();
        },
        totalColumns: function totalColumns() {
          return _this2.countRenderableColumns();
        },
        fixedColumnsLeft: function fixedColumnsLeft() {
          var countCols = _this2.instance.countCols();
          var visualFixedColumnsLeft = Math.min(parseInt(_this2.settings.fixedColumnsLeft, 10), countCols) - 1;
          return _this2.countNotHiddenColumnIndexes(visualFixedColumnsLeft, -1);
        },
        fixedRowsTop: function fixedRowsTop() {
          var countRows = _this2.instance.countRows();
          var visualFixedRowsTop = Math.min(parseInt(_this2.settings.fixedRowsTop, 10), countRows) - 1;
          return _this2.countNotHiddenRowIndexes(visualFixedRowsTop, -1);
        },
        fixedRowsBottom: function fixedRowsBottom() {
          var countRows = _this2.instance.countRows();
          var visualFixedRowsBottom = Math.max(countRows - parseInt(_this2.settings.fixedRowsBottom, 10), 0);
          return _this2.countNotHiddenRowIndexes(visualFixedRowsBottom, 1);
        },
        shouldRenderLeftOverlay: function shouldRenderLeftOverlay() {
          return _this2.settings.fixedColumnsLeft > 0 || walkontableConfig.rowHeaders().length > 0;
        },
        shouldRenderTopOverlay: function shouldRenderTopOverlay() {
          return _this2.settings.fixedRowsTop > 0 || walkontableConfig.columnHeaders().length > 0;
        },
        shouldRenderBottomOverlay: function shouldRenderBottomOverlay() {
          return _this2.settings.fixedRowsBottom > 0;
        },
        minSpareRows: function minSpareRows() {
          return _this2.settings.minSpareRows;
        },
        renderAllRows: this.settings.renderAllRows,
        rowHeaders: function rowHeaders() {
          var headerRenderers = [];
          if (_this2.instance.hasRowHeaders()) {
            headerRenderers.push(function(renderableRowIndex, TH) {
              var visualRowIndex = renderableRowIndex >= 0 ? _this2.instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;
              _this2.appendRowHeader(visualRowIndex, TH);
            });
          }
          _this2.instance.runHooks("afterGetRowHeaderRenderers", headerRenderers);
          return headerRenderers;
        },
        columnHeaders: function columnHeaders() {
          var headerRenderers = [];
          if (_this2.instance.hasColHeaders()) {
            headerRenderers.push(function(renderedColumnIndex, TH) {
              var visualColumnsIndex = renderedColumnIndex >= 0 ? _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex) : renderedColumnIndex;
              _this2.appendColHeader(visualColumnsIndex, TH);
            });
          }
          _this2.instance.runHooks("afterGetColumnHeaderRenderers", headerRenderers);
          return headerRenderers;
        },
        columnWidth: function columnWidth(renderedColumnIndex) {
          var visualIndex = _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
          return _this2.instance.getColWidth(visualIndex === null ? renderedColumnIndex : visualIndex);
        },
        rowHeight: function rowHeight(renderedRowIndex) {
          var visualIndex = _this2.instance.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);
          return _this2.instance.getRowHeight(visualIndex === null ? renderedRowIndex : visualIndex);
        },
        cellRenderer: function cellRenderer(renderedRowIndex, renderedColumnIndex, TD) {
          var _this2$translateFromR = _this2.translateFromRenderableToVisualIndex(renderedRowIndex, renderedColumnIndex), _this2$translateFromR2 = _slicedToArray$8(_this2$translateFromR, 2), visualRowIndex = _this2$translateFromR2[0], visualColumnIndex = _this2$translateFromR2[1];
          var modifiedCellCoords = _this2.instance.runHooks("modifyGetCellCoords", visualRowIndex, visualColumnIndex);
          var visualRowToCheck = visualRowIndex;
          var visualColumnToCheck = visualColumnIndex;
          if (Array.isArray(modifiedCellCoords)) {
            var _modifiedCellCoords = _slicedToArray$8(modifiedCellCoords, 2);
            visualRowToCheck = _modifiedCellCoords[0];
            visualColumnToCheck = _modifiedCellCoords[1];
          }
          var cellProperties = _this2.instance.getCellMeta(visualRowToCheck, visualColumnToCheck);
          var prop = _this2.instance.colToProp(visualColumnToCheck);
          var value = _this2.instance.getDataAtRowProp(visualRowToCheck, prop);
          if (_this2.instance.hasHook("beforeValueRender")) {
            value = _this2.instance.runHooks("beforeValueRender", value, cellProperties);
          }
          _this2.instance.runHooks("beforeRenderer", TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
          _this2.instance.getCellRenderer(cellProperties)(_this2.instance, TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
          _this2.instance.runHooks("afterRenderer", TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
        },
        selections: this.instance.selection.highlight,
        hideBorderOnMouseDownOver: function hideBorderOnMouseDownOver() {
          return _this2.settings.fragmentSelection;
        },
        onWindowResize: function onWindowResize() {
          if (!_this2.instance || _this2.instance.isDestroyed) {
            return;
          }
          _this2.instance.refreshDimensions();
        },
        onCellMouseDown: function onCellMouseDown(event, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          var blockCalculations = {
            row: false,
            column: false,
            cell: false
          };
          _this2.instance.listen();
          _this2.activeWt = wt;
          priv.mouseDown = true;
          _this2.instance.runHooks("beforeOnCellMouseDown", event, visualCoords, TD, blockCalculations);
          if (isImmediatePropagationStopped(event)) {
            return;
          }
          handleMouseEvent(event, {
            coords: visualCoords,
            selection: _this2.instance.selection,
            controller: blockCalculations
          });
          _this2.instance.runHooks("afterOnCellMouseDown", event, visualCoords, TD);
          _this2.activeWt = _this2.wt;
        },
        onCellContextMenu: function onCellContextMenu(event, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          _this2.activeWt = wt;
          priv.mouseDown = false;
          if (_this2.instance.selection.isInProgress()) {
            _this2.instance.selection.finish();
          }
          _this2.instance.runHooks("beforeOnCellContextMenu", event, visualCoords, TD);
          if (isImmediatePropagationStopped(event)) {
            return;
          }
          _this2.instance.runHooks("afterOnCellContextMenu", event, visualCoords, TD);
          _this2.activeWt = _this2.wt;
        },
        onCellMouseOut: function onCellMouseOut(event, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          _this2.activeWt = wt;
          _this2.instance.runHooks("beforeOnCellMouseOut", event, visualCoords, TD);
          if (isImmediatePropagationStopped(event)) {
            return;
          }
          _this2.instance.runHooks("afterOnCellMouseOut", event, visualCoords, TD);
          _this2.activeWt = _this2.wt;
        },
        onCellMouseOver: function onCellMouseOver(event, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          var blockCalculations = {
            row: false,
            column: false,
            cell: false
          };
          _this2.activeWt = wt;
          _this2.instance.runHooks("beforeOnCellMouseOver", event, visualCoords, TD, blockCalculations);
          if (isImmediatePropagationStopped(event)) {
            return;
          }
          if (priv.mouseDown) {
            handleMouseEvent(event, {
              coords: visualCoords,
              selection: _this2.instance.selection,
              controller: blockCalculations
            });
          }
          _this2.instance.runHooks("afterOnCellMouseOver", event, visualCoords, TD);
          _this2.activeWt = _this2.wt;
        },
        onCellMouseUp: function onCellMouseUp(event, coords, TD, wt) {
          var visualCoords = _this2.translateFromRenderableToVisualCoords(coords);
          _this2.activeWt = wt;
          _this2.instance.runHooks("beforeOnCellMouseUp", event, visualCoords, TD);
          if (isImmediatePropagationStopped(event) || _this2.instance.isDestroyed) {
            return;
          }
          _this2.instance.runHooks("afterOnCellMouseUp", event, visualCoords, TD);
          _this2.activeWt = _this2.wt;
        },
        onCellCornerMouseDown: function onCellCornerMouseDown(event) {
          event.preventDefault();
          _this2.instance.runHooks("afterOnCellCornerMouseDown", event);
        },
        onCellCornerDblClick: function onCellCornerDblClick(event) {
          event.preventDefault();
          _this2.instance.runHooks("afterOnCellCornerDblClick", event);
        },
        beforeDraw: function beforeDraw(force, skipRender) {
          return _this2.beforeRender(force, skipRender);
        },
        onDraw: function onDraw(force) {
          return _this2.onDraw(force);
        },
        onScrollVertically: function onScrollVertically() {
          return _this2.instance.runHooks("afterScrollVertically");
        },
        onScrollHorizontally: function onScrollHorizontally() {
          return _this2.instance.runHooks("afterScrollHorizontally");
        },
        onBeforeRemoveCellClassNames: function onBeforeRemoveCellClassNames() {
          return _this2.instance.runHooks("beforeRemoveCellClassNames");
        },
        onBeforeHighlightingRowHeader: function onBeforeHighlightingRowHeader(renderableRow, headerLevel, highlightMeta) {
          var rowMapper = _this2.instance.rowIndexMapper;
          var visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);
          var newVisualRow = _this2.instance.runHooks("beforeHighlightingRowHeader", visualRow, headerLevel, highlightMeta);
          return rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(newVisualRow, 1));
        },
        onBeforeHighlightingColumnHeader: function onBeforeHighlightingColumnHeader(renderableColumn, headerLevel, highlightMeta) {
          var columnMapper = _this2.instance.columnIndexMapper;
          var visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);
          var newVisualColumn = _this2.instance.runHooks("beforeHighlightingColumnHeader", visualColumn, headerLevel, highlightMeta);
          return columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(newVisualColumn, 1));
        },
        onAfterDrawSelection: function onAfterDrawSelection(currentRow, currentColumn, layerLevel) {
          var cornersOfSelection;
          var _this2$translateFromR3 = _this2.translateFromRenderableToVisualIndex(currentRow, currentColumn), _this2$translateFromR4 = _slicedToArray$8(_this2$translateFromR3, 2), visualRowIndex = _this2$translateFromR4[0], visualColumnIndex = _this2$translateFromR4[1];
          var selectedRange = _this2.instance.selection.getSelectedRange();
          var selectionRangeSize = selectedRange.size();
          if (selectionRangeSize > 0) {
            var selectionOffset = (layerLevel !== null && layerLevel !== void 0 ? layerLevel : 0) + 1 - selectionRangeSize;
            var selectionForLayer = selectedRange.peekByIndex(selectionOffset);
            cornersOfSelection = [selectionForLayer.from.row, selectionForLayer.from.col, selectionForLayer.to.row, selectionForLayer.to.col];
          }
          return _this2.instance.runHooks("afterDrawSelection", visualRowIndex, visualColumnIndex, cornersOfSelection, layerLevel);
        },
        onBeforeDrawBorders: function onBeforeDrawBorders(corners, borderClassName) {
          var _corners = _slicedToArray$8(corners, 4), startRenderableRow = _corners[0], startRenderableColumn = _corners[1], endRenderableRow = _corners[2], endRenderableColumn = _corners[3];
          var visualCorners = [_this2.instance.rowIndexMapper.getVisualFromRenderableIndex(startRenderableRow), _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(startRenderableColumn), _this2.instance.rowIndexMapper.getVisualFromRenderableIndex(endRenderableRow), _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(endRenderableColumn)];
          return _this2.instance.runHooks("beforeDrawBorders", visualCorners, borderClassName);
        },
        onBeforeTouchScroll: function onBeforeTouchScroll() {
          return _this2.instance.runHooks("beforeTouchScroll");
        },
        onAfterMomentumScroll: function onAfterMomentumScroll() {
          return _this2.instance.runHooks("afterMomentumScroll");
        },
        onBeforeStretchingColumnWidth: function onBeforeStretchingColumnWidth(stretchedWidth, renderedColumnIndex) {
          var visualColumnIndex = _this2.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
          return _this2.instance.runHooks("beforeStretchingColumnWidth", stretchedWidth, visualColumnIndex);
        },
        onModifyRowHeaderWidth: function onModifyRowHeaderWidth(rowHeaderWidth) {
          return _this2.instance.runHooks("modifyRowHeaderWidth", rowHeaderWidth);
        },
        onModifyGetCellCoords: function onModifyGetCellCoords(renderableRowIndex, renderableColumnIndex, topmost) {
          var rowMapper = _this2.instance.rowIndexMapper;
          var columnMapper = _this2.instance.columnIndexMapper;
          var visualColumnIndex = renderableColumnIndex >= 0 ? columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : renderableColumnIndex;
          var visualRowIndex = renderableRowIndex >= 0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;
          var visualIndexes = _this2.instance.runHooks("modifyGetCellCoords", visualRowIndex, visualColumnIndex, topmost);
          if (Array.isArray(visualIndexes)) {
            var _visualIndexes = _slicedToArray$8(visualIndexes, 4), visualRowFrom = _visualIndexes[0], visualColumnFrom = _visualIndexes[1], visualRowTo = _visualIndexes[2], visualColumnTo = _visualIndexes[3];
            return [visualRowFrom >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(visualRowFrom, 1)) : visualRowFrom, visualColumnFrom >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(visualColumnFrom, 1)) : visualColumnFrom, visualRowTo >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(visualRowTo, -1)) : visualRowTo, visualColumnTo >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(visualColumnTo, -1)) : visualColumnTo];
          }
        },
        viewportRowCalculatorOverride: function viewportRowCalculatorOverride(calc) {
          var viewportOffset = _this2.settings.viewportRowRenderingOffset;
          if (viewportOffset === "auto" && _this2.settings.fixedRowsTop) {
            viewportOffset = 10;
          }
          if (viewportOffset > 0 || viewportOffset === "auto") {
            var renderableRows = _this2.countRenderableRows();
            var firstRenderedRow = calc.startRow;
            var lastRenderedRow = calc.endRow;
            if (typeof viewportOffset === "number") {
              calc.startRow = Math.max(firstRenderedRow - viewportOffset, 0);
              calc.endRow = Math.min(lastRenderedRow + viewportOffset, renderableRows - 1);
            } else if (viewportOffset === "auto") {
              var offset = Math.ceil(lastRenderedRow / renderableRows * 12);
              calc.startRow = Math.max(firstRenderedRow - offset, 0);
              calc.endRow = Math.min(lastRenderedRow + offset, renderableRows - 1);
            }
          }
          _this2.instance.runHooks("afterViewportRowCalculatorOverride", calc);
        },
        viewportColumnCalculatorOverride: function viewportColumnCalculatorOverride(calc) {
          var viewportOffset = _this2.settings.viewportColumnRenderingOffset;
          if (viewportOffset === "auto" && _this2.settings.fixedColumnsLeft) {
            viewportOffset = 10;
          }
          if (viewportOffset > 0 || viewportOffset === "auto") {
            var renderableColumns = _this2.countRenderableColumns();
            var firstRenderedColumn = calc.startColumn;
            var lastRenderedColumn = calc.endColumn;
            if (typeof viewportOffset === "number") {
              calc.startColumn = Math.max(firstRenderedColumn - viewportOffset, 0);
              calc.endColumn = Math.min(lastRenderedColumn + viewportOffset, renderableColumns - 1);
            }
            if (viewportOffset === "auto") {
              var offset = Math.ceil(lastRenderedColumn / renderableColumns * 6);
              calc.startColumn = Math.max(firstRenderedColumn - offset, 0);
              calc.endColumn = Math.min(lastRenderedColumn + offset, renderableColumns - 1);
            }
          }
          _this2.instance.runHooks("afterViewportColumnCalculatorOverride", calc);
        },
        rowHeaderWidth: function rowHeaderWidth() {
          return _this2.settings.rowHeaderWidth;
        },
        columnHeaderHeight: function columnHeaderHeight() {
          var columnHeaderHeight2 = _this2.instance.runHooks("modifyColumnHeaderHeight");
          return _this2.settings.columnHeaderHeight || columnHeaderHeight2;
        }
      };
      this.instance.runHooks("beforeInitWalkontable", walkontableConfig);
      this.wt = new Walkontable(walkontableConfig);
      this.activeWt = this.wt;
      var spreader = this.wt.wtTable.spreader;
      var _this$instance$rootEl = this.instance.rootElement.getBoundingClientRect(), width = _this$instance$rootEl.width, height = _this$instance$rootEl.height;
      this.setLastSize(width, height);
      this.eventManager.addEventListener(spreader, "mousedown", function(event) {
        if (event.target === spreader && event.which === 3) {
          event.stopPropagation();
        }
      });
      this.eventManager.addEventListener(spreader, "contextmenu", function(event) {
        if (event.target === spreader && event.which === 3) {
          event.stopPropagation();
        }
      });
      this.eventManager.addEventListener(this.instance.rootDocument.documentElement, "click", function() {
        if (_this2.settings.observeDOMVisibility) {
          if (_this2.wt.drawInterrupted) {
            _this2.instance.forceFullRender = true;
            _this2.render();
          }
        }
      });
    }
  }, {
    key: "isTextSelectionAllowed",
    value: function isTextSelectionAllowed(el) {
      if (isInput(el)) {
        return true;
      }
      var isChildOfTableBody = isChildOf(el, this.instance.view.wt.wtTable.spreader);
      if (this.settings.fragmentSelection === true && isChildOfTableBody) {
        return true;
      }
      if (this.settings.fragmentSelection === "cell" && this.isSelectedOnlyCell() && isChildOfTableBody) {
        return true;
      }
      if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {
        return true;
      }
      return false;
    }
  }, {
    key: "isMouseDown",
    value: function isMouseDown() {
      return privatePool$3.get(this).mouseDown;
    }
  }, {
    key: "isSelectedOnlyCell",
    value: function isSelectedOnlyCell() {
      var _this$instance$getSel, _this$instance$getSel2;
      return (_this$instance$getSel = (_this$instance$getSel2 = this.instance.getSelectedRangeLast()) === null || _this$instance$getSel2 === void 0 ? void 0 : _this$instance$getSel2.isSingle()) !== null && _this$instance$getSel !== void 0 ? _this$instance$getSel : false;
    }
  }, {
    key: "isCellEdited",
    value: function isCellEdited() {
      var activeEditor = this.instance.getActiveEditor();
      return activeEditor && activeEditor.isOpened();
    }
  }, {
    key: "beforeRender",
    value: function beforeRender(force, skipRender) {
      if (force) {
        this.instance.runHooks("beforeRender", this.instance.forceFullRender, skipRender);
      }
    }
  }, {
    key: "onDraw",
    value: function onDraw(force) {
      if (force) {
        this.instance.runHooks("afterRender", this.instance.forceFullRender);
      }
    }
  }, {
    key: "appendRowHeader",
    value: function appendRowHeader(visualRowIndex, TH) {
      if (TH.firstChild) {
        var container = TH.firstChild;
        if (!hasClass(container, "relative")) {
          empty(TH);
          this.appendRowHeader(visualRowIndex, TH);
          return;
        }
        this.updateCellHeader(container.querySelector(".rowHeader"), visualRowIndex, this.instance.getRowHeader);
      } else {
        var _this$instance3 = this.instance, rootDocument = _this$instance3.rootDocument, getRowHeader = _this$instance3.getRowHeader;
        var div = rootDocument.createElement("div");
        var span = rootDocument.createElement("span");
        div.className = "relative";
        span.className = "rowHeader";
        this.updateCellHeader(span, visualRowIndex, getRowHeader);
        div.appendChild(span);
        TH.appendChild(div);
      }
      this.instance.runHooks("afterGetRowHeader", visualRowIndex, TH);
    }
  }, {
    key: "appendColHeader",
    value: function appendColHeader(visualColumnIndex, TH) {
      if (TH.firstChild) {
        var container = TH.firstChild;
        if (hasClass(container, "relative")) {
          this.updateCellHeader(container.querySelector(".colHeader"), visualColumnIndex, this.instance.getColHeader);
        } else {
          empty(TH);
          this.appendColHeader(visualColumnIndex, TH);
        }
      } else {
        var rootDocument = this.instance.rootDocument;
        var div = rootDocument.createElement("div");
        var span = rootDocument.createElement("span");
        div.className = "relative";
        span.className = "colHeader";
        this.updateCellHeader(span, visualColumnIndex, this.instance.getColHeader);
        div.appendChild(span);
        TH.appendChild(div);
      }
      this.instance.runHooks("afterGetColHeader", visualColumnIndex, TH);
    }
  }, {
    key: "updateCellHeader",
    value: function updateCellHeader(element, index, content) {
      var renderedIndex = index;
      var parentOverlay = this.wt.wtOverlays.getParentOverlay(element) || this.wt;
      if (element.parentNode) {
        if (hasClass(element, "colHeader")) {
          renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index);
        } else if (hasClass(element, "rowHeader")) {
          renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index);
        }
      }
      if (renderedIndex > -1) {
        fastInnerHTML(element, content(index));
      } else {
        fastInnerText(element, String.fromCharCode(160));
        addClass(element, "cornerHeader");
      }
    }
  }, {
    key: "maximumVisibleElementWidth",
    value: function maximumVisibleElementWidth(leftOffset) {
      var workspaceWidth = this.wt.wtViewport.getWorkspaceWidth();
      var maxWidth = workspaceWidth - leftOffset;
      return maxWidth > 0 ? maxWidth : 0;
    }
  }, {
    key: "maximumVisibleElementHeight",
    value: function maximumVisibleElementHeight(topOffset) {
      var workspaceHeight = this.wt.wtViewport.getWorkspaceHeight();
      var maxHeight = workspaceHeight - topOffset;
      return maxHeight > 0 ? maxHeight : 0;
    }
  }, {
    key: "setLastSize",
    value: function setLastSize(width, height) {
      var priv = privatePool$3.get(this);
      var _ref2 = [width, height];
      priv.lastWidth = _ref2[0];
      priv.lastHeight = _ref2[1];
    }
  }, {
    key: "getLastSize",
    value: function getLastSize() {
      var priv = privatePool$3.get(this);
      return {
        width: priv.lastWidth,
        height: priv.lastHeight
      };
    }
  }, {
    key: "mainViewIsActive",
    value: function mainViewIsActive() {
      return this.wt === this.activeWt;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.wt.destroy();
      this.eventManager.destroy();
    }
  }]);
  return TableView2;
}();

var _staticRegister$3 = staticRegister("cellTypes"), register$3 = _staticRegister$3.register, getItem$3 = _staticRegister$3.getItem, hasItem$3 = _staticRegister$3.hasItem, getNames$3 = _staticRegister$3.getNames;
function _getItem$3(name) {
  if (!hasItem$3(name)) {
    throw Error('You declared cell type "'.concat(name, '" as a string that is not mapped to a known object.\n                 Cell type must be an object or a string mapped to an object registered by\n                 "Handsontable.cellTypes.registerCellType" method'));
  }
  return getItem$3(name);
}
function _register$3(name, type) {
  if (typeof name !== "string") {
    type = name;
    name = type.CELL_TYPE;
  }
  var _type = type, editor = _type.editor, renderer = _type.renderer, validator = _type.validator;
  if (editor) {
    _register(name, editor);
  }
  if (renderer) {
    _register$1(name, renderer);
  }
  if (validator) {
    _register$2(name, validator);
  }
  register$3(name, type);
}

function _typeof$p(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$p = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$p = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$p(obj);
}
var COLUMN_LABEL_BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;
function spreadsheetColumnLabel(index) {
  var dividend = index + 1;
  var columnLabel = "";
  var modulo;
  while (dividend > 0) {
    modulo = (dividend - 1) % COLUMN_LABEL_BASE_LENGTH;
    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
    dividend = parseInt((dividend - modulo) / COLUMN_LABEL_BASE_LENGTH, 10);
  }
  return columnLabel;
}
function spreadsheetColumnIndex(label) {
  var result = 0;
  if (label) {
    for (var i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {
      result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j) * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);
    }
  }
  result -= 1;
  return result;
}
function createSpreadsheetData() {
  var rows = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
  var columns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
  var _rows = [];
  var i;
  var j;
  for (i = 0; i < rows; i++) {
    var row = [];
    for (j = 0; j < columns; j++) {
      row.push(spreadsheetColumnLabel(j) + (i + 1));
    }
    _rows.push(row);
  }
  return _rows;
}
function createSpreadsheetObjectData() {
  var rows = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
  var colCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
  var _rows = [];
  var i;
  var j;
  for (i = 0; i < rows; i++) {
    var row = {};
    for (j = 0; j < colCount; j++) {
      row["prop".concat(j)] = spreadsheetColumnLabel(j) + (i + 1);
    }
    _rows.push(row);
  }
  return _rows;
}
function createEmptySpreadsheetData(rows, columns) {
  var data = [];
  var row;
  for (var i = 0; i < rows; i++) {
    row = [];
    for (var j = 0; j < columns; j++) {
      row.push("");
    }
    data.push(row);
  }
  return data;
}
function translateRowsToColumns(input) {
  var output = [];
  var i;
  var ilen;
  var j;
  var jlen;
  var olen = 0;
  for (i = 0, ilen = input.length; i < ilen; i++) {
    for (j = 0, jlen = input[i].length; j < jlen; j++) {
      if (j === olen) {
        output.push([]);
        olen += 1;
      }
      output[j].push(input[i][j]);
    }
  }
  return output;
}
function cellMethodLookupFactory(methodName, allowUndefined) {
  var isUndefinedAllowed = typeof allowUndefined === "undefined" ? true : allowUndefined;
  return function cellMethodLookup(row, col) {
    return function getMethodFromProperties(properties) {
      if (!properties) {
        return;
      }
      if (hasOwnProperty(properties, methodName) && properties[methodName] !== void 0) {
        return properties[methodName];
      } else if (hasOwnProperty(properties, "type") && properties.type) {
        if (typeof properties.type !== "string") {
          throw new Error('Cell "type" must be a string');
        }
        var type = _getItem$3(properties.type);
        if (hasOwnProperty(type, methodName)) {
          return type[methodName];
        } else if (isUndefinedAllowed) {
          return;
        }
      }
      return getMethodFromProperties(Object.getPrototypeOf(properties));
    }(typeof row === "number" ? this.getCellMeta(row, col) : row);
  };
}
function dataRowToChangesArray(dataRow) {
  var rowOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var dataRows = dataRow;
  var changesArray = [];
  if (!Array.isArray(dataRow) || !Array.isArray(dataRow[0])) {
    dataRows = [dataRow];
  }
  dataRows.forEach(function(row, rowIndex) {
    if (Array.isArray(row)) {
      row.forEach(function(value, column) {
        changesArray.push([rowIndex + rowOffset, column, value]);
      });
    } else {
      Object.keys(row).forEach(function(propName) {
        changesArray.push([rowIndex + rowOffset, propName, row[propName]]);
      });
    }
  });
  return changesArray;
}
function countFirstRowKeys(data) {
  var result = 0;
  if (Array.isArray(data)) {
    if (data[0] && Array.isArray(data[0])) {
      result = data[0].length;
    } else if (data[0] && isObject(data[0])) {
      result = deepObjectSize(data[0]);
    }
  }
  return result;
}
function isArrayOfArrays(data) {
  return !!(Array.isArray(data) && data.length && data.every(function(el) {
    return Array.isArray(el);
  }));
}
function isArrayOfObjects(data) {
  return !!(Array.isArray(data) && data.length && data.every(function(el) {
    return _typeof$p(el) === "object" && !Array.isArray(el) && el !== null;
  }));
}

var dataHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  spreadsheetColumnLabel: spreadsheetColumnLabel,
  spreadsheetColumnIndex: spreadsheetColumnIndex,
  createSpreadsheetData: createSpreadsheetData,
  createSpreadsheetObjectData: createSpreadsheetObjectData,
  createEmptySpreadsheetData: createEmptySpreadsheetData,
  translateRowsToColumns: translateRowsToColumns,
  cellMethodLookupFactory: cellMethodLookupFactory,
  dataRowToChangesArray: dataRowToChangesArray,
  countFirstRowKeys: countFirstRowKeys,
  isArrayOfArrays: isArrayOfArrays,
  isArrayOfObjects: isArrayOfObjects
});

function _classCallCheck$L(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$G(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$G(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$G(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$G(Constructor, staticProps);
  return Constructor;
}
var DataSource = /* @__PURE__ */ function() {
  function DataSource2(hotInstance) {
    var dataSource = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    _classCallCheck$L(this, DataSource2);
    this.hot = hotInstance;
    this.data = dataSource;
    this.dataType = "array";
    this.colToProp = function() {
    };
    this.propToCol = function() {
    };
  }
  _createClass$G(DataSource2, [{
    key: "modifyRowData",
    value: function modifyRowData(rowIndex) {
      var modifyRowData2;
      if (this.hot.hasHook("modifyRowData")) {
        modifyRowData2 = this.hot.runHooks("modifyRowData", rowIndex);
      }
      return modifyRowData2 !== void 0 && !Number.isInteger(modifyRowData2) ? modifyRowData2 : this.data[rowIndex];
    }
  }, {
    key: "getData",
    value: function getData() {
      var toArray = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!this.data || this.data.length === 0) {
        return this.data;
      }
      return this.getByRange(null, null, toArray);
    }
  }, {
    key: "setData",
    value: function setData(data) {
      this.data = data;
    }
  }, {
    key: "getAtColumn",
    value: function getAtColumn(column) {
      var _this = this;
      var result = [];
      arrayEach(this.data, function(row, rowIndex) {
        var value = _this.getAtCell(rowIndex, column);
        result.push(value);
      });
      return result;
    }
  }, {
    key: "getAtRow",
    value: function getAtRow(row, startColumn, endColumn) {
      var _this2 = this;
      var toArray = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var getAllProps = startColumn === void 0 && endColumn === void 0;
      var dataRow = null;
      var newDataRow = null;
      dataRow = this.modifyRowData(row);
      if (Array.isArray(dataRow)) {
        newDataRow = [];
        if (getAllProps) {
          dataRow.forEach(function(cell, column) {
            newDataRow[column] = _this2.getAtPhysicalCell(row, column, dataRow);
          });
        } else {
          rangeEach(startColumn, endColumn, function(column) {
            newDataRow[column - startColumn] = _this2.getAtPhysicalCell(row, column, dataRow);
          });
        }
      } else if (isObject(dataRow) || isFunction$1(dataRow)) {
        if (toArray) {
          newDataRow = [];
        } else {
          newDataRow = {};
        }
        if (!getAllProps || toArray) {
          var rangeStart = 0;
          var rangeEnd = this.countFirstRowKeys() - 1;
          rangeEach(rangeStart, rangeEnd, function(column) {
            var prop = _this2.colToProp(column);
            if (column >= (startColumn || rangeStart) && column <= (endColumn || rangeEnd) && !Number.isInteger(prop)) {
              var cellValue = _this2.getAtPhysicalCell(row, prop, dataRow);
              if (toArray) {
                newDataRow.push(cellValue);
              } else {
                setProperty(newDataRow, prop, cellValue);
              }
            }
          });
        } else {
          objectEach(dataRow, function(value, prop) {
            setProperty(newDataRow, prop, _this2.getAtPhysicalCell(row, prop, dataRow));
          });
        }
      }
      return newDataRow;
    }
  }, {
    key: "setAtCell",
    value: function setAtCell(row, column, value) {
      if (row >= this.countRows() || column >= this.countFirstRowKeys()) {
        return;
      }
      if (this.hot.hasHook("modifySourceData")) {
        var valueHolder = createObjectPropListener(value);
        this.hot.runHooks("modifySourceData", row, this.propToCol(column), valueHolder, "set");
        if (valueHolder.isTouched()) {
          value = valueHolder.value;
        }
      }
      if (!Number.isInteger(column)) {
        setProperty(this.data[row], column, value);
      } else {
        this.data[row][column] = value;
      }
    }
  }, {
    key: "getAtPhysicalCell",
    value: function getAtPhysicalCell(row, column, dataRow) {
      var result = null;
      if (dataRow) {
        if (typeof column === "string") {
          result = getProperty(dataRow, column);
        } else if (typeof column === "function") {
          result = column(dataRow);
        } else {
          result = dataRow[column];
        }
      }
      if (this.hot.hasHook("modifySourceData")) {
        var valueHolder = createObjectPropListener(result);
        this.hot.runHooks("modifySourceData", row, this.colToProp(column), valueHolder, "get");
        if (valueHolder.isTouched()) {
          result = valueHolder.value;
        }
      }
      return result;
    }
  }, {
    key: "getAtCell",
    value: function getAtCell(row, column) {
      var dataRow = this.modifyRowData(row);
      return this.getAtPhysicalCell(row, this.colToProp(column), dataRow);
    }
  }, {
    key: "getByRange",
    value: function getByRange() {
      var _this3 = this;
      var start = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      var end = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var toArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var getAllProps = false;
      var startRow = null;
      var startCol = null;
      var endRow = null;
      var endCol = null;
      if (start === null || end === null) {
        getAllProps = true;
        startRow = 0;
        endRow = this.countRows() - 1;
      } else {
        startRow = Math.min(start.row, end.row);
        startCol = Math.min(start.col, end.col);
        endRow = Math.max(start.row, end.row);
        endCol = Math.max(start.col, end.col);
      }
      var result = [];
      rangeEach(startRow, endRow, function(currentRow) {
        result.push(getAllProps ? _this3.getAtRow(currentRow, void 0, void 0, toArray) : _this3.getAtRow(currentRow, startCol, endCol, toArray));
      });
      return result;
    }
  }, {
    key: "countRows",
    value: function countRows() {
      if (this.hot.hasHook("modifySourceLength")) {
        var modifiedSourceLength = this.hot.runHooks("modifySourceLength");
        if (Number.isInteger(modifiedSourceLength)) {
          return modifiedSourceLength;
        }
      }
      return this.data.length;
    }
  }, {
    key: "countFirstRowKeys",
    value: function countFirstRowKeys$1() {
      return countFirstRowKeys(this.data);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.data = null;
      this.hot = null;
    }
  }]);
  return DataSource2;
}();

var MIXIN_NAME$6 = "localHooks";
var localHooks = {
  _localHooks: Object.create(null),
  addLocalHook: function addLocalHook(key, callback) {
    if (!this._localHooks[key]) {
      this._localHooks[key] = [];
    }
    this._localHooks[key].push(callback);
    return this;
  },
  runLocalHooks: function runLocalHooks(key) {
    var _this = this;
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    if (this._localHooks[key]) {
      arrayEach(this._localHooks[key], function(callback) {
        return callback.apply(_this, params);
      });
    }
  },
  clearLocalHooks: function clearLocalHooks() {
    this._localHooks = {};
    return this;
  }
};
defineGetter(localHooks, "MIXIN_NAME", MIXIN_NAME$6, {
  writable: false,
  enumerable: false
});

function _classCallCheck$M(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$H(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$H(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$H(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$H(Constructor, staticProps);
  return Constructor;
}
var IndexMap = /* @__PURE__ */ function() {
  function IndexMap2() {
    var initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    _classCallCheck$M(this, IndexMap2);
    this.indexedValues = [];
    this.initValueOrFn = initValueOrFn;
  }
  _createClass$H(IndexMap2, [{
    key: "getValues",
    value: function getValues() {
      return this.indexedValues;
    }
  }, {
    key: "getValueAtIndex",
    value: function getValueAtIndex(index) {
      var values = this.indexedValues;
      if (index < values.length) {
        return values[index];
      }
    }
  }, {
    key: "setValues",
    value: function setValues(values) {
      this.indexedValues = values.slice();
      this.runLocalHooks("change");
    }
  }, {
    key: "setValueAtIndex",
    value: function setValueAtIndex(index, value) {
      if (index < this.indexedValues.length) {
        this.indexedValues[index] = value;
        this.runLocalHooks("change");
        return true;
      }
      return false;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.setDefaultValues();
    }
  }, {
    key: "getLength",
    value: function getLength() {
      return this.getValues().length;
    }
  }, {
    key: "setDefaultValues",
    value: function setDefaultValues() {
      var _this = this;
      var length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.indexedValues.length;
      this.indexedValues.length = 0;
      if (isFunction$1(this.initValueOrFn)) {
        rangeEach(length - 1, function(index) {
          return _this.indexedValues.push(_this.initValueOrFn(index));
        });
      } else {
        rangeEach(length - 1, function() {
          return _this.indexedValues.push(_this.initValueOrFn);
        });
      }
      this.runLocalHooks("change");
    }
  }, {
    key: "init",
    value: function init(length) {
      this.setDefaultValues(length);
      this.runLocalHooks("init");
      return this;
    }
  }, {
    key: "insert",
    value: function insert() {
      this.runLocalHooks("change");
    }
  }, {
    key: "remove",
    value: function remove() {
      this.runLocalHooks("change");
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clearLocalHooks();
      this.indexedValues = null;
      this.initValueOrFn = null;
    }
  }]);
  return IndexMap2;
}();
mixin(IndexMap, localHooks);

function _toConsumableArray$b(arr) {
  return _arrayWithoutHoles$9(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$d(arr) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$d(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$d(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$d(o, minLen);
}
function _iterableToArray$9(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$9(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$d(arr);
}
function _arrayLikeToArray$d(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function getListWithInsertedItems(indexedValues, insertionIndex, insertedIndexes, insertedValuesMapping) {
  var firstInsertedIndex = insertedIndexes.length ? insertedIndexes[0] : void 0;
  return [].concat(_toConsumableArray$b(indexedValues.slice(0, firstInsertedIndex)), _toConsumableArray$b(insertedIndexes.map(function(insertedIndex, ordinalNumber) {
    if (isFunction$1(insertedValuesMapping)) {
      return insertedValuesMapping(insertedIndex, ordinalNumber);
    }
    return insertedValuesMapping;
  })), _toConsumableArray$b(firstInsertedIndex === void 0 ? [] : indexedValues.slice(firstInsertedIndex)));
}
function getListWithRemovedItems(indexedValues, removedIndexes) {
  return arrayFilter(indexedValues, function(_, index) {
    return removedIndexes.includes(index) === false;
  });
}

function _typeof$q(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$q = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$q = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$q(obj);
}
function _classCallCheck$N(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$I(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$I(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$I(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$I(Constructor, staticProps);
  return Constructor;
}
function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target2, property2, receiver2) {
      var base = _superPropBase(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property, receiver || target);
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$i(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$j(subClass, superClass);
}
function _setPrototypeOf$j(o, p) {
  _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$j(o, p);
}
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$i(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$i(this, result);
  };
}
function _possibleConstructorReturn$i(self, call) {
  if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$i(self);
}
function _assertThisInitialized$i(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$i(o) {
  _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$i(o);
}
var PhysicalIndexToValueMap = /* @__PURE__ */ function(_IndexMap) {
  _inherits$i(PhysicalIndexToValueMap2, _IndexMap);
  var _super = _createSuper$i(PhysicalIndexToValueMap2);
  function PhysicalIndexToValueMap2() {
    _classCallCheck$N(this, PhysicalIndexToValueMap2);
    return _super.apply(this, arguments);
  }
  _createClass$I(PhysicalIndexToValueMap2, [{
    key: "insert",
    value: function insert(insertionIndex, insertedIndexes) {
      this.indexedValues = getListWithInsertedItems(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);
      _get(_getPrototypeOf$i(PhysicalIndexToValueMap2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
    }
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      this.indexedValues = getListWithRemovedItems(this.indexedValues, removedIndexes);
      _get(_getPrototypeOf$i(PhysicalIndexToValueMap2.prototype), "remove", this).call(this, removedIndexes);
    }
  }]);
  return PhysicalIndexToValueMap2;
}(IndexMap);

function _typeof$r(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$r = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$r = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$r(obj);
}
function _classCallCheck$O(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$J(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$J(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$J(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$J(Constructor, staticProps);
  return Constructor;
}
function _inherits$j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$k(subClass, superClass);
}
function _setPrototypeOf$k(o, p) {
  _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$k(o, p);
}
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$j(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$j(this, result);
  };
}
function _possibleConstructorReturn$j(self, call) {
  if (call && (_typeof$r(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$j(self);
}
function _assertThisInitialized$j(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$j(o) {
  _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$j(o);
}
var HidingMap = /* @__PURE__ */ function(_PhysicalIndexToValue) {
  _inherits$j(HidingMap2, _PhysicalIndexToValue);
  var _super = _createSuper$j(HidingMap2);
  function HidingMap2() {
    var initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    _classCallCheck$O(this, HidingMap2);
    return _super.call(this, initValueOrFn);
  }
  _createClass$J(HidingMap2, [{
    key: "getHiddenIndexes",
    value: function getHiddenIndexes() {
      return arrayReduce(this.getValues(), function(indexesList, isHidden, physicalIndex) {
        if (isHidden) {
          indexesList.push(physicalIndex);
        }
        return indexesList;
      }, []);
    }
  }]);
  return HidingMap2;
}(PhysicalIndexToValueMap);

function _toConsumableArray$c(arr) {
  return _arrayWithoutHoles$a(arr) || _iterableToArray$a(arr) || _unsupportedIterableToArray$e(arr) || _nonIterableSpread$a();
}
function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$e(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$e(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$e(o, minLen);
}
function _iterableToArray$a(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$a(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$e(arr);
}
function _arrayLikeToArray$e(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function getListWithInsertedItems$1(indexedValues, insertionIndex, insertedIndexes) {
  return [].concat(_toConsumableArray$c(indexedValues.slice(0, insertionIndex)), _toConsumableArray$c(insertedIndexes), _toConsumableArray$c(indexedValues.slice(insertionIndex)));
}
function getListWithRemovedItems$1(indexedValues, removedIndexes) {
  return arrayFilter(indexedValues, function(index) {
    return removedIndexes.includes(index) === false;
  });
}

function getDecreasedIndexes(indexedValues, removedIndexes) {
  return arrayMap(indexedValues, function(index) {
    return index - removedIndexes.filter(function(removedIndex) {
      return removedIndex < index;
    }).length;
  });
}
function getIncreasedIndexes(indexedValues, insertedIndexes) {
  var firstInsertedIndex = insertedIndexes[0];
  var amountOfIndexes = insertedIndexes.length;
  return arrayMap(indexedValues, function(index) {
    if (index >= firstInsertedIndex) {
      return index + amountOfIndexes;
    }
    return index;
  });
}

function _typeof$s(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$s = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$s = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$s(obj);
}
function _toConsumableArray$d(arr) {
  return _arrayWithoutHoles$b(arr) || _iterableToArray$b(arr) || _unsupportedIterableToArray$f(arr) || _nonIterableSpread$b();
}
function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$f(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$f(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$f(o, minLen);
}
function _iterableToArray$b(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$b(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$f(arr);
}
function _arrayLikeToArray$f(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$P(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$K(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$K(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$K(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$K(Constructor, staticProps);
  return Constructor;
}
function _get$1(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$1 = Reflect.get;
  } else {
    _get$1 = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$1(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$1(target, property, receiver || target);
}
function _superPropBase$1(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$k(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$l(subClass, superClass);
}
function _setPrototypeOf$l(o, p) {
  _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$l(o, p);
}
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$k(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$k(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$k(this, result);
  };
}
function _possibleConstructorReturn$k(self, call) {
  if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$k(self);
}
function _assertThisInitialized$k(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$k(o) {
  _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$k(o);
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var LinkedPhysicalIndexToValueMap = /* @__PURE__ */ function(_IndexMap) {
  _inherits$k(LinkedPhysicalIndexToValueMap2, _IndexMap);
  var _super = _createSuper$k(LinkedPhysicalIndexToValueMap2);
  function LinkedPhysicalIndexToValueMap2() {
    var _this;
    _classCallCheck$P(this, LinkedPhysicalIndexToValueMap2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$3(_assertThisInitialized$k(_this), "orderOfIndexes", []);
    return _this;
  }
  _createClass$K(LinkedPhysicalIndexToValueMap2, [{
    key: "getValues",
    value: function getValues() {
      var _this2 = this;
      return this.orderOfIndexes.map(function(physicalIndex) {
        return _this2.indexedValues[physicalIndex];
      });
    }
  }, {
    key: "setValues",
    value: function setValues(values) {
      this.orderOfIndexes = _toConsumableArray$d(Array(values.length).keys());
      _get$1(_getPrototypeOf$k(LinkedPhysicalIndexToValueMap2.prototype), "setValues", this).call(this, values);
    }
  }, {
    key: "setValueAtIndex",
    value: function setValueAtIndex(index, value) {
      var position = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.orderOfIndexes.length;
      if (index < this.indexedValues.length) {
        this.indexedValues[index] = value;
        if (this.orderOfIndexes.includes(index) === false) {
          this.orderOfIndexes.splice(position, 0, index);
        }
        this.runLocalHooks("change");
        return true;
      }
      return false;
    }
  }, {
    key: "clearValue",
    value: function clearValue(physicalIndex) {
      this.orderOfIndexes = getListWithRemovedItems$1(this.orderOfIndexes, [physicalIndex]);
      if (isFunction$1(this.initValueOrFn)) {
        _get$1(_getPrototypeOf$k(LinkedPhysicalIndexToValueMap2.prototype), "setValueAtIndex", this).call(this, physicalIndex, this.initValueOrFn(physicalIndex));
      } else {
        _get$1(_getPrototypeOf$k(LinkedPhysicalIndexToValueMap2.prototype), "setValueAtIndex", this).call(this, physicalIndex, this.initValueOrFn);
      }
    }
  }, {
    key: "getLength",
    value: function getLength() {
      return this.orderOfIndexes.length;
    }
  }, {
    key: "setDefaultValues",
    value: function setDefaultValues() {
      var length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.indexedValues.length;
      this.orderOfIndexes.length = 0;
      _get$1(_getPrototypeOf$k(LinkedPhysicalIndexToValueMap2.prototype), "setDefaultValues", this).call(this, length);
    }
  }, {
    key: "insert",
    value: function insert(insertionIndex, insertedIndexes) {
      this.indexedValues = getListWithInsertedItems(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);
      this.orderOfIndexes = getIncreasedIndexes(this.orderOfIndexes, insertedIndexes);
      _get$1(_getPrototypeOf$k(LinkedPhysicalIndexToValueMap2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
    }
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      this.indexedValues = getListWithRemovedItems(this.indexedValues, removedIndexes);
      this.orderOfIndexes = getListWithRemovedItems$1(this.orderOfIndexes, removedIndexes);
      this.orderOfIndexes = getDecreasedIndexes(this.orderOfIndexes, removedIndexes);
      _get$1(_getPrototypeOf$k(LinkedPhysicalIndexToValueMap2.prototype), "remove", this).call(this, removedIndexes);
    }
  }, {
    key: "getEntries",
    value: function getEntries() {
      var _this3 = this;
      return this.orderOfIndexes.map(function(physicalIndex) {
        return [physicalIndex, _this3.getValueAtIndex(physicalIndex)];
      });
    }
  }]);
  return LinkedPhysicalIndexToValueMap2;
}(IndexMap);

function _typeof$t(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$t = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$t = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$t(obj);
}
function _classCallCheck$Q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$L(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$L(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$L(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$L(Constructor, staticProps);
  return Constructor;
}
function _inherits$l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$m(subClass, superClass);
}
function _setPrototypeOf$m(o, p) {
  _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$m(o, p);
}
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$l(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$l(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$l(this, result);
  };
}
function _possibleConstructorReturn$l(self, call) {
  if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$l(self);
}
function _assertThisInitialized$l(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$l(o) {
  _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$l(o);
}
var TrimmingMap = /* @__PURE__ */ function(_PhysicalIndexToValue) {
  _inherits$l(TrimmingMap2, _PhysicalIndexToValue);
  var _super = _createSuper$l(TrimmingMap2);
  function TrimmingMap2() {
    var initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    _classCallCheck$Q(this, TrimmingMap2);
    return _super.call(this, initValueOrFn);
  }
  _createClass$L(TrimmingMap2, [{
    key: "getTrimmedIndexes",
    value: function getTrimmedIndexes() {
      return arrayReduce(this.getValues(), function(indexesList, isTrimmed, physicalIndex) {
        if (isTrimmed) {
          indexesList.push(physicalIndex);
        }
        return indexesList;
      }, []);
    }
  }]);
  return TrimmingMap2;
}(PhysicalIndexToValueMap);

var alterStrategies = new Map([["indexesSequence", {
  getListWithInsertedItems: getListWithInsertedItems$1,
  getListWithRemovedItems: getListWithRemovedItems$1
}], ["physicallyIndexed", {
  getListWithInsertedItems: getListWithInsertedItems,
  getListWithRemovedItems: getListWithRemovedItems
}]]);
var alterUtilsFactory = function alterUtilsFactory2(indexationStrategy) {
  if (alterStrategies.has(indexationStrategy) === false) {
    throw new Error("Alter strategy with ID '".concat(indexationStrategy, "' does not exist."));
  }
  return alterStrategies.get(indexationStrategy);
};

function _typeof$u(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$u = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$u = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$u(obj);
}
function _classCallCheck$R(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$M(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$M(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$M(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$M(Constructor, staticProps);
  return Constructor;
}
function _get$2(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$2 = Reflect.get;
  } else {
    _get$2 = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$2(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$2(target, property, receiver || target);
}
function _superPropBase$2(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$m(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$n(subClass, superClass);
}
function _setPrototypeOf$n(o, p) {
  _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$n(o, p);
}
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$m(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$m(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$m(this, result);
  };
}
function _possibleConstructorReturn$m(self, call) {
  if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$m(self);
}
function _assertThisInitialized$m(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$m(o) {
  _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$m(o);
}
var IndexesSequence = /* @__PURE__ */ function(_IndexMap) {
  _inherits$m(IndexesSequence2, _IndexMap);
  var _super = _createSuper$m(IndexesSequence2);
  function IndexesSequence2() {
    _classCallCheck$R(this, IndexesSequence2);
    return _super.call(this, function(index) {
      return index;
    });
  }
  _createClass$M(IndexesSequence2, [{
    key: "insert",
    value: function insert(insertionIndex, insertedIndexes) {
      var listAfterUpdate = getIncreasedIndexes(this.indexedValues, insertedIndexes);
      this.indexedValues = getListWithInsertedItems$1(listAfterUpdate, insertionIndex, insertedIndexes);
      _get$2(_getPrototypeOf$m(IndexesSequence2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
    }
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      var listAfterUpdate = getListWithRemovedItems$1(this.indexedValues, removedIndexes);
      this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);
      _get$2(_getPrototypeOf$m(IndexesSequence2.prototype), "remove", this).call(this, removedIndexes);
    }
  }]);
  return IndexesSequence2;
}(IndexMap);

var availableIndexMapTypes = new Map([["hiding", HidingMap], ["index", IndexMap], ["linkedPhysicalIndexToValue", LinkedPhysicalIndexToValueMap], ["physicalIndexToValue", PhysicalIndexToValueMap], ["trimming", TrimmingMap]]);
function createIndexMap(mapType) {
  var initValueOrFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!availableIndexMapTypes.has(mapType)) {
    throw new Error('The provided map type ("'.concat(mapType, '") does not exist.'));
  }
  return new (availableIndexMapTypes.get(mapType))(initValueOrFn);
}

function _classCallCheck$S(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$N(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$N(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$N(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$N(Constructor, staticProps);
  return Constructor;
}
var registeredMaps = 0;
var MapCollection = /* @__PURE__ */ function() {
  function MapCollection2() {
    _classCallCheck$S(this, MapCollection2);
    this.collection = new Map();
  }
  _createClass$N(MapCollection2, [{
    key: "register",
    value: function register(uniqueName, indexMap) {
      var _this = this;
      if (this.collection.has(uniqueName) === false) {
        this.collection.set(uniqueName, indexMap);
        indexMap.addLocalHook("change", function() {
          return _this.runLocalHooks("change", indexMap);
        });
        registeredMaps += 1;
      }
    }
  }, {
    key: "unregister",
    value: function unregister(name) {
      var indexMap = this.collection.get(name);
      if (isDefined(indexMap)) {
        indexMap.destroy();
        this.collection.delete(name);
        this.runLocalHooks("change", indexMap);
        registeredMaps -= 1;
      }
    }
  }, {
    key: "unregisterAll",
    value: function unregisterAll() {
      var _this2 = this;
      this.collection.forEach(function(indexMap, name) {
        return _this2.unregister(name);
      });
      this.collection.clear();
    }
  }, {
    key: "get",
    value: function get(name) {
      if (isUndefined$1(name)) {
        return Array.from(this.collection.values());
      }
      return this.collection.get(name);
    }
  }, {
    key: "getLength",
    value: function getLength() {
      return this.collection.size;
    }
  }, {
    key: "removeFromEvery",
    value: function removeFromEvery(removedIndexes) {
      this.collection.forEach(function(indexMap) {
        indexMap.remove(removedIndexes);
      });
    }
  }, {
    key: "insertToEvery",
    value: function insertToEvery(insertionIndex, insertedIndexes) {
      this.collection.forEach(function(indexMap) {
        indexMap.insert(insertionIndex, insertedIndexes);
      });
    }
  }, {
    key: "initEvery",
    value: function initEvery(length) {
      this.collection.forEach(function(indexMap) {
        indexMap.init(length);
      });
    }
  }]);
  return MapCollection2;
}();
mixin(MapCollection, localHooks);
function getRegisteredMapsCounter() {
  return registeredMaps;
}

function _typeof$v(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$v = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$v = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$v(obj);
}
function _classCallCheck$T(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$O(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$O(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$O(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$O(Constructor, staticProps);
  return Constructor;
}
function _inherits$n(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$o(subClass, superClass);
}
function _setPrototypeOf$o(o, p) {
  _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$o(o, p);
}
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$n(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$n(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$n(this, result);
  };
}
function _possibleConstructorReturn$n(self, call) {
  if (call && (_typeof$v(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$n(self);
}
function _assertThisInitialized$n(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$n(o) {
  _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$n(o);
}
var AggregatedCollection = /* @__PURE__ */ function(_MapCollection) {
  _inherits$n(AggregatedCollection2, _MapCollection);
  var _super = _createSuper$n(AggregatedCollection2);
  function AggregatedCollection2(aggregationFunction, fallbackValue) {
    var _this;
    _classCallCheck$T(this, AggregatedCollection2);
    _this = _super.call(this);
    _this.mergedValuesCache = [];
    _this.aggregationFunction = aggregationFunction;
    _this.fallbackValue = fallbackValue;
    return _this;
  }
  _createClass$O(AggregatedCollection2, [{
    key: "getMergedValues",
    value: function getMergedValues() {
      var readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (readFromCache === true) {
        return this.mergedValuesCache;
      }
      if (this.getLength() === 0) {
        return [];
      }
      var mapsValuesMatrix = arrayMap(this.get(), function(map) {
        return map.getValues();
      });
      var indexesValuesMatrix = [];
      var mapsLength = isDefined(mapsValuesMatrix[0]) && mapsValuesMatrix[0].length || 0;
      for (var index = 0; index < mapsLength; index += 1) {
        var valuesForIndex = [];
        for (var mapIndex = 0; mapIndex < this.getLength(); mapIndex += 1) {
          valuesForIndex.push(mapsValuesMatrix[mapIndex][index]);
        }
        indexesValuesMatrix.push(valuesForIndex);
      }
      return arrayMap(indexesValuesMatrix, this.aggregationFunction);
    }
  }, {
    key: "getMergedValueAtIndex",
    value: function getMergedValueAtIndex(index, readFromCache) {
      var valueAtIndex = this.getMergedValues(readFromCache)[index];
      return isDefined(valueAtIndex) ? valueAtIndex : this.fallbackValue;
    }
  }, {
    key: "updateCache",
    value: function updateCache() {
      this.mergedValuesCache = this.getMergedValues(false);
    }
  }]);
  return AggregatedCollection2;
}(MapCollection);

function _classCallCheck$U(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$P(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$P(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$P(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$P(Constructor, staticProps);
  return Constructor;
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var _currentInitialChanges = /* @__PURE__ */ new WeakMap();
var ChangesObserver = /* @__PURE__ */ function() {
  function ChangesObserver2() {
    _classCallCheck$U(this, ChangesObserver2);
    _currentInitialChanges.set(this, {
      writable: true,
      value: []
    });
  }
  _createClass$P(ChangesObserver2, [{
    key: "subscribe",
    value: function subscribe(callback) {
      this.addLocalHook("change", callback);
      this._write(_classPrivateFieldGet(this, _currentInitialChanges));
      return this;
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      this.runLocalHooks("unsubscribe");
      this.clearLocalHooks();
      return this;
    }
  }, {
    key: "_write",
    value: function _write(changes) {
      if (changes.length > 0) {
        this.runLocalHooks("change", changes);
      }
      return this;
    }
  }, {
    key: "_writeInitialChanges",
    value: function _writeInitialChanges(initialChanges) {
      _classPrivateFieldSet(this, _currentInitialChanges, initialChanges);
    }
  }]);
  return ChangesObserver2;
}();
mixin(ChangesObserver, localHooks);

function arrayDiff(baseArray, newArray) {
  var changes = [];
  var i = 0;
  var j = 0;
  for (; i < baseArray.length && j < newArray.length; i++, j++) {
    if (baseArray[i] !== newArray[j]) {
      changes.push({
        op: "replace",
        index: j,
        oldValue: baseArray[i],
        newValue: newArray[j]
      });
    }
  }
  for (; i < newArray.length; i++) {
    changes.push({
      op: "insert",
      index: i,
      oldValue: void 0,
      newValue: newArray[i]
    });
  }
  for (; j < baseArray.length; j++) {
    changes.push({
      op: "remove",
      index: j,
      oldValue: baseArray[j],
      newValue: void 0
    });
  }
  return changes;
}

function _classCallCheck$V(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$Q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$Q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$Q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$Q(Constructor, staticProps);
  return Constructor;
}
function _classPrivateFieldGet$1(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$1(receiver, privateMap, "get");
  return _classApplyDescriptorGet$1(receiver, descriptor);
}
function _classApplyDescriptorGet$1(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$1(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$1(receiver, privateMap, "set");
  _classApplyDescriptorSet$1(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$1(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$1(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _observers = /* @__PURE__ */ new WeakMap();
var _indexMatrix = /* @__PURE__ */ new WeakMap();
var _currentIndexState = /* @__PURE__ */ new WeakMap();
var _isMatrixIndexesInitialized = /* @__PURE__ */ new WeakMap();
var _initialIndexValue = /* @__PURE__ */ new WeakMap();
var ChangesObservable = /* @__PURE__ */ function() {
  function ChangesObservable2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, initialIndexValue = _ref.initialIndexValue;
    _classCallCheck$V(this, ChangesObservable2);
    _observers.set(this, {
      writable: true,
      value: new Set()
    });
    _indexMatrix.set(this, {
      writable: true,
      value: []
    });
    _currentIndexState.set(this, {
      writable: true,
      value: []
    });
    _isMatrixIndexesInitialized.set(this, {
      writable: true,
      value: false
    });
    _initialIndexValue.set(this, {
      writable: true,
      value: false
    });
    _classPrivateFieldSet$1(this, _initialIndexValue, initialIndexValue !== null && initialIndexValue !== void 0 ? initialIndexValue : false);
  }
  _createClass$Q(ChangesObservable2, [{
    key: "createObserver",
    value: function createObserver() {
      var _this = this;
      var observer = new ChangesObserver();
      _classPrivateFieldGet$1(this, _observers).add(observer);
      observer.addLocalHook("unsubscribe", function() {
        _classPrivateFieldGet$1(_this, _observers).delete(observer);
      });
      observer._writeInitialChanges(arrayDiff(_classPrivateFieldGet$1(this, _indexMatrix), _classPrivateFieldGet$1(this, _currentIndexState)));
      return observer;
    }
  }, {
    key: "emit",
    value: function emit(indexesState) {
      var currentIndexState = _classPrivateFieldGet$1(this, _currentIndexState);
      if (!_classPrivateFieldGet$1(this, _isMatrixIndexesInitialized) || _classPrivateFieldGet$1(this, _indexMatrix).length !== indexesState.length) {
        if (indexesState.length === 0) {
          indexesState = new Array(currentIndexState.length).fill(_classPrivateFieldGet$1(this, _initialIndexValue));
        } else {
          _classPrivateFieldSet$1(this, _indexMatrix, new Array(indexesState.length).fill(_classPrivateFieldGet$1(this, _initialIndexValue)));
        }
        if (!_classPrivateFieldGet$1(this, _isMatrixIndexesInitialized)) {
          _classPrivateFieldSet$1(this, _isMatrixIndexesInitialized, true);
          currentIndexState = _classPrivateFieldGet$1(this, _indexMatrix);
        }
      }
      var changes = arrayDiff(currentIndexState, indexesState);
      _classPrivateFieldGet$1(this, _observers).forEach(function(observer) {
        return observer._write(changes);
      });
      _classPrivateFieldSet$1(this, _currentIndexState, indexesState);
    }
  }]);
  return ChangesObservable2;
}();

function _toConsumableArray$e(arr) {
  return _arrayWithoutHoles$c(arr) || _iterableToArray$c(arr) || _unsupportedIterableToArray$g(arr) || _nonIterableSpread$c();
}
function _nonIterableSpread$c() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$g(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$g(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$g(o, minLen);
}
function _iterableToArray$c(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$c(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$g(arr);
}
function _arrayLikeToArray$g(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$W(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$R(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$R(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$R(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$R(Constructor, staticProps);
  return Constructor;
}
var IndexMapper = /* @__PURE__ */ function() {
  function IndexMapper2() {
    var _this = this;
    _classCallCheck$W(this, IndexMapper2);
    this.indexesSequence = new IndexesSequence();
    this.trimmingMapsCollection = new AggregatedCollection(function(valuesForIndex) {
      return valuesForIndex.some(function(value) {
        return value === true;
      });
    }, false);
    this.hidingMapsCollection = new AggregatedCollection(function(valuesForIndex) {
      return valuesForIndex.some(function(value) {
        return value === true;
      });
    }, false);
    this.variousMapsCollection = new MapCollection();
    this.hidingChangesObservable = new ChangesObservable({
      initialIndexValue: false
    });
    this.notTrimmedIndexesCache = [];
    this.notHiddenIndexesCache = [];
    this.isBatched = false;
    this.indexesSequenceChanged = false;
    this.trimmedIndexesChanged = false;
    this.hiddenIndexesChanged = false;
    this.renderablePhysicalIndexesCache = [];
    this.fromPhysicalToVisualIndexesCache = new Map();
    this.fromVisualToRenderableIndexesCache = new Map();
    this.indexesSequence.addLocalHook("change", function() {
      _this.indexesSequenceChanged = true;
      _this.updateCache();
      _this.runLocalHooks("change", _this.indexesSequence, null);
    });
    this.trimmingMapsCollection.addLocalHook("change", function(changedMap) {
      _this.trimmedIndexesChanged = true;
      _this.updateCache();
      _this.runLocalHooks("change", changedMap, _this.trimmingMapsCollection);
    });
    this.hidingMapsCollection.addLocalHook("change", function(changedMap) {
      _this.hiddenIndexesChanged = true;
      _this.updateCache();
      _this.runLocalHooks("change", changedMap, _this.hidingMapsCollection);
    });
    this.variousMapsCollection.addLocalHook("change", function(changedMap) {
      _this.runLocalHooks("change", changedMap, _this.variousMapsCollection);
    });
  }
  _createClass$R(IndexMapper2, [{
    key: "suspendOperations",
    value: function suspendOperations() {
      this.isBatched = true;
    }
  }, {
    key: "resumeOperations",
    value: function resumeOperations() {
      this.isBatched = false;
      this.updateCache();
    }
  }, {
    key: "createChangesObserver",
    value: function createChangesObserver(indexMapType) {
      if (indexMapType !== "hiding") {
        throw new Error('Unsupported index map type "'.concat(indexMapType, '".'));
      }
      return this.hidingChangesObservable.createObserver();
    }
  }, {
    key: "createAndRegisterIndexMap",
    value: function createAndRegisterIndexMap(indexName, mapType, initValueOrFn) {
      return this.registerMap(indexName, createIndexMap(mapType, initValueOrFn));
    }
  }, {
    key: "registerMap",
    value: function registerMap(uniqueName, indexMap) {
      if (this.trimmingMapsCollection.get(uniqueName) || this.hidingMapsCollection.get(uniqueName) || this.variousMapsCollection.get(uniqueName)) {
        throw Error('Map with name "'.concat(uniqueName, '" has been already registered.'));
      }
      if (indexMap instanceof TrimmingMap) {
        this.trimmingMapsCollection.register(uniqueName, indexMap);
      } else if (indexMap instanceof HidingMap) {
        this.hidingMapsCollection.register(uniqueName, indexMap);
      } else {
        this.variousMapsCollection.register(uniqueName, indexMap);
      }
      var numberOfIndexes = this.getNumberOfIndexes();
      if (numberOfIndexes > 0) {
        indexMap.init(numberOfIndexes);
      }
      return indexMap;
    }
  }, {
    key: "unregisterMap",
    value: function unregisterMap(name) {
      this.trimmingMapsCollection.unregister(name);
      this.hidingMapsCollection.unregister(name);
      this.variousMapsCollection.unregister(name);
    }
  }, {
    key: "unregisterAll",
    value: function unregisterAll() {
      this.trimmingMapsCollection.unregisterAll();
      this.hidingMapsCollection.unregisterAll();
      this.variousMapsCollection.unregisterAll();
    }
  }, {
    key: "getPhysicalFromVisualIndex",
    value: function getPhysicalFromVisualIndex(visualIndex) {
      var physicalIndex = this.notTrimmedIndexesCache[visualIndex];
      if (isDefined(physicalIndex)) {
        return physicalIndex;
      }
      return null;
    }
  }, {
    key: "getPhysicalFromRenderableIndex",
    value: function getPhysicalFromRenderableIndex(renderableIndex) {
      var physicalIndex = this.renderablePhysicalIndexesCache[renderableIndex];
      if (isDefined(physicalIndex)) {
        return physicalIndex;
      }
      return null;
    }
  }, {
    key: "getVisualFromPhysicalIndex",
    value: function getVisualFromPhysicalIndex(physicalIndex) {
      var visualIndex = this.fromPhysicalToVisualIndexesCache.get(physicalIndex);
      if (isDefined(visualIndex)) {
        return visualIndex;
      }
      return null;
    }
  }, {
    key: "getVisualFromRenderableIndex",
    value: function getVisualFromRenderableIndex(renderableIndex) {
      return this.getVisualFromPhysicalIndex(this.getPhysicalFromRenderableIndex(renderableIndex));
    }
  }, {
    key: "getRenderableFromVisualIndex",
    value: function getRenderableFromVisualIndex(visualIndex) {
      var renderableIndex = this.fromVisualToRenderableIndexesCache.get(visualIndex);
      if (isDefined(renderableIndex)) {
        return renderableIndex;
      }
      return null;
    }
  }, {
    key: "getFirstNotHiddenIndex",
    value: function getFirstNotHiddenIndex(fromVisualIndex, incrementBy) {
      var searchAlsoOtherWayAround = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var indexForNextSearch = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : fromVisualIndex - incrementBy;
      var physicalIndex = this.getPhysicalFromVisualIndex(fromVisualIndex);
      if (physicalIndex === null) {
        if (searchAlsoOtherWayAround === true && indexForNextSearch !== fromVisualIndex - incrementBy) {
          return this.getFirstNotHiddenIndex(indexForNextSearch, -incrementBy, false, indexForNextSearch);
        }
        return null;
      }
      if (this.isHidden(physicalIndex) === false) {
        return fromVisualIndex;
      }
      return this.getFirstNotHiddenIndex(fromVisualIndex + incrementBy, incrementBy, searchAlsoOtherWayAround, indexForNextSearch);
    }
  }, {
    key: "initToLength",
    value: function initToLength() {
      var length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getNumberOfIndexes();
      this.notTrimmedIndexesCache = _toConsumableArray$e(new Array(length).keys());
      this.notHiddenIndexesCache = _toConsumableArray$e(new Array(length).keys());
      this.suspendOperations();
      this.indexesSequence.init(length);
      this.trimmingMapsCollection.initEvery(length);
      this.resumeOperations();
      this.suspendOperations();
      this.hidingMapsCollection.initEvery(length);
      this.variousMapsCollection.initEvery(length);
      this.resumeOperations();
      this.runLocalHooks("init");
    }
  }, {
    key: "getIndexesSequence",
    value: function getIndexesSequence() {
      return this.indexesSequence.getValues();
    }
  }, {
    key: "setIndexesSequence",
    value: function setIndexesSequence(indexes) {
      this.indexesSequence.setValues(indexes);
    }
  }, {
    key: "getNotTrimmedIndexes",
    value: function getNotTrimmedIndexes() {
      var _this2 = this;
      var readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (readFromCache === true) {
        return this.notTrimmedIndexesCache;
      }
      var indexesSequence = this.getIndexesSequence();
      return indexesSequence.filter(function(physicalIndex) {
        return _this2.isTrimmed(physicalIndex) === false;
      });
    }
  }, {
    key: "getNotTrimmedIndexesLength",
    value: function getNotTrimmedIndexesLength() {
      return this.getNotTrimmedIndexes().length;
    }
  }, {
    key: "getNotHiddenIndexes",
    value: function getNotHiddenIndexes() {
      var _this3 = this;
      var readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (readFromCache === true) {
        return this.notHiddenIndexesCache;
      }
      var indexesSequence = this.getIndexesSequence();
      return indexesSequence.filter(function(physicalIndex) {
        return _this3.isHidden(physicalIndex) === false;
      });
    }
  }, {
    key: "getNotHiddenIndexesLength",
    value: function getNotHiddenIndexesLength() {
      return this.getNotHiddenIndexes().length;
    }
  }, {
    key: "getRenderableIndexes",
    value: function getRenderableIndexes() {
      var _this4 = this;
      var readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (readFromCache === true) {
        return this.renderablePhysicalIndexesCache;
      }
      var notTrimmedIndexes = this.getNotTrimmedIndexes();
      return notTrimmedIndexes.filter(function(physicalIndex) {
        return _this4.isHidden(physicalIndex) === false;
      });
    }
  }, {
    key: "getRenderableIndexesLength",
    value: function getRenderableIndexesLength() {
      return this.getRenderableIndexes().length;
    }
  }, {
    key: "getNumberOfIndexes",
    value: function getNumberOfIndexes() {
      return this.getIndexesSequence().length;
    }
  }, {
    key: "moveIndexes",
    value: function moveIndexes(movedIndexes, finalIndex) {
      var _this5 = this;
      if (typeof movedIndexes === "number") {
        movedIndexes = [movedIndexes];
      }
      var physicalMovedIndexes = arrayMap(movedIndexes, function(visualIndex) {
        return _this5.getPhysicalFromVisualIndex(visualIndex);
      });
      var notTrimmedIndexesLength = this.getNotTrimmedIndexesLength();
      var movedIndexesLength = movedIndexes.length;
      var listWithRemovedItems = getListWithRemovedItems$1(this.getIndexesSequence(), physicalMovedIndexes);
      var destinationPosition = notTrimmedIndexesLength - movedIndexesLength;
      if (finalIndex + movedIndexesLength < notTrimmedIndexesLength) {
        var physicalIndex = listWithRemovedItems.filter(function(index) {
          return _this5.isTrimmed(index) === false;
        })[finalIndex];
        destinationPosition = listWithRemovedItems.indexOf(physicalIndex);
      }
      this.setIndexesSequence(getListWithInsertedItems$1(listWithRemovedItems, destinationPosition, physicalMovedIndexes));
    }
  }, {
    key: "isTrimmed",
    value: function isTrimmed(physicalIndex) {
      return this.trimmingMapsCollection.getMergedValueAtIndex(physicalIndex);
    }
  }, {
    key: "isHidden",
    value: function isHidden(physicalIndex) {
      return this.hidingMapsCollection.getMergedValueAtIndex(physicalIndex);
    }
  }, {
    key: "insertIndexes",
    value: function insertIndexes(firstInsertedVisualIndex, amountOfIndexes) {
      var nthVisibleIndex = this.getNotTrimmedIndexes()[firstInsertedVisualIndex];
      var firstInsertedPhysicalIndex = isDefined(nthVisibleIndex) ? nthVisibleIndex : this.getNumberOfIndexes();
      var insertionIndex = this.getIndexesSequence().includes(nthVisibleIndex) ? this.getIndexesSequence().indexOf(nthVisibleIndex) : this.getNumberOfIndexes();
      var insertedIndexes = arrayMap(new Array(amountOfIndexes).fill(firstInsertedPhysicalIndex), function(nextIndex, stepsFromStart) {
        return nextIndex + stepsFromStart;
      });
      this.suspendOperations();
      this.indexesSequence.insert(insertionIndex, insertedIndexes);
      this.trimmingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
      this.hidingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
      this.variousMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
      this.resumeOperations();
    }
  }, {
    key: "removeIndexes",
    value: function removeIndexes(removedIndexes) {
      this.suspendOperations();
      this.indexesSequence.remove(removedIndexes);
      this.trimmingMapsCollection.removeFromEvery(removedIndexes);
      this.hidingMapsCollection.removeFromEvery(removedIndexes);
      this.variousMapsCollection.removeFromEvery(removedIndexes);
      this.resumeOperations();
    }
  }, {
    key: "updateCache",
    value: function updateCache() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var anyCachedIndexChanged = this.indexesSequenceChanged || this.trimmedIndexesChanged || this.hiddenIndexesChanged;
      if (force === true || this.isBatched === false && anyCachedIndexChanged === true) {
        this.trimmingMapsCollection.updateCache();
        this.hidingMapsCollection.updateCache();
        this.notTrimmedIndexesCache = this.getNotTrimmedIndexes(false);
        this.notHiddenIndexesCache = this.getNotHiddenIndexes(false);
        this.renderablePhysicalIndexesCache = this.getRenderableIndexes(false);
        this.cacheFromPhysicalToVisualIndexes();
        this.cacheFromVisualToRenderabIendexes();
        if (this.hiddenIndexesChanged) {
          this.hidingChangesObservable.emit(this.hidingMapsCollection.getMergedValues());
        }
        this.runLocalHooks("cacheUpdated", {
          indexesSequenceChanged: this.indexesSequenceChanged,
          trimmedIndexesChanged: this.trimmedIndexesChanged,
          hiddenIndexesChanged: this.hiddenIndexesChanged
        });
        this.indexesSequenceChanged = false;
        this.trimmedIndexesChanged = false;
        this.hiddenIndexesChanged = false;
      }
    }
  }, {
    key: "cacheFromPhysicalToVisualIndexes",
    value: function cacheFromPhysicalToVisualIndexes() {
      var nrOfNotTrimmedIndexes = this.getNotTrimmedIndexesLength();
      this.fromPhysicalToVisualIndexesCache.clear();
      for (var visualIndex = 0; visualIndex < nrOfNotTrimmedIndexes; visualIndex += 1) {
        var physicalIndex = this.getPhysicalFromVisualIndex(visualIndex);
        this.fromPhysicalToVisualIndexesCache.set(physicalIndex, visualIndex);
      }
    }
  }, {
    key: "cacheFromVisualToRenderabIendexes",
    value: function cacheFromVisualToRenderabIendexes() {
      var nrOfRenderableIndexes = this.getRenderableIndexesLength();
      this.fromVisualToRenderableIndexesCache.clear();
      for (var renderableIndex = 0; renderableIndex < nrOfRenderableIndexes; renderableIndex += 1) {
        var physicalIndex = this.getPhysicalFromRenderableIndex(renderableIndex);
        var visualIndex = this.getVisualFromPhysicalIndex(physicalIndex);
        this.fromVisualToRenderableIndexesCache.set(visualIndex, renderableIndex);
      }
    }
  }]);
  return IndexMapper2;
}();
mixin(IndexMapper, localHooks);

var _templateObject$3;
function _taggedTemplateLiteral$3(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function extendNotExistingKeys(target, extension) {
  objectEach(extension, function(value, key) {
    if (isUndefined$1(target[key])) {
      target[key] = value;
    }
  });
  return target;
}
function normalizeLanguageCode(languageCode) {
  var languageCodePattern = /^([a-zA-Z]{2})-([a-zA-Z]{2})$/;
  var partsOfLanguageCode = languageCodePattern.exec(languageCode);
  if (partsOfLanguageCode) {
    return "".concat(partsOfLanguageCode[1].toLowerCase(), "-").concat(partsOfLanguageCode[2].toUpperCase());
  }
  return languageCode;
}
function warnUserAboutLanguageRegistration(languageCode) {
  if (isDefined(languageCode)) {
    error(toSingleLine(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral$3(['Language with code "', '" was not found. You should register particular language \n    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.'], ['Language with code "', '" was not found. You should register particular language\\x20\n    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.'])), languageCode));
  }
}

function pluralize(phrasePropositions, pluralForm) {
  var isPluralizable = Array.isArray(phrasePropositions) && Number.isInteger(pluralForm);
  if (isPluralizable) {
    return phrasePropositions[pluralForm];
  }
  return phrasePropositions;
}

var _staticRegister$4 = staticRegister("phraseFormatters"), registerGloballyPhraseFormatter = _staticRegister$4.register, getGlobalPhraseFormatters = _staticRegister$4.getValues;
function register$4(name, formatterFn) {
  registerGloballyPhraseFormatter(name, formatterFn);
}
function getAll() {
  return getGlobalPhraseFormatters();
}
register$4("pluralize", pluralize);

var CONTEXT_MENU_ITEMS_NAMESPACE = "ContextMenu:items";
var CONTEXTMENU_ITEMS_NO_ITEMS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".noItems");
var CONTEXTMENU_ITEMS_ROW_ABOVE = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertRowAbove");
var CONTEXTMENU_ITEMS_ROW_BELOW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertRowBelow");
var CONTEXTMENU_ITEMS_INSERT_LEFT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertColumnOnTheLeft");
var CONTEXTMENU_ITEMS_INSERT_RIGHT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertColumnOnTheRight");
var CONTEXTMENU_ITEMS_REMOVE_ROW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".removeRow");
var CONTEXTMENU_ITEMS_REMOVE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".removeColumn");
var CONTEXTMENU_ITEMS_UNDO = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".undo");
var CONTEXTMENU_ITEMS_REDO = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".redo");
var CONTEXTMENU_ITEMS_READ_ONLY = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".readOnly");
var CONTEXTMENU_ITEMS_CLEAR_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".clearColumn");
var CONTEXTMENU_ITEMS_COPY = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".copy");
var CONTEXTMENU_ITEMS_CUT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".cut");
var CONTEXTMENU_ITEMS_FREEZE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".freezeColumn");
var CONTEXTMENU_ITEMS_UNFREEZE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".unfreezeColumn");
var CONTEXTMENU_ITEMS_MERGE_CELLS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".mergeCells");
var CONTEXTMENU_ITEMS_UNMERGE_CELLS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".unmergeCells");
var CONTEXTMENU_ITEMS_ADD_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".addComment");
var CONTEXTMENU_ITEMS_EDIT_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".editComment");
var CONTEXTMENU_ITEMS_REMOVE_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".removeComment");
var CONTEXTMENU_ITEMS_READ_ONLY_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".readOnlyComment");
var CONTEXTMENU_ITEMS_ALIGNMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align");
var CONTEXTMENU_ITEMS_ALIGNMENT_LEFT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.left");
var CONTEXTMENU_ITEMS_ALIGNMENT_CENTER = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.center");
var CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.right");
var CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.justify");
var CONTEXTMENU_ITEMS_ALIGNMENT_TOP = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.top");
var CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.middle");
var CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.bottom");
var CONTEXTMENU_ITEMS_BORDERS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders");
var CONTEXTMENU_ITEMS_BORDERS_TOP = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.top");
var CONTEXTMENU_ITEMS_BORDERS_RIGHT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.right");
var CONTEXTMENU_ITEMS_BORDERS_BOTTOM = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.bottom");
var CONTEXTMENU_ITEMS_BORDERS_LEFT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.left");
var CONTEXTMENU_ITEMS_REMOVE_BORDERS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.remove");
var CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".nestedHeaders.insertChildRow");
var CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".nestedHeaders.detachFromParent");
var CONTEXTMENU_ITEMS_HIDE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".hideColumn");
var CONTEXTMENU_ITEMS_SHOW_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".showColumn");
var CONTEXTMENU_ITEMS_HIDE_ROW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".hideRow");
var CONTEXTMENU_ITEMS_SHOW_ROW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".showRow");
var FILTERS_NAMESPACE = "Filters:";
var FILTERS_CONDITIONS_NAMESPACE = "".concat(FILTERS_NAMESPACE, "conditions");
var FILTERS_CONDITIONS_NONE = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".none");
var FILTERS_CONDITIONS_EMPTY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isEmpty");
var FILTERS_CONDITIONS_NOT_EMPTY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isNotEmpty");
var FILTERS_CONDITIONS_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isEqualTo");
var FILTERS_CONDITIONS_NOT_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isNotEqualTo");
var FILTERS_CONDITIONS_BEGINS_WITH = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".beginsWith");
var FILTERS_CONDITIONS_ENDS_WITH = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".endsWith");
var FILTERS_CONDITIONS_CONTAINS = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".contains");
var FILTERS_CONDITIONS_NOT_CONTAIN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".doesNotContain");
var FILTERS_CONDITIONS_BY_VALUE = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".byValue");
var FILTERS_CONDITIONS_GREATER_THAN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".greaterThan");
var FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".greaterThanOrEqualTo");
var FILTERS_CONDITIONS_LESS_THAN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".lessThan");
var FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".lessThanOrEqualTo");
var FILTERS_CONDITIONS_BETWEEN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isBetween");
var FILTERS_CONDITIONS_NOT_BETWEEN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isNotBetween");
var FILTERS_CONDITIONS_AFTER = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".after");
var FILTERS_CONDITIONS_BEFORE = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".before");
var FILTERS_CONDITIONS_TODAY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".today");
var FILTERS_CONDITIONS_TOMORROW = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".tomorrow");
var FILTERS_CONDITIONS_YESTERDAY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".yesterday");
var FILTERS_DIVS_FILTER_BY_CONDITION = "".concat(FILTERS_NAMESPACE, "labels.filterByCondition");
var FILTERS_DIVS_FILTER_BY_VALUE = "".concat(FILTERS_NAMESPACE, "labels.filterByValue");
var FILTERS_LABELS_CONJUNCTION = "".concat(FILTERS_NAMESPACE, "labels.conjunction");
var FILTERS_LABELS_DISJUNCTION = "".concat(FILTERS_NAMESPACE, "labels.disjunction");
var FILTERS_VALUES_BLANK_CELLS = "".concat(FILTERS_NAMESPACE, "values.blankCells");
var FILTERS_BUTTONS_SELECT_ALL = "".concat(FILTERS_NAMESPACE, "buttons.selectAll");
var FILTERS_BUTTONS_CLEAR = "".concat(FILTERS_NAMESPACE, "buttons.clear");
var FILTERS_BUTTONS_OK = "".concat(FILTERS_NAMESPACE, "buttons.ok");
var FILTERS_BUTTONS_CANCEL = "".concat(FILTERS_NAMESPACE, "buttons.cancel");
var FILTERS_BUTTONS_PLACEHOLDER_SEARCH = "".concat(FILTERS_NAMESPACE, "buttons.placeholder.search");
var FILTERS_BUTTONS_PLACEHOLDER_VALUE = "".concat(FILTERS_NAMESPACE, "buttons.placeholder.value");
var FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE = "".concat(FILTERS_NAMESPACE, "buttons.placeholder.secondValue");

var dictionaryKeys = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CONTEXT_MENU_ITEMS_NAMESPACE: CONTEXT_MENU_ITEMS_NAMESPACE,
  CONTEXTMENU_ITEMS_NO_ITEMS: CONTEXTMENU_ITEMS_NO_ITEMS,
  CONTEXTMENU_ITEMS_ROW_ABOVE: CONTEXTMENU_ITEMS_ROW_ABOVE,
  CONTEXTMENU_ITEMS_ROW_BELOW: CONTEXTMENU_ITEMS_ROW_BELOW,
  CONTEXTMENU_ITEMS_INSERT_LEFT: CONTEXTMENU_ITEMS_INSERT_LEFT,
  CONTEXTMENU_ITEMS_INSERT_RIGHT: CONTEXTMENU_ITEMS_INSERT_RIGHT,
  CONTEXTMENU_ITEMS_REMOVE_ROW: CONTEXTMENU_ITEMS_REMOVE_ROW,
  CONTEXTMENU_ITEMS_REMOVE_COLUMN: CONTEXTMENU_ITEMS_REMOVE_COLUMN,
  CONTEXTMENU_ITEMS_UNDO: CONTEXTMENU_ITEMS_UNDO,
  CONTEXTMENU_ITEMS_REDO: CONTEXTMENU_ITEMS_REDO,
  CONTEXTMENU_ITEMS_READ_ONLY: CONTEXTMENU_ITEMS_READ_ONLY,
  CONTEXTMENU_ITEMS_CLEAR_COLUMN: CONTEXTMENU_ITEMS_CLEAR_COLUMN,
  CONTEXTMENU_ITEMS_COPY: CONTEXTMENU_ITEMS_COPY,
  CONTEXTMENU_ITEMS_CUT: CONTEXTMENU_ITEMS_CUT,
  CONTEXTMENU_ITEMS_FREEZE_COLUMN: CONTEXTMENU_ITEMS_FREEZE_COLUMN,
  CONTEXTMENU_ITEMS_UNFREEZE_COLUMN: CONTEXTMENU_ITEMS_UNFREEZE_COLUMN,
  CONTEXTMENU_ITEMS_MERGE_CELLS: CONTEXTMENU_ITEMS_MERGE_CELLS,
  CONTEXTMENU_ITEMS_UNMERGE_CELLS: CONTEXTMENU_ITEMS_UNMERGE_CELLS,
  CONTEXTMENU_ITEMS_ADD_COMMENT: CONTEXTMENU_ITEMS_ADD_COMMENT,
  CONTEXTMENU_ITEMS_EDIT_COMMENT: CONTEXTMENU_ITEMS_EDIT_COMMENT,
  CONTEXTMENU_ITEMS_REMOVE_COMMENT: CONTEXTMENU_ITEMS_REMOVE_COMMENT,
  CONTEXTMENU_ITEMS_READ_ONLY_COMMENT: CONTEXTMENU_ITEMS_READ_ONLY_COMMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT: CONTEXTMENU_ITEMS_ALIGNMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT_LEFT: CONTEXTMENU_ITEMS_ALIGNMENT_LEFT,
  CONTEXTMENU_ITEMS_ALIGNMENT_CENTER: CONTEXTMENU_ITEMS_ALIGNMENT_CENTER,
  CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT: CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT,
  CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY: CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY,
  CONTEXTMENU_ITEMS_ALIGNMENT_TOP: CONTEXTMENU_ITEMS_ALIGNMENT_TOP,
  CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE: CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE,
  CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM: CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM,
  CONTEXTMENU_ITEMS_BORDERS: CONTEXTMENU_ITEMS_BORDERS,
  CONTEXTMENU_ITEMS_BORDERS_TOP: CONTEXTMENU_ITEMS_BORDERS_TOP,
  CONTEXTMENU_ITEMS_BORDERS_RIGHT: CONTEXTMENU_ITEMS_BORDERS_RIGHT,
  CONTEXTMENU_ITEMS_BORDERS_BOTTOM: CONTEXTMENU_ITEMS_BORDERS_BOTTOM,
  CONTEXTMENU_ITEMS_BORDERS_LEFT: CONTEXTMENU_ITEMS_BORDERS_LEFT,
  CONTEXTMENU_ITEMS_REMOVE_BORDERS: CONTEXTMENU_ITEMS_REMOVE_BORDERS,
  CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD: CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD,
  CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD: CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD,
  CONTEXTMENU_ITEMS_HIDE_COLUMN: CONTEXTMENU_ITEMS_HIDE_COLUMN,
  CONTEXTMENU_ITEMS_SHOW_COLUMN: CONTEXTMENU_ITEMS_SHOW_COLUMN,
  CONTEXTMENU_ITEMS_HIDE_ROW: CONTEXTMENU_ITEMS_HIDE_ROW,
  CONTEXTMENU_ITEMS_SHOW_ROW: CONTEXTMENU_ITEMS_SHOW_ROW,
  FILTERS_NAMESPACE: FILTERS_NAMESPACE,
  FILTERS_CONDITIONS_NAMESPACE: FILTERS_CONDITIONS_NAMESPACE,
  FILTERS_CONDITIONS_NONE: FILTERS_CONDITIONS_NONE,
  FILTERS_CONDITIONS_EMPTY: FILTERS_CONDITIONS_EMPTY,
  FILTERS_CONDITIONS_NOT_EMPTY: FILTERS_CONDITIONS_NOT_EMPTY,
  FILTERS_CONDITIONS_EQUAL: FILTERS_CONDITIONS_EQUAL,
  FILTERS_CONDITIONS_NOT_EQUAL: FILTERS_CONDITIONS_NOT_EQUAL,
  FILTERS_CONDITIONS_BEGINS_WITH: FILTERS_CONDITIONS_BEGINS_WITH,
  FILTERS_CONDITIONS_ENDS_WITH: FILTERS_CONDITIONS_ENDS_WITH,
  FILTERS_CONDITIONS_CONTAINS: FILTERS_CONDITIONS_CONTAINS,
  FILTERS_CONDITIONS_NOT_CONTAIN: FILTERS_CONDITIONS_NOT_CONTAIN,
  FILTERS_CONDITIONS_BY_VALUE: FILTERS_CONDITIONS_BY_VALUE,
  FILTERS_CONDITIONS_GREATER_THAN: FILTERS_CONDITIONS_GREATER_THAN,
  FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL: FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_LESS_THAN: FILTERS_CONDITIONS_LESS_THAN,
  FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL: FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_BETWEEN: FILTERS_CONDITIONS_BETWEEN,
  FILTERS_CONDITIONS_NOT_BETWEEN: FILTERS_CONDITIONS_NOT_BETWEEN,
  FILTERS_CONDITIONS_AFTER: FILTERS_CONDITIONS_AFTER,
  FILTERS_CONDITIONS_BEFORE: FILTERS_CONDITIONS_BEFORE,
  FILTERS_CONDITIONS_TODAY: FILTERS_CONDITIONS_TODAY,
  FILTERS_CONDITIONS_TOMORROW: FILTERS_CONDITIONS_TOMORROW,
  FILTERS_CONDITIONS_YESTERDAY: FILTERS_CONDITIONS_YESTERDAY,
  FILTERS_DIVS_FILTER_BY_CONDITION: FILTERS_DIVS_FILTER_BY_CONDITION,
  FILTERS_DIVS_FILTER_BY_VALUE: FILTERS_DIVS_FILTER_BY_VALUE,
  FILTERS_LABELS_CONJUNCTION: FILTERS_LABELS_CONJUNCTION,
  FILTERS_LABELS_DISJUNCTION: FILTERS_LABELS_DISJUNCTION,
  FILTERS_VALUES_BLANK_CELLS: FILTERS_VALUES_BLANK_CELLS,
  FILTERS_BUTTONS_SELECT_ALL: FILTERS_BUTTONS_SELECT_ALL,
  FILTERS_BUTTONS_CLEAR: FILTERS_BUTTONS_CLEAR,
  FILTERS_BUTTONS_OK: FILTERS_BUTTONS_OK,
  FILTERS_BUTTONS_CANCEL: FILTERS_BUTTONS_CANCEL,
  FILTERS_BUTTONS_PLACEHOLDER_SEARCH: FILTERS_BUTTONS_PLACEHOLDER_SEARCH,
  FILTERS_BUTTONS_PLACEHOLDER_VALUE: FILTERS_BUTTONS_PLACEHOLDER_VALUE,
  FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE: FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE
});

var _dictionary;
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var dictionary = (_dictionary = {
  languageCode: "en-US"
}, _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_NO_ITEMS, "No available options"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ROW_ABOVE, "Insert row above"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ROW_BELOW, "Insert row below"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_INSERT_LEFT, "Insert column left"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_INSERT_RIGHT, "Insert column right"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_REMOVE_ROW, ["Remove row", "Remove rows"]), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_REMOVE_COLUMN, ["Remove column", "Remove columns"]), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_UNDO, "Undo"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_REDO, "Redo"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_READ_ONLY, "Read only"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_CLEAR_COLUMN, "Clear column"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT, "Alignment"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_LEFT, "Left"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_CENTER, "Center"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT, "Right"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY, "Justify"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_TOP, "Top"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE, "Middle"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM, "Bottom"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_FREEZE_COLUMN, "Freeze column"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_UNFREEZE_COLUMN, "Unfreeze column"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_BORDERS, "Borders"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_BORDERS_TOP, "Top"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_BORDERS_RIGHT, "Right"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_BORDERS_BOTTOM, "Bottom"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_BORDERS_LEFT, "Left"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_REMOVE_BORDERS, "Remove border(s)"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_ADD_COMMENT, "Add comment"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_EDIT_COMMENT, "Edit comment"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_REMOVE_COMMENT, "Delete comment"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_READ_ONLY_COMMENT, "Read-only comment"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_MERGE_CELLS, "Merge cells"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_UNMERGE_CELLS, "Unmerge cells"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_COPY, "Copy"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_CUT, "Cut"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD, "Insert child row"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD, "Detach from parent"), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_HIDE_COLUMN, ["Hide column", "Hide columns"]), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_SHOW_COLUMN, ["Show column", "Show columns"]), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_HIDE_ROW, ["Hide row", "Hide rows"]), _defineProperty$4(_dictionary, CONTEXTMENU_ITEMS_SHOW_ROW, ["Show row", "Show rows"]), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_NONE, "None"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_EMPTY, "Is empty"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_NOT_EMPTY, "Is not empty"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_EQUAL, "Is equal to"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_NOT_EQUAL, "Is not equal to"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_BEGINS_WITH, "Begins with"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_ENDS_WITH, "Ends with"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_CONTAINS, "Contains"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_NOT_CONTAIN, "Does not contain"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_GREATER_THAN, "Greater than"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL, "Greater than or equal to"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_LESS_THAN, "Less than"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL, "Less than or equal to"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_BETWEEN, "Is between"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_NOT_BETWEEN, "Is not between"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_AFTER, "After"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_BEFORE, "Before"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_TODAY, "Today"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_TOMORROW, "Tomorrow"), _defineProperty$4(_dictionary, FILTERS_CONDITIONS_YESTERDAY, "Yesterday"), _defineProperty$4(_dictionary, FILTERS_VALUES_BLANK_CELLS, "Blank cells"), _defineProperty$4(_dictionary, FILTERS_DIVS_FILTER_BY_CONDITION, "Filter by condition"), _defineProperty$4(_dictionary, FILTERS_DIVS_FILTER_BY_VALUE, "Filter by value"), _defineProperty$4(_dictionary, FILTERS_LABELS_CONJUNCTION, "And"), _defineProperty$4(_dictionary, FILTERS_LABELS_DISJUNCTION, "Or"), _defineProperty$4(_dictionary, FILTERS_BUTTONS_SELECT_ALL, "Select all"), _defineProperty$4(_dictionary, FILTERS_BUTTONS_CLEAR, "Clear"), _defineProperty$4(_dictionary, FILTERS_BUTTONS_OK, "OK"), _defineProperty$4(_dictionary, FILTERS_BUTTONS_CANCEL, "Cancel"), _defineProperty$4(_dictionary, FILTERS_BUTTONS_PLACEHOLDER_SEARCH, "Search"), _defineProperty$4(_dictionary, FILTERS_BUTTONS_PLACEHOLDER_VALUE, "Value"), _defineProperty$4(_dictionary, FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE, "Second value"), _dictionary);

var DEFAULT_LANGUAGE_CODE = dictionary.languageCode;
var _staticRegister$5 = staticRegister("languagesDictionaries"), registerGloballyLanguageDictionary = _staticRegister$5.register, getGlobalLanguageDictionary = _staticRegister$5.getItem, hasGlobalLanguageDictionary = _staticRegister$5.hasItem, getGlobalLanguagesDictionaries = _staticRegister$5.getValues;
registerLanguageDictionary(dictionary);
function registerLanguageDictionary(languageCodeOrDictionary, dictionary) {
  var languageCode = languageCodeOrDictionary;
  var dictionaryObject = dictionary;
  if (isObject(languageCodeOrDictionary)) {
    dictionaryObject = languageCodeOrDictionary;
    languageCode = dictionaryObject.languageCode;
  }
  extendLanguageDictionary(languageCode, dictionaryObject);
  registerGloballyLanguageDictionary(languageCode, deepClone(dictionaryObject));
  return deepClone(dictionaryObject);
}
function extendLanguageDictionary(languageCode, dictionary) {
  if (languageCode !== DEFAULT_LANGUAGE_CODE) {
    extendNotExistingKeys(dictionary, getGlobalLanguageDictionary(DEFAULT_LANGUAGE_CODE));
  }
}
function getLanguageDictionary(languageCode) {
  if (!hasLanguageDictionary(languageCode)) {
    return null;
  }
  return deepClone(getGlobalLanguageDictionary(languageCode));
}
function hasLanguageDictionary(languageCode) {
  return hasGlobalLanguageDictionary(languageCode);
}
function getLanguagesDictionaries() {
  return getGlobalLanguagesDictionaries();
}
function getTranslatedPhrase(languageCode, dictionaryKey, argumentsForFormatters) {
  var languageDictionary = getLanguageDictionary(languageCode);
  if (languageDictionary === null) {
    return null;
  }
  var phrasePropositions = languageDictionary[dictionaryKey];
  if (isUndefined$1(phrasePropositions)) {
    return null;
  }
  var formattedPhrase = getFormattedPhrase(phrasePropositions, argumentsForFormatters);
  if (Array.isArray(formattedPhrase)) {
    return formattedPhrase[0];
  }
  return formattedPhrase;
}
function getFormattedPhrase(phrasePropositions, argumentsForFormatters) {
  var formattedPhrasePropositions = phrasePropositions;
  arrayEach(getAll(), function(formatter) {
    formattedPhrasePropositions = formatter(phrasePropositions, argumentsForFormatters);
  });
  return formattedPhrasePropositions;
}
function getValidLanguageCode(languageCode) {
  var normalizedLanguageCode = normalizeLanguageCode(languageCode);
  if (!hasLanguageDictionary(normalizedLanguageCode)) {
    normalizedLanguageCode = DEFAULT_LANGUAGE_CODE;
    warnUserAboutLanguageRegistration(languageCode);
  }
  return normalizedLanguageCode;
}

var eventManager = new EventManager();
var pressedKeys = new Set();
var refCount = 0;
function startObserving(rootDocument) {
  if (refCount === 0) {
    eventManager.addEventListener(rootDocument, "keydown", function(event) {
      if (!pressedKeys.has(event.keyCode)) {
        pressedKeys.add(event.keyCode);
      }
    });
    eventManager.addEventListener(rootDocument, "keyup", function(event) {
      if (pressedKeys.has(event.keyCode)) {
        pressedKeys.delete(event.keyCode);
      }
    });
    eventManager.addEventListener(rootDocument, "visibilitychange", function() {
      if (rootDocument.hidden) {
        pressedKeys.clear();
      }
    });
    eventManager.addEventListener(rootDocument.defaultView, "blur", function() {
      pressedKeys.clear();
    });
  }
  refCount += 1;
}
function stopObserving() {
  if (refCount > 0) {
    refCount -= 1;
  }
  if (refCount === 0) {
    _resetState();
  }
}
function _resetState() {
  eventManager.clearEvents();
  pressedKeys.clear();
  refCount = 0;
}
function isPressedCtrlKey() {
  var values = Array.from(pressedKeys.values());
  return values.some(function(_keyCode) {
    return isCtrlMetaKey(_keyCode);
  });
}

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
_export({ target: 'Object', stat: true, sham: !descriptors }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var keys = ownKeys$g(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});

var ACTIVE_HEADER_TYPE = "active-header";
var AREA_TYPE = "area";
var CELL_TYPE = "cell";
var FILL_TYPE = "fill";
var HEADER_TYPE = "header";
var CUSTOM_SELECTION_TYPE = "custom-selection";

function _typeof$w(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$w = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$w = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$w(obj);
}
function _slicedToArray$9(arr, i) {
  return _arrayWithHoles$9(arr) || _iterableToArrayLimit$9(arr, i) || _unsupportedIterableToArray$h(arr, i) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$h(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$h(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$h(o, minLen);
}
function _arrayLikeToArray$h(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$9(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$9(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$X(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$S(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$S(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$S(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$S(Constructor, staticProps);
  return Constructor;
}
function _get$3(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$3 = Reflect.get;
  } else {
    _get$3 = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$3(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$3(target, property, receiver || target);
}
function _superPropBase$3(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$o(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$o(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$p(subClass, superClass);
}
function _setPrototypeOf$p(o, p) {
  _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$p(o, p);
}
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$o(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$o(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$o(this, result);
  };
}
function _possibleConstructorReturn$o(self, call) {
  if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$o(self);
}
function _assertThisInitialized$o(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$o(o) {
  _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$o(o);
}
var VisualSelection = /* @__PURE__ */ function(_Selection) {
  _inherits$o(VisualSelection2, _Selection);
  var _super = _createSuper$o(VisualSelection2);
  function VisualSelection2(settings, visualCellRange) {
    var _this;
    _classCallCheck$X(this, VisualSelection2);
    _this = _super.call(this, settings, null);
    _this.visualCellRange = visualCellRange || null;
    _this.commit();
    return _this;
  }
  _createClass$S(VisualSelection2, [{
    key: "add",
    value: function add(coords) {
      if (this.visualCellRange === null) {
        this.visualCellRange = new CellRange(coords);
      } else {
        this.visualCellRange.expand(coords);
      }
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.visualCellRange = null;
      return _get$3(_getPrototypeOf$o(VisualSelection2.prototype), "clear", this).call(this);
    }
  }, {
    key: "findVisibleCoordsInRange",
    value: function findVisibleCoordsInRange(startCoords, endCoords, incrementByRow) {
      var incrementByColumn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : incrementByRow;
      var nextVisibleRow = this.findVisibleCoordsInRowsRange(startCoords.row, endCoords.row, incrementByRow);
      if (nextVisibleRow === null) {
        return null;
      }
      var nextVisibleColumn = this.findVisibleCoordsInColumnsRange(startCoords.col, endCoords.col, incrementByColumn);
      if (nextVisibleColumn === null) {
        return null;
      }
      return new CellCoords(nextVisibleRow, nextVisibleColumn);
    }
  }, {
    key: "findVisibleCoordsInRowsRange",
    value: function findVisibleCoordsInRowsRange(startVisibleRow, endVisibleRow, incrementBy) {
      var _this$settings$visual = this.settings.visualToRenderableCoords({
        row: startVisibleRow,
        col: -1
      }), startRowRenderable = _this$settings$visual.row;
      if (endVisibleRow === startVisibleRow && startRowRenderable === null) {
        return null;
      }
      if (startRowRenderable === null) {
        return this.findVisibleCoordsInRowsRange(startVisibleRow + incrementBy, endVisibleRow, incrementBy);
      }
      return startVisibleRow;
    }
  }, {
    key: "findVisibleCoordsInColumnsRange",
    value: function findVisibleCoordsInColumnsRange(startVisibleColumn, endVisibleColumn, incrementBy) {
      var _this$settings$visual2 = this.settings.visualToRenderableCoords({
        row: -1,
        col: startVisibleColumn
      }), startColumnRenderable = _this$settings$visual2.col;
      if (endVisibleColumn === startVisibleColumn && startColumnRenderable === null) {
        return null;
      }
      if (startColumnRenderable === null) {
        return this.findVisibleCoordsInColumnsRange(startVisibleColumn + incrementBy, endVisibleColumn, incrementBy);
      }
      return startVisibleColumn;
    }
  }, {
    key: "findVisibleHeaderRange",
    value: function findVisibleHeaderRange(visualFromCoords, visualToCoords, incrementByRow, incrementByColumn) {
      var fromRangeVisualRow = this.findVisibleCoordsInRowsRange(visualFromCoords.row, visualToCoords.row, incrementByRow);
      var toRangeVisualRow = this.findVisibleCoordsInRowsRange(visualToCoords.row, visualFromCoords.row, -incrementByRow);
      var fromRangeVisualColumn = this.findVisibleCoordsInColumnsRange(visualFromCoords.col, visualToCoords.col, incrementByColumn);
      var toRangeVisualColumn = this.findVisibleCoordsInColumnsRange(visualToCoords.col, visualFromCoords.col, -incrementByColumn);
      if (fromRangeVisualRow === null && toRangeVisualRow === null && fromRangeVisualColumn === null && toRangeVisualColumn === null) {
        return null;
      }
      return [new CellCoords(fromRangeVisualRow, fromRangeVisualColumn), new CellCoords(toRangeVisualRow, toRangeVisualColumn)];
    }
  }, {
    key: "commit",
    value: function commit() {
      if (this.visualCellRange === null) {
        return this;
      }
      var _this$visualCellRange = this.visualCellRange, visualFromCoords = _this$visualCellRange.from, visualToCoords = _this$visualCellRange.to;
      var incrementByRow = this.getRowSearchDirection(this.visualCellRange);
      var incrementByColumn = this.getColumnSearchDirection(this.visualCellRange);
      var fromRangeVisual = this.findVisibleCoordsInRange(visualFromCoords, visualToCoords, incrementByRow, incrementByColumn);
      var toRangeVisual = this.findVisibleCoordsInRange(visualToCoords, visualFromCoords, -incrementByRow, -incrementByColumn);
      if (fromRangeVisual === null || toRangeVisual === null) {
        var isHeaderSelectionType = this.settings.type === "header";
        var cellRange = null;
        if (isHeaderSelectionType) {
          var _this$findVisibleHead = this.findVisibleHeaderRange(visualFromCoords, visualToCoords, incrementByRow, incrementByColumn), _this$findVisibleHead2 = _slicedToArray$9(_this$findVisibleHead, 2), fromRangeVisualHeader = _this$findVisibleHead2[0], toRangeVisualHeader = _this$findVisibleHead2[1];
          cellRange = this.createRenderableCellRange(fromRangeVisualHeader, toRangeVisualHeader);
        }
        this.cellRange = cellRange;
      } else {
        this.cellRange = this.createRenderableCellRange(fromRangeVisual, toRangeVisual);
      }
      return this;
    }
  }, {
    key: "adjustCoordinates",
    value: function adjustCoordinates(broaderCellRange) {
      var incrementByRow = this.getRowSearchDirection(broaderCellRange);
      var incrementByColumn = this.getColumnSearchDirection(broaderCellRange);
      var normFromCoords = broaderCellRange.from.clone().normalize();
      var normToCoords = broaderCellRange.to.clone().normalize();
      var singleCellRangeVisual = this.findVisibleCoordsInRange(normFromCoords, normToCoords, incrementByRow, incrementByColumn);
      if (singleCellRangeVisual !== null) {
        if (this.cellRange === null) {
          var singleCellRangeRenderable = this.settings.visualToRenderableCoords(singleCellRangeVisual);
          this.cellRange = new CellRange(singleCellRangeRenderable);
        }
        broaderCellRange.setHighlight(singleCellRangeVisual);
        return this;
      }
      broaderCellRange.setHighlight(broaderCellRange.from);
      return this;
    }
  }, {
    key: "getCorners",
    value: function getCorners() {
      var _this$cellRange = this.cellRange, from = _this$cellRange.from, to = _this$cellRange.to;
      var isRowUndefined = from.row === null || to.row === null;
      var isColumnUndefined = from.col === null || to.col === null;
      var topLeftCorner = new CellCoords(isRowUndefined ? null : Math.min(from.row, to.row), isColumnUndefined ? null : Math.min(from.col, to.col));
      var bottomRightCorner = new CellCoords(isRowUndefined ? null : Math.max(from.row, to.row), isColumnUndefined ? null : Math.max(from.col, to.col));
      return [topLeftCorner.row, topLeftCorner.col, bottomRightCorner.row, bottomRightCorner.col];
    }
  }, {
    key: "getVisualCorners",
    value: function getVisualCorners() {
      var topLeft = this.settings.renderableToVisualCoords(this.cellRange.getTopLeftCorner());
      var bottomRight = this.settings.renderableToVisualCoords(this.cellRange.getBottomRightCorner());
      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];
    }
  }, {
    key: "createRenderableCellRange",
    value: function createRenderableCellRange(visualFromCoords, visualToCoords) {
      var renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);
      var renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);
      return new CellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);
    }
  }, {
    key: "getRowSearchDirection",
    value: function getRowSearchDirection(cellRange) {
      if (cellRange.from.row < cellRange.to.row) {
        return 1;
      }
      return -1;
    }
  }, {
    key: "getColumnSearchDirection",
    value: function getColumnSearchDirection(cellRange) {
      if (cellRange.from.col < cellRange.to.col) {
        return 1;
      }
      return -1;
    }
  }]);
  return VisualSelection2;
}(Selection);

var _excluded = ["activeHeaderClassName"];
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty$5(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight(_ref) {
  var activeHeaderClassName = _ref.activeHeaderClassName, restOptions = _objectWithoutProperties(_ref, _excluded);
  var s = new VisualSelection(_objectSpread(_objectSpread({
    highlightHeaderClassName: activeHeaderClassName
  }, restOptions), {}, {
    selectionType: ACTIVE_HEADER_TYPE
  }));
  return s;
}

var _excluded$1 = ["layerLevel", "areaCornerVisible"];
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$6(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight$1(_ref) {
  var layerLevel = _ref.layerLevel, areaCornerVisible = _ref.areaCornerVisible, restOptions = _objectWithoutProperties$1(_ref, _excluded$1);
  var s = new VisualSelection(_objectSpread$1(_objectSpread$1({
    className: "area",
    markIntersections: true,
    layerLevel: Math.min(layerLevel, 7),
    border: {
      width: 1,
      color: "#4b89ff",
      cornerVisible: areaCornerVisible
    }
  }, restOptions), {}, {
    selectionType: AREA_TYPE
  }));
  return s;
}

var _excluded$2 = ["cellCornerVisible"];
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty$7(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight$2(_ref) {
  var cellCornerVisible = _ref.cellCornerVisible, restOptions = _objectWithoutProperties$2(_ref, _excluded$2);
  var s = new VisualSelection(_objectSpread$2(_objectSpread$2({
    className: "current",
    border: {
      width: 2,
      color: "#4b89ff",
      cornerVisible: cellCornerVisible
    }
  }, restOptions), {}, {
    selectionType: CELL_TYPE
  }));
  return s;
}

var _excluded$3 = ["border", "visualCellRange"];
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty$8(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight$3(_ref) {
  var border = _ref.border, visualCellRange = _ref.visualCellRange, restOptions = _objectWithoutProperties$3(_ref, _excluded$3);
  var s = new VisualSelection(_objectSpread$3(_objectSpread$3(_objectSpread$3({}, border), restOptions), {}, {
    selectionType: CUSTOM_SELECTION_TYPE
  }), visualCellRange);
  return s;
}

function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty$9(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function createHighlight$4(_ref) {
  var restOptions = Object.assign({}, _ref);
  var s = new VisualSelection(_objectSpread$4(_objectSpread$4({
    className: "fill",
    border: {
      width: 1,
      color: "#ff0000"
    }
  }, restOptions), {}, {
    selectionType: FILL_TYPE
  }));
  return s;
}

var _excluded$4 = ["headerClassName", "rowClassName", "columnClassName"];
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty$a(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createHighlight$5(_ref) {
  var headerClassName = _ref.headerClassName, rowClassName = _ref.rowClassName, columnClassName = _ref.columnClassName, restOptions = _objectWithoutProperties$4(_ref, _excluded$4);
  var s = new VisualSelection(_objectSpread$5(_objectSpread$5({
    className: "highlight",
    highlightHeaderClassName: headerClassName,
    highlightRowClassName: rowClassName,
    highlightColumnClassName: columnClassName
  }, restOptions), {}, {
    highlightOnlyClosestHeader: true,
    selectionType: HEADER_TYPE
  }));
  return s;
}

function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty$b(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var _staticRegister$6 = staticRegister("highlight/types"), register$5 = _staticRegister$6.register, getItem$4 = _staticRegister$6.getItem;
register$5(ACTIVE_HEADER_TYPE, createHighlight);
register$5(AREA_TYPE, createHighlight$1);
register$5(CELL_TYPE, createHighlight$2);
register$5(CUSTOM_SELECTION_TYPE, createHighlight$3);
register$5(FILL_TYPE, createHighlight$4);
register$5(HEADER_TYPE, createHighlight$5);
function createHighlight$6(highlightType, options) {
  return getItem$4(highlightType)(_objectSpread$6({
    type: highlightType
  }, options));
}

function _toConsumableArray$f(arr) {
  return _arrayWithoutHoles$d(arr) || _iterableToArray$d(arr) || _unsupportedIterableToArray$i(arr) || _nonIterableSpread$d();
}
function _nonIterableSpread$d() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$i(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$i(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$i(o, minLen);
}
function _iterableToArray$d(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$d(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$i(arr);
}
function _arrayLikeToArray$i(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty$c(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$Y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$T(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$T(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$T(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$T(Constructor, staticProps);
  return Constructor;
}
var Highlight = /* @__PURE__ */ function() {
  function Highlight2(options) {
    _classCallCheck$Y(this, Highlight2);
    this.options = options;
    this.layerLevel = 0;
    this.cell = createHighlight$6(CELL_TYPE, options);
    this.fill = createHighlight$6(FILL_TYPE, options);
    this.areas = new Map();
    this.headers = new Map();
    this.activeHeaders = new Map();
    this.customSelections = [];
  }
  _createClass$T(Highlight2, [{
    key: "isEnabledFor",
    value: function isEnabledFor(highlightType, coords) {
      var type = highlightType;
      if (highlightType === CELL_TYPE) {
        type = "current";
      }
      var disableHighlight = this.options.disabledCellSelection(coords.row, coords.col);
      if (typeof disableHighlight === "string") {
        disableHighlight = [disableHighlight];
      }
      return disableHighlight === false || Array.isArray(disableHighlight) && !disableHighlight.includes(type);
    }
  }, {
    key: "useLayerLevel",
    value: function useLayerLevel() {
      var level = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this.layerLevel = level;
      return this;
    }
  }, {
    key: "getCell",
    value: function getCell() {
      return this.cell;
    }
  }, {
    key: "getFill",
    value: function getFill() {
      return this.fill;
    }
  }, {
    key: "createOrGetArea",
    value: function createOrGetArea() {
      var layerLevel = this.layerLevel;
      var area;
      if (this.areas.has(layerLevel)) {
        area = this.areas.get(layerLevel);
      } else {
        area = createHighlight$6(AREA_TYPE, _objectSpread$7({
          layerLevel
        }, this.options));
        this.areas.set(layerLevel, area);
      }
      return area;
    }
  }, {
    key: "getAreas",
    value: function getAreas() {
      return _toConsumableArray$f(this.areas.values());
    }
  }, {
    key: "createOrGetHeader",
    value: function createOrGetHeader() {
      var layerLevel = this.layerLevel;
      var header;
      if (this.headers.has(layerLevel)) {
        header = this.headers.get(layerLevel);
      } else {
        header = createHighlight$6(HEADER_TYPE, _objectSpread$7({}, this.options));
        this.headers.set(layerLevel, header);
      }
      return header;
    }
  }, {
    key: "getHeaders",
    value: function getHeaders() {
      return _toConsumableArray$f(this.headers.values());
    }
  }, {
    key: "createOrGetActiveHeader",
    value: function createOrGetActiveHeader() {
      var layerLevel = this.layerLevel;
      var header;
      if (this.activeHeaders.has(layerLevel)) {
        header = this.activeHeaders.get(layerLevel);
      } else {
        header = createHighlight$6(ACTIVE_HEADER_TYPE, _objectSpread$7({}, this.options));
        this.activeHeaders.set(layerLevel, header);
      }
      return header;
    }
  }, {
    key: "getActiveHeaders",
    value: function getActiveHeaders() {
      return _toConsumableArray$f(this.activeHeaders.values());
    }
  }, {
    key: "getCustomSelections",
    value: function getCustomSelections() {
      return _toConsumableArray$f(this.customSelections.values());
    }
  }, {
    key: "addCustomSelection",
    value: function addCustomSelection(selectionInstance) {
      this.customSelections.push(createHighlight$6(CUSTOM_SELECTION_TYPE, _objectSpread$7(_objectSpread$7({}, this.options), selectionInstance)));
    }
  }, {
    key: "clear",
    value: function clear() {
      this.cell.clear();
      this.fill.clear();
      arrayEach(this.areas.values(), function(highlight) {
        return void highlight.clear();
      });
      arrayEach(this.headers.values(), function(highlight) {
        return void highlight.clear();
      });
      arrayEach(this.activeHeaders.values(), function(highlight) {
        return void highlight.clear();
      });
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return [this.cell, this.fill].concat(_toConsumableArray$f(this.areas.values()), _toConsumableArray$f(this.headers.values()), _toConsumableArray$f(this.activeHeaders.values()), _toConsumableArray$f(this.customSelections))[Symbol.iterator]();
    }
  }]);
  return Highlight2;
}();

function _classCallCheck$Z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$U(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$U(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$U(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$U(Constructor, staticProps);
  return Constructor;
}
var SelectionRange = /* @__PURE__ */ function() {
  function SelectionRange2() {
    _classCallCheck$Z(this, SelectionRange2);
    this.ranges = [];
  }
  _createClass$U(SelectionRange2, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.size() === 0;
    }
  }, {
    key: "set",
    value: function set(coords) {
      this.clear();
      this.ranges.push(new CellRange(coords));
      return this;
    }
  }, {
    key: "add",
    value: function add(coords) {
      this.ranges.push(new CellRange(coords));
      return this;
    }
  }, {
    key: "pop",
    value: function pop() {
      this.ranges.pop();
      return this;
    }
  }, {
    key: "current",
    value: function current() {
      return this.peekByIndex(0);
    }
  }, {
    key: "previous",
    value: function previous() {
      return this.peekByIndex(-1);
    }
  }, {
    key: "includes",
    value: function includes(coords) {
      return this.ranges.some(function(cellRange) {
        return cellRange.includes(coords);
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.ranges.length = 0;
      return this;
    }
  }, {
    key: "size",
    value: function size() {
      return this.ranges.length;
    }
  }, {
    key: "peekByIndex",
    value: function peekByIndex() {
      var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var rangeIndex = this.size() + offset - 1;
      var cellRange;
      if (rangeIndex >= 0) {
        cellRange = this.ranges[rangeIndex];
      }
      return cellRange;
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this.ranges[Symbol.iterator]();
    }
  }]);
  return SelectionRange2;
}();

function _classCallCheck$_(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$V(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$V(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$V(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$V(Constructor, staticProps);
  return Constructor;
}
var Transformation = /* @__PURE__ */ function() {
  function Transformation2(range, options) {
    _classCallCheck$_(this, Transformation2);
    this.range = range;
    this.options = options;
  }
  _createClass$V(Transformation2, [{
    key: "transformStart",
    value: function transformStart(rowDelta, colDelta, force) {
      var delta = new CellCoords(rowDelta, colDelta);
      var highlightCoords = this.range.current().highlight;
      var _this$options$visualT = this.options.visualToRenderableCoords(highlightCoords), renderableRow = _this$options$visualT.row, renderableColumn = _this$options$visualT.col;
      var visualCoords = highlightCoords;
      var rowTransformDir = 0;
      var colTransformDir = 0;
      this.runLocalHooks("beforeTransformStart", delta);
      if (renderableRow !== null && renderableColumn !== null) {
        var totalRows = this.options.countRows();
        var totalCols = this.options.countCols();
        var fixedRowsBottom = this.options.fixedRowsBottom();
        var minSpareRows = this.options.minSpareRows();
        var minSpareCols = this.options.minSpareCols();
        var autoWrapRow = this.options.autoWrapRow();
        var autoWrapCol = this.options.autoWrapCol();
        if (renderableRow + rowDelta > totalRows - 1) {
          if (force && minSpareRows > 0 && !(fixedRowsBottom && renderableRow >= totalRows - fixedRowsBottom - 1)) {
            this.runLocalHooks("insertRowRequire", totalRows);
            totalRows = this.options.countRows();
          } else if (autoWrapCol) {
            delta.row = 1 - totalRows;
            delta.col = renderableColumn + delta.col === totalCols - 1 ? 1 - totalCols : 1;
          }
        } else if (autoWrapCol && renderableRow + delta.row < 0 && renderableColumn + delta.col >= 0) {
          delta.row = totalRows - 1;
          delta.col = renderableColumn + delta.col === 0 ? totalCols - 1 : -1;
        }
        if (renderableColumn + delta.col > totalCols - 1) {
          if (force && minSpareCols > 0) {
            this.runLocalHooks("insertColRequire", totalCols);
            totalCols = this.options.countCols();
          } else if (autoWrapRow) {
            delta.row = renderableRow + delta.row === totalRows - 1 ? 1 - totalRows : 1;
            delta.col = 1 - totalCols;
          }
        } else if (autoWrapRow && renderableColumn + delta.col < 0 && renderableRow + delta.row >= 0) {
          delta.row = renderableRow + delta.row === 0 ? totalRows - 1 : -1;
          delta.col = totalCols - 1;
        }
        var coords = new CellCoords(renderableRow + delta.row, renderableColumn + delta.col);
        rowTransformDir = 0;
        colTransformDir = 0;
        if (coords.row < 0) {
          rowTransformDir = -1;
          coords.row = 0;
        } else if (coords.row > 0 && coords.row >= totalRows) {
          rowTransformDir = 1;
          coords.row = totalRows - 1;
        }
        if (coords.col < 0) {
          colTransformDir = -1;
          coords.col = 0;
        } else if (coords.col > 0 && coords.col >= totalCols) {
          colTransformDir = 1;
          coords.col = totalCols - 1;
        }
        visualCoords = this.options.renderableToVisualCoords(coords);
      }
      this.runLocalHooks("afterTransformStart", visualCoords, rowTransformDir, colTransformDir);
      return visualCoords;
    }
  }, {
    key: "transformEnd",
    value: function transformEnd(rowDelta, colDelta) {
      var delta = new CellCoords(rowDelta, colDelta);
      var cellRange = this.range.current();
      var visualCoords = cellRange.to;
      var rowTransformDir = 0;
      var colTransformDir = 0;
      this.runLocalHooks("beforeTransformEnd", delta);
      var _this$options$visualT2 = this.options.visualToRenderableCoords(cellRange.highlight), rowHighlight = _this$options$visualT2.row, colHighlight = _this$options$visualT2.col;
      if (rowHighlight !== null && colHighlight !== null) {
        var totalRows = this.options.countRows();
        var totalCols = this.options.countCols();
        var _this$options$visualT3 = this.options.visualToRenderableCoords(cellRange.to), rowTo = _this$options$visualT3.row, colTo = _this$options$visualT3.col;
        var coords = new CellCoords(rowTo + delta.row, colTo + delta.col);
        rowTransformDir = 0;
        colTransformDir = 0;
        if (coords.row < 0) {
          rowTransformDir = -1;
          coords.row = 0;
        } else if (coords.row > 0 && coords.row >= totalRows) {
          rowTransformDir = 1;
          coords.row = totalRows - 1;
        }
        if (coords.col < 0) {
          colTransformDir = -1;
          coords.col = 0;
        } else if (coords.col > 0 && coords.col >= totalCols) {
          colTransformDir = 1;
          coords.col = totalCols - 1;
        }
        visualCoords = this.options.renderableToVisualCoords(coords);
      }
      this.runLocalHooks("afterTransformEnd", visualCoords, rowTransformDir, colTransformDir);
      return visualCoords;
    }
  }]);
  return Transformation2;
}();
mixin(Transformation, localHooks);

function _slicedToArray$a(arr, i) {
  return _arrayWithHoles$a(arr) || _iterableToArrayLimit$a(arr, i) || _unsupportedIterableToArray$j(arr, i) || _nonIterableRest$a();
}
function _nonIterableRest$a() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$j(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$j(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$j(o, minLen);
}
function _arrayLikeToArray$j(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$a(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$a(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof$x(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$x = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$x = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$x(obj);
}
var SELECTION_TYPE_UNRECOGNIZED = 0;
var SELECTION_TYPE_EMPTY = 1;
var SELECTION_TYPE_ARRAY = 2;
var SELECTION_TYPE_OBJECT = 3;
var SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];
var ARRAY_TYPE_PATTERN = [["number"], ["number", "string"], ["number", "undefined"], ["number", "string", "undefined"]];
var rootCall = Symbol("root");
var childCall = Symbol("child");
function detectSelectionType(selectionRanges) {
  var _callSymbol = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rootCall;
  if (_callSymbol !== rootCall && _callSymbol !== childCall) {
    throw new Error("The second argument is used internally only and cannot be overwritten.");
  }
  var isArray = Array.isArray(selectionRanges);
  var isRootCall = _callSymbol === rootCall;
  var result = SELECTION_TYPE_UNRECOGNIZED;
  if (isArray) {
    var firstItem = selectionRanges[0];
    if (selectionRanges.length === 0) {
      result = SELECTION_TYPE_EMPTY;
    } else if (isRootCall && firstItem instanceof CellRange) {
      result = SELECTION_TYPE_OBJECT;
    } else if (isRootCall && Array.isArray(firstItem)) {
      result = detectSelectionType(firstItem, childCall);
    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {
      var isArrayType = !selectionRanges.some(function(value, index) {
        return !ARRAY_TYPE_PATTERN[index].includes(_typeof$x(value));
      });
      if (isArrayType) {
        result = SELECTION_TYPE_ARRAY;
      }
    }
  }
  return result;
}
function normalizeSelectionFactory(type) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$keepDirection = _ref.keepDirection, keepDirection = _ref$keepDirection === void 0 ? false : _ref$keepDirection, propToCol = _ref.propToCol;
  if (!SELECTION_TYPES.includes(type)) {
    throw new Error("Unsupported selection ranges schema type was provided.");
  }
  return function(selection) {
    var isObjectType = type === SELECTION_TYPE_OBJECT;
    var rowStart = isObjectType ? selection.from.row : selection[0];
    var columnStart = isObjectType ? selection.from.col : selection[1];
    var rowEnd = isObjectType ? selection.to.row : selection[2];
    var columnEnd = isObjectType ? selection.to.col : selection[3];
    if (typeof propToCol === "function") {
      if (typeof columnStart === "string") {
        columnStart = propToCol(columnStart);
      }
      if (typeof columnEnd === "string") {
        columnEnd = propToCol(columnEnd);
      }
    }
    if (isUndefined$1(rowEnd)) {
      rowEnd = rowStart;
    }
    if (isUndefined$1(columnEnd)) {
      columnEnd = columnStart;
    }
    if (!keepDirection) {
      var origRowStart = rowStart;
      var origColumnStart = columnStart;
      var origRowEnd = rowEnd;
      var origColumnEnd = columnEnd;
      rowStart = Math.min(origRowStart, origRowEnd);
      columnStart = Math.min(origColumnStart, origColumnEnd);
      rowEnd = Math.max(origRowStart, origRowEnd);
      columnEnd = Math.max(origColumnStart, origColumnEnd);
    }
    return [rowStart, columnStart, rowEnd, columnEnd];
  };
}
function transformSelectionToColumnDistance(selectionRanges) {
  var selectionType = detectSelectionType(selectionRanges);
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
  var unorderedIndexes = new Set();
  arrayEach(selectionRanges, function(selection) {
    var _selectionSchemaNorma = selectionSchemaNormalizer(selection), _selectionSchemaNorma2 = _slicedToArray$a(_selectionSchemaNorma, 4), columnStart = _selectionSchemaNorma2[1], columnEnd = _selectionSchemaNorma2[3];
    var columnNonHeaderStart = Math.max(columnStart, 0);
    var amount = columnEnd - columnNonHeaderStart + 1;
    arrayEach(Array.from(new Array(amount), function(_, i) {
      return columnNonHeaderStart + i;
    }), function(index) {
      if (!unorderedIndexes.has(index)) {
        unorderedIndexes.add(index);
      }
    });
  });
  var orderedIndexes = Array.from(unorderedIndexes).sort(function(a, b) {
    return a - b;
  });
  var normalizedColumnRanges = arrayReduce(orderedIndexes, function(acc, visualColumnIndex, index, array) {
    if (index !== 0 && visualColumnIndex === array[index - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([visualColumnIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedColumnRanges;
}
function transformSelectionToRowDistance(selectionRanges) {
  var selectionType = detectSelectionType(selectionRanges);
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
  var unorderedIndexes = new Set();
  arrayEach(selectionRanges, function(selection) {
    var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection), _selectionSchemaNorma4 = _slicedToArray$a(_selectionSchemaNorma3, 3), rowStart = _selectionSchemaNorma4[0], rowEnd = _selectionSchemaNorma4[2];
    var rowNonHeaderStart = Math.max(rowStart, 0);
    var amount = rowEnd - rowNonHeaderStart + 1;
    arrayEach(Array.from(new Array(amount), function(_, i) {
      return rowNonHeaderStart + i;
    }), function(index) {
      if (!unorderedIndexes.has(index)) {
        unorderedIndexes.add(index);
      }
    });
  });
  var orderedIndexes = Array.from(unorderedIndexes).sort(function(a, b) {
    return a - b;
  });
  var normalizedRowRanges = arrayReduce(orderedIndexes, function(acc, rowIndex, index, array) {
    if (index !== 0 && rowIndex === array[index - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([rowIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedRowRanges;
}
function isValidCoord(coord) {
  var maxTableItemsCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
  return typeof coord === "number" && coord >= 0 && coord < maxTableItemsCount;
}

var _templateObject$4;
function _slicedToArray$b(arr, i) {
  return _arrayWithHoles$b(arr) || _iterableToArrayLimit$b(arr, i) || _unsupportedIterableToArray$k(arr, i) || _nonIterableRest$b();
}
function _nonIterableRest$b() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$k(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$k(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$k(o, minLen);
}
function _arrayLikeToArray$k(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$b(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$b(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _taggedTemplateLiteral$4(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _classCallCheck$$(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$W(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$W(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$W(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$W(Constructor, staticProps);
  return Constructor;
}
var Selection$1 = /* @__PURE__ */ function() {
  function Selection2(settings, tableProps) {
    var _this = this;
    _classCallCheck$$(this, Selection2);
    this.settings = settings;
    this.tableProps = tableProps;
    this.inProgress = false;
    this.selectedByCorner = false;
    this.selectedByRowHeader = new Set();
    this.selectedByColumnHeader = new Set();
    this.selectedRange = new SelectionRange();
    this.highlight = new Highlight({
      headerClassName: settings.currentHeaderClassName,
      activeHeaderClassName: settings.activeHeaderClassName,
      rowClassName: settings.currentRowClassName,
      columnClassName: settings.currentColClassName,
      disabledCellSelection: function disabledCellSelection(row, column) {
        return _this.tableProps.isDisabledCellSelection(row, column);
      },
      cellCornerVisible: function cellCornerVisible() {
        return _this.isCellCornerVisible.apply(_this, arguments);
      },
      areaCornerVisible: function areaCornerVisible() {
        return _this.isAreaCornerVisible.apply(_this, arguments);
      },
      visualToRenderableCoords: function visualToRenderableCoords(coords) {
        return _this.tableProps.visualToRenderableCoords(coords);
      },
      renderableToVisualCoords: function renderableToVisualCoords(coords) {
        return _this.tableProps.renderableToVisualCoords(coords);
      }
    });
    this.transformation = new Transformation(this.selectedRange, {
      countRows: function countRows() {
        return _this.tableProps.countRowsTranslated();
      },
      countCols: function countCols() {
        return _this.tableProps.countColsTranslated();
      },
      visualToRenderableCoords: function visualToRenderableCoords(coords) {
        return _this.tableProps.visualToRenderableCoords(coords);
      },
      renderableToVisualCoords: function renderableToVisualCoords(coords) {
        return _this.tableProps.renderableToVisualCoords(coords);
      },
      fixedRowsBottom: function fixedRowsBottom() {
        return settings.fixedRowsBottom;
      },
      minSpareRows: function minSpareRows() {
        return settings.minSpareRows;
      },
      minSpareCols: function minSpareCols() {
        return settings.minSpareCols;
      },
      autoWrapRow: function autoWrapRow() {
        return settings.autoWrapRow;
      },
      autoWrapCol: function autoWrapCol() {
        return settings.autoWrapCol;
      }
    });
    this.transformation.addLocalHook("beforeTransformStart", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _this.runLocalHooks.apply(_this, ["beforeModifyTransformStart"].concat(args));
    });
    this.transformation.addLocalHook("afterTransformStart", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.runLocalHooks.apply(_this, ["afterModifyTransformStart"].concat(args));
    });
    this.transformation.addLocalHook("beforeTransformEnd", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.runLocalHooks.apply(_this, ["beforeModifyTransformEnd"].concat(args));
    });
    this.transformation.addLocalHook("afterTransformEnd", function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.runLocalHooks.apply(_this, ["afterModifyTransformEnd"].concat(args));
    });
    this.transformation.addLocalHook("insertRowRequire", function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.runLocalHooks.apply(_this, ["insertRowRequire"].concat(args));
    });
    this.transformation.addLocalHook("insertColRequire", function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.runLocalHooks.apply(_this, ["insertColRequire"].concat(args));
    });
  }
  _createClass$W(Selection2, [{
    key: "getSelectedRange",
    value: function getSelectedRange() {
      return this.selectedRange;
    }
  }, {
    key: "begin",
    value: function begin() {
      this.inProgress = true;
    }
  }, {
    key: "finish",
    value: function finish() {
      this.runLocalHooks("afterSelectionFinished", Array.from(this.selectedRange));
      this.inProgress = false;
    }
  }, {
    key: "isInProgress",
    value: function isInProgress() {
      return this.inProgress;
    }
  }, {
    key: "setRangeStart",
    value: function setRangeStart(coords, multipleSelection) {
      var fragment = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var isMultipleMode = this.settings.selectionMode === "multiple";
      var isMultipleSelection = isUndefined$1(multipleSelection) ? isPressedCtrlKey() : multipleSelection;
      var isRowNegative = coords.row < 0;
      var isColumnNegative = coords.col < 0;
      var selectedByCorner = isRowNegative && isColumnNegative;
      this.selectedByCorner = selectedByCorner;
      this.runLocalHooks("beforeSetRangeStart".concat(fragment ? "Only" : ""), coords);
      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined$1(multipleSelection)) {
        this.selectedRange.clear();
      }
      this.selectedRange.add(coords);
      if (this.getLayerLevel() === 0) {
        this.selectedByRowHeader.clear();
        this.selectedByColumnHeader.clear();
      }
      if (!selectedByCorner && isColumnNegative) {
        this.selectedByRowHeader.add(this.getLayerLevel());
      }
      if (!selectedByCorner && isRowNegative) {
        this.selectedByColumnHeader.add(this.getLayerLevel());
      }
      if (!fragment) {
        this.setRangeEnd(coords);
      }
    }
  }, {
    key: "setRangeStartOnly",
    value: function setRangeStartOnly(coords, multipleSelection) {
      this.setRangeStart(coords, multipleSelection, true);
    }
  }, {
    key: "setRangeEnd",
    value: function setRangeEnd(coords) {
      if (this.selectedRange.isEmpty()) {
        return;
      }
      this.runLocalHooks("beforeSetRangeEnd", coords);
      this.begin();
      var cellRange = this.selectedRange.current();
      if (this.settings.selectionMode !== "single") {
        cellRange.setTo(new CellCoords(coords.row, coords.col));
      }
      this.highlight.getCell().clear();
      if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {
        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().adjustCoordinates(cellRange);
      }
      var layerLevel = this.getLayerLevel();
      if (layerLevel < this.highlight.layerLevel) {
        arrayEach(this.highlight.getAreas(), function(highlight) {
          return void highlight.clear();
        });
        arrayEach(this.highlight.getHeaders(), function(highlight) {
          return void highlight.clear();
        });
        arrayEach(this.highlight.getActiveHeaders(), function(highlight) {
          return void highlight.clear();
        });
      }
      this.highlight.useLayerLevel(layerLevel);
      var areaHighlight = this.highlight.createOrGetArea();
      var headerHighlight = this.highlight.createOrGetHeader();
      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();
      areaHighlight.clear();
      headerHighlight.clear();
      activeHeaderHighlight.clear();
      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {
        areaHighlight.add(cellRange.from).add(cellRange.to).commit();
        if (layerLevel === 1) {
          var previousRange = this.selectedRange.previous();
          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit().adjustCoordinates(previousRange);
          this.highlight.useLayerLevel(layerLevel);
        }
      }
      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {
        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;
        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;
        var headerCellRange = cellRange;
        if (areAnyRowsRendered || areAnyColumnsRendered) {
          headerCellRange = cellRange.clone();
        }
        if (areAnyRowsRendered) {
          headerCellRange.from.row = -1;
        }
        if (areAnyColumnsRendered) {
          headerCellRange.from.col = -1;
        }
        if (this.settings.selectionMode === "single") {
          if (this.isSelectedByAnyHeader()) {
            headerCellRange.from.normalize();
          }
          headerHighlight.add(headerCellRange.from).commit();
        } else {
          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();
        }
        if (this.isEntireRowSelected()) {
          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth();
          if (isRowSelected) {
            activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1)).commit();
          }
        }
        if (this.isEntireColumnSelected()) {
          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight();
          if (isColumnSelected) {
            activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col)).commit();
          }
        }
      }
      this.runLocalHooks("afterSetRangeEnd", coords);
    }
  }, {
    key: "isMultiple",
    value: function isMultiple() {
      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());
      this.runLocalHooks("afterIsMultipleSelection", isMultipleListener);
      return isMultipleListener.value;
    }
  }, {
    key: "transformStart",
    value: function transformStart(rowDelta, colDelta, force) {
      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));
    }
  }, {
    key: "transformEnd",
    value: function transformEnd(rowDelta, colDelta) {
      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));
    }
  }, {
    key: "getLayerLevel",
    value: function getLayerLevel() {
      return this.selectedRange.size() - 1;
    }
  }, {
    key: "isSelected",
    value: function isSelected() {
      return !this.selectedRange.isEmpty();
    }
  }, {
    key: "isSelectedByRowHeader",
    value: function isSelectedByRowHeader() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);
    }
  }, {
    key: "isEntireRowSelected",
    value: function isEntireRowSelected() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);
    }
  }, {
    key: "isSelectedByColumnHeader",
    value: function isSelectedByColumnHeader() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);
    }
  }, {
    key: "isEntireColumnSelected",
    value: function isEntireColumnSelected() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);
    }
  }, {
    key: "isSelectedByAnyHeader",
    value: function isSelectedByAnyHeader() {
      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();
    }
  }, {
    key: "isSelectedByCorner",
    value: function isSelectedByCorner() {
      return this.selectedByCorner;
    }
  }, {
    key: "inInSelection",
    value: function inInSelection(coords) {
      return this.selectedRange.includes(coords);
    }
  }, {
    key: "isCellCornerVisible",
    value: function isCellCornerVisible() {
      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();
    }
  }, {
    key: "isAreaCornerVisible",
    value: function isAreaCornerVisible(layerLevel) {
      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {
        return false;
      }
      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();
    }
  }, {
    key: "clear",
    value: function clear() {
      this.selectedRange.clear();
      this.highlight.clear();
    }
  }, {
    key: "deselect",
    value: function deselect() {
      if (!this.isSelected()) {
        return;
      }
      this.inProgress = false;
      this.clear();
      this.runLocalHooks("afterDeselect");
    }
  }, {
    key: "selectAll",
    value: function selectAll() {
      var includeRowHeaders = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var nrOfRows = this.tableProps.countRows();
      var nrOfColumns = this.tableProps.countCols();
      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {
        return;
      }
      var startCoords = new CellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);
      this.clear();
      this.setRangeStartOnly(startCoords);
      this.selectedByRowHeader.add(this.getLayerLevel());
      this.selectedByColumnHeader.add(this.getLayerLevel());
      this.setRangeEnd(new CellCoords(nrOfRows - 1, nrOfColumns - 1));
      this.finish();
    }
  }, {
    key: "selectCells",
    value: function selectCells(selectionRanges) {
      var _this2 = this;
      var selectionType = detectSelectionType(selectionRanges);
      if (selectionType === SELECTION_TYPE_EMPTY) {
        return false;
      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {
        throw new Error(toSingleLine(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral$4(["Unsupported format of the selection ranges was passed. To select cells pass \n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \n        columnEnd/columnPropEnd]]) or as an array of CellRange objects."], ["Unsupported format of the selection ranges was passed. To select cells pass\\x20\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\x20\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects."]))));
      }
      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {
        propToCol: function propToCol(prop) {
          return _this2.tableProps.propToCol(prop);
        },
        keepDirection: true
      });
      var nrOfRows = this.tableProps.countRows();
      var nrOfColumns = this.tableProps.countCols();
      var isValid = !selectionRanges.some(function(selection) {
        var _selectionSchemaNorma = selectionSchemaNormalizer(selection), _selectionSchemaNorma2 = _slicedToArray$b(_selectionSchemaNorma, 4), rowStart = _selectionSchemaNorma2[0], columnStart = _selectionSchemaNorma2[1], rowEnd = _selectionSchemaNorma2[2], columnEnd = _selectionSchemaNorma2[3];
        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);
        return !_isValid;
      });
      if (isValid) {
        this.clear();
        arrayEach(selectionRanges, function(selection) {
          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection), _selectionSchemaNorma4 = _slicedToArray$b(_selectionSchemaNorma3, 4), rowStart = _selectionSchemaNorma4[0], columnStart = _selectionSchemaNorma4[1], rowEnd = _selectionSchemaNorma4[2], columnEnd = _selectionSchemaNorma4[3];
          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);
          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));
          _this2.finish();
        });
      }
      return isValid;
    }
  }, {
    key: "selectColumns",
    value: function selectColumns(startColumn) {
      var endColumn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startColumn;
      var headerLevel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      var start = typeof startColumn === "string" ? this.tableProps.propToCol(startColumn) : startColumn;
      var end = typeof endColumn === "string" ? this.tableProps.propToCol(endColumn) : endColumn;
      var nrOfColumns = this.tableProps.countCols();
      var nrOfRows = this.tableProps.countRows();
      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);
      if (isValid) {
        this.setRangeStartOnly(new CellCoords(headerLevel, start));
        this.setRangeEnd(new CellCoords(nrOfRows - 1, end));
        this.finish();
      }
      return isValid;
    }
  }, {
    key: "selectRows",
    value: function selectRows(startRow) {
      var endRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startRow;
      var headerLevel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      var nrOfRows = this.tableProps.countRows();
      var nrOfColumns = this.tableProps.countCols();
      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);
      if (isValid) {
        this.setRangeStartOnly(new CellCoords(startRow, headerLevel));
        this.setRangeEnd(new CellCoords(endRow, nrOfColumns - 1));
        this.finish();
      }
      return isValid;
    }
  }, {
    key: "refresh",
    value: function refresh() {
      var customSelections = this.highlight.getCustomSelections();
      customSelections.forEach(function(customSelection) {
        customSelection.commit();
      });
      if (!this.isSelected()) {
        return;
      }
      var cellHighlight = this.highlight.getCell();
      var currentLayer = this.getLayerLevel();
      cellHighlight.commit().adjustCoordinates(this.selectedRange.current());
      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {
        this.highlight.useLayerLevel(layerLevel);
        var areaHighlight = this.highlight.createOrGetArea();
        var headerHighlight = this.highlight.createOrGetHeader();
        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();
        areaHighlight.commit();
        headerHighlight.commit();
        activeHeaderHighlight.commit();
      }
      this.highlight.useLayerLevel(currentLayer);
    }
  }]);
  return Selection2;
}();
mixin(Selection$1, localHooks);

var regUniversalNewLine = /^(\r\n|\n\r|\r|\n)/;
var regNextCellNoQuotes = /^[^\t\r\n]+/;
var regNextEmptyCell = /^\t/;
function parse(str) {
  var arr = [[""]];
  if (str.length === 0) {
    return arr;
  }
  var column = 0;
  var row = 0;
  var lastLength;
  while (str.length > 0) {
    if (lastLength === str.length) {
      break;
    }
    lastLength = str.length;
    if (str.match(regNextEmptyCell)) {
      str = str.replace(regNextEmptyCell, "");
      column += 1;
      arr[row][column] = "";
    } else if (str.match(regUniversalNewLine)) {
      str = str.replace(regUniversalNewLine, "");
      column = 0;
      row += 1;
      arr[row] = [""];
    } else {
      var nextCell = "";
      if (str.startsWith('"')) {
        var quoteNo = 0;
        var isStillCell = true;
        while (isStillCell) {
          var nextChar = str.slice(0, 1);
          if (nextChar === '"') {
            quoteNo += 1;
          }
          nextCell += nextChar;
          str = str.slice(1);
          if (str.length === 0 || str.match(/^[\t\r\n]/) && quoteNo % 2 === 0) {
            isStillCell = false;
          }
        }
        nextCell = nextCell.replace(/^"/, "").replace(/"$/, "").replace(/["]*/g, function(match) {
          return new Array(Math.floor(match.length / 2)).fill('"').join("");
        });
      } else {
        var matchedText = str.match(regNextCellNoQuotes);
        nextCell = matchedText ? matchedText[0] : "";
        str = str.slice(nextCell.length);
      }
      arr[row][column] = nextCell;
    }
  }
  return arr;
}
function stringify$1(arr) {
  var r;
  var rLen;
  var c;
  var cLen;
  var str = "";
  var val;
  for (r = 0, rLen = arr.length; r < rLen; r += 1) {
    cLen = arr[r].length;
    for (c = 0; c < cLen; c += 1) {
      if (c > 0) {
        str += "	";
      }
      val = arr[r][c];
      if (typeof val === "string") {
        if (val.indexOf("\n") > -1) {
          str += '"'.concat(val.replace(/"/g, '""'), '"');
        } else {
          str += val;
        }
      } else if (val === null || val === void 0) {
        str += "";
      } else {
        str += val;
      }
    }
    if (r !== rLen - 1) {
      str += "\n";
    }
  }
  return str;
}

function _typeof$y(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$y = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$y = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$y(obj);
}
function _classCallCheck$10(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$X(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$X(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$X(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$X(Constructor, staticProps);
  return Constructor;
}
var copyableLookup = cellMethodLookupFactory("copyable", false);
var DataMap = /* @__PURE__ */ function() {
  function DataMap2(instance, data, tableMeta) {
    _classCallCheck$10(this, DataMap2);
    this.instance = instance;
    this.tableMeta = tableMeta;
    this.dataSource = data;
    this.duckSchema = this.dataSource && this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};
    this.colToPropCache = void 0;
    this.propToColCache = void 0;
    this.createMap();
  }
  _createClass$X(DataMap2, [{
    key: "createMap",
    value: function createMap() {
      var schema = this.getSchema();
      if (typeof schema === "undefined") {
        throw new Error("trying to create `columns` definition but you didn't provide `schema` nor `data`");
      }
      var columns = this.tableMeta.columns;
      var i;
      this.colToPropCache = [];
      this.propToColCache = new Map();
      if (columns) {
        var columnsLen = 0;
        var filteredIndex = 0;
        var columnsAsFunc = false;
        if (typeof columns === "function") {
          var schemaLen = deepObjectSize(schema);
          columnsLen = schemaLen > 0 ? schemaLen : this.countFirstRowKeys();
          columnsAsFunc = true;
        } else {
          var maxCols = this.tableMeta.maxCols;
          columnsLen = Math.min(maxCols, columns.length);
        }
        for (i = 0; i < columnsLen; i++) {
          var column = columnsAsFunc ? columns(i) : columns[i];
          if (isObject(column)) {
            if (typeof column.data !== "undefined") {
              var index = columnsAsFunc ? filteredIndex : i;
              this.colToPropCache[index] = column.data;
              this.propToColCache.set(column.data, index);
            }
            filteredIndex += 1;
          }
        }
      } else {
        this.recursiveDuckColumns(schema);
      }
    }
  }, {
    key: "countFirstRowKeys",
    value: function countFirstRowKeys$1() {
      return countFirstRowKeys(this.dataSource);
    }
  }, {
    key: "recursiveDuckColumns",
    value: function recursiveDuckColumns(schema, lastCol, parent) {
      var _this = this;
      var lastColumn = lastCol;
      var propertyParent = parent;
      var prop;
      if (typeof lastColumn === "undefined") {
        lastColumn = 0;
        propertyParent = "";
      }
      if (_typeof$y(schema) === "object" && !Array.isArray(schema)) {
        objectEach(schema, function(value, key) {
          if (value === null) {
            prop = propertyParent + key;
            _this.colToPropCache.push(prop);
            _this.propToColCache.set(prop, lastColumn);
            lastColumn += 1;
          } else {
            lastColumn = _this.recursiveDuckColumns(value, lastColumn, "".concat(key, "."));
          }
        });
      }
      return lastColumn;
    }
  }, {
    key: "colToProp",
    value: function colToProp(column) {
      if (Number.isInteger(column) === false) {
        return column;
      }
      var physicalColumn = this.instance.toPhysicalColumn(column);
      if (physicalColumn === null) {
        return column;
      }
      if (this.colToPropCache && isDefined(this.colToPropCache[physicalColumn])) {
        return this.colToPropCache[physicalColumn];
      }
      return physicalColumn;
    }
  }, {
    key: "propToCol",
    value: function propToCol(prop) {
      var cachedPhysicalIndex = this.propToColCache.get(prop);
      if (isDefined(cachedPhysicalIndex)) {
        return this.instance.toVisualColumn(cachedPhysicalIndex);
      }
      var visualColumn = this.instance.toVisualColumn(prop);
      if (visualColumn === null) {
        return prop;
      }
      return visualColumn;
    }
  }, {
    key: "getSchema",
    value: function getSchema() {
      var schema = this.tableMeta.dataSchema;
      if (schema) {
        if (typeof schema === "function") {
          return schema();
        }
        return schema;
      }
      return this.duckSchema;
    }
  }, {
    key: "createRow",
    value: function createRow(index) {
      var _this2 = this;
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var source = arguments.length > 2 ? arguments[2] : void 0;
      var sourceRowsCount = this.instance.countSourceRows();
      var physicalRowIndex = sourceRowsCount;
      var numberOfCreatedRows = 0;
      var rowIndex = index;
      if (typeof rowIndex !== "number" || rowIndex >= sourceRowsCount) {
        rowIndex = sourceRowsCount;
      }
      if (rowIndex < this.instance.countRows()) {
        physicalRowIndex = this.instance.toPhysicalRow(rowIndex);
      }
      var continueProcess = this.instance.runHooks("beforeCreateRow", rowIndex, amount, source);
      if (continueProcess === false || physicalRowIndex === null) {
        return 0;
      }
      var maxRows = this.tableMeta.maxRows;
      var columnCount = this.instance.countCols();
      var rowsToAdd = [];
      var _loop = function _loop2() {
        var row = null;
        if (_this2.instance.dataType === "array") {
          if (_this2.tableMeta.dataSchema) {
            row = deepClone(_this2.getSchema());
          } else {
            row = [];
            rangeEach(columnCount - 1, function() {
              return row.push(null);
            });
          }
        } else if (_this2.instance.dataType === "function") {
          row = _this2.tableMeta.dataSchema(rowIndex + numberOfCreatedRows);
        } else {
          row = {};
          deepExtend(row, _this2.getSchema());
        }
        rowsToAdd.push(row);
        numberOfCreatedRows += 1;
      };
      while (numberOfCreatedRows < amount && sourceRowsCount + numberOfCreatedRows < maxRows) {
        _loop();
      }
      this.instance.rowIndexMapper.insertIndexes(rowIndex, numberOfCreatedRows);
      this.spliceData.apply(this, [physicalRowIndex, 0].concat(rowsToAdd));
      this.instance.runHooks("afterCreateRow", rowIndex, numberOfCreatedRows, source);
      this.instance.forceFullRender = true;
      return numberOfCreatedRows;
    }
  }, {
    key: "createCol",
    value: function createCol(index) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var source = arguments.length > 2 ? arguments[2] : void 0;
      if (!this.instance.isColumnModificationAllowed()) {
        throw new Error("Cannot create new column. When data source in an object, you can only have as much columns as defined in first data row, data schema or in the 'columns' setting.If you want to be able to add new columns, you have to use array datasource.");
      }
      var dataSource = this.dataSource;
      var maxCols = this.tableMeta.maxCols;
      var columnIndex = index;
      if (typeof columnIndex !== "number" || columnIndex >= this.instance.countSourceCols()) {
        columnIndex = this.instance.countSourceCols();
      }
      var continueProcess = this.instance.runHooks("beforeCreateCol", columnIndex, amount, source);
      if (continueProcess === false) {
        return 0;
      }
      var physicalColumnIndex = this.instance.countSourceCols();
      if (columnIndex < this.instance.countCols()) {
        physicalColumnIndex = this.instance.toPhysicalColumn(columnIndex);
      }
      var numberOfSourceRows = this.instance.countSourceRows();
      var nrOfColumns = this.instance.countCols();
      var numberOfCreatedCols = 0;
      var currentIndex = physicalColumnIndex;
      while (numberOfCreatedCols < amount && nrOfColumns < maxCols) {
        if (typeof columnIndex !== "number" || columnIndex >= nrOfColumns) {
          if (numberOfSourceRows > 0) {
            for (var row = 0; row < numberOfSourceRows; row += 1) {
              if (typeof dataSource[row] === "undefined") {
                dataSource[row] = [];
              }
              dataSource[row].push(null);
            }
          } else {
            dataSource.push([null]);
          }
        } else {
          for (var _row = 0; _row < numberOfSourceRows; _row++) {
            dataSource[_row].splice(currentIndex, 0, null);
          }
        }
        numberOfCreatedCols += 1;
        currentIndex += 1;
        nrOfColumns += 1;
      }
      this.instance.columnIndexMapper.insertIndexes(columnIndex, numberOfCreatedCols);
      this.instance.runHooks("afterCreateCol", columnIndex, numberOfCreatedCols, source);
      this.instance.forceFullRender = true;
      return numberOfCreatedCols;
    }
  }, {
    key: "removeRow",
    value: function removeRow(index) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var source = arguments.length > 2 ? arguments[2] : void 0;
      var rowIndex = Number.isInteger(index) ? index : -amount;
      var removedPhysicalIndexes = this.visualRowsToPhysical(rowIndex, amount);
      var sourceRowsLength = this.instance.countSourceRows();
      rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength;
      var actionWasNotCancelled = this.instance.runHooks("beforeRemoveRow", rowIndex, removedPhysicalIndexes.length, removedPhysicalIndexes, source);
      if (actionWasNotCancelled === false) {
        return false;
      }
      var data = this.dataSource;
      var numberOfRemovedIndexes = removedPhysicalIndexes.length;
      var newData = this.filterData(rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes);
      if (newData) {
        data.length = 0;
        Array.prototype.push.apply(data, newData);
      }
      if (rowIndex < this.instance.countRows()) {
        this.instance.rowIndexMapper.removeIndexes(removedPhysicalIndexes);
        var customDefinedColumns = isDefined(this.tableMeta.columns) || isDefined(this.tableMeta.dataSchema);
        if (this.instance.rowIndexMapper.getNotTrimmedIndexesLength() === 0 && customDefinedColumns === false) {
          this.instance.columnIndexMapper.setIndexesSequence([]);
        }
      }
      this.instance.runHooks("afterRemoveRow", rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes, source);
      this.instance.forceFullRender = true;
      return true;
    }
  }, {
    key: "removeCol",
    value: function removeCol(index) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var source = arguments.length > 2 ? arguments[2] : void 0;
      if (this.instance.dataType === "object" || this.tableMeta.columns) {
        throw new Error("cannot remove column with object data source or columns option specified");
      }
      var columnIndex = typeof index !== "number" ? -amount : index;
      columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();
      var logicColumns = this.visualColumnsToPhysical(columnIndex, amount);
      var descendingLogicColumns = logicColumns.slice(0).sort(function(a, b) {
        return b - a;
      });
      var actionWasNotCancelled = this.instance.runHooks("beforeRemoveCol", columnIndex, amount, logicColumns, source);
      if (actionWasNotCancelled === false) {
        return false;
      }
      var isTableUniform = true;
      var removedColumnsCount = descendingLogicColumns.length;
      var data = this.dataSource;
      for (var c = 0; c < removedColumnsCount; c++) {
        if (isTableUniform && logicColumns[0] !== logicColumns[c] - c) {
          isTableUniform = false;
        }
      }
      if (isTableUniform) {
        for (var r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {
          data[r].splice(logicColumns[0], amount);
        }
      } else {
        for (var _r = 0, _rlen = this.instance.countSourceRows(); _r < _rlen; _r++) {
          for (var _c = 0; _c < removedColumnsCount; _c++) {
            data[_r].splice(descendingLogicColumns[_c], 1);
          }
        }
      }
      if (columnIndex < this.instance.countCols()) {
        this.instance.columnIndexMapper.removeIndexes(logicColumns);
        if (this.instance.columnIndexMapper.getNotTrimmedIndexesLength() === 0) {
          this.instance.rowIndexMapper.setIndexesSequence([]);
        }
      }
      this.instance.runHooks("afterRemoveCol", columnIndex, amount, logicColumns, source);
      this.instance.forceFullRender = true;
      return true;
    }
  }, {
    key: "spliceCol",
    value: function spliceCol(col, index, amount) {
      var colData = this.instance.getDataAtCol(col);
      var removed = colData.slice(index, index + amount);
      var after = colData.slice(index + amount);
      for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        elements[_key - 3] = arguments[_key];
      }
      extendArray(elements, after);
      var i = 0;
      while (i < amount) {
        elements.push(null);
        i += 1;
      }
      to2dArray(elements);
      this.instance.populateFromArray(index, col, elements, null, null, "spliceCol");
      return removed;
    }
  }, {
    key: "spliceRow",
    value: function spliceRow(row, index, amount) {
      var rowData = this.instance.getSourceDataAtRow(row);
      var removed = rowData.slice(index, index + amount);
      var after = rowData.slice(index + amount);
      for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        elements[_key2 - 3] = arguments[_key2];
      }
      extendArray(elements, after);
      var i = 0;
      while (i < amount) {
        elements.push(null);
        i += 1;
      }
      this.instance.populateFromArray(row, index, [elements], null, null, "spliceRow");
      return removed;
    }
  }, {
    key: "spliceData",
    value: function spliceData(index, amount) {
      for (var _len3 = arguments.length, elements = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        elements[_key3 - 2] = arguments[_key3];
      }
      var continueSplicing = this.instance.runHooks("beforeDataSplice", index, amount, elements);
      if (continueSplicing !== false) {
        var _this$dataSource;
        (_this$dataSource = this.dataSource).splice.apply(_this$dataSource, [index, amount].concat(elements));
      }
    }
  }, {
    key: "filterData",
    value: function filterData(index, amount, physicalRows) {
      var continueSplicing = this.instance.runHooks("beforeDataFilter", index, amount, physicalRows);
      if (continueSplicing !== false) {
        var newData = this.dataSource.filter(function(row, rowIndex) {
          return physicalRows.indexOf(rowIndex) === -1;
        });
        return newData;
      }
    }
  }, {
    key: "get",
    value: function get(row, prop) {
      var physicalRow = this.instance.toPhysicalRow(row);
      var dataRow = this.dataSource[physicalRow];
      var modifiedRowData = this.instance.runHooks("modifyRowData", physicalRow);
      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
      var value = null;
      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {
        value = dataRow[prop];
      } else if (typeof prop === "string" && prop.indexOf(".") > -1) {
        var sliced = prop.split(".");
        var out = dataRow;
        if (!out) {
          return null;
        }
        for (var i = 0, ilen = sliced.length; i < ilen; i++) {
          out = out[sliced[i]];
          if (typeof out === "undefined") {
            return null;
          }
        }
        value = out;
      } else if (typeof prop === "function") {
        value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);
      }
      if (this.instance.hasHook("modifyData")) {
        var valueHolder = createObjectPropListener(value);
        this.instance.runHooks("modifyData", physicalRow, this.propToCol(prop), valueHolder, "get");
        if (valueHolder.isTouched()) {
          value = valueHolder.value;
        }
      }
      return value;
    }
  }, {
    key: "getCopyable",
    value: function getCopyable(row, prop) {
      if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {
        return this.get(row, prop);
      }
      return "";
    }
  }, {
    key: "set",
    value: function set(row, prop, value) {
      var physicalRow = this.instance.toPhysicalRow(row);
      var newValue = value;
      var dataRow = this.dataSource[physicalRow];
      var modifiedRowData = this.instance.runHooks("modifyRowData", physicalRow);
      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
      if (this.instance.hasHook("modifyData")) {
        var valueHolder = createObjectPropListener(newValue);
        this.instance.runHooks("modifyData", physicalRow, this.propToCol(prop), valueHolder, "set");
        if (valueHolder.isTouched()) {
          newValue = valueHolder.value;
        }
      }
      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {
        dataRow[prop] = newValue;
      } else if (typeof prop === "string" && prop.indexOf(".") > -1) {
        var sliced = prop.split(".");
        var out = dataRow;
        var i = 0;
        var ilen;
        for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {
          if (typeof out[sliced[i]] === "undefined") {
            out[sliced[i]] = {};
          }
          out = out[sliced[i]];
        }
        out[sliced[i]] = newValue;
      } else if (typeof prop === "function") {
        prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);
      } else {
        dataRow[prop] = newValue;
      }
    }
  }, {
    key: "visualRowsToPhysical",
    value: function visualRowsToPhysical(index, amount) {
      var totalRows = this.instance.countSourceRows();
      var logicRows = [];
      var physicRow = (totalRows + index) % totalRows;
      var rowsToRemove = amount;
      var row;
      while (physicRow < totalRows && rowsToRemove) {
        row = this.instance.toPhysicalRow(physicRow);
        logicRows.push(row);
        rowsToRemove -= 1;
        physicRow += 1;
      }
      return logicRows;
    }
  }, {
    key: "visualColumnsToPhysical",
    value: function visualColumnsToPhysical(index, amount) {
      var totalCols = this.instance.countCols();
      var visualCols = [];
      var physicalCol = (totalCols + index) % totalCols;
      var colsToRemove = amount;
      while (physicalCol < totalCols && colsToRemove) {
        var col = this.instance.toPhysicalColumn(physicalCol);
        visualCols.push(col);
        colsToRemove -= 1;
        physicalCol += 1;
      }
      return visualCols;
    }
  }, {
    key: "clear",
    value: function clear() {
      for (var r = 0; r < this.instance.countSourceRows(); r++) {
        for (var c = 0; c < this.instance.countCols(); c++) {
          this.set(r, this.colToProp(c), "");
        }
      }
    }
  }, {
    key: "getLength",
    value: function getLength() {
      var maxRowsFromSettings = this.tableMeta.maxRows;
      var maxRows;
      if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {
        maxRows = 0;
      } else {
        maxRows = maxRowsFromSettings || Infinity;
      }
      var length = this.instance.rowIndexMapper.getNotTrimmedIndexesLength();
      return Math.min(length, maxRows);
    }
  }, {
    key: "getAll",
    value: function getAll() {
      var start = {
        row: 0,
        col: 0
      };
      var end = {
        row: Math.max(this.instance.countRows() - 1, 0),
        col: Math.max(this.instance.countCols() - 1, 0)
      };
      if (start.row - end.row === 0 && !this.instance.countSourceRows()) {
        return [];
      }
      return this.getRange(start, end, DataMap2.DESTINATION_RENDERER);
    }
  }, {
    key: "countCachedColumns",
    value: function countCachedColumns() {
      return this.colToPropCache.length;
    }
  }, {
    key: "getRange",
    value: function getRange(start, end, destination) {
      var output = [];
      var r;
      var c;
      var row;
      var maxRows = this.tableMeta.maxRows;
      var maxCols = this.tableMeta.maxCols;
      if (maxRows === 0 || maxCols === 0) {
        return [];
      }
      var getFn = destination === DataMap2.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;
      var rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));
      var clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));
      for (r = Math.min(start.row, end.row); r <= rlen; r++) {
        row = [];
        var physicalRow = r >= 0 ? this.instance.toPhysicalRow(r) : r;
        for (c = Math.min(start.col, end.col); c <= clen; c++) {
          if (physicalRow === null) {
            break;
          }
          row.push(getFn.call(this, r, this.colToProp(c)));
        }
        if (physicalRow !== null) {
          output.push(row);
        }
      }
      return output;
    }
  }, {
    key: "getText",
    value: function getText(start, end) {
      return stringify$1(this.getRange(start, end, DataMap2.DESTINATION_RENDERER));
    }
  }, {
    key: "getCopyableText",
    value: function getCopyableText(start, end) {
      return stringify$1(this.getRange(start, end, DataMap2.DESTINATION_CLIPBOARD_GENERATOR));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.instance = null;
      this.tableMeta = null;
      this.dataSource = null;
      this.duckSchema = null;
      this.colToPropCache.length = 0;
      this.propToColCache.clear();
      this.propToColCache = void 0;
    }
  }], [{
    key: "DESTINATION_RENDERER",
    get: function get() {
      return 1;
    }
  }, {
    key: "DESTINATION_CLIPBOARD_GENERATOR",
    get: function get() {
      return 2;
    }
  }]);
  return DataMap2;
}();

function expandMetaType(type, metaObject) {
  var validType = typeof type === "string" ? _getItem$3(type) : type;
  if (!isObject(validType)) {
    return;
  }
  var preventSourceOverwrite = isObject(metaObject);
  var expandedType = {};
  objectEach(validType, function(value, property) {
    if (property !== "CELL_TYPE" && (!preventSourceOverwrite || preventSourceOverwrite && !hasOwnProperty(metaObject, property))) {
      expandedType[property] = value;
    }
  });
  return expandedType;
}
function columnFactory(TableMeta) {
  var conflictList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  function ColumnMeta() {
  }
  inherit(ColumnMeta, TableMeta);
  for (var i = 0; i < conflictList.length; i++) {
    ColumnMeta.prototype[conflictList[i]] = void 0;
  }
  return ColumnMeta;
}
function isUnsignedNumber(value) {
  return Number.isInteger(value) && value >= 0;
}
function assert(condition, errorMessage) {
  if (!condition()) {
    throw new Error("Assertion failed: ".concat(errorMessage));
  }
}
function isNullish(variable) {
  return variable === null || variable === void 0;
}

function _typeof$z(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$z = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$z = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$z(obj);
}
var metaSchemaFactory = (function() {
  return {
    licenseKey: void 0,
    data: void 0,
    dataSchema: void 0,
    width: void 0,
    height: void 0,
    startRows: 5,
    startCols: 5,
    rowHeaders: void 0,
    colHeaders: null,
    colWidths: void 0,
    rowHeights: void 0,
    columns: void 0,
    cells: void 0,
    cell: [],
    comments: false,
    customBorders: false,
    minRows: 0,
    minCols: 0,
    maxRows: Infinity,
    maxCols: Infinity,
    minSpareRows: 0,
    minSpareCols: 0,
    allowInsertRow: true,
    allowInsertColumn: true,
    allowRemoveRow: true,
    allowRemoveColumn: true,
    selectionMode: "multiple",
    fillHandle: {
      autoInsertRow: false
    },
    fixedRowsTop: 0,
    fixedRowsBottom: 0,
    fixedColumnsLeft: 0,
    outsideClickDeselects: true,
    enterBeginsEditing: true,
    enterMoves: {
      col: 0,
      row: 1
    },
    tabMoves: {
      row: 0,
      col: 1
    },
    autoWrapRow: true,
    autoWrapCol: true,
    persistentState: void 0,
    currentRowClassName: void 0,
    currentColClassName: void 0,
    currentHeaderClassName: "ht__highlight",
    activeHeaderClassName: "ht__active_highlight",
    className: void 0,
    tableClassName: void 0,
    stretchH: "none",
    isEmptyRow: function isEmptyRow(row) {
      var col;
      var colLen;
      var value;
      var meta;
      for (col = 0, colLen = this.countCols(); col < colLen; col++) {
        value = this.getDataAtCell(row, col);
        if (isEmpty(value) === false) {
          if (_typeof$z(value) === "object") {
            meta = this.getCellMeta(row, col);
            return isObjectEqual(this.getSchema()[meta.prop], value);
          }
          return false;
        }
      }
      return true;
    },
    isEmptyCol: function isEmptyCol(col) {
      var row;
      var rowLen;
      var value;
      for (row = 0, rowLen = this.countRows(); row < rowLen; row++) {
        value = this.getDataAtCell(row, col);
        if (isEmpty(value) === false) {
          return false;
        }
      }
      return true;
    },
    observeDOMVisibility: true,
    allowInvalid: true,
    allowEmpty: true,
    invalidCellClassName: "htInvalid",
    placeholder: void 0,
    placeholderCellClassName: "htPlaceholder",
    readOnlyCellClassName: "htDimmed",
    renderer: void 0,
    commentedCellClassName: "htCommentCell",
    fragmentSelection: false,
    readOnly: false,
    skipColumnOnPaste: false,
    skipRowOnPaste: false,
    search: false,
    type: "text",
    copyable: true,
    editor: void 0,
    visibleRows: 10,
    trimDropdown: true,
    wordWrap: true,
    noWordWrapClassName: "htNoWrap",
    contextMenu: void 0,
    copyPaste: true,
    undo: void 0,
    columnSorting: void 0,
    manualColumnMove: void 0,
    manualColumnResize: void 0,
    manualRowMove: void 0,
    manualRowResize: void 0,
    mergeCells: false,
    multiColumnSorting: void 0,
    viewportRowRenderingOffset: "auto",
    viewportColumnRenderingOffset: "auto",
    validator: void 0,
    disableVisualSelection: false,
    manualColumnFreeze: void 0,
    trimWhitespace: true,
    source: void 0,
    title: void 0,
    checkedTemplate: void 0,
    uncheckedTemplate: void 0,
    label: void 0,
    numericFormat: void 0,
    language: "en-US",
    selectOptions: void 0,
    autoColumnSize: void 0,
    autoRowSize: void 0,
    dateFormat: "DD/MM/YYYY",
    correctFormat: false,
    defaultDate: void 0,
    strict: void 0,
    allowHtml: false,
    renderAllRows: void 0,
    preventOverflow: false,
    preventWheel: false,
    bindRowsWithHeaders: void 0,
    collapsibleColumns: void 0,
    columnSummary: void 0,
    dropdownMenu: void 0,
    filters: void 0,
    formulas: void 0,
    hiddenColumns: void 0,
    hiddenRows: void 0,
    nestedHeaders: void 0,
    trimRows: void 0,
    rowHeaderWidth: void 0,
    columnHeaderHeight: void 0,
    sortByRelevance: true,
    filter: true,
    filteringCaseSensitive: false,
    dragToScroll: true,
    nestedRows: void 0
  };
});

function _defineProperties$Y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$Y(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$Y(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$Y(Constructor, staticProps);
  return Constructor;
}
function _classCallCheck$11(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function createTableMetaEmptyClass() {
  return function TableMeta() {
    _classCallCheck$11(this, TableMeta);
  };
}
var GlobalMeta = /* @__PURE__ */ function() {
  function GlobalMeta2() {
    _classCallCheck$11(this, GlobalMeta2);
    this.metaCtor = createTableMetaEmptyClass();
    this.meta = this.metaCtor.prototype;
    extend(this.meta, metaSchemaFactory());
  }
  _createClass$Y(GlobalMeta2, [{
    key: "getMetaConstructor",
    value: function getMetaConstructor() {
      return this.metaCtor;
    }
  }, {
    key: "getMeta",
    value: function getMeta() {
      return this.meta;
    }
  }, {
    key: "updateMeta",
    value: function updateMeta(settings) {
      extend(this.meta, settings);
      extend(this.meta, expandMetaType(settings.type, settings));
    }
  }]);
  return GlobalMeta2;
}();

function _classCallCheck$12(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$Z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$Z(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$Z(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$Z(Constructor, staticProps);
  return Constructor;
}
var TableMeta = /* @__PURE__ */ function() {
  function TableMeta2(globalMeta) {
    _classCallCheck$12(this, TableMeta2);
    var MetaCtor = globalMeta.getMetaConstructor();
    this.meta = new MetaCtor();
  }
  _createClass$Z(TableMeta2, [{
    key: "getMeta",
    value: function getMeta() {
      return this.meta;
    }
  }, {
    key: "updateMeta",
    value: function updateMeta(settings) {
      extend(this.meta, settings);
      extend(this.meta, expandMetaType(settings.type, settings));
    }
  }]);
  return TableMeta2;
}();

function _classCallCheck$13(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$_(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$_(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$_(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$_(Constructor, staticProps);
  return Constructor;
}
var LazyFactoryMap = /* @__PURE__ */ function() {
  function LazyFactoryMap2(valueFactory) {
    _classCallCheck$13(this, LazyFactoryMap2);
    this.valueFactory = valueFactory;
    this.data = [];
    this.index = [];
    this.holes = new Set();
  }
  _createClass$_(LazyFactoryMap2, [{
    key: "obtain",
    value: function obtain(key) {
      assert(function() {
        return isUnsignedNumber(key);
      }, "Expecting an unsigned number.");
      var dataIndex = this._getStorageIndexByKey(key);
      var result;
      if (dataIndex >= 0) {
        result = this.data[dataIndex];
        if (result === void 0) {
          result = this.valueFactory(key);
          this.data[dataIndex] = result;
        }
      } else {
        result = this.valueFactory(key);
        if (this.holes.size > 0) {
          var reuseIndex = this.holes.values().next().value;
          this.holes.delete(reuseIndex);
          this.data[reuseIndex] = result;
          this.index[key] = reuseIndex;
        } else {
          this.data.push(result);
          this.index[key] = this.data.length - 1;
        }
      }
      return result;
    }
  }, {
    key: "insert",
    value: function insert(key) {
      var _this$index;
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      assert(function() {
        return isUnsignedNumber(key) || isNullish(key);
      }, "Expecting an unsigned number or null/undefined argument.");
      var newIndexes = [];
      var dataLength = this.data.length;
      for (var i = 0; i < amount; i++) {
        newIndexes.push(dataLength + i);
        this.data.push(void 0);
      }
      (_this$index = this.index).splice.apply(_this$index, [isNullish(key) ? this.index.length : key, 0].concat(newIndexes));
    }
  }, {
    key: "remove",
    value: function remove(key) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      assert(function() {
        return isUnsignedNumber(key) || isNullish(key);
      }, "Expecting an unsigned number or null/undefined argument.");
      var removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);
      for (var i = 0; i < removed.length; i++) {
        var removedIndex = removed[i];
        if (typeof removedIndex === "number") {
          this.holes.add(removedIndex);
        }
      }
    }
  }, {
    key: "size",
    value: function size() {
      return this.data.length - this.holes.size;
    }
  }, {
    key: "values",
    value: function values() {
      var _this = this;
      return arrayFilter(this.data, function(_, index) {
        return !_this.holes.has(index);
      })[Symbol.iterator]();
    }
  }, {
    key: "entries",
    value: function entries() {
      var validEntries = [];
      for (var i = 0; i < this.data.length; i++) {
        var keyIndex = this._getKeyByStorageIndex(i);
        if (keyIndex !== -1) {
          validEntries.push([keyIndex, this.data[i]]);
        }
      }
      var dataIndex = 0;
      return {
        next: function next() {
          if (dataIndex < validEntries.length) {
            var value = validEntries[dataIndex];
            dataIndex += 1;
            return {
              value,
              done: false
            };
          }
          return {
            done: true
          };
        }
      };
    }
  }, {
    key: "clear",
    value: function clear() {
      this.data = [];
      this.index = [];
      this.holes.clear();
    }
  }, {
    key: "_getStorageIndexByKey",
    value: function _getStorageIndexByKey(key) {
      return this.index.length > key ? this.index[key] : -1;
    }
  }, {
    key: "_getKeyByStorageIndex",
    value: function _getKeyByStorageIndex(dataIndex) {
      return this.index.indexOf(dataIndex);
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this.entries();
    }
  }]);
  return LazyFactoryMap2;
}();

function _classCallCheck$14(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$$(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$$(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$$(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$$(Constructor, staticProps);
  return Constructor;
}
var COLUMNS_PROPS_CONFLICTS = ["data", "width"];
var ColumnMeta = /* @__PURE__ */ function() {
  function ColumnMeta2(globalMeta) {
    var _this = this;
    _classCallCheck$14(this, ColumnMeta2);
    this.globalMeta = globalMeta;
    this.metas = new LazyFactoryMap(function() {
      return _this._createMeta();
    });
  }
  _createClass$$(ColumnMeta2, [{
    key: "updateMeta",
    value: function updateMeta(physicalColumn, settings) {
      var meta = this.getMeta(physicalColumn);
      extend(meta, settings);
      extend(meta, expandMetaType(settings.type, meta));
    }
  }, {
    key: "createColumn",
    value: function createColumn(physicalColumn, amount) {
      this.metas.insert(physicalColumn, amount);
    }
  }, {
    key: "removeColumn",
    value: function removeColumn(physicalColumn, amount) {
      this.metas.remove(physicalColumn, amount);
    }
  }, {
    key: "getMeta",
    value: function getMeta(physicalColumn) {
      return this.metas.obtain(physicalColumn);
    }
  }, {
    key: "getMetaConstructor",
    value: function getMetaConstructor(physicalColumn) {
      return this.metas.obtain(physicalColumn).constructor;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.metas.clear();
    }
  }, {
    key: "_createMeta",
    value: function _createMeta() {
      return columnFactory(this.globalMeta.getMetaConstructor(), COLUMNS_PROPS_CONFLICTS).prototype;
    }
  }]);
  return ColumnMeta2;
}();

function _toConsumableArray$g(arr) {
  return _arrayWithoutHoles$e(arr) || _iterableToArray$e(arr) || _unsupportedIterableToArray$l(arr) || _nonIterableSpread$e();
}
function _nonIterableSpread$e() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$l(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$l(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$l(o, minLen);
}
function _iterableToArray$e(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$e(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$l(arr);
}
function _arrayLikeToArray$l(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$15(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$10(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$10(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$10(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$10(Constructor, staticProps);
  return Constructor;
}
var CellMeta = /* @__PURE__ */ function() {
  function CellMeta2(columnMeta) {
    var _this = this;
    _classCallCheck$15(this, CellMeta2);
    this.columnMeta = columnMeta;
    this.metas = new LazyFactoryMap(function() {
      return _this._createRow();
    });
  }
  _createClass$10(CellMeta2, [{
    key: "updateMeta",
    value: function updateMeta(physicalRow, physicalColumn, settings) {
      var meta = this.getMeta(physicalRow, physicalColumn);
      extend(meta, settings);
      extend(meta, expandMetaType(settings.type, meta));
    }
  }, {
    key: "createRow",
    value: function createRow(physicalRow, amount) {
      this.metas.insert(physicalRow, amount);
    }
  }, {
    key: "createColumn",
    value: function createColumn(physicalColumn, amount) {
      for (var i = 0; i < this.metas.size(); i++) {
        this.metas.obtain(i).insert(physicalColumn, amount);
      }
    }
  }, {
    key: "removeRow",
    value: function removeRow(physicalRow, amount) {
      this.metas.remove(physicalRow, amount);
    }
  }, {
    key: "removeColumn",
    value: function removeColumn(physicalColumn, amount) {
      for (var i = 0; i < this.metas.size(); i++) {
        this.metas.obtain(i).remove(physicalColumn, amount);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(physicalRow, physicalColumn, key) {
      var cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
      if (key === void 0) {
        return cellMeta;
      }
      return cellMeta[key];
    }
  }, {
    key: "setMeta",
    value: function setMeta(physicalRow, physicalColumn, key, value) {
      var cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
      cellMeta[key] = value;
    }
  }, {
    key: "removeMeta",
    value: function removeMeta(physicalRow, physicalColumn, key) {
      var cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
      delete cellMeta[key];
    }
  }, {
    key: "getMetas",
    value: function getMetas() {
      var metas = [];
      var rows = Array.from(this.metas.values());
      for (var row = 0; row < rows.length; row++) {
        metas.push.apply(metas, _toConsumableArray$g(rows[row].values()));
      }
      return metas;
    }
  }, {
    key: "getMetasAtRow",
    value: function getMetasAtRow(physicalRow) {
      assert(function() {
        return isUnsignedNumber(physicalRow);
      }, "Expecting an unsigned number.");
      var rowsMeta = new Map(this.metas);
      return rowsMeta.has(physicalRow) ? Array.from(rowsMeta.get(physicalRow).values()) : [];
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.metas.clear();
    }
  }, {
    key: "_createRow",
    value: function _createRow() {
      var _this2 = this;
      return new LazyFactoryMap(function(physicalColumn) {
        return _this2._createMeta(physicalColumn);
      });
    }
  }, {
    key: "_createMeta",
    value: function _createMeta(physicalColumn) {
      var ColumnMeta = this.columnMeta.getMetaConstructor(physicalColumn);
      return new ColumnMeta();
    }
  }]);
  return CellMeta2;
}();

function _classCallCheck$16(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$11(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$11(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$11(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$11(Constructor, staticProps);
  return Constructor;
}
var MetaManager = /* @__PURE__ */ function() {
  function MetaManager2() {
    var customSettings = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck$16(this, MetaManager2);
    this.globalMeta = new GlobalMeta();
    this.globalMeta.updateMeta(customSettings);
    this.tableMeta = new TableMeta(this.globalMeta);
    this.columnMeta = new ColumnMeta(this.globalMeta);
    this.cellMeta = new CellMeta(this.columnMeta);
  }
  _createClass$11(MetaManager2, [{
    key: "getGlobalMeta",
    value: function getGlobalMeta() {
      return this.globalMeta.getMeta();
    }
  }, {
    key: "updateGlobalMeta",
    value: function updateGlobalMeta(settings) {
      this.globalMeta.updateMeta(settings);
    }
  }, {
    key: "getTableMeta",
    value: function getTableMeta() {
      return this.tableMeta.getMeta();
    }
  }, {
    key: "updateTableMeta",
    value: function updateTableMeta(settings) {
      this.tableMeta.updateMeta(settings);
    }
  }, {
    key: "getColumnMeta",
    value: function getColumnMeta(physicalColumn) {
      return this.columnMeta.getMeta(physicalColumn);
    }
  }, {
    key: "updateColumnMeta",
    value: function updateColumnMeta(physicalColumn, settings) {
      this.columnMeta.updateMeta(physicalColumn, settings);
    }
  }, {
    key: "getCellMeta",
    value: function getCellMeta(physicalRow, physicalColumn, key) {
      return this.cellMeta.getMeta(physicalRow, physicalColumn, key);
    }
  }, {
    key: "setCellMeta",
    value: function setCellMeta(physicalRow, physicalColumn, key, value) {
      this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);
    }
  }, {
    key: "updateCellMeta",
    value: function updateCellMeta(physicalRow, physicalColumn, settings) {
      this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);
    }
  }, {
    key: "removeCellMeta",
    value: function removeCellMeta(physicalRow, physicalColumn, key) {
      this.cellMeta.removeMeta(physicalRow, physicalColumn, key);
    }
  }, {
    key: "getCellsMeta",
    value: function getCellsMeta() {
      return this.cellMeta.getMetas();
    }
  }, {
    key: "getCellsMetaAtRow",
    value: function getCellsMetaAtRow(physicalRow) {
      return this.cellMeta.getMetasAtRow(physicalRow);
    }
  }, {
    key: "createRow",
    value: function createRow(physicalRow) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.cellMeta.createRow(physicalRow, amount);
    }
  }, {
    key: "removeRow",
    value: function removeRow(physicalRow) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.cellMeta.removeRow(physicalRow, amount);
    }
  }, {
    key: "createColumn",
    value: function createColumn(physicalColumn) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.cellMeta.createColumn(physicalColumn, amount);
      this.columnMeta.createColumn(physicalColumn, amount);
    }
  }, {
    key: "removeColumn",
    value: function removeColumn(physicalColumn) {
      var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.cellMeta.removeColumn(physicalColumn, amount);
      this.columnMeta.removeColumn(physicalColumn, amount);
    }
  }, {
    key: "clearCellsCache",
    value: function clearCellsCache() {
      this.cellMeta.clearCache();
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.cellMeta.clearCache();
      this.columnMeta.clearCache();
    }
  }]);
  return MetaManager2;
}();

function _typeof$A(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$A = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$A = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$A(obj);
}
function _slicedToArray$c(arr, i) {
  return _arrayWithHoles$c(arr) || _iterableToArrayLimit$c(arr, i) || _unsupportedIterableToArray$m(arr, i) || _nonIterableRest$c();
}
function _nonIterableRest$c() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$c(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$c(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray$h(arr) {
  return _arrayWithoutHoles$f(arr) || _iterableToArray$f(arr) || _unsupportedIterableToArray$m(arr) || _nonIterableSpread$f();
}
function _nonIterableSpread$f() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$m(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$m(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$m(o, minLen);
}
function _iterableToArray$f(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$f(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$m(arr);
}
function _arrayLikeToArray$m(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var activeGuid = null;
function Core(rootElement, userSettings) {
  var _this = this;
  var rootInstanceSymbol = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var preventScrollingToCell = false;
  var instance = this;
  var eventManager = new EventManager(instance);
  var datamap;
  var dataSource;
  var grid;
  var editorManager;
  var firstRun = true;
  userSettings.language = getValidLanguageCode(userSettings.language);
  var metaManager = new MetaManager(userSettings);
  var tableMeta = metaManager.getTableMeta();
  var globalMeta = metaManager.getGlobalMeta();
  var pluginsRegistry = createUniqueMap();
  if (hasValidParameter(rootInstanceSymbol)) {
    registerAsRootInstance(this);
  }
  this.rootElement = rootElement;
  this.rootDocument = rootElement.ownerDocument;
  this.rootWindow = this.rootDocument.defaultView;
  this.isDestroyed = false;
  this.renderSuspendedCounter = 0;
  this.executionSuspendedCounter = 0;
  startObserving(this.rootDocument);
  this.container = this.rootDocument.createElement("div");
  this.renderCall = false;
  rootElement.insertBefore(this.container, rootElement.firstChild);
  if (isRootInstance(this)) {
    _injectProductInfo(userSettings.licenseKey, rootElement);
  }
  this.guid = "ht_".concat(randomString());
  this.columnIndexMapper = new IndexMapper();
  this.rowIndexMapper = new IndexMapper();
  dataSource = new DataSource(instance);
  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === "ht_") {
    this.rootElement.id = this.guid;
  }
  var visualToRenderableCoords = function visualToRenderableCoords2(coords) {
    var visualRow = coords.row, visualColumn = coords.col;
    return new CellCoords(visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow, visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn);
  };
  var renderableToVisualCoords = function renderableToVisualCoords2(coords) {
    var renderableRow = coords.row, renderableColumn = coords.col;
    return new CellCoords(renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow, renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn);
  };
  var selection = new Selection$1(tableMeta, {
    countCols: function countCols() {
      return instance.countCols();
    },
    countRows: function countRows() {
      return instance.countRows();
    },
    propToCol: function propToCol(prop) {
      return datamap.propToCol(prop);
    },
    isEditorOpened: function isEditorOpened() {
      return instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false;
    },
    countColsTranslated: function countColsTranslated() {
      return _this.view.countRenderableColumns();
    },
    countRowsTranslated: function countRowsTranslated() {
      return _this.view.countRenderableRows();
    },
    visualToRenderableCoords,
    renderableToVisualCoords,
    isDisabledCellSelection: function isDisabledCellSelection(visualRow, visualColumn) {
      return instance.getCellMeta(visualRow, visualColumn).disableVisualSelection;
    }
  });
  this.selection = selection;
  var onIndexMapperCacheUpdate = function onIndexMapperCacheUpdate2(_ref) {
    var hiddenIndexesChanged = _ref.hiddenIndexesChanged;
    if (hiddenIndexesChanged) {
      _this.selection.refresh();
    }
  };
  this.columnIndexMapper.addLocalHook("cacheUpdated", onIndexMapperCacheUpdate);
  this.rowIndexMapper.addLocalHook("cacheUpdated", onIndexMapperCacheUpdate);
  this.selection.addLocalHook("beforeSetRangeStart", function(cellCoords) {
    _this.runHooks("beforeSetRangeStart", cellCoords);
  });
  this.selection.addLocalHook("beforeSetRangeStartOnly", function(cellCoords) {
    _this.runHooks("beforeSetRangeStartOnly", cellCoords);
  });
  this.selection.addLocalHook("beforeSetRangeEnd", function(cellCoords) {
    _this.runHooks("beforeSetRangeEnd", cellCoords);
    if (cellCoords.row < 0) {
      cellCoords.row = _this.view.wt.wtTable.getFirstVisibleRow();
    }
    if (cellCoords.col < 0) {
      cellCoords.col = _this.view.wt.wtTable.getFirstVisibleColumn();
    }
  });
  this.selection.addLocalHook("afterSetRangeEnd", function(cellCoords) {
    var preventScrolling = createObjectPropListener(false);
    var selectionRange = _this.selection.getSelectedRange();
    var _selectionRange$curre = selectionRange.current(), from = _selectionRange$curre.from, to = _selectionRange$curre.to;
    var selectionLayerLevel = selectionRange.size() - 1;
    _this.runHooks("afterSelection", from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);
    _this.runHooks("afterSelectionByProp", from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel);
    var isSelectedByAnyHeader = _this.selection.isSelectedByAnyHeader();
    var currentSelectedRange = _this.selection.selectedRange.current();
    var scrollToCell = true;
    if (preventScrollingToCell) {
      scrollToCell = false;
    }
    if (preventScrolling.isTouched()) {
      scrollToCell = !preventScrolling.value;
    }
    var isSelectedByRowHeader = _this.selection.isSelectedByRowHeader();
    var isSelectedByColumnHeader = _this.selection.isSelectedByColumnHeader();
    if (scrollToCell !== false) {
      if (!isSelectedByAnyHeader) {
        if (currentSelectedRange && !_this.selection.isMultiple()) {
          _this.view.scrollViewport(visualToRenderableCoords(currentSelectedRange.from));
        } else {
          _this.view.scrollViewport(visualToRenderableCoords(cellCoords));
        }
      } else if (isSelectedByRowHeader) {
        _this.view.scrollViewportVertically(instance.rowIndexMapper.getRenderableFromVisualIndex(cellCoords.row));
      } else if (isSelectedByColumnHeader) {
        _this.view.scrollViewportHorizontally(instance.columnIndexMapper.getRenderableFromVisualIndex(cellCoords.col));
      }
    }
    if (isSelectedByRowHeader && isSelectedByColumnHeader) {
      addClass(_this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    } else if (isSelectedByRowHeader) {
      removeClass(_this.rootElement, "ht__selection--columns");
      addClass(_this.rootElement, "ht__selection--rows");
    } else if (isSelectedByColumnHeader) {
      removeClass(_this.rootElement, "ht__selection--rows");
      addClass(_this.rootElement, "ht__selection--columns");
    } else {
      removeClass(_this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    }
    _this._refreshBorders(null);
  });
  this.selection.addLocalHook("afterSelectionFinished", function(cellRanges) {
    var selectionLayerLevel = cellRanges.length - 1;
    var _cellRanges$selection = cellRanges[selectionLayerLevel], from = _cellRanges$selection.from, to = _cellRanges$selection.to;
    _this.runHooks("afterSelectionEnd", from.row, from.col, to.row, to.col, selectionLayerLevel);
    _this.runHooks("afterSelectionEndByProp", from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);
  });
  this.selection.addLocalHook("afterIsMultipleSelection", function(isMultiple) {
    var changedIsMultiple = _this.runHooks("afterIsMultipleSelection", isMultiple.value);
    if (isMultiple.value) {
      isMultiple.value = changedIsMultiple;
    }
  });
  this.selection.addLocalHook("beforeModifyTransformStart", function(cellCoordsDelta) {
    _this.runHooks("modifyTransformStart", cellCoordsDelta);
  });
  this.selection.addLocalHook("afterModifyTransformStart", function(coords, rowTransformDir, colTransformDir) {
    _this.runHooks("afterModifyTransformStart", coords, rowTransformDir, colTransformDir);
  });
  this.selection.addLocalHook("beforeModifyTransformEnd", function(cellCoordsDelta) {
    _this.runHooks("modifyTransformEnd", cellCoordsDelta);
  });
  this.selection.addLocalHook("afterModifyTransformEnd", function(coords, rowTransformDir, colTransformDir) {
    _this.runHooks("afterModifyTransformEnd", coords, rowTransformDir, colTransformDir);
  });
  this.selection.addLocalHook("afterDeselect", function() {
    editorManager.destroyEditor();
    _this._refreshBorders();
    removeClass(_this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    _this.runHooks("afterDeselect");
  });
  this.selection.addLocalHook("insertRowRequire", function(totalRows) {
    _this.alter("insert_row", totalRows, 1, "auto");
  });
  this.selection.addLocalHook("insertColRequire", function(totalCols) {
    _this.alter("insert_col", totalCols, 1, "auto");
  });
  grid = {
    alter: function alter(action, index) {
      var amount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var source = arguments.length > 3 ? arguments[3] : void 0;
      var keepEmptyRows = arguments.length > 4 ? arguments[4] : void 0;
      var delta;
      var normalizeIndexesGroup = function normalizeIndexesGroup2(indexes) {
        if (indexes.length === 0) {
          return [];
        }
        var sortedIndexes = _toConsumableArray$h(indexes);
        sortedIndexes.sort(function(_ref2, _ref3) {
          var _ref4 = _slicedToArray$c(_ref2, 1), indexA = _ref4[0];
          var _ref5 = _slicedToArray$c(_ref3, 1), indexB = _ref5[0];
          if (indexA === indexB) {
            return 0;
          }
          return indexA > indexB ? 1 : -1;
        });
        var normalizedIndexes = arrayReduce(sortedIndexes, function(acc, _ref6) {
          var _ref7 = _slicedToArray$c(_ref6, 2), groupIndex = _ref7[0], groupAmount = _ref7[1];
          var previousItem = acc[acc.length - 1];
          var _previousItem = _slicedToArray$c(previousItem, 2), prevIndex = _previousItem[0], prevAmount = _previousItem[1];
          var prevLastIndex = prevIndex + prevAmount;
          if (groupIndex <= prevLastIndex) {
            var amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);
            previousItem[1] += amountToAdd;
          } else {
            acc.push([groupIndex, groupAmount]);
          }
          return acc;
        }, [sortedIndexes[0]]);
        return normalizedIndexes;
      };
      switch (action) {
        case "insert_row":
          var numberOfSourceRows = instance.countSourceRows();
          if (tableMeta.maxRows === numberOfSourceRows) {
            return;
          }
          index = isDefined(index) ? index : numberOfSourceRows;
          delta = datamap.createRow(index, amount, source);
          if (delta) {
            metaManager.createRow(instance.toPhysicalRow(index), amount);
            var currentSelectedRange = selection.selectedRange.current();
            var currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;
            var currentFromRow = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.row;
            if (isDefined(currentFromRow) && currentFromRow >= index) {
              var _currentSelectedRange = currentSelectedRange.to, currentToRow = _currentSelectedRange.row, currentToColumn = _currentSelectedRange.col;
              var currentFromColumn = currentFromRange.col;
              if (selection.isSelectedByRowHeader()) {
                currentFromColumn = -1;
              }
              selection.getSelectedRange().pop();
              selection.setRangeStartOnly(new CellCoords(currentFromRow + delta, currentFromColumn), true);
              selection.setRangeEnd(new CellCoords(currentToRow + delta, currentToColumn));
            } else {
              instance._refreshBorders();
            }
          }
          break;
        case "insert_col":
          delta = datamap.createCol(index, amount, source);
          if (delta) {
            metaManager.createColumn(instance.toPhysicalColumn(index), amount);
            if (Array.isArray(tableMeta.colHeaders)) {
              var spliceArray = [index, 0];
              spliceArray.length += delta;
              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray);
            }
            var _currentSelectedRange2 = selection.selectedRange.current();
            var _currentFromRange = _currentSelectedRange2 === null || _currentSelectedRange2 === void 0 ? void 0 : _currentSelectedRange2.from;
            var _currentFromColumn = _currentFromRange === null || _currentFromRange === void 0 ? void 0 : _currentFromRange.col;
            if (isDefined(_currentFromColumn) && _currentFromColumn >= index) {
              var _currentSelectedRange3 = _currentSelectedRange2.to, _currentToRow = _currentSelectedRange3.row, _currentToColumn = _currentSelectedRange3.col;
              var _currentFromRow = _currentFromRange.row;
              if (selection.isSelectedByColumnHeader()) {
                _currentFromRow = -1;
              }
              selection.getSelectedRange().pop();
              selection.setRangeStartOnly(new CellCoords(_currentFromRow, _currentFromColumn + delta), true);
              selection.setRangeEnd(new CellCoords(_currentToRow, _currentToColumn + delta));
            } else {
              instance._refreshBorders();
            }
          }
          break;
        case "remove_row":
          var removeRow = function removeRow2(indexes) {
            var offset = 0;
            arrayEach(indexes, function(_ref8) {
              var _ref9 = _slicedToArray$c(_ref8, 2), groupIndex = _ref9[0], groupAmount = _ref9[1];
              var calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0);
              if (Number.isInteger(groupIndex)) {
                groupIndex = Math.max(groupIndex - offset, 0);
              }
              var wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);
              if (!wasRemoved) {
                return;
              }
              metaManager.removeRow(instance.toPhysicalRow(calcIndex), groupAmount);
              var totalRows = instance.countRows();
              var fixedRowsTop = tableMeta.fixedRowsTop;
              if (fixedRowsTop >= calcIndex + 1) {
                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);
              }
              var fixedRowsBottom = tableMeta.fixedRowsBottom;
              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {
                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);
              }
              offset += groupAmount;
            });
          };
          if (Array.isArray(index)) {
            removeRow(normalizeIndexesGroup(index));
          } else {
            removeRow([[index, amount]]);
          }
          grid.adjustRowsAndCols();
          instance._refreshBorders();
          break;
        case "remove_col":
          var removeCol = function removeCol2(indexes) {
            var offset = 0;
            arrayEach(indexes, function(_ref10) {
              var _ref11 = _slicedToArray$c(_ref10, 2), groupIndex = _ref11[0], groupAmount = _ref11[1];
              var calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);
              var physicalColumnIndex = instance.toPhysicalColumn(calcIndex);
              if (Number.isInteger(groupIndex)) {
                groupIndex = Math.max(groupIndex - offset, 0);
              }
              var wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);
              if (!wasRemoved) {
                return;
              }
              metaManager.removeColumn(physicalColumnIndex, groupAmount);
              var fixedColumnsLeft = tableMeta.fixedColumnsLeft;
              if (fixedColumnsLeft >= calcIndex + 1) {
                tableMeta.fixedColumnsLeft -= Math.min(groupAmount, fixedColumnsLeft - calcIndex);
              }
              if (Array.isArray(tableMeta.colHeaders)) {
                if (typeof physicalColumnIndex === "undefined") {
                  physicalColumnIndex = -1;
                }
                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);
              }
              offset += groupAmount;
            });
          };
          if (Array.isArray(index)) {
            removeCol(normalizeIndexesGroup(index));
          } else {
            removeCol([[index, amount]]);
          }
          grid.adjustRowsAndCols();
          instance._refreshBorders();
          break;
        default:
          throw new Error('There is no such action "'.concat(action, '"'));
      }
      if (!keepEmptyRows) {
        grid.adjustRowsAndCols();
      }
    },
    adjustRowsAndCols: function adjustRowsAndCols() {
      var minRows = tableMeta.minRows;
      var minSpareRows = tableMeta.minSpareRows;
      var minCols = tableMeta.minCols;
      var minSpareCols = tableMeta.minSpareCols;
      if (minRows) {
        var nrOfRows = instance.countRows();
        if (nrOfRows < minRows) {
          datamap.createRow(nrOfRows, minRows - nrOfRows, "auto");
        }
      }
      if (minSpareRows) {
        var emptyRows = instance.countEmptyRows(true);
        if (emptyRows < minSpareRows) {
          var emptyRowsMissing = minSpareRows - emptyRows;
          var rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows());
          datamap.createRow(instance.countRows(), rowsToCreate, "auto");
        }
      }
      {
        var emptyCols;
        if (minCols || minSpareCols) {
          emptyCols = instance.countEmptyCols(true);
        }
        var nrOfColumns = instance.countCols();
        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {
          var colsToCreate = minCols - nrOfColumns;
          emptyCols += colsToCreate;
          datamap.createCol(nrOfColumns, colsToCreate, "auto");
        }
        if (minSpareCols && !tableMeta.columns && instance.dataType === "array" && emptyCols < minSpareCols) {
          nrOfColumns = instance.countCols();
          var emptyColsMissing = minSpareCols - emptyCols;
          var _colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns);
          datamap.createCol(nrOfColumns, _colsToCreate, "auto");
        }
      }
      var rowCount = instance.countRows();
      var colCount = instance.countCols();
      if (rowCount === 0 || colCount === 0) {
        selection.deselect();
      }
      if (selection.isSelected()) {
        arrayEach(selection.selectedRange, function(range) {
          var selectionChanged = false;
          var fromRow = range.from.row;
          var fromCol = range.from.col;
          var toRow = range.to.row;
          var toCol = range.to.col;
          if (fromRow > rowCount - 1) {
            fromRow = rowCount - 1;
            selectionChanged = true;
            if (toRow > fromRow) {
              toRow = fromRow;
            }
          } else if (toRow > rowCount - 1) {
            toRow = rowCount - 1;
            selectionChanged = true;
            if (fromRow > toRow) {
              fromRow = toRow;
            }
          }
          if (fromCol > colCount - 1) {
            fromCol = colCount - 1;
            selectionChanged = true;
            if (toCol > fromCol) {
              toCol = fromCol;
            }
          } else if (toCol > colCount - 1) {
            toCol = colCount - 1;
            selectionChanged = true;
            if (fromCol > toCol) {
              fromCol = toCol;
            }
          }
          if (selectionChanged) {
            instance.selectCell(fromRow, fromCol, toRow, toCol);
          }
        });
      }
      if (instance.view) {
        instance.view.adjustElementsSize();
      }
    },
    populateFromArray: function populateFromArray(start, input, end, source, method, direction, deltas) {
      var r;
      var rlen;
      var c;
      var clen;
      var setData = [];
      var current = {};
      rlen = input.length;
      if (rlen === 0) {
        return false;
      }
      var repeatCol;
      var repeatRow;
      var cmax;
      var rmax;
      switch (method) {
        case "shift_down":
          repeatCol = end ? end.col - start.col + 1 : 0;
          repeatRow = end ? end.row - start.row + 1 : 0;
          input = translateRowsToColumns(input);
          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {
            if (c < clen) {
              var _instance;
              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {
                input[c].push(input[c][r % rlen]);
              }
              input[c].unshift(start.col + c, start.row, 0);
              (_instance = instance).spliceCol.apply(_instance, _toConsumableArray$h(input[c]));
            } else {
              var _instance2;
              input[c % clen][0] = start.col + c;
              (_instance2 = instance).spliceCol.apply(_instance2, _toConsumableArray$h(input[c % clen]));
            }
          }
          break;
        case "shift_right":
          repeatCol = end ? end.col - start.col + 1 : 0;
          repeatRow = end ? end.row - start.row + 1 : 0;
          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {
            if (r < rlen) {
              var _instance3;
              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {
                input[r].push(input[r][c % clen]);
              }
              input[r].unshift(start.row + r, start.col, 0);
              (_instance3 = instance).spliceRow.apply(_instance3, _toConsumableArray$h(input[r]));
            } else {
              var _instance4;
              input[r % rlen][0] = start.row + r;
              (_instance4 = instance).spliceRow.apply(_instance4, _toConsumableArray$h(input[r % rlen]));
            }
          }
          break;
        case "overwrite":
        default:
          current.row = start.row;
          current.col = start.col;
          var selected = {
            row: end && start ? end.row - start.row + 1 : 1,
            col: end && start ? end.col - start.col + 1 : 1
          };
          var skippedRow = 0;
          var skippedColumn = 0;
          var pushData = true;
          var cellMeta;
          var getInputValue = function getInputValue2(row) {
            var col = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var rowValue = input[row % input.length];
            if (col !== null) {
              return rowValue[col % rowValue.length];
            }
            return rowValue;
          };
          var rowInputLength = input.length;
          var rowSelectionLength = end ? end.row - start.row + 1 : 0;
          if (end) {
            rlen = rowSelectionLength;
          } else {
            rlen = Math.max(rowInputLength, rowSelectionLength);
          }
          for (r = 0; r < rlen; r++) {
            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {
              break;
            }
            var visualRow = r - skippedRow;
            var colInputLength = getInputValue(visualRow).length;
            var colSelectionLength = end ? end.col - start.col + 1 : 0;
            if (end) {
              clen = colSelectionLength;
            } else {
              clen = Math.max(colInputLength, colSelectionLength);
            }
            current.col = start.col;
            cellMeta = instance.getCellMeta(current.row, current.col);
            if ((source === "CopyPaste.paste" || source === "Autofill.fill") && cellMeta.skipRowOnPaste) {
              skippedRow += 1;
              current.row += 1;
              rlen += 1;
              continue;
            }
            skippedColumn = 0;
            for (c = 0; c < clen; c++) {
              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {
                break;
              }
              cellMeta = instance.getCellMeta(current.row, current.col);
              if ((source === "CopyPaste.paste" || source === "Autofill.fill") && cellMeta.skipColumnOnPaste) {
                skippedColumn += 1;
                current.col += 1;
                clen += 1;
                continue;
              }
              if (cellMeta.readOnly && source !== "UndoRedo.undo") {
                current.col += 1;
                continue;
              }
              var visualColumn = c - skippedColumn;
              var value = getInputValue(visualRow, visualColumn);
              var orgValue = instance.getDataAtCell(current.row, current.col);
              var index = {
                row: visualRow,
                col: visualColumn
              };
              if (source === "Autofill.fill") {
                var result = instance.runHooks("beforeAutofillInsidePopulate", index, direction, input, deltas, {}, selected);
                if (result) {
                  value = isUndefined$1(result.value) ? value : result.value;
                }
              }
              if (value !== null && _typeof$A(value) === "object") {
                if (Array.isArray(value) && orgValue === null)
                  orgValue = [];
                if (orgValue === null || _typeof$A(orgValue) !== "object") {
                  pushData = false;
                } else {
                  var orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);
                  var valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);
                  if (isObjectEqual(orgValueSchema, valueSchema)) {
                    value = deepClone(value);
                  } else {
                    pushData = false;
                  }
                }
              } else if (orgValue !== null && _typeof$A(orgValue) === "object") {
                pushData = false;
              }
              if (pushData) {
                setData.push([current.row, current.col, value]);
              }
              pushData = true;
              current.col += 1;
            }
            current.row += 1;
          }
          instance.setDataAtCell(setData, null, null, source || "populateFromArray");
          break;
      }
    }
  };
  function setLanguage(languageCode) {
    var normalizedLanguageCode = normalizeLanguageCode(languageCode);
    if (hasLanguageDictionary(normalizedLanguageCode)) {
      instance.runHooks("beforeLanguageChange", normalizedLanguageCode);
      globalMeta.language = normalizedLanguageCode;
      instance.runHooks("afterLanguageChange", normalizedLanguageCode);
    } else {
      warnUserAboutLanguageRegistration(languageCode);
    }
  }
  function setClassName(className, classSettings) {
    var element = className === "className" ? instance.rootElement : instance.table;
    if (firstRun) {
      addClass(element, classSettings);
    } else {
      var globalMetaSettingsArray = [];
      var settingsArray = [];
      if (globalMeta[className]) {
        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : stringToArray(globalMeta[className]);
      }
      if (classSettings) {
        settingsArray = Array.isArray(classSettings) ? classSettings : stringToArray(classSettings);
      }
      var classNameToRemove = getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);
      var classNameToAdd = getDifferenceOfArrays(settingsArray, globalMetaSettingsArray);
      if (classNameToRemove.length) {
        removeClass(element, classNameToRemove);
      }
      if (classNameToAdd.length) {
        addClass(element, classNameToAdd);
      }
    }
    globalMeta[className] = classSettings;
  }
  this.init = function() {
    dataSource.setData(tableMeta.data);
    instance.runHooks("beforeInit");
    if (isMobileBrowser() || isIpadOS()) {
      addClass(instance.rootElement, "mobile");
    }
    this.updateSettings(tableMeta, true);
    this.view = new TableView(this);
    editorManager = EditorManager.getInstance(instance, tableMeta, selection);
    instance.runHooks("init");
    this.forceFullRender = true;
    this.view.render();
    if (_typeof$A(firstRun) === "object") {
      instance.runHooks("afterChange", firstRun[0], firstRun[1]);
      firstRun = false;
    }
    instance.runHooks("afterInit");
  };
  function ValidatorsQueue() {
    var resolved = false;
    return {
      validatorsInQueue: 0,
      valid: true,
      addValidatorToQueue: function addValidatorToQueue() {
        this.validatorsInQueue += 1;
        resolved = false;
      },
      removeValidatorFormQueue: function removeValidatorFormQueue() {
        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;
        this.checkIfQueueIsEmpty();
      },
      onQueueEmpty: function onQueueEmpty() {
      },
      checkIfQueueIsEmpty: function checkIfQueueIsEmpty() {
        if (this.validatorsInQueue === 0 && resolved === false) {
          resolved = true;
          this.onQueueEmpty(this.valid);
        }
      }
    };
  }
  function getParsedNumber(numericData) {
    var unifiedNumericData = numericData.replace(",", ".");
    if (isNaN(parseFloat(unifiedNumericData)) === false) {
      return parseFloat(unifiedNumericData);
    }
    return numericData;
  }
  function validateChanges(changes, source, callback) {
    if (!changes.length) {
      return;
    }
    var activeEditor = instance.getActiveEditor();
    var beforeChangeResult = instance.runHooks("beforeChange", changes, source || "edit");
    var shouldBeCanceled = true;
    if (beforeChangeResult === false) {
      if (activeEditor) {
        activeEditor.cancelChanges();
      }
      return;
    }
    var waitingForValidator = new ValidatorsQueue();
    var isNumericData = function isNumericData2(value) {
      return value.length > 0 && /^\s*[+-.]?\s*(?:(?:\d+(?:(\.|,)\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/.test(value);
    };
    waitingForValidator.onQueueEmpty = function(isValid) {
      if (activeEditor && shouldBeCanceled) {
        activeEditor.cancelChanges();
      }
      callback(isValid);
    };
    for (var i = changes.length - 1; i >= 0; i--) {
      if (changes[i] === null) {
        changes.splice(i, 1);
      } else {
        var _changes$i = _slicedToArray$c(changes[i], 4), row = _changes$i[0], prop = _changes$i[1], newValue = _changes$i[3];
        var col = datamap.propToCol(prop);
        var cellProperties = instance.getCellMeta(row, col);
        if (cellProperties.type === "numeric" && typeof newValue === "string" && isNumericData(newValue)) {
          changes[i][3] = getParsedNumber(newValue);
        }
        if (instance.getCellValidator(cellProperties)) {
          waitingForValidator.addValidatorToQueue();
          instance.validateCell(changes[i][3], cellProperties, function(index, cellPropertiesReference) {
            return function(result) {
              if (typeof result !== "boolean") {
                throw new Error("Validation error: result is not boolean");
              }
              if (result === false && cellPropertiesReference.allowInvalid === false) {
                shouldBeCanceled = false;
                changes.splice(index, 1);
                cellPropertiesReference.valid = true;
                var cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);
                if (cell !== null) {
                  removeClass(cell, tableMeta.invalidCellClassName);
                }
              }
              waitingForValidator.removeValidatorFormQueue();
            };
          }(i, cellProperties), source);
        }
      }
    }
    waitingForValidator.checkIfQueueIsEmpty();
  }
  function applyChanges(changes, source) {
    var i = changes.length - 1;
    if (i < 0) {
      return;
    }
    for (; i >= 0; i--) {
      var skipThisChange = false;
      if (changes[i] === null) {
        changes.splice(i, 1);
        continue;
      }
      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {
        continue;
      }
      if (tableMeta.allowInsertRow) {
        while (changes[i][0] > instance.countRows() - 1) {
          var numberOfCreatedRows = datamap.createRow(void 0, void 0, source);
          if (numberOfCreatedRows >= 1) {
            metaManager.createRow(null, numberOfCreatedRows);
          } else {
            skipThisChange = true;
            break;
          }
        }
      }
      if (instance.dataType === "array" && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {
        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {
          var numberOfCreatedColumns = datamap.createCol(void 0, void 0, source);
          if (numberOfCreatedColumns >= 1) {
            metaManager.createColumn(null, numberOfCreatedColumns);
          } else {
            skipThisChange = true;
            break;
          }
        }
      }
      if (skipThisChange) {
        continue;
      }
      datamap.set(changes[i][0], changes[i][1], changes[i][3]);
    }
    instance.forceFullRender = true;
    grid.adjustRowsAndCols();
    instance.runHooks("beforeChangeRender", changes, source);
    editorManager.lockEditor();
    instance._refreshBorders(null);
    editorManager.unlockEditor();
    instance.view.adjustElementsSize();
    instance.runHooks("afterChange", changes, source || "edit");
    var activeEditor = instance.getActiveEditor();
    if (activeEditor && isDefined(activeEditor.refreshValue)) {
      activeEditor.refreshValue();
    }
  }
  this.validateCell = function(value, cellProperties, callback, source) {
    var validator = instance.getCellValidator(cellProperties);
    function done(valid) {
      var canBeValidated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (!canBeValidated || cellProperties.hidden === true) {
        callback(valid);
        return;
      }
      var col = cellProperties.visualCol;
      var row = cellProperties.visualRow;
      var td = instance.getCell(row, col, true);
      if (td && td.nodeName !== "TH") {
        var renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);
        var renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);
        instance.view.wt.wtSettings.settings.cellRenderer(renderableRow, renderableColumn, td);
      }
      callback(valid);
    }
    if (isRegExp(validator)) {
      validator = function(expression) {
        return function(cellValue, validatorCallback) {
          validatorCallback(expression.test(cellValue));
        };
      }(validator);
    }
    if (isFunction$1(validator)) {
      value = instance.runHooks("beforeValidate", value, cellProperties.visualRow, cellProperties.prop, source);
      instance._registerImmediate(function() {
        validator.call(cellProperties, value, function(valid) {
          if (!instance) {
            return;
          }
          valid = instance.runHooks("afterValidate", valid, value, cellProperties.visualRow, cellProperties.prop, source);
          cellProperties.valid = valid;
          done(valid);
          instance.runHooks("postAfterValidate", valid, value, cellProperties.visualRow, cellProperties.prop, source);
        });
      });
    } else {
      instance._registerImmediate(function() {
        cellProperties.valid = true;
        done(cellProperties.valid, false);
      });
    }
  };
  function setDataInputToArray(row, propOrCol, value) {
    if (Array.isArray(row)) {
      return row;
    }
    return [[row, propOrCol, value]];
  }
  this.setDataAtCell = function(row, column, value, source) {
    var input = setDataInputToArray(row, column, value);
    var changes = [];
    var changeSource = source;
    var i;
    var ilen;
    var prop;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      if (_typeof$A(input[i]) !== "object") {
        throw new Error("Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter");
      }
      if (typeof input[i][1] !== "number") {
        throw new Error("Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`");
      }
      if (input[i][1] >= this.countCols()) {
        prop = input[i][1];
      } else {
        prop = datamap.colToProp(input[i][1]);
      }
      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }
    if (!changeSource && _typeof$A(row) === "object") {
      changeSource = column;
    }
    instance.runHooks("afterSetDataAtCell", changes, changeSource);
    validateChanges(changes, changeSource, function() {
      applyChanges(changes, changeSource);
    });
  };
  this.setDataAtRowProp = function(row, prop, value, source) {
    var input = setDataInputToArray(row, prop, value);
    var changes = [];
    var changeSource = source;
    var i;
    var ilen;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }
    if (!changeSource && _typeof$A(row) === "object") {
      changeSource = prop;
    }
    instance.runHooks("afterSetDataAtRowProp", changes, changeSource);
    validateChanges(changes, changeSource, function() {
      applyChanges(changes, changeSource);
    });
  };
  this.listen = function() {
    if (instance && !instance.isListening()) {
      activeGuid = instance.guid;
      instance.runHooks("afterListen");
    }
  };
  this.unlisten = function() {
    if (this.isListening()) {
      activeGuid = null;
      instance.runHooks("afterUnlisten");
    }
  };
  this.isListening = function() {
    return activeGuid === instance.guid;
  };
  this.destroyEditor = function() {
    var revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);
  };
  this.populateFromArray = function(row, column, input, endRow, endCol, source, method, direction, deltas) {
    if (!(_typeof$A(input) === "object" && _typeof$A(input[0]) === "object")) {
      throw new Error("populateFromArray parameter `input` must be an array of arrays");
    }
    var c = typeof endRow === "number" ? new CellCoords(endRow, endCol) : null;
    return grid.populateFromArray(new CellCoords(row, column), input, c, source, method, direction, deltas);
  };
  this.spliceCol = function(column, index, amount) {
    var _datamap;
    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      elements[_key - 3] = arguments[_key];
    }
    return (_datamap = datamap).spliceCol.apply(_datamap, [column, index, amount].concat(elements));
  };
  this.spliceRow = function(row, index, amount) {
    var _datamap2;
    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      elements[_key2 - 3] = arguments[_key2];
    }
    return (_datamap2 = datamap).spliceRow.apply(_datamap2, [row, index, amount].concat(elements));
  };
  this.getSelected = function() {
    if (selection.isSelected()) {
      return arrayMap(selection.getSelectedRange(), function(_ref12) {
        var from = _ref12.from, to = _ref12.to;
        return [from.row, from.col, to.row, to.col];
      });
    }
  };
  this.getSelectedLast = function() {
    var selected = this.getSelected();
    var result;
    if (selected && selected.length > 0) {
      result = selected[selected.length - 1];
    }
    return result;
  };
  this.getSelectedRange = function() {
    if (selection.isSelected()) {
      return Array.from(selection.getSelectedRange());
    }
  };
  this.getSelectedRangeLast = function() {
    var selectedRange = this.getSelectedRange();
    var result;
    if (selectedRange && selectedRange.length > 0) {
      result = selectedRange[selectedRange.length - 1];
    }
    return result;
  };
  this.emptySelectedCells = function(source) {
    var _this2 = this;
    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {
      return;
    }
    var changes = [];
    arrayEach(selection.getSelectedRange(), function(cellRange) {
      var topLeft = cellRange.getTopLeftCorner();
      var bottomRight = cellRange.getBottomRightCorner();
      rangeEach(topLeft.row, bottomRight.row, function(row) {
        rangeEach(topLeft.col, bottomRight.col, function(column) {
          if (!_this2.getCellMeta(row, column).readOnly) {
            changes.push([row, column, null]);
          }
        });
      });
    });
    if (changes.length > 0) {
      this.setDataAtCell(changes, source);
    }
  };
  this.isRenderSuspended = function() {
    return this.renderSuspendedCounter > 0;
  };
  this.suspendRender = function() {
    this.renderSuspendedCounter += 1;
  };
  this.resumeRender = function() {
    var nextValue = this.renderSuspendedCounter - 1;
    this.renderSuspendedCounter = Math.max(nextValue, 0);
    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {
      if (this.renderCall) {
        this.render();
      } else {
        this._refreshBorders(null);
      }
    }
  };
  this.render = function() {
    if (this.view) {
      this.renderCall = true;
      this.forceFullRender = true;
      if (!this.isRenderSuspended()) {
        editorManager.lockEditor();
        this._refreshBorders(null);
        editorManager.unlockEditor();
      }
    }
  };
  this.batchRender = function(wrappedOperations) {
    this.suspendRender();
    var result = wrappedOperations();
    this.resumeRender();
    return result;
  };
  this.isExecutionSuspended = function() {
    return this.executionSuspendedCounter > 0;
  };
  this.suspendExecution = function() {
    this.executionSuspendedCounter += 1;
    this.columnIndexMapper.suspendOperations();
    this.rowIndexMapper.suspendOperations();
  };
  this.resumeExecution = function() {
    var forceFlushChanges = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var nextValue = this.executionSuspendedCounter - 1;
    this.executionSuspendedCounter = Math.max(nextValue, 0);
    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {
      this.columnIndexMapper.resumeOperations();
      this.rowIndexMapper.resumeOperations();
    }
  };
  this.batchExecution = function(wrappedOperations) {
    var forceFlushChanges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    this.suspendExecution();
    var result = wrappedOperations();
    this.resumeExecution(forceFlushChanges);
    return result;
  };
  this.batch = function(wrappedOperations) {
    this.suspendRender();
    this.suspendExecution();
    var result = wrappedOperations();
    this.resumeExecution();
    this.resumeRender();
    return result;
  };
  this.refreshDimensions = function() {
    if (!instance.view) {
      return;
    }
    var _instance$view$getLas = instance.view.getLastSize(), lastWidth = _instance$view$getLas.width, lastHeight = _instance$view$getLas.height;
    var _instance$rootElement = instance.rootElement.getBoundingClientRect(), width = _instance$rootElement.width, height = _instance$rootElement.height;
    var isSizeChanged = width !== lastWidth || height !== lastHeight;
    var isResizeBlocked = instance.runHooks("beforeRefreshDimensions", {
      width: lastWidth,
      height: lastHeight
    }, {
      width,
      height
    }, isSizeChanged) === false;
    if (isResizeBlocked) {
      return;
    }
    if (isSizeChanged || instance.view.wt.wtOverlays.scrollableElement === instance.rootWindow) {
      instance.view.setLastSize(width, height);
      instance.render();
    }
    instance.runHooks("afterRefreshDimensions", {
      width: lastWidth,
      height: lastHeight
    }, {
      width,
      height
    }, isSizeChanged);
  };
  this.loadData = function(data, source) {
    if (Array.isArray(tableMeta.dataSchema)) {
      instance.dataType = "array";
    } else if (isFunction$1(tableMeta.dataSchema)) {
      instance.dataType = "function";
    } else {
      instance.dataType = "object";
    }
    if (datamap) {
      datamap.destroy();
    }
    data = instance.runHooks("beforeLoadData", data, firstRun, source);
    datamap = new DataMap(instance, data, tableMeta);
    if (_typeof$A(data) === "object" && data !== null) {
      if (!(data.push && data.splice)) {
        data = [data];
      }
    } else if (data === null) {
      var dataSchema = datamap.getSchema();
      data = [];
      var row;
      var r = 0;
      var rlen = 0;
      for (r = 0, rlen = tableMeta.startRows; r < rlen; r++) {
        if ((instance.dataType === "object" || instance.dataType === "function") && tableMeta.dataSchema) {
          row = deepClone(dataSchema);
          data.push(row);
        } else if (instance.dataType === "array") {
          row = deepClone(dataSchema[0]);
          data.push(row);
        } else {
          row = [];
          for (var c = 0, clen = tableMeta.startCols; c < clen; c++) {
            row.push(null);
          }
          data.push(row);
        }
      }
    } else {
      throw new Error("loadData only accepts array of objects or array of arrays (".concat(_typeof$A(data), " given)"));
    }
    if (Array.isArray(data[0])) {
      instance.dataType = "array";
    }
    tableMeta.data = data;
    datamap.dataSource = data;
    dataSource.data = data;
    dataSource.dataType = instance.dataType;
    dataSource.colToProp = datamap.colToProp.bind(datamap);
    dataSource.propToCol = datamap.propToCol.bind(datamap);
    dataSource.countCachedColumns = datamap.countCachedColumns.bind(datamap);
    metaManager.clearCellsCache();
    instance.initIndexMappers();
    grid.adjustRowsAndCols();
    instance.runHooks("afterLoadData", data, firstRun, source);
    if (firstRun) {
      firstRun = [null, "loadData"];
    } else {
      instance.runHooks("afterChange", null, "loadData");
      instance.render();
    }
  };
  this.initIndexMappers = function() {
    var columnsSettings = tableMeta.columns;
    var finalNrOfColumns = 0;
    if (Array.isArray(columnsSettings)) {
      finalNrOfColumns = columnsSettings.length;
    } else if (isFunction$1(columnsSettings)) {
      if (instance.dataType === "array") {
        var nrOfSourceColumns = this.countSourceCols();
        for (var columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {
          if (columnsSettings(columnIndex)) {
            finalNrOfColumns += 1;
          }
        }
      } else if (instance.dataType === "object" || instance.dataType === "function") {
        finalNrOfColumns = datamap.colToPropCache.length;
      }
    } else if (isDefined(tableMeta.dataSchema)) {
      var schema = datamap.getSchema();
      finalNrOfColumns = Array.isArray(schema) ? schema.length : deepObjectSize(schema);
    } else {
      finalNrOfColumns = this.countSourceCols();
    }
    this.columnIndexMapper.initToLength(finalNrOfColumns);
    this.rowIndexMapper.initToLength(this.countSourceRows());
  };
  this.getData = function(row, column, row2, column2) {
    if (isUndefined$1(row)) {
      return datamap.getAll();
    }
    return datamap.getRange(new CellCoords(row, column), new CellCoords(row2, column2), datamap.DESTINATION_RENDERER);
  };
  this.getCopyableText = function(startRow, startCol, endRow, endCol) {
    return datamap.getCopyableText(new CellCoords(startRow, startCol), new CellCoords(endRow, endCol));
  };
  this.getCopyableData = function(row, column) {
    return datamap.getCopyable(row, datamap.colToProp(column));
  };
  this.getSchema = function() {
    return datamap.getSchema();
  };
  this.updateSettings = function(settings) {
    var init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var columnsAsFunc = false;
    var i;
    var j;
    if (isDefined(settings.rows)) {
      throw new Error('The "rows" setting is no longer supported. Do you mean startRows, minRows or maxRows?');
    }
    if (isDefined(settings.cols)) {
      throw new Error('The "cols" setting is no longer supported. Do you mean startCols, minCols or maxCols?');
    }
    if (isDefined(settings.ganttChart)) {
      throw new Error('Since 8.0.0 the "ganttChart" setting is no longer supported.');
    }
    for (i in settings) {
      if (i === "data") {
        continue;
      } else if (i === "language") {
        setLanguage(settings.language);
        continue;
      } else if (i === "className") {
        setClassName("className", settings.className);
      } else if (i === "tableClassName" && instance.table) {
        setClassName("tableClassName", settings.tableClassName);
        instance.view.wt.wtOverlays.syncOverlayTableClassNames();
      } else if (Hooks.getSingleton().isRegistered(i) || Hooks.getSingleton().isDeprecated(i)) {
        if (isFunction$1(settings[i]) || Array.isArray(settings[i])) {
          settings[i].initialHook = true;
          instance.addHook(i, settings[i]);
        }
      } else if (!init && hasOwnProperty(settings, i)) {
        globalMeta[i] = settings[i];
      }
    }
    if (settings.data === void 0 && tableMeta.data === void 0) {
      instance.loadData(null, "updateSettings");
    } else if (settings.data !== void 0) {
      instance.loadData(settings.data, "updateSettings");
    } else if (settings.columns !== void 0) {
      datamap.createMap();
      instance.initIndexMappers();
    }
    var clen = instance.countCols();
    var columnSetting = tableMeta.columns;
    if (columnSetting && isFunction$1(columnSetting)) {
      columnsAsFunc = true;
    }
    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {
      metaManager.clearCache();
    }
    if (clen > 0) {
      for (i = 0, j = 0; i < clen; i++) {
        if (columnSetting) {
          var column = columnsAsFunc ? columnSetting(i) : columnSetting[j];
          if (column) {
            metaManager.updateColumnMeta(j, column);
          }
        }
        j += 1;
      }
    }
    if (isDefined(settings.cell)) {
      objectEach(settings.cell, function(cell) {
        instance.setCellMetaObject(cell.row, cell.col, cell);
      });
    }
    instance.runHooks("afterCellMetaReset");
    var currentHeight = instance.rootElement.style.height;
    if (currentHeight !== "") {
      currentHeight = parseInt(instance.rootElement.style.height, 10);
    }
    var height = settings.height;
    if (isFunction$1(height)) {
      height = height();
    }
    if (init) {
      var initialStyle = instance.rootElement.getAttribute("style");
      if (initialStyle) {
        instance.rootElement.setAttribute("data-initialstyle", instance.rootElement.getAttribute("style"));
      }
    }
    if (height === null) {
      var _initialStyle = instance.rootElement.getAttribute("data-initialstyle");
      if (_initialStyle && (_initialStyle.indexOf("height") > -1 || _initialStyle.indexOf("overflow") > -1)) {
        instance.rootElement.setAttribute("style", _initialStyle);
      } else {
        instance.rootElement.style.height = "";
        instance.rootElement.style.overflow = "";
      }
    } else if (height !== void 0) {
      instance.rootElement.style.height = isNaN(height) ? "".concat(height) : "".concat(height, "px");
      instance.rootElement.style.overflow = "hidden";
    }
    if (typeof settings.width !== "undefined") {
      var width = settings.width;
      if (isFunction$1(width)) {
        width = width();
      }
      instance.rootElement.style.width = isNaN(width) ? "".concat(width) : "".concat(width, "px");
    }
    if (!init) {
      if (instance.view) {
        instance.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked();
        instance.view.wt.exportSettingsAsClassNames();
      }
      instance.runHooks("afterUpdateSettings", settings);
    }
    grid.adjustRowsAndCols();
    if (instance.view && !firstRun) {
      instance.forceFullRender = true;
      editorManager.lockEditor();
      instance._refreshBorders(null);
      editorManager.unlockEditor();
    }
    if (!init && instance.view && (currentHeight === "" || height === "" || height === void 0) && currentHeight !== height) {
      instance.view.wt.wtOverlays.updateMainScrollableElements();
    }
  };
  this.getValue = function() {
    var sel = instance.getSelectedLast();
    if (tableMeta.getValue) {
      if (isFunction$1(tableMeta.getValue)) {
        return tableMeta.getValue.call(instance);
      } else if (sel) {
        return instance.getData()[sel[0][0]][tableMeta.getValue];
      }
    } else if (sel) {
      return instance.getDataAtCell(sel[0], sel[1]);
    }
  };
  this.getSettings = function() {
    return tableMeta;
  };
  this.clear = function() {
    this.selectAll();
    this.emptySelectedCells();
  };
  this.alter = function(action, index, amount, source, keepEmptyRows) {
    grid.alter(action, index, amount, source, keepEmptyRows);
  };
  this.getCell = function(row, column) {
    var topmost = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var renderableColumnIndex = column;
    var renderableRowIndex = row;
    if (column >= 0) {
      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {
        return null;
      }
      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);
    }
    if (row >= 0) {
      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {
        return null;
      }
      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);
    }
    if (renderableRowIndex === null || renderableColumnIndex === null) {
      return null;
    }
    return instance.view.getCellAtCoords(new CellCoords(renderableRowIndex, renderableColumnIndex), topmost);
  };
  this.getCoords = function(element) {
    var renderableCoords = this.view.wt.wtTable.getCoords(element);
    if (renderableCoords === null) {
      return null;
    }
    var renderableRow = renderableCoords.row, renderableColumn = renderableCoords.col;
    var visualRow = renderableRow;
    var visualColumn = renderableColumn;
    if (renderableRow >= 0) {
      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);
    }
    if (renderableColumn >= 0) {
      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);
    }
    return new CellCoords(visualRow, visualColumn);
  };
  this.colToProp = function(column) {
    return datamap.colToProp(column);
  };
  this.propToCol = function(prop) {
    return datamap.propToCol(prop);
  };
  this.toVisualRow = function(row) {
    return _this.rowIndexMapper.getVisualFromPhysicalIndex(row);
  };
  this.toVisualColumn = function(column) {
    return _this.columnIndexMapper.getVisualFromPhysicalIndex(column);
  };
  this.toPhysicalRow = function(row) {
    return _this.rowIndexMapper.getPhysicalFromVisualIndex(row);
  };
  this.toPhysicalColumn = function(column) {
    return _this.columnIndexMapper.getPhysicalFromVisualIndex(column);
  };
  this.getDataAtCell = function(row, column) {
    return datamap.get(row, datamap.colToProp(column));
  };
  this.getDataAtRowProp = function(row, prop) {
    return datamap.get(row, prop);
  };
  this.getDataAtCol = function(column) {
    var _ref13;
    return (_ref13 = []).concat.apply(_ref13, _toConsumableArray$h(datamap.getRange(new CellCoords(0, column), new CellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER)));
  };
  this.getDataAtProp = function(prop) {
    var _ref14;
    var range = datamap.getRange(new CellCoords(0, datamap.propToCol(prop)), new CellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);
    return (_ref14 = []).concat.apply(_ref14, _toConsumableArray$h(range));
  };
  this.getSourceData = function(row, column, row2, column2) {
    var data;
    if (row === void 0) {
      data = dataSource.getData();
    } else {
      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2));
    }
    return data;
  };
  this.getSourceDataArray = function(row, column, row2, column2) {
    var data;
    if (row === void 0) {
      data = dataSource.getData(true);
    } else {
      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2), true);
    }
    return data;
  };
  this.getSourceDataAtCol = function(column) {
    return dataSource.getAtColumn(column);
  };
  this.setSourceDataAtCell = function(row, column, value, source) {
    var input = setDataInputToArray(row, column, value);
    var isThereAnySetSourceListener = this.hasHook("afterSetSourceDataAtCell");
    var changesForHook = [];
    if (isThereAnySetSourceListener) {
      arrayEach(input, function(_ref15) {
        var _ref16 = _slicedToArray$c(_ref15, 3), changeRow = _ref16[0], changeProp = _ref16[1], changeValue = _ref16[2];
        changesForHook.push([
          changeRow,
          changeProp,
          dataSource.getAtCell(changeRow, changeProp),
          changeValue
        ]);
      });
    }
    arrayEach(input, function(_ref17) {
      var _ref18 = _slicedToArray$c(_ref17, 3), changeRow = _ref18[0], changeProp = _ref18[1], changeValue = _ref18[2];
      dataSource.setAtCell(changeRow, changeProp, changeValue);
    });
    if (isThereAnySetSourceListener) {
      this.runHooks("afterSetSourceDataAtCell", changesForHook, source);
    }
    this.render();
    var activeEditor = instance.getActiveEditor();
    if (activeEditor && isDefined(activeEditor.refreshValue)) {
      activeEditor.refreshValue();
    }
  };
  this.getSourceDataAtRow = function(row) {
    return dataSource.getAtRow(row);
  };
  this.getSourceDataAtCell = function(row, column) {
    return dataSource.getAtCell(row, column);
  };
  this.getDataAtRow = function(row) {
    var data = datamap.getRange(new CellCoords(row, 0), new CellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);
    return data[0] || [];
  };
  this.getDataType = function(rowFrom, columnFrom, rowTo, columnTo) {
    var _this3 = this;
    var coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];
    var rowStart = coords[0], columnStart = coords[1];
    var rowEnd = coords[2], columnEnd = coords[3];
    var previousType = null;
    var currentType = null;
    if (rowEnd === void 0) {
      rowEnd = rowStart;
    }
    if (columnEnd === void 0) {
      columnEnd = columnStart;
    }
    var type = "mixed";
    rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), function(row) {
      var isTypeEqual = true;
      rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), function(column) {
        var cellType = _this3.getCellMeta(row, column);
        currentType = cellType.type;
        if (previousType) {
          isTypeEqual = previousType === currentType;
        } else {
          previousType = currentType;
        }
        return isTypeEqual;
      });
      type = isTypeEqual ? currentType : "mixed";
      return isTypeEqual;
    });
    return type;
  };
  this.removeCellMeta = function(row, column, key) {
    var _ref19 = [this.toPhysicalRow(row), this.toPhysicalColumn(column)], physicalRow = _ref19[0], physicalColumn = _ref19[1];
    var cachedValue = metaManager.getCellMeta(physicalRow, physicalColumn, key);
    var hookResult = instance.runHooks("beforeRemoveCellMeta", row, column, key, cachedValue);
    if (hookResult !== false) {
      metaManager.removeCellMeta(physicalRow, physicalColumn, key);
      instance.runHooks("afterRemoveCellMeta", row, column, key, cachedValue);
    }
    cachedValue = null;
  };
  this.spliceCellsMeta = function(visualIndex) {
    var _this4 = this;
    var deleteAmount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (var _len3 = arguments.length, cellMetaRows = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      cellMetaRows[_key3 - 2] = arguments[_key3];
    }
    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {
      throw new Error("The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.");
    }
    if (deleteAmount > 0) {
      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);
    }
    if (cellMetaRows.length > 0) {
      arrayEach(cellMetaRows.reverse(), function(cellMetaRow) {
        metaManager.createRow(_this4.toPhysicalRow(visualIndex));
        arrayEach(cellMetaRow, function(cellMeta, columnIndex) {
          return _this4.setCellMetaObject(visualIndex, columnIndex, cellMeta);
        });
      });
    }
  };
  this.setCellMetaObject = function(row, column, prop) {
    var _this5 = this;
    if (_typeof$A(prop) === "object") {
      objectEach(prop, function(value, key) {
        _this5.setCellMeta(row, column, key, value);
      });
    }
  };
  this.setCellMeta = function(row, column, key, value) {
    var allowSetCellMeta = instance.runHooks("beforeSetCellMeta", row, column, key, value);
    if (allowSetCellMeta === false) {
      return;
    }
    var physicalRow = row;
    var physicalColumn = column;
    if (row < this.countRows()) {
      physicalRow = this.toPhysicalRow(row);
    }
    if (column < this.countCols()) {
      physicalColumn = this.toPhysicalColumn(column);
    }
    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);
    instance.runHooks("afterSetCellMeta", row, column, key, value);
  };
  this.getCellsMeta = function() {
    return metaManager.getCellsMeta();
  };
  this.getCellMeta = function(row, column) {
    var physicalRow = this.toPhysicalRow(row);
    var physicalColumn = this.toPhysicalColumn(column);
    if (physicalRow === null) {
      physicalRow = row;
    }
    if (physicalColumn === null) {
      physicalColumn = column;
    }
    var prop = datamap.colToProp(column);
    var cellProperties = metaManager.getCellMeta(physicalRow, physicalColumn);
    cellProperties.row = physicalRow;
    cellProperties.col = physicalColumn;
    cellProperties.visualRow = row;
    cellProperties.visualCol = column;
    cellProperties.prop = prop;
    cellProperties.instance = instance;
    instance.runHooks("beforeGetCellMeta", row, column, cellProperties);
    if (instance.hasHook("beforeGetCellMeta") && hasOwnProperty(cellProperties, "type")) {
      metaManager.updateCellMeta(physicalRow, physicalColumn, {
        type: cellProperties.type
      });
    }
    if (cellProperties.cells) {
      var settings = cellProperties.cells(physicalRow, physicalColumn, prop);
      if (settings) {
        metaManager.updateCellMeta(physicalRow, physicalColumn, settings);
      }
    }
    instance.runHooks("afterGetCellMeta", row, column, cellProperties);
    return cellProperties;
  };
  this.getCellMetaAtRow = function(row) {
    return metaManager.getCellsMetaAtRow(row);
  };
  this.isColumnModificationAllowed = function() {
    return !(instance.dataType === "object" || tableMeta.columns);
  };
  var rendererLookup = cellMethodLookupFactory("renderer");
  this.getCellRenderer = function(row, column) {
    return _getItem$1(rendererLookup.call(this, row, column));
  };
  this.getCellEditor = cellMethodLookupFactory("editor");
  var validatorLookup = cellMethodLookupFactory("validator");
  this.getCellValidator = function(row, column) {
    var validator = validatorLookup.call(this, row, column);
    if (typeof validator === "string") {
      validator = _getItem$2(validator);
    }
    return validator;
  };
  this.validateCells = function(callback) {
    this._validateCells(callback);
  };
  this.validateRows = function(rows, callback) {
    if (!Array.isArray(rows)) {
      throw new Error("validateRows parameter `rows` must be an array");
    }
    this._validateCells(callback, rows);
  };
  this.validateColumns = function(columns, callback) {
    if (!Array.isArray(columns)) {
      throw new Error("validateColumns parameter `columns` must be an array");
    }
    this._validateCells(callback, void 0, columns);
  };
  this._validateCells = function(callback, rows, columns) {
    var waitingForValidator = new ValidatorsQueue();
    if (callback) {
      waitingForValidator.onQueueEmpty = callback;
    }
    var i = instance.countRows() - 1;
    while (i >= 0) {
      if (rows !== void 0 && rows.indexOf(i) === -1) {
        i -= 1;
        continue;
      }
      var j = instance.countCols() - 1;
      while (j >= 0) {
        if (columns !== void 0 && columns.indexOf(j) === -1) {
          j -= 1;
          continue;
        }
        waitingForValidator.addValidatorToQueue();
        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function(result) {
          if (typeof result !== "boolean") {
            throw new Error("Validation error: result is not boolean");
          }
          if (result === false) {
            waitingForValidator.valid = false;
          }
          waitingForValidator.removeValidatorFormQueue();
        }, "validateCells");
        j -= 1;
      }
      i -= 1;
    }
    waitingForValidator.checkIfQueueIsEmpty();
  };
  this.getRowHeader = function(row) {
    var rowHeader = tableMeta.rowHeaders;
    var physicalRow = row;
    if (physicalRow !== void 0) {
      physicalRow = instance.runHooks("modifyRowHeader", physicalRow);
    }
    if (physicalRow === void 0) {
      rowHeader = [];
      rangeEach(instance.countRows() - 1, function(i) {
        rowHeader.push(instance.getRowHeader(i));
      });
    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {
      rowHeader = rowHeader[physicalRow];
    } else if (isFunction$1(rowHeader)) {
      rowHeader = rowHeader(physicalRow);
    } else if (rowHeader && typeof rowHeader !== "string" && typeof rowHeader !== "number") {
      rowHeader = physicalRow + 1;
    }
    return rowHeader;
  };
  this.hasRowHeaders = function() {
    return !!tableMeta.rowHeaders;
  };
  this.hasColHeaders = function() {
    if (tableMeta.colHeaders !== void 0 && tableMeta.colHeaders !== null) {
      return !!tableMeta.colHeaders;
    }
    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {
      if (instance.getColHeader(i)) {
        return true;
      }
    }
    return false;
  };
  this.getColHeader = function(column) {
    var columnIndex = instance.runHooks("modifyColHeader", column);
    var result = tableMeta.colHeaders;
    if (columnIndex === void 0) {
      var out = [];
      var ilen = instance.countCols();
      for (var i = 0; i < ilen; i++) {
        out.push(instance.getColHeader(i));
      }
      result = out;
    } else {
      var translateVisualIndexToColumns = function translateVisualIndexToColumns2(visualColumnIndex) {
        var arr = [];
        var columnsLen = instance.countCols();
        var index = 0;
        for (; index < columnsLen; index++) {
          if (isFunction$1(tableMeta.columns) && tableMeta.columns(index)) {
            arr.push(index);
          }
        }
        return arr[visualColumnIndex];
      };
      var physicalColumn = instance.toPhysicalColumn(columnIndex);
      var prop = translateVisualIndexToColumns(physicalColumn);
      if (tableMeta.colHeaders === false) {
        result = null;
      } else if (tableMeta.columns && isFunction$1(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {
        result = tableMeta.columns(prop).title;
      } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {
        result = tableMeta.columns[physicalColumn].title;
      } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== void 0) {
        result = tableMeta.colHeaders[physicalColumn];
      } else if (isFunction$1(tableMeta.colHeaders)) {
        result = tableMeta.colHeaders(physicalColumn);
      } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== "string" && typeof tableMeta.colHeaders !== "number") {
        result = spreadsheetColumnLabel(columnIndex);
      }
    }
    return result;
  };
  this._getColWidthFromSettings = function(col) {
    var width;
    if (col >= 0) {
      var cellProperties = instance.getCellMeta(0, col);
      width = cellProperties.width;
    }
    if (width === void 0 || width === tableMeta.width) {
      width = tableMeta.colWidths;
    }
    if (width !== void 0 && width !== null) {
      switch (_typeof$A(width)) {
        case "object":
          width = width[col];
          break;
        case "function":
          width = width(col);
          break;
      }
      if (typeof width === "string") {
        width = parseInt(width, 10);
      }
    }
    return width;
  };
  this.getColWidth = function(column) {
    var width = instance._getColWidthFromSettings(column);
    width = instance.runHooks("modifyColWidth", width, column);
    if (width === void 0) {
      width = ViewportColumnsCalculator.DEFAULT_WIDTH;
    }
    return width;
  };
  this._getRowHeightFromSettings = function(row) {
    var height = tableMeta.rowHeights;
    if (height !== void 0 && height !== null) {
      switch (_typeof$A(height)) {
        case "object":
          height = height[row];
          break;
        case "function":
          height = height(row);
          break;
      }
      if (typeof height === "string") {
        height = parseInt(height, 10);
      }
    }
    return height;
  };
  this.getRowHeight = function(row) {
    var height = instance._getRowHeightFromSettings(row);
    height = instance.runHooks("modifyRowHeight", height, row);
    return height;
  };
  this.countSourceRows = function() {
    return dataSource.countRows();
  };
  this.countSourceCols = function() {
    return dataSource.countFirstRowKeys();
  };
  this.countRows = function() {
    return datamap.getLength();
  };
  this.countCols = function() {
    var maxCols = tableMeta.maxCols;
    var dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();
    return Math.min(maxCols, dataLen);
  };
  this.countRenderedRows = function() {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;
  };
  this.countVisibleRows = function() {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;
  };
  this.countRenderedCols = function() {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;
  };
  this.countVisibleCols = function() {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;
  };
  this.countEmptyRows = function() {
    var ending = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var emptyRows = 0;
    rangeEachReverse(instance.countRows() - 1, function(visualIndex) {
      if (instance.isEmptyRow(visualIndex)) {
        emptyRows += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyRows;
  };
  this.countEmptyCols = function() {
    var ending = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (instance.countRows() < 1) {
      return 0;
    }
    var emptyColumns = 0;
    rangeEachReverse(instance.countCols() - 1, function(visualIndex) {
      if (instance.isEmptyCol(visualIndex)) {
        emptyColumns += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyColumns;
  };
  this.isEmptyRow = function(row) {
    return tableMeta.isEmptyRow.call(instance, row);
  };
  this.isEmptyCol = function(column) {
    return tableMeta.isEmptyCol.call(instance, column);
  };
  this.selectCell = function(row, column, endRow, endColumn) {
    var scrollToCell = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var changeListener = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    if (isUndefined$1(row) || isUndefined$1(column)) {
      return false;
    }
    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);
  };
  this.selectCells = function() {
    var coords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [[]];
    var scrollToCell = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var changeListener = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (scrollToCell === false) {
      preventScrollingToCell = true;
    }
    var wasSelected = selection.selectCells(coords);
    if (wasSelected && changeListener) {
      instance.listen();
    }
    preventScrollingToCell = false;
    return wasSelected;
  };
  this.selectColumns = function(startColumn) {
    var endColumn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startColumn;
    return selection.selectColumns(startColumn, endColumn);
  };
  this.selectRows = function(startRow) {
    var endRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startRow;
    return selection.selectRows(startRow, endRow);
  };
  this.deselectCell = function() {
    selection.deselect();
  };
  this.selectAll = function() {
    var includeHeaders = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    var includeRowHeaders = includeHeaders && this.hasRowHeaders();
    var includeColumnHeaders = includeHeaders && this.hasColHeaders();
    preventScrollingToCell = true;
    selection.selectAll(includeRowHeaders, includeColumnHeaders);
    preventScrollingToCell = false;
  };
  var getIndexToScroll = function getIndexToScroll2(indexMapper, visualIndex) {
    return indexMapper.getFirstNotHiddenIndex(visualIndex, 1, true);
  };
  this.scrollViewportTo = function(row, column) {
    var snapToBottom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var snapToRight = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var considerHiddenIndexes = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var snapToTop = !snapToBottom;
    var snapToLeft = !snapToRight;
    var renderableRow = row;
    var renderableColumn = column;
    if (considerHiddenIndexes) {
      var _isRowInteger = Number.isInteger(row);
      var _isColumnInteger = Number.isInteger(column);
      var visualRowToScroll = _isRowInteger ? getIndexToScroll(this.rowIndexMapper, row) : void 0;
      var visualColumnToScroll = _isColumnInteger ? getIndexToScroll(this.columnIndexMapper, column) : void 0;
      if (visualRowToScroll === null || visualColumnToScroll === null) {
        return false;
      }
      renderableRow = _isRowInteger ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : void 0;
      renderableColumn = _isColumnInteger ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : void 0;
    }
    var isRowInteger = Number.isInteger(renderableRow);
    var isColumnInteger = Number.isInteger(renderableColumn);
    if (isRowInteger && isColumnInteger) {
      return instance.view.scrollViewport(new CellCoords(renderableRow, renderableColumn), snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
    if (isRowInteger && isColumnInteger === false) {
      return instance.view.scrollViewportVertically(renderableRow, snapToTop, snapToBottom);
    }
    if (isColumnInteger && isRowInteger === false) {
      return instance.view.scrollViewportHorizontally(renderableColumn, snapToRight, snapToLeft);
    }
    return false;
  };
  this.destroy = function() {
    instance._clearTimeouts();
    instance._clearImmediates();
    if (instance.view) {
      instance.view.destroy();
    }
    if (dataSource) {
      dataSource.destroy();
    }
    dataSource = null;
    metaManager.clearCache();
    stopObserving();
    if (isRootInstance(instance)) {
      var licenseInfo = this.rootDocument.querySelector("#hot-display-license-info");
      if (licenseInfo) {
        licenseInfo.parentNode.removeChild(licenseInfo);
      }
    }
    empty(instance.rootElement);
    eventManager.destroy();
    if (editorManager) {
      editorManager.destroy();
    }
    instance.batchExecution(function() {
      instance.rowIndexMapper.unregisterAll();
      instance.columnIndexMapper.unregisterAll();
      pluginsRegistry.getItems().forEach(function(_ref20) {
        var _ref21 = _slicedToArray$c(_ref20, 2), plugin = _ref21[1];
        plugin.destroy();
      });
      pluginsRegistry.clear();
      instance.runHooks("afterDestroy");
    }, true);
    Hooks.getSingleton().destroy(instance);
    objectEach(instance, function(property, key, obj) {
      if (isFunction$1(property)) {
        obj[key] = postMortem(key);
      } else if (key !== "guid") {
        obj[key] = null;
      }
    });
    instance.isDestroyed = true;
    if (datamap) {
      datamap.destroy();
    }
    instance.rowIndexMapper = null;
    instance.columnIndexMapper = null;
    datamap = null;
    grid = null;
    selection = null;
    editorManager = null;
    instance = null;
  };
  function postMortem(method) {
    return function() {
      throw new Error('The "'.concat(method, '" method cannot be called because this Handsontable instance has been destroyed'));
    };
  }
  this.getActiveEditor = function() {
    return editorManager.getActiveEditor();
  };
  this.getPlugin = function(pluginName) {
    var unifiedPluginName = toUpperCaseFirst(pluginName);
    if (unifiedPluginName === "UndoRedo") {
      return this.undoRedo;
    }
    return pluginsRegistry.getItem(unifiedPluginName);
  };
  this.getPluginName = function(plugin) {
    if (plugin === this.undoRedo) {
      return this.undoRedo.constructor.PLUGIN_KEY;
    }
    return pluginsRegistry.getId(plugin);
  };
  this.getInstance = function() {
    return instance;
  };
  this.addHook = function(key, callback) {
    Hooks.getSingleton().add(key, callback, instance);
  };
  this.hasHook = function(key) {
    return Hooks.getSingleton().has(key, instance);
  };
  this.addHookOnce = function(key, callback) {
    Hooks.getSingleton().once(key, callback, instance);
  };
  this.removeHook = function(key, callback) {
    Hooks.getSingleton().remove(key, callback, instance);
  };
  this.runHooks = function(key, p1, p2, p3, p4, p5, p6) {
    return Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);
  };
  this.getTranslatedPhrase = function(dictionaryKey, extraArguments) {
    return getTranslatedPhrase(tableMeta.language, dictionaryKey, extraArguments);
  };
  this.toHTML = function() {
    return instanceToHTML(_this);
  };
  this.toTableElement = function() {
    var tempElement = _this.rootDocument.createElement("div");
    tempElement.insertAdjacentHTML("afterbegin", instanceToHTML(_this));
    return tempElement.firstElementChild;
  };
  this.timeouts = [];
  this._registerTimeout = function(handle) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var handleFunc = handle;
    if (typeof handleFunc === "function") {
      handleFunc = setTimeout(handleFunc, delay);
    }
    this.timeouts.push(handleFunc);
  };
  this._clearTimeouts = function() {
    arrayEach(this.timeouts, function(handler) {
      clearTimeout(handler);
    });
  };
  this.immediates = [];
  this._registerImmediate = function(callback) {
    this.immediates.push(setImmediate(callback));
  };
  this._clearImmediates = function() {
    arrayEach(this.immediates, function(handler) {
      clearImmediate(handler);
    });
  };
  this._refreshBorders = function() {
    var revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    editorManager.destroyEditor(revertOriginal);
    instance.view.render();
    if (prepareEditorIfNeeded && selection.isSelected()) {
      editorManager.prepareEditor();
    }
  };
  getPluginsNames().forEach(function(pluginName) {
    var PluginClass = getPlugin(pluginName);
    pluginsRegistry.addItem(pluginName, new PluginClass(_this));
  });
  Hooks.getSingleton().run(instance, "construct");
}

function autoResize() {
  var defaults = {
    minHeight: 200,
    maxHeight: 300,
    minWidth: 100,
    maxWidth: 300
  }, el, body = document.body, text = document.createTextNode(""), span = document.createElement("SPAN"), observe = function observe2(element, event, handler) {
    element.addEventListener(event, handler, false);
  }, _unObserve = function unObserve(element, event, handler) {
    element.removeEventListener(event, handler, false);
  }, resize = function resize2(newChar) {
    var width, scrollHeight;
    if (!newChar) {
      newChar = "";
    } else if (!/^[a-zA-Z \.,\\\/\|0-9]$/.test(newChar)) {
      newChar = ".";
    }
    if (text.textContent !== void 0) {
      text.textContent = el.value + newChar;
    } else {
      text.data = el.value + newChar;
    }
    span.style.fontSize = getComputedStyle(el).fontSize;
    span.style.fontFamily = getComputedStyle(el).fontFamily;
    span.style.whiteSpace = "pre";
    body.appendChild(span);
    width = span.clientWidth + 2;
    body.removeChild(span);
    el.style.height = defaults.minHeight + "px";
    if (defaults.minWidth > width) {
      el.style.width = defaults.minWidth + "px";
    } else if (width > defaults.maxWidth) {
      el.style.width = defaults.maxWidth + "px";
    } else {
      el.style.width = width + "px";
    }
    scrollHeight = el.scrollHeight ? el.scrollHeight - 1 : 0;
    if (defaults.minHeight > scrollHeight) {
      el.style.height = defaults.minHeight + "px";
    } else if (defaults.maxHeight < scrollHeight) {
      el.style.height = defaults.maxHeight + "px";
      el.style.overflowY = "visible";
    } else {
      el.style.height = scrollHeight + "px";
    }
  }, delayedResize = function delayedResize2() {
    window.setTimeout(resize, 0);
  }, extendDefaults = function extendDefaults2(config) {
    if (config && config.minHeight) {
      if (config.minHeight == "inherit") {
        defaults.minHeight = el.clientHeight;
      } else {
        var minHeight = parseInt(config.minHeight);
        if (!isNaN(minHeight)) {
          defaults.minHeight = minHeight;
        }
      }
    }
    if (config && config.maxHeight) {
      if (config.maxHeight == "inherit") {
        defaults.maxHeight = el.clientHeight;
      } else {
        var maxHeight = parseInt(config.maxHeight);
        if (!isNaN(maxHeight)) {
          defaults.maxHeight = maxHeight;
        }
      }
    }
    if (config && config.minWidth) {
      if (config.minWidth == "inherit") {
        defaults.minWidth = el.clientWidth;
      } else {
        var minWidth = parseInt(config.minWidth);
        if (!isNaN(minWidth)) {
          defaults.minWidth = minWidth;
        }
      }
    }
    if (config && config.maxWidth) {
      if (config.maxWidth == "inherit") {
        defaults.maxWidth = el.clientWidth;
      } else {
        var maxWidth = parseInt(config.maxWidth);
        if (!isNaN(maxWidth)) {
          defaults.maxWidth = maxWidth;
        }
      }
    }
    if (!span.firstChild) {
      span.className = "autoResize";
      span.style.display = "inline-block";
      span.appendChild(text);
    }
  }, _init = function init(el_, config, doObserve) {
    el = el_;
    extendDefaults(config);
    if (el.nodeName == "TEXTAREA") {
      el.style.resize = "none";
      el.style.overflowY = "";
      el.style.height = defaults.minHeight + "px";
      el.style.minWidth = defaults.minWidth + "px";
      el.style.maxWidth = defaults.maxWidth + "px";
      el.style.overflowY = "hidden";
    }
    if (doObserve) {
      observe(el, "change", resize);
      observe(el, "cut", delayedResize);
      observe(el, "paste", delayedResize);
      observe(el, "drop", delayedResize);
      observe(el, "keydown", delayedResize);
      observe(el, "focus", resize);
      observe(el, "compositionstart", delayedResize);
      observe(el, "compositionupdate", delayedResize);
      observe(el, "compositionend", delayedResize);
    }
    resize();
  };
  function getComputedStyle(element) {
    return element.currentStyle || document.defaultView.getComputedStyle(element);
  }
  return {
    init: function init(el_, config, doObserve) {
      _init(el_, config, doObserve);
    },
    unObserve: function unObserve() {
      _unObserve(el, "change", resize);
      _unObserve(el, "cut", delayedResize);
      _unObserve(el, "paste", delayedResize);
      _unObserve(el, "drop", delayedResize);
      _unObserve(el, "keydown", delayedResize);
      _unObserve(el, "focus", resize);
      _unObserve(el, "compositionstart", delayedResize);
      _unObserve(el, "compositionupdate", delayedResize);
      _unObserve(el, "compositionend", delayedResize);
    },
    resize
  };
}

function _typeof$B(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$B = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$B = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$B(obj);
}
function _classCallCheck$17(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$12(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$12(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$12(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$12(Constructor, staticProps);
  return Constructor;
}
function _get$4(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$4 = Reflect.get;
  } else {
    _get$4 = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$4(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$4(target, property, receiver || target);
}
function _superPropBase$4(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$p(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$p(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$q(subClass, superClass);
}
function _setPrototypeOf$q(o, p) {
  _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$q(o, p);
}
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$p(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$p(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$p(this, result);
  };
}
function _possibleConstructorReturn$p(self, call) {
  if (call && (_typeof$B(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$p(self);
}
function _assertThisInitialized$p(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$p(o) {
  _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$p(o);
}
var EDITOR_VISIBLE_CLASS_NAME = "ht_editor_visible";
var EDITOR_HIDDEN_CLASS_NAME = "ht_editor_hidden";
var EDITOR_TYPE$1 = "text";
var TextEditor = /* @__PURE__ */ function(_BaseEditor) {
  _inherits$p(TextEditor2, _BaseEditor);
  var _super = _createSuper$p(TextEditor2);
  function TextEditor2(instance) {
    var _this;
    _classCallCheck$17(this, TextEditor2);
    _this = _super.call(this, instance);
    _this.eventManager = new EventManager(_assertThisInitialized$p(_this));
    _this.autoResize = autoResize();
    _this.TEXTAREA = void 0;
    _this.textareaStyle = void 0;
    _this.TEXTAREA_PARENT = void 0;
    _this.textareaParentStyle = void 0;
    _this.layerClass = void 0;
    _this.createElements();
    _this.bindEvents();
    _this.hot.addHookOnce("afterDestroy", function() {
      return _this.destroy();
    });
    return _this;
  }
  _createClass$12(TextEditor2, [{
    key: "getValue",
    value: function getValue() {
      return this.TEXTAREA.value;
    }
  }, {
    key: "setValue",
    value: function setValue(newValue) {
      this.TEXTAREA.value = newValue;
    }
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;
      this.refreshDimensions();
      this.showEditableElement();
      this.addHook("beforeKeyDown", function(event) {
        return _this2.onBeforeKeyDown(event);
      });
    }
  }, {
    key: "close",
    value: function close() {
      this.autoResize.unObserve();
      if (this.hot.rootDocument.activeElement === this.TEXTAREA) {
        this.hot.listen();
      }
      this.hideEditableElement();
      this.removeHooksByKey("beforeKeyDown");
    }
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      var previousState = this.state;
      _get$4(_getPrototypeOf$p(TextEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
      if (!cellProperties.readOnly) {
        this.refreshDimensions(true);
        var allowInvalid = cellProperties.allowInvalid, fragmentSelection = cellProperties.fragmentSelection;
        if (allowInvalid) {
          this.TEXTAREA.value = "";
        }
        if (previousState !== EDITOR_STATE.FINISHED) {
          this.hideEditableElement();
        }
        var restoreFocus = !fragmentSelection;
        if (restoreFocus && !isMobileBrowser()) {
          this.focus();
        }
      }
    }
  }, {
    key: "beginEditing",
    value: function beginEditing(newInitialValue, event) {
      if (this.state !== EDITOR_STATE.VIRGIN) {
        return;
      }
      this.TEXTAREA.value = "";
      _get$4(_getPrototypeOf$p(TextEditor2.prototype), "beginEditing", this).call(this, newInitialValue, event);
    }
  }, {
    key: "focus",
    value: function focus() {
      this.TEXTAREA.select();
      setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
    }
  }, {
    key: "createElements",
    value: function createElements() {
      var rootDocument = this.hot.rootDocument;
      this.TEXTAREA = rootDocument.createElement("TEXTAREA");
      this.TEXTAREA.setAttribute("data-hot-input", "");
      this.TEXTAREA.tabIndex = -1;
      addClass(this.TEXTAREA, "handsontableInput");
      this.textareaStyle = this.TEXTAREA.style;
      this.textareaStyle.width = 0;
      this.textareaStyle.height = 0;
      this.textareaStyle.overflowY = "visible";
      this.TEXTAREA_PARENT = rootDocument.createElement("DIV");
      addClass(this.TEXTAREA_PARENT, "handsontableInputHolder");
      if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {
        removeClass(this.TEXTAREA_PARENT, this.layerClass);
      }
      addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
      this.textareaParentStyle = this.TEXTAREA_PARENT.style;
      this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
      this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);
    }
  }, {
    key: "hideEditableElement",
    value: function hideEditableElement() {
      if (isIE() || isEdge()) {
        this.textareaStyle.textIndent = "-99999px";
      }
      this.textareaStyle.overflowY = "visible";
      this.textareaParentStyle.opacity = "0";
      this.textareaParentStyle.height = "1px";
      if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {
        removeClass(this.TEXTAREA_PARENT, this.layerClass);
      }
      addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
    }
  }, {
    key: "showEditableElement",
    value: function showEditableElement() {
      this.textareaParentStyle.height = "";
      this.textareaParentStyle.overflow = "";
      this.textareaParentStyle.position = "";
      this.textareaParentStyle.right = "auto";
      this.textareaParentStyle.opacity = "1";
      this.textareaStyle.textIndent = "";
      this.textareaStyle.overflowY = "hidden";
      var childNodes = this.TEXTAREA_PARENT.childNodes;
      var hasClassHandsontableEditor = false;
      rangeEach(childNodes.length - 1, function(index) {
        var childNode = childNodes[index];
        if (hasClass(childNode, "handsontableEditor")) {
          hasClassHandsontableEditor = true;
          return false;
        }
      });
      if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {
        removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
      }
      if (hasClassHandsontableEditor) {
        this.layerClass = EDITOR_VISIBLE_CLASS_NAME;
        addClass(this.TEXTAREA_PARENT, this.layerClass);
      } else {
        this.layerClass = this.getEditedCellsLayerClass();
        addClass(this.TEXTAREA_PARENT, this.layerClass);
      }
    }
  }, {
    key: "refreshValue",
    value: function refreshValue() {
      var physicalRow = this.hot.toPhysicalRow(this.row);
      var sourceData = this.hot.getSourceDataAtCell(physicalRow, this.col);
      this.originalValue = sourceData;
      this.setValue(sourceData);
      this.refreshDimensions();
    }
  }, {
    key: "refreshDimensions",
    value: function refreshDimensions() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (this.state !== EDITOR_STATE.EDITING && !force) {
        return;
      }
      this.TD = this.getEditedCell();
      if (!this.TD) {
        if (!force) {
          this.close();
        }
        return;
      }
      var _this$hot$view$wt = this.hot.view.wt, wtOverlays = _this$hot$view$wt.wtOverlays, wtViewport = _this$hot$view$wt.wtViewport;
      var currentOffset = offset$1(this.TD);
      var containerOffset = offset$1(this.hot.rootElement);
      var scrollableContainerTop = wtOverlays.topOverlay.holder;
      var scrollableContainerLeft = wtOverlays.leftOverlay.holder;
      var containerScrollTop = scrollableContainerTop !== this.hot.rootWindow ? scrollableContainerTop.scrollTop : 0;
      var containerScrollLeft = scrollableContainerLeft !== this.hot.rootWindow ? scrollableContainerLeft.scrollLeft : 0;
      var editorSection = this.checkEditorSection();
      var scrollTop = ["", "left"].includes(editorSection) ? containerScrollTop : 0;
      var scrollLeft = ["", "top", "bottom"].includes(editorSection) ? containerScrollLeft : 0;
      var editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;
      var backgroundColor = this.TD.style.backgroundColor;
      var editTop = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;
      var editLeft = currentOffset.left - containerOffset.left - 1 - scrollLeft;
      var cssTransformOffset;
      switch (editorSection) {
        case "top":
          cssTransformOffset = getCssTransform(wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
          break;
        case "left":
          cssTransformOffset = getCssTransform(wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
          break;
        case "top-left-corner":
          cssTransformOffset = getCssTransform(wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
          break;
        case "bottom-left-corner":
          cssTransformOffset = getCssTransform(wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
          break;
        case "bottom":
          cssTransformOffset = getCssTransform(wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
          break;
      }
      var hasColumnHeaders = this.hot.hasColHeaders();
      var renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);
      var renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);
      var nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();
      var firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view.wt.getSetting("fixedRowsBottom");
      if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {
        editTop += 1;
      }
      if (renderableColumn <= 0) {
        editLeft += 1;
      }
      if (cssTransformOffset && cssTransformOffset !== -1) {
        this.textareaParentStyle[cssTransformOffset[0]] = cssTransformOffset[1];
      } else {
        resetCssTransform(this.TEXTAREA_PARENT);
      }
      this.textareaParentStyle.top = "".concat(editTop, "px");
      this.textareaParentStyle.left = "".concat(editLeft, "px");
      this.showEditableElement();
      var firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;
      var firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;
      var horizontalScrollPosition = wtOverlays.leftOverlay.getScrollPosition();
      var verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();
      var scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);
      var cellTopOffset = this.TD.offsetTop + firstRowOffset - verticalScrollPosition;
      var cellLeftOffset = this.TD.offsetLeft + firstColumnOffset - horizontalScrollPosition;
      var width = innerWidth(this.TD) - 8;
      var actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;
      var actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;
      var maxWidth = this.hot.view.maximumVisibleElementWidth(cellLeftOffset) - 9 - actualVerticalScrollbarWidth;
      var height = this.TD.scrollHeight + 1;
      var maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth, 23);
      var cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);
      this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;
      this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;
      this.TEXTAREA.style.backgroundColor = backgroundColor;
      this.autoResize.init(this.TEXTAREA, {
        minHeight: Math.min(height, maxHeight),
        maxHeight,
        minWidth: Math.min(width, maxWidth),
        maxWidth
      }, true);
    }
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      var _this3 = this;
      this.eventManager.addEventListener(this.TEXTAREA, "cut", function(event) {
        return event.stopPropagation();
      });
      this.eventManager.addEventListener(this.TEXTAREA, "paste", function(event) {
        return event.stopPropagation();
      });
      if (isIOS()) {
        this.eventManager.addEventListener(this.TEXTAREA, "focusout", function() {
          return _this3.finishEditing(false);
        });
      }
      this.addHook("afterScrollHorizontally", function() {
        return _this3.refreshDimensions();
      });
      this.addHook("afterScrollVertically", function() {
        return _this3.refreshDimensions();
      });
      this.addHook("afterColumnResize", function() {
        _this3.refreshDimensions();
        _this3.focus();
      });
      this.addHook("afterRowResize", function() {
        _this3.refreshDimensions();
        _this3.focus();
      });
    }
  }, {
    key: "allowKeyEventPropagation",
    value: function allowKeyEventPropagation() {
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.eventManager.destroy();
      this.clearHooks();
    }
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown(event) {
      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
      if (event.target !== this.TEXTAREA || isImmediatePropagationStopped(event)) {
        return;
      }
      switch (event.keyCode) {
        case KEY_CODES.ARROW_RIGHT:
          if (this.isInFullEditMode()) {
            if (!this.isWaiting() && !this.allowKeyEventPropagation(event.keyCode)) {
              stopImmediatePropagation(event);
            }
          }
          break;
        case KEY_CODES.ARROW_LEFT:
          if (this.isInFullEditMode()) {
            if (!this.isWaiting() && !this.allowKeyEventPropagation(event.keyCode)) {
              stopImmediatePropagation(event);
            }
          }
          break;
        case KEY_CODES.ARROW_UP:
        case KEY_CODES.ARROW_DOWN:
          if (this.isInFullEditMode()) {
            if (!this.isWaiting() && !this.allowKeyEventPropagation(event.keyCode)) {
              stopImmediatePropagation(event);
            }
          }
          break;
        case KEY_CODES.ENTER: {
          var isMultipleSelection = this.hot.selection.isMultiple();
          if (ctrlDown && !isMultipleSelection || event.altKey) {
            if (this.isOpened()) {
              var caretPosition = getCaretPosition(this.TEXTAREA);
              var value = this.getValue();
              var newValue = "".concat(value.slice(0, caretPosition), "\n").concat(value.slice(caretPosition));
              this.setValue(newValue);
              setCaretPosition(this.TEXTAREA, caretPosition + 1);
            } else {
              this.beginEditing("".concat(this.originalValue, "\n"));
            }
            stopImmediatePropagation(event);
          }
          event.preventDefault();
          break;
        }
        case KEY_CODES.BACKSPACE:
        case KEY_CODES.DELETE:
        case KEY_CODES.HOME:
        case KEY_CODES.END:
          stopImmediatePropagation(event);
          break;
      }
      var arrowKeyCodes = [KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_LEFT];
      if (arrowKeyCodes.indexOf(event.keyCode) === -1) {
        this.autoResize.resize(String.fromCharCode(event.keyCode));
      }
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE$1;
    }
  }]);
  return TextEditor2;
}(BaseEditor);

var RENDERER_TYPE = "base";
function baseRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var classesToAdd = [];
  var classesToRemove = [];
  if (cellProperties.className) {
    addClass(TD, cellProperties.className);
  }
  if (cellProperties.readOnly) {
    classesToAdd.push(cellProperties.readOnlyCellClassName);
  }
  if (cellProperties.valid === false && cellProperties.invalidCellClassName) {
    classesToAdd.push(cellProperties.invalidCellClassName);
  } else {
    classesToRemove.push(cellProperties.invalidCellClassName);
  }
  if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {
    classesToAdd.push(cellProperties.noWordWrapClassName);
  }
  if (!value && cellProperties.placeholder) {
    classesToAdd.push(cellProperties.placeholderCellClassName);
  }
  removeClass(TD, classesToRemove);
  addClass(TD, classesToAdd);
}
baseRenderer.RENDERER_TYPE = RENDERER_TYPE;

var RENDERER_TYPE$1 = "text";
function textRenderer(instance, TD, row, col, prop, value, cellProperties) {
  baseRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  var escaped = value;
  if (!escaped && cellProperties.placeholder) {
    escaped = cellProperties.placeholder;
  }
  escaped = stringify(escaped);
  if (instance.getSettings().trimWhitespace) {
    escaped = escaped.trim();
  }
  if (cellProperties.rendererTemplate) {
    empty(TD);
    var TEMPLATE = instance.rootDocument.createElement("TEMPLATE");
    TEMPLATE.setAttribute("bind", "{{}}");
    TEMPLATE.innerHTML = cellProperties.rendererTemplate;
    HTMLTemplateElement.decorate(TEMPLATE);
    TEMPLATE.model = instance.getSourceDataAtRow(row);
    TD.appendChild(TEMPLATE);
  } else {
    fastInnerText(TD, escaped);
  }
}
textRenderer.RENDERER_TYPE = RENDERER_TYPE$1;

var CELL_TYPE$1 = "text";
var TextCellType = {
  CELL_TYPE: CELL_TYPE$1,
  editor: TextEditor,
  renderer: textRenderer
};

_register$3(TextCellType);
function Handsontable(rootElement, userSettings) {
  var instance = new Core(rootElement, userSettings || {}, rootInstanceSymbol);
  instance.init();
  return instance;
}
Handsontable.Core = function(rootElement) {
  var userSettings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Core(rootElement, userSettings, rootInstanceSymbol);
};
Handsontable.packageName = "handsontable";
Handsontable.buildDate = "17/06/2021 09:14:07";
Handsontable.version = "9.0.1";
Handsontable.languages = {
  dictionaryKeys,
  getLanguageDictionary,
  getLanguagesDictionaries,
  registerLanguageDictionary,
  getTranslatedPhrase
};

function jQueryWrapper(Handsontable) {
  var jQuery = typeof window === "undefined" ? false : window.jQuery;
  if (!jQuery) {
    return;
  }
  jQuery.fn.handsontable = function(action) {
    var $this = this.first();
    var instance = $this.data("handsontable");
    if (typeof action !== "string") {
      var userSettings = action || {};
      if (instance) {
        instance.updateSettings(userSettings);
      } else {
        instance = new Handsontable.Core($this[0], userSettings);
        $this.data("handsontable", instance);
        instance.init();
      }
      return $this;
    }
    var output;
    if (instance) {
      if (typeof instance[action] !== "undefined") {
        var _instance$action;
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        output = (_instance$action = instance[action]).call.apply(_instance$action, [instance].concat(args));
        if (action === "destroy") {
          $this.removeData();
        }
      } else {
        throw new Error("Handsontable do not provide action: ".concat(action));
      }
    }
    return output;
  };
}

function _slicedToArray$d(arr, i) {
  return _arrayWithHoles$d(arr) || _iterableToArrayLimit$d(arr, i) || _unsupportedIterableToArray$n(arr, i) || _nonIterableRest$d();
}
function _nonIterableRest$d() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$n(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$n(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$n(o, minLen);
}
function _arrayLikeToArray$n(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$d(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$d(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$18(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$13(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$13(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$13(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$13(Constructor, staticProps);
  return Constructor;
}
var GhostTable = /* @__PURE__ */ function() {
  function GhostTable2(hotInstance) {
    _classCallCheck$18(this, GhostTable2);
    this.hot = hotInstance;
    this.container = null;
    this.injected = false;
    this.rows = [];
    this.columns = [];
    this.samples = null;
    this.settings = {
      useHeaders: true
    };
  }
  _createClass$13(GhostTable2, [{
    key: "addRow",
    value: function addRow(row, samples) {
      if (this.columns.length) {
        throw new Error("Doesn't support multi-dimensional table");
      }
      if (!this.rows.length) {
        this.container = this.createContainer(this.hot.rootElement.className);
      }
      var rowObject = {
        row
      };
      this.rows.push(rowObject);
      this.samples = samples;
      this.table = this.createTable(this.hot.table.className);
      this.table.colGroup.appendChild(this.createColGroupsCol());
      this.table.tr.appendChild(this.createRow(row));
      this.container.container.appendChild(this.table.fragment);
      rowObject.table = this.table.table;
    }
  }, {
    key: "addColumnHeadersRow",
    value: function addColumnHeadersRow(samples) {
      var colHeader = this.hot.getColHeader(0);
      if (colHeader !== null && colHeader !== void 0) {
        var rowObject = {
          row: -1
        };
        this.rows.push(rowObject);
        this.container = this.createContainer(this.hot.rootElement.className);
        this.samples = samples;
        this.table = this.createTable(this.hot.table.className);
        this.table.colGroup.appendChild(this.createColGroupsCol());
        this.appendColumnHeadersRow();
        this.container.container.appendChild(this.table.fragment);
        rowObject.table = this.table.table;
      }
    }
  }, {
    key: "addColumn",
    value: function addColumn(column, samples) {
      if (this.rows.length) {
        throw new Error("Doesn't support multi-dimensional table");
      }
      if (!this.columns.length) {
        this.container = this.createContainer(this.hot.rootElement.className);
      }
      var columnObject = {
        col: column
      };
      this.columns.push(columnObject);
      this.samples = samples;
      this.table = this.createTable(this.hot.table.className);
      if (this.getSetting("useHeaders") && this.hot.getColHeader(column) !== null) {
        this.hot.view.appendColHeader(column, this.table.th);
      }
      this.table.tBody.appendChild(this.createCol(column));
      this.container.container.appendChild(this.table.fragment);
      columnObject.table = this.table.table;
    }
  }, {
    key: "getHeights",
    value: function getHeights(callback) {
      if (!this.injected) {
        this.injectTable();
      }
      arrayEach(this.rows, function(row) {
        callback(row.row, outerHeight(row.table) - 1);
      });
    }
  }, {
    key: "getWidths",
    value: function getWidths(callback) {
      if (!this.injected) {
        this.injectTable();
      }
      arrayEach(this.columns, function(column) {
        callback(column.col, outerWidth(column.table));
      });
    }
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      this.settings = settings;
    }
  }, {
    key: "setSetting",
    value: function setSetting(name, value) {
      if (!this.settings) {
        this.settings = {};
      }
      this.settings[name] = value;
    }
  }, {
    key: "getSettings",
    value: function getSettings() {
      return this.settings;
    }
  }, {
    key: "getSetting",
    value: function getSetting(name) {
      if (this.settings) {
        return this.settings[name];
      }
      return null;
    }
  }, {
    key: "createColGroupsCol",
    value: function createColGroupsCol() {
      var _this = this;
      var fragment = this.hot.rootDocument.createDocumentFragment();
      if (this.hot.hasRowHeaders()) {
        fragment.appendChild(this.createColElement(-1));
      }
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          fragment.appendChild(_this.createColElement(string.col));
        });
      });
      return fragment;
    }
  }, {
    key: "createRow",
    value: function createRow(row) {
      var _this2 = this;
      var rootDocument = this.hot.rootDocument;
      var fragment = rootDocument.createDocumentFragment();
      var th = rootDocument.createElement("th");
      if (this.hot.hasRowHeaders()) {
        this.hot.view.appendRowHeader(row, th);
        fragment.appendChild(th);
      }
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          var column = string.col;
          var cellProperties = _this2.hot.getCellMeta(row, column);
          cellProperties.col = column;
          cellProperties.row = row;
          var renderer = _this2.hot.getCellRenderer(cellProperties);
          var td = rootDocument.createElement("td");
          td.setAttribute("ghost-table", 1);
          renderer(_this2.hot, td, row, column, _this2.hot.colToProp(column), string.value, cellProperties);
          fragment.appendChild(td);
        });
      });
      return fragment;
    }
  }, {
    key: "appendColumnHeadersRow",
    value: function appendColumnHeadersRow() {
      var _this3 = this;
      var rootDocument = this.hot.rootDocument;
      var domFragment = rootDocument.createDocumentFragment();
      var columnHeaders = [];
      if (this.hot.hasRowHeaders()) {
        var th = rootDocument.createElement("th");
        columnHeaders.push([-1, th]);
        domFragment.appendChild(th);
      }
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          var column = string.col;
          var th2 = rootDocument.createElement("th");
          columnHeaders.push([column, th2]);
          domFragment.appendChild(th2);
        });
      });
      this.table.tHead.appendChild(domFragment);
      arrayEach(columnHeaders, function(columnHeader) {
        var _columnHeader = _slicedToArray$d(columnHeader, 2), column = _columnHeader[0], th2 = _columnHeader[1];
        _this3.hot.view.appendColHeader(column, th2);
      });
    }
  }, {
    key: "createCol",
    value: function createCol(column) {
      var _this4 = this;
      var rootDocument = this.hot.rootDocument;
      var fragment = rootDocument.createDocumentFragment();
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          var row = string.row;
          var cellProperties = _this4.hot.getCellMeta(row, column);
          cellProperties.col = column;
          cellProperties.row = row;
          var renderer = _this4.hot.getCellRenderer(cellProperties);
          var td = rootDocument.createElement("td");
          var tr = rootDocument.createElement("tr");
          td.setAttribute("ghost-table", 1);
          renderer(_this4.hot, td, row, column, _this4.hot.colToProp(column), string.value, cellProperties);
          tr.appendChild(td);
          fragment.appendChild(tr);
        });
      });
      return fragment;
    }
  }, {
    key: "clean",
    value: function clean() {
      this.rows.length = 0;
      this.rows[-1] = void 0;
      this.columns.length = 0;
      if (this.samples) {
        this.samples.clear();
      }
      this.samples = null;
      this.removeTable();
    }
  }, {
    key: "injectTable",
    value: function injectTable() {
      var parent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (!this.injected) {
        (parent || this.hot.rootElement).appendChild(this.container.fragment);
        this.injected = true;
      }
    }
  }, {
    key: "removeTable",
    value: function removeTable() {
      if (this.injected && this.container.container.parentNode) {
        this.container.container.parentNode.removeChild(this.container.container);
        this.container = null;
        this.injected = false;
      }
    }
  }, {
    key: "createColElement",
    value: function createColElement(column) {
      var col = this.hot.rootDocument.createElement("col");
      col.style.width = "".concat(this.hot.view.wt.wtTable.getStretchedColumnWidth(column), "px");
      return col;
    }
  }, {
    key: "createTable",
    value: function createTable() {
      var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var rootDocument = this.hot.rootDocument;
      var fragment = rootDocument.createDocumentFragment();
      var table = rootDocument.createElement("table");
      var tHead = rootDocument.createElement("thead");
      var tBody = rootDocument.createElement("tbody");
      var colGroup = rootDocument.createElement("colgroup");
      var tr = rootDocument.createElement("tr");
      var th = rootDocument.createElement("th");
      if (this.isVertical()) {
        table.appendChild(colGroup);
      }
      if (this.isHorizontal()) {
        tr.appendChild(th);
        tHead.appendChild(tr);
        table.style.tableLayout = "auto";
        table.style.width = "auto";
      }
      table.appendChild(tHead);
      if (this.isVertical()) {
        tBody.appendChild(tr);
      }
      table.appendChild(tBody);
      addClass(table, className);
      fragment.appendChild(table);
      return {
        fragment,
        table,
        tHead,
        tBody,
        colGroup,
        tr,
        th
      };
    }
  }, {
    key: "createContainer",
    value: function createContainer() {
      var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var rootDocument = this.hot.rootDocument;
      var fragment = rootDocument.createDocumentFragment();
      var container = rootDocument.createElement("div");
      var containerClassName = "htGhostTable htAutoSize ".concat(className.trim());
      addClass(container, containerClassName);
      fragment.appendChild(container);
      return {
        fragment,
        container
      };
    }
  }, {
    key: "isVertical",
    value: function isVertical() {
      return !!(this.rows.length && !this.columns.length);
    }
  }, {
    key: "isHorizontal",
    value: function isHorizontal() {
      return !!(this.columns.length && !this.rows.length);
    }
  }]);
  return GhostTable2;
}();

function getNormalizedDate(dateString) {
  var nativeDate = new Date(dateString);
  if (!isNaN(new Date("".concat(dateString, "T00:00")).getDate())) {
    return new Date(nativeDate.getTime() + nativeDate.getTimezoneOffset() * 6e4);
  }
  return nativeDate;
}

var dateHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getNormalizedDate: getNormalizedDate
});

function _typeof$C(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$C = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$C = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$C(obj);
}
function _classCallCheck$19(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$14(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$14(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$14(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$14(Constructor, staticProps);
  return Constructor;
}
function _get$5(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$5 = Reflect.get;
  } else {
    _get$5 = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$5(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$5(target, property, receiver || target);
}
function _superPropBase$5(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$q(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$r(subClass, superClass);
}
function _setPrototypeOf$r(o, p) {
  _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$r(o, p);
}
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$q(this, result);
  };
}
function _possibleConstructorReturn$q(self, call) {
  if (call && (_typeof$C(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$q(self);
}
function _assertThisInitialized$q(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$q(o) {
  _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$q(o);
}
var EDITOR_TYPE$2 = "handsontable";
var HandsontableEditor = /* @__PURE__ */ function(_TextEditor) {
  _inherits$q(HandsontableEditor2, _TextEditor);
  var _super = _createSuper$q(HandsontableEditor2);
  function HandsontableEditor2() {
    _classCallCheck$19(this, HandsontableEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$14(HandsontableEditor2, [{
    key: "open",
    value: function open() {
      _get$5(_getPrototypeOf$q(HandsontableEditor2.prototype), "open", this).call(this);
      if (this.htEditor) {
        this.htEditor.destroy();
      }
      if (this.htContainer.style.display === "none") {
        this.htContainer.style.display = "";
      }
      this.htEditor = new this.hot.constructor(this.htContainer, this.htOptions);
      this.htEditor.init();
      this.htEditor.rootElement.style.display = "";
      if (this.cellProperties.strict) {
        this.htEditor.selectCell(0, 0);
      } else {
        this.htEditor.deselectCell();
      }
      setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);
    }
  }, {
    key: "close",
    value: function close() {
      if (this.htEditor) {
        this.htEditor.rootElement.style.display = "none";
      }
      this.removeHooksByKey("beforeKeyDown");
      _get$5(_getPrototypeOf$q(HandsontableEditor2.prototype), "close", this).call(this);
    }
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      _get$5(_getPrototypeOf$q(HandsontableEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
      var parent = this;
      var options = {
        startRows: 0,
        startCols: 0,
        minRows: 0,
        minCols: 0,
        className: "listbox",
        copyPaste: false,
        autoColumnSize: false,
        autoRowSize: false,
        readOnly: true,
        fillHandle: false,
        autoWrapCol: false,
        autoWrapRow: false,
        afterOnCellMouseDown: function afterOnCellMouseDown(_, coords) {
          var sourceValue = this.getSourceData(coords.row, coords.col);
          if (sourceValue !== void 0) {
            parent.setValue(sourceValue);
          }
          parent.instance.destroyEditor();
        },
        preventWheel: true
      };
      if (this.cellProperties.handsontable) {
        extend(options, cellProperties.handsontable);
      }
      this.htOptions = options;
    }
  }, {
    key: "beginEditing",
    value: function beginEditing(newInitialValue, event) {
      var onBeginEditing = this.hot.getSettings().onBeginEditing;
      if (onBeginEditing && onBeginEditing() === false) {
        return;
      }
      _get$5(_getPrototypeOf$q(HandsontableEditor2.prototype), "beginEditing", this).call(this, newInitialValue, event);
    }
  }, {
    key: "createElements",
    value: function createElements() {
      _get$5(_getPrototypeOf$q(HandsontableEditor2.prototype), "createElements", this).call(this);
      var DIV = this.hot.rootDocument.createElement("DIV");
      DIV.className = "handsontableEditor";
      this.TEXTAREA_PARENT.appendChild(DIV);
      this.htContainer = DIV;
      this.assignHooks();
    }
  }, {
    key: "finishEditing",
    value: function finishEditing(restoreOriginalValue, ctrlDown, callback) {
      if (this.htEditor && this.htEditor.isListening()) {
        this.hot.listen();
      }
      if (this.htEditor && this.htEditor.getSelectedLast()) {
        var value = this.htEditor.getInstance().getValue();
        if (value !== void 0) {
          this.setValue(value);
        }
      }
      _get$5(_getPrototypeOf$q(HandsontableEditor2.prototype), "finishEditing", this).call(this, restoreOriginalValue, ctrlDown, callback);
    }
  }, {
    key: "assignHooks",
    value: function assignHooks() {
      var _this = this;
      this.hot.addHook("afterDestroy", function() {
        if (_this.htEditor) {
          _this.htEditor.destroy();
        }
      });
    }
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown(event) {
      if (isImmediatePropagationStopped(event)) {
        return;
      }
      var innerHOT = this.htEditor.getInstance();
      var rowToSelect;
      var selectedRow;
      if (event.keyCode === KEY_CODES.ARROW_DOWN) {
        if (!innerHOT.getSelectedLast() && !innerHOT.flipped) {
          rowToSelect = 0;
        } else if (innerHOT.getSelectedLast()) {
          if (innerHOT.flipped) {
            rowToSelect = innerHOT.getSelectedLast()[0] + 1;
          } else if (!innerHOT.flipped) {
            var lastRow = innerHOT.countRows() - 1;
            selectedRow = innerHOT.getSelectedLast()[0];
            rowToSelect = Math.min(lastRow, selectedRow + 1);
          }
        }
      } else if (event.keyCode === KEY_CODES.ARROW_UP) {
        if (!innerHOT.getSelectedLast() && innerHOT.flipped) {
          rowToSelect = innerHOT.countRows() - 1;
        } else if (innerHOT.getSelectedLast()) {
          if (innerHOT.flipped) {
            selectedRow = innerHOT.getSelectedLast()[0];
            rowToSelect = Math.max(0, selectedRow - 1);
          } else {
            selectedRow = innerHOT.getSelectedLast()[0];
            rowToSelect = selectedRow - 1;
          }
        }
      }
      if (rowToSelect !== void 0) {
        if (rowToSelect < 0 || innerHOT.flipped && rowToSelect > innerHOT.countRows() - 1) {
          innerHOT.deselectCell();
        } else {
          innerHOT.selectCell(rowToSelect, 0);
        }
        if (innerHOT.getData().length) {
          event.preventDefault();
          stopImmediatePropagation(event);
          this.hot.listen();
          this.TEXTAREA.focus();
        }
      }
      _get$5(_getPrototypeOf$q(HandsontableEditor2.prototype), "onBeforeKeyDown", this).call(this, event);
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE$2;
    }
  }]);
  return HandsontableEditor2;
}(TextEditor);

function _typeof$D(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$D = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$D = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$D(obj);
}
function _classCallCheck$1a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$15(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$15(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$15(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$15(Constructor, staticProps);
  return Constructor;
}
function _get$6(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$6 = Reflect.get;
  } else {
    _get$6 = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$6(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$6(target, property, receiver || target);
}
function _superPropBase$6(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$r(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$r(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$s(subClass, superClass);
}
function _setPrototypeOf$s(o, p) {
  _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$s(o, p);
}
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$r(this, result);
  };
}
function _possibleConstructorReturn$r(self, call) {
  if (call && (_typeof$D(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$r(self);
}
function _assertThisInitialized$r(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$r(o) {
  _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$r(o);
}
var privatePool$4 = new WeakMap();
var EDITOR_TYPE$3 = "autocomplete";
var AutocompleteEditor = /* @__PURE__ */ function(_HandsontableEditor) {
  _inherits$r(AutocompleteEditor2, _HandsontableEditor);
  var _super = _createSuper$r(AutocompleteEditor2);
  function AutocompleteEditor2(instance) {
    var _this;
    _classCallCheck$1a(this, AutocompleteEditor2);
    _this = _super.call(this, instance);
    _this.query = null;
    _this.strippedChoices = [];
    _this.rawChoices = [];
    privatePool$4.set(_assertThisInitialized$r(_this), {
      skipOne: false,
      isMacOS: _this.hot.rootWindow.navigator.platform.indexOf("Mac") > -1
    });
    return _this;
  }
  _createClass$15(AutocompleteEditor2, [{
    key: "getValue",
    value: function getValue() {
      var _this2 = this;
      var selectedValue = this.rawChoices.find(function(value) {
        var strippedValue = _this2.stripValueIfNeeded(value);
        return strippedValue === _this2.TEXTAREA.value;
      });
      if (isDefined(selectedValue)) {
        return selectedValue;
      }
      return this.TEXTAREA.value;
    }
  }, {
    key: "createElements",
    value: function createElements() {
      _get$6(_getPrototypeOf$r(AutocompleteEditor2.prototype), "createElements", this).call(this);
      addClass(this.htContainer, "autocompleteEditor");
      addClass(this.htContainer, this.hot.rootWindow.navigator.platform.indexOf("Mac") === -1 ? "" : "htMacScroll");
    }
  }, {
    key: "open",
    value: function open() {
      var _this3 = this;
      var priv = privatePool$4.get(this);
      _get$6(_getPrototypeOf$r(AutocompleteEditor2.prototype), "open", this).call(this);
      var choicesListHot = this.htEditor.getInstance();
      var trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;
      this.showEditableElement();
      this.focus();
      var scrollbarWidth = getScrollbarWidth();
      if (scrollbarWidth === 0 && priv.isMacOS) {
        scrollbarWidth += 15;
      }
      choicesListHot.updateSettings({
        colWidths: trimDropdown ? [outerWidth(this.TEXTAREA) - 2] : void 0,
        width: trimDropdown ? outerWidth(this.TEXTAREA) + scrollbarWidth : void 0,
        renderer: function renderer(instance, TD, row, col, prop, value, cellProperties) {
          textRenderer(instance, TD, row, col, prop, value, cellProperties);
          var _this3$cellProperties = _this3.cellProperties, filteringCaseSensitive = _this3$cellProperties.filteringCaseSensitive, allowHtml = _this3$cellProperties.allowHtml;
          var query = _this3.query;
          var cellValue = stringify(value);
          var indexOfMatch;
          var match;
          if (cellValue && !allowHtml) {
            indexOfMatch = filteringCaseSensitive === true ? cellValue.indexOf(query) : cellValue.toLowerCase().indexOf(query.toLowerCase());
            if (indexOfMatch !== -1) {
              match = cellValue.substr(indexOfMatch, query.length);
              cellValue = cellValue.replace(match, "<strong>".concat(match, "</strong>"));
            }
          }
          TD.innerHTML = cellValue;
        },
        autoColumnSize: true
      });
      if (priv.skipOne) {
        priv.skipOne = false;
      }
      this.hot._registerTimeout(function() {
        _this3.queryChoices(_this3.TEXTAREA.value);
      });
    }
  }, {
    key: "close",
    value: function close() {
      this.removeHooksByKey("beforeKeyDown");
      _get$6(_getPrototypeOf$r(AutocompleteEditor2.prototype), "close", this).call(this);
    }
  }, {
    key: "discardEditor",
    value: function discardEditor(result) {
      _get$6(_getPrototypeOf$r(AutocompleteEditor2.prototype), "discardEditor", this).call(this, result);
      this.hot.view.render();
    }
  }, {
    key: "queryChoices",
    value: function queryChoices(query) {
      var _this4 = this;
      var source = this.cellProperties.source;
      this.query = query;
      if (typeof source === "function") {
        source.call(this.cellProperties, query, function(choices) {
          _this4.rawChoices = choices;
          _this4.updateChoicesList(_this4.stripValuesIfNeeded(choices));
        });
      } else if (Array.isArray(source)) {
        this.rawChoices = source;
        this.updateChoicesList(this.stripValuesIfNeeded(source));
      } else {
        this.updateChoicesList([]);
      }
    }
  }, {
    key: "updateChoicesList",
    value: function updateChoicesList(choicesList) {
      var pos = getCaretPosition(this.TEXTAREA);
      var endPos = getSelectionEndPosition(this.TEXTAREA);
      var sortByRelevanceSetting = this.cellProperties.sortByRelevance;
      var filterSetting = this.cellProperties.filter;
      var orderByRelevance = null;
      var highlightIndex = null;
      var choices = choicesList;
      if (sortByRelevanceSetting) {
        orderByRelevance = AutocompleteEditor2.sortByRelevance(this.stripValueIfNeeded(this.getValue()), choices, this.cellProperties.filteringCaseSensitive);
      }
      var orderByRelevanceLength = Array.isArray(orderByRelevance) ? orderByRelevance.length : 0;
      if (filterSetting === false) {
        if (orderByRelevanceLength) {
          highlightIndex = orderByRelevance[0];
        }
      } else {
        var sorted = [];
        for (var i = 0, choicesCount = choices.length; i < choicesCount; i++) {
          if (sortByRelevanceSetting && orderByRelevanceLength <= i) {
            break;
          }
          if (orderByRelevanceLength) {
            sorted.push(choices[orderByRelevance[i]]);
          } else {
            sorted.push(choices[i]);
          }
        }
        highlightIndex = 0;
        choices = sorted;
      }
      this.strippedChoices = choices;
      this.htEditor.loadData(pivot([choices]));
      this.updateDropdownHeight();
      this.flipDropdownIfNeeded();
      if (this.cellProperties.strict === true) {
        this.highlightBestMatchingChoice(highlightIndex);
      }
      this.hot.listen();
      setCaretPosition(this.TEXTAREA, pos, pos === endPos ? void 0 : endPos);
    }
  }, {
    key: "flipDropdownIfNeeded",
    value: function flipDropdownIfNeeded() {
      var textareaOffset = offset$1(this.TEXTAREA);
      var textareaHeight = outerHeight(this.TEXTAREA);
      var dropdownHeight = this.getDropdownHeight();
      var trimmingContainer = getTrimmingContainer(this.hot.view.wt.wtTable.TABLE);
      var trimmingContainerScrollTop = trimmingContainer.scrollTop;
      var headersHeight = outerHeight(this.hot.view.wt.wtTable.THEAD);
      var containerOffset = {
        row: 0,
        col: 0
      };
      if (trimmingContainer !== this.hot.rootWindow) {
        containerOffset = offset$1(trimmingContainer);
      }
      var spaceAbove = textareaOffset.top - containerOffset.top - headersHeight + trimmingContainerScrollTop;
      var spaceBelow = trimmingContainer.scrollHeight - spaceAbove - headersHeight - textareaHeight;
      var flipNeeded = dropdownHeight > spaceBelow && spaceAbove > spaceBelow;
      if (flipNeeded) {
        this.flipDropdown(dropdownHeight);
      } else {
        this.unflipDropdown();
      }
      this.limitDropdownIfNeeded(flipNeeded ? spaceAbove : spaceBelow, dropdownHeight);
      return flipNeeded;
    }
  }, {
    key: "limitDropdownIfNeeded",
    value: function limitDropdownIfNeeded(spaceAvailable, dropdownHeight) {
      if (dropdownHeight > spaceAvailable) {
        var tempHeight = 0;
        var i = 0;
        var lastRowHeight = 0;
        var height = null;
        do {
          lastRowHeight = this.htEditor.getRowHeight(i) || this.htEditor.view.wt.wtSettings.settings.defaultRowHeight;
          tempHeight += lastRowHeight;
          i += 1;
        } while (tempHeight < spaceAvailable);
        height = tempHeight - lastRowHeight;
        if (this.htEditor.flipped) {
          this.htEditor.rootElement.style.top = "".concat(parseInt(this.htEditor.rootElement.style.top, 10) + dropdownHeight - height, "px");
        }
        this.setDropdownHeight(tempHeight - lastRowHeight);
      }
    }
  }, {
    key: "flipDropdown",
    value: function flipDropdown(dropdownHeight) {
      var dropdownStyle = this.htEditor.rootElement.style;
      dropdownStyle.position = "absolute";
      dropdownStyle.top = "".concat(-dropdownHeight, "px");
      this.htEditor.flipped = true;
    }
  }, {
    key: "unflipDropdown",
    value: function unflipDropdown() {
      var dropdownStyle = this.htEditor.rootElement.style;
      if (dropdownStyle.position === "absolute") {
        dropdownStyle.position = "";
        dropdownStyle.top = "";
      }
      this.htEditor.flipped = void 0;
    }
  }, {
    key: "updateDropdownHeight",
    value: function updateDropdownHeight() {
      var currentDropdownWidth = this.htEditor.getColWidth(0) + getScrollbarWidth(this.hot.rootDocument) + 2;
      var trimDropdown = this.cellProperties.trimDropdown;
      this.htEditor.updateSettings({
        height: this.getDropdownHeight(),
        width: trimDropdown ? void 0 : currentDropdownWidth
      });
      this.htEditor.view.wt.wtTable.alignOverlaysWithTrimmingContainer();
    }
  }, {
    key: "setDropdownHeight",
    value: function setDropdownHeight(height) {
      this.htEditor.updateSettings({
        height
      });
    }
  }, {
    key: "highlightBestMatchingChoice",
    value: function highlightBestMatchingChoice(index) {
      if (typeof index === "number") {
        this.htEditor.selectCell(index, 0, void 0, void 0, void 0, false);
      } else {
        this.htEditor.deselectCell();
      }
    }
  }, {
    key: "getDropdownHeight",
    value: function getDropdownHeight() {
      var firstRowHeight = this.htEditor.getInstance().getRowHeight(0) || 23;
      var visibleRows = this.cellProperties.visibleRows;
      return this.strippedChoices.length >= visibleRows ? visibleRows * firstRowHeight : this.strippedChoices.length * firstRowHeight + 8;
    }
  }, {
    key: "stripValueIfNeeded",
    value: function stripValueIfNeeded(value) {
      return this.stripValuesIfNeeded([value])[0];
    }
  }, {
    key: "stripValuesIfNeeded",
    value: function stripValuesIfNeeded(values) {
      var allowHtml = this.cellProperties.allowHtml;
      var stringifiedValues = arrayMap(values, function(value) {
        return stringify(value);
      });
      var strippedValues = arrayMap(stringifiedValues, function(value) {
        return allowHtml ? value : stripTags(value);
      });
      return strippedValues;
    }
  }, {
    key: "allowKeyEventPropagation",
    value: function allowKeyEventPropagation(keyCode) {
      var selectedRange = this.htEditor.getSelectedRangeLast();
      var selected = {
        row: selectedRange ? selectedRange.from.row : -1
      };
      var allowed = false;
      if (keyCode === KEY_CODES.ARROW_DOWN && selected.row > 0 && selected.row < this.htEditor.countRows() - 1) {
        allowed = true;
      }
      if (keyCode === KEY_CODES.ARROW_UP && selected.row > -1) {
        allowed = true;
      }
      return allowed;
    }
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown(event) {
      var _this5 = this;
      var priv = privatePool$4.get(this);
      priv.skipOne = false;
      if (isPrintableChar(event.keyCode) || event.keyCode === KEY_CODES.BACKSPACE || event.keyCode === KEY_CODES.DELETE || event.keyCode === KEY_CODES.INSERT) {
        var timeOffset = 0;
        if (event.keyCode === KEY_CODES.C && (event.ctrlKey || event.metaKey)) {
          return;
        }
        if (!this.isOpened()) {
          timeOffset += 10;
        }
        if (this.htEditor) {
          this.hot._registerTimeout(function() {
            _this5.queryChoices(_this5.TEXTAREA.value);
            priv.skipOne = true;
          }, timeOffset);
        }
      }
      _get$6(_getPrototypeOf$r(AutocompleteEditor2.prototype), "onBeforeKeyDown", this).call(this, event);
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE$3;
    }
  }]);
  return AutocompleteEditor2;
}(HandsontableEditor);
AutocompleteEditor.sortByRelevance = function(value, choices, caseSensitive) {
  var choicesRelevance = [];
  var result = [];
  var valueLength = value.length;
  var choicesCount = choices.length;
  var charsLeft;
  var currentItem;
  var i;
  var valueIndex;
  if (valueLength === 0) {
    for (i = 0; i < choicesCount; i++) {
      result.push(i);
    }
    return result;
  }
  for (i = 0; i < choicesCount; i++) {
    currentItem = stripTags(stringify(choices[i]));
    if (caseSensitive) {
      valueIndex = currentItem.indexOf(value);
    } else {
      valueIndex = currentItem.toLowerCase().indexOf(value.toLowerCase());
    }
    if (valueIndex !== -1) {
      charsLeft = currentItem.length - valueIndex - valueLength;
      choicesRelevance.push({
        baseIndex: i,
        index: valueIndex,
        charsLeft,
        value: currentItem
      });
    }
  }
  choicesRelevance.sort(function(a, b) {
    if (b.index === -1) {
      return -1;
    }
    if (a.index === -1) {
      return 1;
    }
    if (a.index < b.index) {
      return -1;
    } else if (b.index < a.index) {
      return 1;
    } else if (a.index === b.index) {
      if (a.charsLeft < b.charsLeft) {
        return -1;
      } else if (a.charsLeft > b.charsLeft) {
        return 1;
      }
    }
    return 0;
  });
  for (i = 0, choicesCount = choicesRelevance.length; i < choicesCount; i++) {
    result.push(choicesRelevance[i].baseIndex);
  }
  return result;
};

function _typeof$E(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$E = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$E = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$E(obj);
}
function _classCallCheck$1b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$16(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$16(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$16(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$16(Constructor, staticProps);
  return Constructor;
}
function _inherits$s(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$t(subClass, superClass);
}
function _setPrototypeOf$t(o, p) {
  _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$t(o, p);
}
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$s(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$s(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$s(this, result);
  };
}
function _possibleConstructorReturn$s(self, call) {
  if (call && (_typeof$E(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$s(self);
}
function _assertThisInitialized$s(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$s(o) {
  _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$s(o);
}
var EDITOR_TYPE$4 = "checkbox";
var CheckboxEditor = /* @__PURE__ */ function(_BaseEditor) {
  _inherits$s(CheckboxEditor2, _BaseEditor);
  var _super = _createSuper$s(CheckboxEditor2);
  function CheckboxEditor2() {
    _classCallCheck$1b(this, CheckboxEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$16(CheckboxEditor2, [{
    key: "beginEditing",
    value: function beginEditing(initialValue, event) {
      if (event && event.type === "mouseup") {
        var checkbox = this.TD.querySelector('input[type="checkbox"]');
        if (!hasClass(checkbox, "htBadValue")) {
          checkbox.click();
        }
      }
    }
  }, {
    key: "finishEditing",
    value: function finishEditing() {
    }
  }, {
    key: "init",
    value: function init() {
    }
  }, {
    key: "open",
    value: function open() {
    }
  }, {
    key: "close",
    value: function close() {
    }
  }, {
    key: "getValue",
    value: function getValue() {
    }
  }, {
    key: "setValue",
    value: function setValue() {
    }
  }, {
    key: "focus",
    value: function focus() {
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE$4;
    }
  }]);
  return CheckboxEditor2;
}(BaseEditor);

var pikaday = createCommonjsModule$1(function (module, exports) {
/*!
 * Pikaday
 *
 * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/Pikaday/Pikaday
 */

(function (root, factory)
{

    var moment;
    {
        // CommonJS module
        // Load moment.js as an optional dependency
        try { moment = hooks; } catch (e) {}
        module.exports = factory(moment);
    }
}(commonjsGlobal, function (moment)
{

    /**
     * feature detection and helper functions
     */
    var hasMoment = typeof moment === 'function',

    hasEventListeners = !!window.addEventListener,

    document = window.document,

    sto = window.setTimeout,

    addEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.addEventListener(e, callback, !!capture);
        } else {
            el.attachEvent('on' + e, callback);
        }
    },

    removeEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.removeEventListener(e, callback, !!capture);
        } else {
            el.detachEvent('on' + e, callback);
        }
    },

    trim = function(str)
    {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
    },

    hasClass = function(el, cn)
    {
        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
    },

    addClass = function(el, cn)
    {
        if (!hasClass(el, cn)) {
            el.className = (el.className === '') ? cn : el.className + ' ' + cn;
        }
    },

    removeClass = function(el, cn)
    {
        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
    },

    isArray = function(obj)
    {
        return (/Array/).test(Object.prototype.toString.call(obj));
    },

    isDate = function(obj)
    {
        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
    },

    isWeekend = function(date)
    {
        var day = date.getDay();
        return day === 0 || day === 6;
    },

    isLeapYear = function(year)
    {
        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    },

    getDaysInMonth = function(year, month)
    {
        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },

    setToStartOfDay = function(date)
    {
        if (isDate(date)) date.setHours(0,0,0,0);
    },

    compareDates = function(a,b)
    {
        // weak date comparison (use setToStartOfDay(date) to ensure correct result)
        return a.getTime() === b.getTime();
    },

    extend = function(to, from, overwrite)
    {
        var prop, hasProp;
        for (prop in from) {
            hasProp = to[prop] !== undefined;
            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                if (isDate(from[prop])) {
                    if (overwrite) {
                        to[prop] = new Date(from[prop].getTime());
                    }
                }
                else if (isArray(from[prop])) {
                    if (overwrite) {
                        to[prop] = from[prop].slice(0);
                    }
                } else {
                    to[prop] = extend({}, from[prop], overwrite);
                }
            } else if (overwrite || !hasProp) {
                to[prop] = from[prop];
            }
        }
        return to;
    },

    fireEvent = function(el, eventName, data)
    {
        var ev;

        if (document.createEvent) {
            ev = document.createEvent('HTMLEvents');
            ev.initEvent(eventName, true, false);
            ev = extend(ev, data);
            el.dispatchEvent(ev);
        } else if (document.createEventObject) {
            ev = document.createEventObject();
            ev = extend(ev, data);
            el.fireEvent('on' + eventName, ev);
        }
    },

    adjustCalendar = function(calendar) {
        if (calendar.month < 0) {
            calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
            calendar.month += 12;
        }
        if (calendar.month > 11) {
            calendar.year += Math.floor(Math.abs(calendar.month)/12);
            calendar.month -= 12;
        }
        return calendar;
    },

    /**
     * defaults and localisation
     */
    defaults = {

        // bind the picker to a form field
        field: null,

        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
        bound: undefined,

        // data-attribute on the input field with an aria assistance tekst (only applied when `bound` is set)
        ariaLabel: 'Use the arrow keys to pick a date',

        // position of the datepicker, relative to the field (default to bottom & left)
        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
        position: 'bottom left',

        // automatically fit in the viewport even if it means repositioning from the position option
        reposition: true,

        // the default output format for `.toString()` and `field` value
        format: 'YYYY-MM-DD',

        // the toString function which gets passed a current date object and format
        // and returns a string
        toString: null,

        // used to create date object from current input string
        parse: null,

        // the initial date to view when first opened
        defaultDate: null,

        // make the `defaultDate` the initial selected value
        setDefaultDate: false,

        // first day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,

        // the default flag for moment's strict date parsing
        formatStrict: false,

        // the minimum/earliest date that can be selected
        minDate: null,
        // the maximum/latest date that can be selected
        maxDate: null,

        // number of years either side, or array of upper/lower range
        yearRange: 10,

        // show week numbers at head of row
        showWeekNumber: false,

        // Week picker mode
        pickWholeWeek: false,

        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: undefined,
        maxMonth: undefined,

        startRange: null,
        endRange: null,

        isRTL: false,

        // Additional text to append to the year in the calendar title
        yearSuffix: '',

        // Render the month after year in the calendar title
        showMonthAfterYear: false,

        // Render days of the calendar grid that fall in the next or previous month
        showDaysInNextAndPreviousMonths: false,

        // Allows user to select days that fall in the next or previous month
        enableSelectionDaysInNextAndPreviousMonths: false,

        // how many months are visible
        numberOfMonths: 1,

        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
        // only used for the first display or when a selected date is not visible
        mainCalendar: 'left',

        // Specify a DOM element to render the calendar in
        container: undefined,

        // Blur field when date is selected
        blurFieldOnSelect : true,

        // internationalization
        i18n: {
            previousMonth : 'Previous Month',
            nextMonth     : 'Next Month',
            months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
            weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
            weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
        },

        // Theme Classname
        theme: null,

        // events array
        events: [],

        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null,

        // Enable keyboard input
        keyboardInput: true
    },


    /**
     * templating functions to abstract HTML rendering
     */
    renderDayName = function(opts, day, abbr)
    {
        day += opts.firstDay;
        while (day >= 7) {
            day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
    },

    renderDay = function(opts)
    {
        var arr = [];
        var ariaSelected = 'false';
        if (opts.isEmpty) {
            if (opts.showDaysInNextAndPreviousMonths) {
                arr.push('is-outside-current-month');

                if(!opts.enableSelectionDaysInNextAndPreviousMonths) {
                    arr.push('is-selection-disabled');
                }

            } else {
                return '<td class="is-empty"></td>';
            }
        }
        if (opts.isDisabled) {
            arr.push('is-disabled');
        }
        if (opts.isToday) {
            arr.push('is-today');
        }
        if (opts.isSelected) {
            arr.push('is-selected');
            ariaSelected = 'true';
        }
        if (opts.hasEvent) {
            arr.push('has-event');
        }
        if (opts.isInRange) {
            arr.push('is-inrange');
        }
        if (opts.isStartRange) {
            arr.push('is-startrange');
        }
        if (opts.isEndRange) {
            arr.push('is-endrange');
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' +
                 '<button class="pika-button pika-day" type="button" ' +
                    'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                        opts.day +
                 '</button>' +
               '</td>';
    },

    renderWeek = function (d, m, y) {
        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
        var onejan = new Date(y, 0, 1),
            weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
        return '<td class="pika-week">' + weekNum + '</td>';
    },

    renderRow = function(days, isRTL, pickWholeWeek, isRowSelected)
    {
        return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
    },

    renderBody = function(rows)
    {
        return '<tbody>' + rows.join('') + '</tbody>';
    },

    renderHead = function(opts)
    {
        var i, arr = [];
        if (opts.showWeekNumber) {
            arr.push('<th></th>');
        }
        for (i = 0; i < 7; i++) {
            arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
        }
        return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
    },

    renderTitle = function(instance, c, year, month, refYear, randId)
    {
        var i, j, arr,
            opts = instance._o,
            isMinYear = year === opts.minYear,
            isMaxYear = year === opts.maxYear,
            html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
            monthHtml,
            yearHtml,
            prev = true,
            next = true;

        for (arr = [], i = 0; i < 12; i++) {
            arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                (i === month ? ' selected="selected"': '') +
                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled="disabled"' : '') + '>' +
                opts.i18n.months[i] + '</option>');
        }

        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

        if (isArray(opts.yearRange)) {
            i = opts.yearRange[0];
            j = opts.yearRange[1] + 1;
        } else {
            i = year - opts.yearRange;
            j = 1 + year + opts.yearRange;
        }

        for (arr = []; i < j && i <= opts.maxYear; i++) {
            if (i >= opts.minYear) {
                arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"': '') + '>' + (i) + '</option>');
            }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

        if (opts.showMonthAfterYear) {
            html += yearHtml + monthHtml;
        } else {
            html += monthHtml + yearHtml;
        }

        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
            prev = false;
        }

        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
            next = false;
        }

        if (c === 0) {
            html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
        }
        if (c === (instance._o.numberOfMonths - 1) ) {
            html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
        }

        return html += '</div>';
    },

    renderTable = function(opts, data, randId)
    {
        return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
    },


    /**
     * Pikaday constructor
     */
    Pikaday = function(options)
    {
        var self = this,
            opts = self.config(options);

        self._onMouseDown = function(e)
        {
            if (!self._v) {
                return;
            }
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }

            if (!hasClass(target, 'is-disabled')) {
                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
                    self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
                    if (opts.bound) {
                        sto(function() {
                            self.hide();
                            if (opts.blurFieldOnSelect && opts.field) {
                                opts.field.blur();
                            }
                        }, 100);
                    }
                }
                else if (hasClass(target, 'pika-prev')) {
                    self.prevMonth();
                }
                else if (hasClass(target, 'pika-next')) {
                    self.nextMonth();
                }
            }
            if (!hasClass(target, 'pika-select')) {
                // if this is touch event prevent mouse events emulation
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                    return false;
                }
            } else {
                self._c = true;
            }
        };

        self._onChange = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }
            if (hasClass(target, 'pika-select-month')) {
                self.gotoMonth(target.value);
            }
            else if (hasClass(target, 'pika-select-year')) {
                self.gotoYear(target.value);
            }
        };

        self._onKeyChange = function(e)
        {
            e = e || window.event;

            if (self.isVisible()) {

                switch(e.keyCode){
                    case 13:
                    case 27:
                        if (opts.field) {
                            opts.field.blur();
                        }
                        break;
                    case 37:
                        e.preventDefault();
                        self.adjustDate('subtract', 1);
                        break;
                    case 38:
                        self.adjustDate('subtract', 7);
                        break;
                    case 39:
                        self.adjustDate('add', 1);
                        break;
                    case 40:
                        self.adjustDate('add', 7);
                        break;
                }
            }
        };

        self._onInputChange = function(e)
        {
            var date;

            if (e.firedBy === self) {
                return;
            }
            if (opts.parse) {
                date = opts.parse(opts.field.value, opts.format);
            } else if (hasMoment) {
                date = moment(opts.field.value, opts.format, opts.formatStrict);
                date = (date && date.isValid()) ? date.toDate() : null;
            }
            else {
                date = new Date(Date.parse(opts.field.value));
            }
            if (isDate(date)) {
              self.setDate(date);
            }
            if (!self._v) {
                self.show();
            }
        };

        self._onInputFocus = function()
        {
            self.show();
        };

        self._onInputClick = function()
        {
            self.show();
        };

        self._onInputBlur = function()
        {
            // IE allows pika div to gain focus; catch blur the input field
            var pEl = document.activeElement;
            do {
                if (hasClass(pEl, 'pika-single')) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));

            if (!self._c) {
                self._b = sto(function() {
                    self.hide();
                }, 50);
            }
            self._c = false;
        };

        self._onClick = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement,
                pEl = target;
            if (!target) {
                return;
            }
            if (!hasEventListeners && hasClass(target, 'pika-select')) {
                if (!target.onchange) {
                    target.setAttribute('onchange', 'return;');
                    addEvent(target, 'change', self._onChange);
                }
            }
            do {
                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));
            if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                self.hide();
            }
        };

        self.el = document.createElement('div');
        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

        addEvent(self.el, 'mousedown', self._onMouseDown, true);
        addEvent(self.el, 'touchend', self._onMouseDown, true);
        addEvent(self.el, 'change', self._onChange);

        if (opts.keyboardInput) {
            addEvent(document, 'keydown', self._onKeyChange);
        }

        if (opts.field) {
            if (opts.container) {
                opts.container.appendChild(self.el);
            } else if (opts.bound) {
                document.body.appendChild(self.el);
            } else {
                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
            }
            addEvent(opts.field, 'change', self._onInputChange);

            if (!opts.defaultDate) {
                if (hasMoment && opts.field.value) {
                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();
                } else {
                    opts.defaultDate = new Date(Date.parse(opts.field.value));
                }
                opts.setDefaultDate = true;
            }
        }

        var defDate = opts.defaultDate;

        if (isDate(defDate)) {
            if (opts.setDefaultDate) {
                self.setDate(defDate, true);
            } else {
                self.gotoDate(defDate);
            }
        } else {
            self.gotoDate(new Date());
        }

        if (opts.bound) {
            this.hide();
            self.el.className += ' is-bound';
            addEvent(opts.trigger, 'click', self._onInputClick);
            addEvent(opts.trigger, 'focus', self._onInputFocus);
            addEvent(opts.trigger, 'blur', self._onInputBlur);
        } else {
            this.show();
        }
    };


    /**
     * public Pikaday API
     */
    Pikaday.prototype = {


        /**
         * configure functionality
         */
        config: function(options)
        {
            if (!this._o) {
                this._o = extend({}, defaults, true);
            }

            var opts = extend(this._o, options, true);

            opts.isRTL = !!opts.isRTL;

            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

            opts.disableWeekends = !!opts.disableWeekends;

            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

            var nom = parseInt(opts.numberOfMonths, 10) || 1;
            opts.numberOfMonths = nom > 4 ? 4 : nom;

            if (!isDate(opts.minDate)) {
                opts.minDate = false;
            }
            if (!isDate(opts.maxDate)) {
                opts.maxDate = false;
            }
            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                opts.maxDate = opts.minDate = false;
            }
            if (opts.minDate) {
                this.setMinDate(opts.minDate);
            }
            if (opts.maxDate) {
                this.setMaxDate(opts.maxDate);
            }

            if (isArray(opts.yearRange)) {
                var fallback = new Date().getFullYear() - 10;
                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
            } else {
                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                if (opts.yearRange > 100) {
                    opts.yearRange = 100;
                }
            }

            return opts;
        },

        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format)
        {
            format = format || this._o.format;
            if (!isDate(this._d)) {
                return '';
            }
            if (this._o.toString) {
              return this._o.toString(this._d, format);
            }
            if (hasMoment) {
              return moment(this._d).format(format);
            }
            return this._d.toDateString();
        },

        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function()
        {
            return hasMoment ? moment(this._d) : null;
        },

        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect)
        {
            if (hasMoment && moment.isMoment(date)) {
                this.setDate(date.toDate(), preventOnSelect);
            }
        },

        /**
         * return a Date object of the current selection
         */
        getDate: function()
        {
            return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },

        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect)
        {
            if (!date) {
                this._d = null;

                if (this._o.field) {
                    this._o.field.value = '';
                    fireEvent(this._o.field, 'change', { firedBy: this });
                }

                return this.draw();
            }
            if (typeof date === 'string') {
                date = new Date(Date.parse(date));
            }
            if (!isDate(date)) {
                return;
            }

            var min = this._o.minDate,
                max = this._o.maxDate;

            if (isDate(min) && date < min) {
                date = min;
            } else if (isDate(max) && date > max) {
                date = max;
            }

            this._d = new Date(date.getTime());
            setToStartOfDay(this._d);
            this.gotoDate(this._d);

            if (this._o.field) {
                this._o.field.value = this.toString();
                fireEvent(this._o.field, 'change', { firedBy: this });
            }
            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                this._o.onSelect.call(this, this.getDate());
            }
        },

        /**
         * change view to a specific date
         */
        gotoDate: function(date)
        {
            var newCalendar = true;

            if (!isDate(date)) {
                return;
            }

            if (this.calendars) {
                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                    lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
                    visibleDate = date.getTime();
                // get the end of the month
                lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
                lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
            }

            if (newCalendar) {
                this.calendars = [{
                    month: date.getMonth(),
                    year: date.getFullYear()
                }];
                if (this._o.mainCalendar === 'right') {
                    this.calendars[0].month += 1 - this._o.numberOfMonths;
                }
            }

            this.adjustCalendars();
        },

        adjustDate: function(sign, days) {

            var day = this.getDate() || new Date();
            var difference = parseInt(days)*24*60*60*1000;

            var newDay;

            if (sign === 'add') {
                newDay = new Date(day.valueOf() + difference);
            } else if (sign === 'subtract') {
                newDay = new Date(day.valueOf() - difference);
            }

            this.setDate(newDay);
        },

        adjustCalendars: function() {
            this.calendars[0] = adjustCalendar(this.calendars[0]);
            for (var c = 1; c < this._o.numberOfMonths; c++) {
                this.calendars[c] = adjustCalendar({
                    month: this.calendars[0].month + c,
                    year: this.calendars[0].year
                });
            }
            this.draw();
        },

        gotoToday: function()
        {
            this.gotoDate(new Date());
        },

        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month)
        {
            if (!isNaN(month)) {
                this.calendars[0].month = parseInt(month, 10);
                this.adjustCalendars();
            }
        },

        nextMonth: function()
        {
            this.calendars[0].month++;
            this.adjustCalendars();
        },

        prevMonth: function()
        {
            this.calendars[0].month--;
            this.adjustCalendars();
        },

        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year)
        {
            if (!isNaN(year)) {
                this.calendars[0].year = parseInt(year, 10);
                this.adjustCalendars();
            }
        },

        /**
         * change the minDate
         */
        setMinDate: function(value)
        {
            if(value instanceof Date) {
                setToStartOfDay(value);
                this._o.minDate = value;
                this._o.minYear  = value.getFullYear();
                this._o.minMonth = value.getMonth();
            } else {
                this._o.minDate = defaults.minDate;
                this._o.minYear  = defaults.minYear;
                this._o.minMonth = defaults.minMonth;
                this._o.startRange = defaults.startRange;
            }

            this.draw();
        },

        /**
         * change the maxDate
         */
        setMaxDate: function(value)
        {
            if(value instanceof Date) {
                setToStartOfDay(value);
                this._o.maxDate = value;
                this._o.maxYear = value.getFullYear();
                this._o.maxMonth = value.getMonth();
            } else {
                this._o.maxDate = defaults.maxDate;
                this._o.maxYear = defaults.maxYear;
                this._o.maxMonth = defaults.maxMonth;
                this._o.endRange = defaults.endRange;
            }

            this.draw();
        },

        setStartRange: function(value)
        {
            this._o.startRange = value;
        },

        setEndRange: function(value)
        {
            this._o.endRange = value;
        },

        /**
         * refresh the HTML
         */
        draw: function(force)
        {
            if (!this._v && !force) {
                return;
            }
            var opts = this._o,
                minYear = opts.minYear,
                maxYear = opts.maxYear,
                minMonth = opts.minMonth,
                maxMonth = opts.maxMonth,
                html = '',
                randId;

            if (this._y <= minYear) {
                this._y = minYear;
                if (!isNaN(minMonth) && this._m < minMonth) {
                    this._m = minMonth;
                }
            }
            if (this._y >= maxYear) {
                this._y = maxYear;
                if (!isNaN(maxMonth) && this._m > maxMonth) {
                    this._m = maxMonth;
                }
            }

            randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

            for (var c = 0; c < opts.numberOfMonths; c++) {
                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
            }

            this.el.innerHTML = html;

            if (opts.bound) {
                if(opts.field.type !== 'hidden') {
                    sto(function() {
                        opts.trigger.focus();
                    }, 1);
                }
            }

            if (typeof this._o.onDraw === 'function') {
                this._o.onDraw(this);
            }

            if (opts.bound) {
                // let the screen reader user know to use arrow keys
                opts.field.setAttribute('aria-label', opts.ariaLabel);
            }
        },

        adjustPosition: function()
        {
            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect, leftAligned, bottomAligned;

            if (this._o.container) return;

            this.el.style.position = 'absolute';

            field = this._o.trigger;
            pEl = field;
            width = this.el.offsetWidth;
            height = this.el.offsetHeight;
            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;
            leftAligned = true;
            bottomAligned = true;

            if (typeof field.getBoundingClientRect === 'function') {
                clientRect = field.getBoundingClientRect();
                left = clientRect.left + window.pageXOffset;
                top = clientRect.bottom + window.pageYOffset;
            } else {
                left = pEl.offsetLeft;
                top  = pEl.offsetTop + pEl.offsetHeight;
                while((pEl = pEl.offsetParent)) {
                    left += pEl.offsetLeft;
                    top  += pEl.offsetTop;
                }
            }

            // default position is bottom & left
            if ((this._o.reposition && left + width > viewportWidth) ||
                (
                    this._o.position.indexOf('right') > -1 &&
                    left - width + field.offsetWidth > 0
                )
            ) {
                left = left - width + field.offsetWidth;
                leftAligned = false;
            }
            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                (
                    this._o.position.indexOf('top') > -1 &&
                    top - height - field.offsetHeight > 0
                )
            ) {
                top = top - height - field.offsetHeight;
                bottomAligned = false;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';

            addClass(this.el, leftAligned ? 'left-aligned' : 'right-aligned');
            addClass(this.el, bottomAligned ? 'bottom-aligned' : 'top-aligned');
            removeClass(this.el, !leftAligned ? 'left-aligned' : 'right-aligned');
            removeClass(this.el, !bottomAligned ? 'bottom-aligned' : 'top-aligned');
        },

        /**
         * render HTML for a particular month
         */
        render: function(year, month, randId)
        {
            var opts   = this._o,
                now    = new Date(),
                days   = getDaysInMonth(year, month),
                before = new Date(year, month, 1).getDay(),
                data   = [],
                row    = [];
            setToStartOfDay(now);
            if (opts.firstDay > 0) {
                before -= opts.firstDay;
                if (before < 0) {
                    before += 7;
                }
            }
            var previousMonth = month === 0 ? 11 : month - 1,
                nextMonth = month === 11 ? 0 : month + 1,
                yearOfPreviousMonth = month === 0 ? year - 1 : year,
                yearOfNextMonth = month === 11 ? year + 1 : year,
                daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
            var cells = days + before,
                after = cells;
            while(after > 7) {
                after -= 7;
            }
            cells += 7 - after;
            var isWeekSelected = false;
            for (var i = 0, r = 0; i < cells; i++)
            {
                var day = new Date(year, month, 1 + (i - before)),
                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                    isToday = compareDates(day, now),
                    hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                    isEmpty = i < before || i >= (days + before),
                    dayNumber = 1 + (i - before),
                    monthNumber = month,
                    yearNumber = year,
                    isStartRange = opts.startRange && compareDates(opts.startRange, day),
                    isEndRange = opts.endRange && compareDates(opts.endRange, day),
                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                    isDisabled = (opts.minDate && day < opts.minDate) ||
                                 (opts.maxDate && day > opts.maxDate) ||
                                 (opts.disableWeekends && isWeekend(day)) ||
                                 (opts.disableDayFn && opts.disableDayFn(day));

                if (isEmpty) {
                    if (i < before) {
                        dayNumber = daysInPreviousMonth + dayNumber;
                        monthNumber = previousMonth;
                        yearNumber = yearOfPreviousMonth;
                    } else {
                        dayNumber = dayNumber - days;
                        monthNumber = nextMonth;
                        yearNumber = yearOfNextMonth;
                    }
                }

                var dayConfig = {
                        day: dayNumber,
                        month: monthNumber,
                        year: yearNumber,
                        hasEvent: hasEvent,
                        isSelected: isSelected,
                        isToday: isToday,
                        isDisabled: isDisabled,
                        isEmpty: isEmpty,
                        isStartRange: isStartRange,
                        isEndRange: isEndRange,
                        isInRange: isInRange,
                        showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                        enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
                    };

                if (opts.pickWholeWeek && isSelected) {
                    isWeekSelected = true;
                }

                row.push(renderDay(dayConfig));

                if (++r === 7) {
                    if (opts.showWeekNumber) {
                        row.unshift(renderWeek(i - before, month, year));
                    }
                    data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                    row = [];
                    r = 0;
                    isWeekSelected = false;
                }
            }
            return renderTable(opts, data, randId);
        },

        isVisible: function()
        {
            return this._v;
        },

        show: function()
        {
            if (!this.isVisible()) {
                this._v = true;
                this.draw();
                removeClass(this.el, 'is-hidden');
                if (this._o.bound) {
                    addEvent(document, 'click', this._onClick);
                    this.adjustPosition();
                }
                if (typeof this._o.onOpen === 'function') {
                    this._o.onOpen.call(this);
                }
            }
        },

        hide: function()
        {
            var v = this._v;
            if (v !== false) {
                if (this._o.bound) {
                    removeEvent(document, 'click', this._onClick);
                }
                this.el.style.position = 'static'; // reset
                this.el.style.left = 'auto';
                this.el.style.top = 'auto';
                addClass(this.el, 'is-hidden');
                this._v = false;
                if (v !== undefined && typeof this._o.onClose === 'function') {
                    this._o.onClose.call(this);
                }
            }
        },

        /**
         * GAME OVER
         */
        destroy: function()
        {
            var opts = this._o;

            this.hide();
            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
            removeEvent(this.el, 'touchend', this._onMouseDown, true);
            removeEvent(this.el, 'change', this._onChange);
            if (opts.keyboardInput) {
                removeEvent(document, 'keydown', this._onKeyChange);
            }
            if (opts.field) {
                removeEvent(opts.field, 'change', this._onInputChange);
                if (opts.bound) {
                    removeEvent(opts.trigger, 'click', this._onInputClick);
                    removeEvent(opts.trigger, 'focus', this._onInputFocus);
                    removeEvent(opts.trigger, 'blur', this._onInputBlur);
                }
            }
            if (this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }

    };

    return Pikaday;
}));
});

function _typeof$F(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$F = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$F = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$F(obj);
}
function _classCallCheck$1c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$17(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$17(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$17(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$17(Constructor, staticProps);
  return Constructor;
}
function _get$7(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$7 = Reflect.get;
  } else {
    _get$7 = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$7(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$7(target, property, receiver || target);
}
function _superPropBase$7(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$t(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$t(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$u(subClass, superClass);
}
function _setPrototypeOf$u(o, p) {
  _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$u(o, p);
}
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$t(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$t(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$t(this, result);
  };
}
function _possibleConstructorReturn$t(self, call) {
  if (call && (_typeof$F(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$t(self);
}
function _assertThisInitialized$t(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$t(o) {
  _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$t(o);
}
var EDITOR_TYPE$5 = "date";
var DateEditor = /* @__PURE__ */ function(_TextEditor) {
  _inherits$t(DateEditor2, _TextEditor);
  var _super = _createSuper$t(DateEditor2);
  function DateEditor2(hotInstance) {
    var _this;
    _classCallCheck$1c(this, DateEditor2);
    _this = _super.call(this, hotInstance);
    _this.defaultDateFormat = "DD/MM/YYYY";
    _this.isCellEdited = false;
    _this.parentDestroyed = false;
    return _this;
  }
  _createClass$17(DateEditor2, [{
    key: "init",
    value: function init() {
      var _this2 = this;
      if (typeof hooks !== "function") {
        throw new Error("You need to include moment.js to your project.");
      }
      if (typeof pikaday !== "function") {
        throw new Error("You need to include Pikaday to your project.");
      }
      _get$7(_getPrototypeOf$t(DateEditor2.prototype), "init", this).call(this);
      this.instance.addHook("afterDestroy", function() {
        _this2.parentDestroyed = true;
        _this2.destroyElements();
      });
    }
  }, {
    key: "createElements",
    value: function createElements() {
      _get$7(_getPrototypeOf$t(DateEditor2.prototype), "createElements", this).call(this);
      this.datePicker = this.hot.rootDocument.createElement("DIV");
      this.datePickerStyle = this.datePicker.style;
      this.datePickerStyle.position = "absolute";
      this.datePickerStyle.top = 0;
      this.datePickerStyle.left = 0;
      this.datePickerStyle.zIndex = 9999;
      addClass(this.datePicker, "htDatepickerHolder");
      this.hot.rootDocument.body.appendChild(this.datePicker);
      this.$datePicker = new pikaday(this.getDatePickerConfig());
      var eventManager = new EventManager(this);
      eventManager.addEventListener(this.datePicker, "mousedown", function(event) {
        return event.stopPropagation();
      });
      this.hideDatepicker();
    }
  }, {
    key: "destroyElements",
    value: function destroyElements() {
      var datePickerParentElement = this.datePicker.parentNode;
      this.$datePicker.destroy();
      if (datePickerParentElement) {
        datePickerParentElement.removeChild(this.datePicker);
      }
    }
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      _get$7(_getPrototypeOf$t(DateEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
    }
  }, {
    key: "open",
    value: function open() {
      var event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      _get$7(_getPrototypeOf$t(DateEditor2.prototype), "open", this).call(this);
      this.showDatepicker(event);
    }
  }, {
    key: "close",
    value: function close() {
      var _this3 = this;
      this._opened = false;
      this.instance._registerTimeout(function() {
        _this3.instance._refreshBorders();
      });
      _get$7(_getPrototypeOf$t(DateEditor2.prototype), "close", this).call(this);
    }
  }, {
    key: "finishEditing",
    value: function finishEditing() {
      var restoreOriginalValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var ctrlDown = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (restoreOriginalValue) {
        var value = this.originalValue;
        if (value !== void 0) {
          this.setValue(value);
        }
      }
      this.hideDatepicker();
      _get$7(_getPrototypeOf$t(DateEditor2.prototype), "finishEditing", this).call(this, restoreOriginalValue, ctrlDown);
    }
  }, {
    key: "showDatepicker",
    value: function showDatepicker(event) {
      this.$datePicker.config(this.getDatePickerConfig());
      var offset = this.TD.getBoundingClientRect();
      var dateFormat = this.cellProperties.dateFormat || this.defaultDateFormat;
      var datePickerConfig = this.$datePicker.config();
      var dateStr;
      var isMouseDown = this.instance.view.isMouseDown();
      var isMeta = event ? isMetaKey(event.keyCode) : false;
      this.datePickerStyle.top = "".concat(this.hot.rootWindow.pageYOffset + offset.top + outerHeight(this.TD), "px");
      this.datePickerStyle.left = "".concat(this.hot.rootWindow.pageXOffset + offset.left, "px");
      this.$datePicker._onInputFocus = function() {
      };
      datePickerConfig.format = dateFormat;
      if (this.originalValue) {
        dateStr = this.originalValue;
        if (hooks(dateStr, dateFormat, true).isValid()) {
          this.$datePicker.setMoment(hooks(dateStr, dateFormat), true);
        }
        if (this.getValue() !== this.originalValue) {
          this.setValue(this.originalValue);
        }
        if (!isMeta && !isMouseDown) {
          this.setValue("");
        }
      } else if (this.cellProperties.defaultDate) {
        dateStr = this.cellProperties.defaultDate;
        datePickerConfig.defaultDate = dateStr;
        if (hooks(dateStr, dateFormat, true).isValid()) {
          this.$datePicker.setMoment(hooks(dateStr, dateFormat), true);
        }
        if (!isMeta && !isMouseDown) {
          this.setValue("");
        }
      } else {
        this.$datePicker.gotoToday();
      }
      this.datePickerStyle.display = "block";
      this.$datePicker.show();
    }
  }, {
    key: "hideDatepicker",
    value: function hideDatepicker() {
      this.datePickerStyle.display = "none";
      this.$datePicker.hide();
    }
  }, {
    key: "getDatePickerConfig",
    value: function getDatePickerConfig() {
      var _this4 = this;
      var htInput = this.TEXTAREA;
      var options = {};
      if (this.cellProperties && this.cellProperties.datePickerConfig) {
        deepExtend(options, this.cellProperties.datePickerConfig);
      }
      var origOnSelect = options.onSelect;
      var origOnClose = options.onClose;
      options.field = htInput;
      options.trigger = htInput;
      options.container = this.datePicker;
      options.bound = false;
      options.format = options.format || this.defaultDateFormat;
      options.reposition = options.reposition || false;
      options.onSelect = function(value) {
        var dateStr = value;
        if (!isNaN(dateStr.getTime())) {
          dateStr = hooks(dateStr).format(_this4.cellProperties.dateFormat || _this4.defaultDateFormat);
        }
        _this4.setValue(dateStr);
        _this4.hideDatepicker();
        if (origOnSelect) {
          origOnSelect();
        }
      };
      options.onClose = function() {
        if (!_this4.parentDestroyed) {
          _this4.finishEditing(false);
        }
        if (origOnClose) {
          origOnClose();
        }
      };
      return options;
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE$5;
    }
  }]);
  return DateEditor2;
}(TextEditor);

function _typeof$G(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$G = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$G = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$G(obj);
}
function _classCallCheck$1d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$18(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$18(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$18(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$18(Constructor, staticProps);
  return Constructor;
}
function _get$8(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$8 = Reflect.get;
  } else {
    _get$8 = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$8(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$8(target, property, receiver || target);
}
function _superPropBase$8(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$u(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$u(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$v(subClass, superClass);
}
function _setPrototypeOf$v(o, p) {
  _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$v(o, p);
}
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$u(this, result);
  };
}
function _possibleConstructorReturn$u(self, call) {
  if (call && (_typeof$G(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$u(self);
}
function _assertThisInitialized$u(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$u(o) {
  _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$u(o);
}
var EDITOR_TYPE$6 = "dropdown";
var DropdownEditor = /* @__PURE__ */ function(_AutocompleteEditor) {
  _inherits$u(DropdownEditor2, _AutocompleteEditor);
  var _super = _createSuper$u(DropdownEditor2);
  function DropdownEditor2() {
    _classCallCheck$1d(this, DropdownEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$18(DropdownEditor2, [{
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      _get$8(_getPrototypeOf$u(DropdownEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
      this.cellProperties.filter = false;
      this.cellProperties.strict = true;
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE$6;
    }
  }]);
  return DropdownEditor2;
}(AutocompleteEditor);
Hooks.getSingleton().add("beforeValidate", function(value, row, col) {
  var cellMeta = this.getCellMeta(row, this.propToCol(col));
  if (cellMeta.editor === DropdownEditor) {
    if (cellMeta.strict === void 0) {
      cellMeta.filter = false;
      cellMeta.strict = true;
    }
  }
});

function _typeof$H(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$H = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$H = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$H(obj);
}
function _classCallCheck$1e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$19(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$19(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$19(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$19(Constructor, staticProps);
  return Constructor;
}
function _inherits$v(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$w(subClass, superClass);
}
function _setPrototypeOf$w(o, p) {
  _setPrototypeOf$w = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$w(o, p);
}
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$w();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$v(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$v(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$v(this, result);
  };
}
function _possibleConstructorReturn$v(self, call) {
  if (call && (_typeof$H(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$v(self);
}
function _assertThisInitialized$v(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$w() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$v(o) {
  _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$v(o);
}
var EDITOR_TYPE$7 = "numeric";
var NumericEditor = /* @__PURE__ */ function(_TextEditor) {
  _inherits$v(NumericEditor2, _TextEditor);
  var _super = _createSuper$v(NumericEditor2);
  function NumericEditor2() {
    _classCallCheck$1e(this, NumericEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$19(NumericEditor2, null, [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE$7;
    }
  }]);
  return NumericEditor2;
}(TextEditor);

function _typeof$I(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$I = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$I = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$I(obj);
}
function _classCallCheck$1f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1a(Constructor, staticProps);
  return Constructor;
}
function _get$9(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$9 = Reflect.get;
  } else {
    _get$9 = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$9(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$9(target, property, receiver || target);
}
function _superPropBase$9(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$w(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$w(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$x(subClass, superClass);
}
function _setPrototypeOf$x(o, p) {
  _setPrototypeOf$x = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$x(o, p);
}
function _createSuper$w(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$x();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$w(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$w(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$w(this, result);
  };
}
function _possibleConstructorReturn$w(self, call) {
  if (call && (_typeof$I(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$w(self);
}
function _assertThisInitialized$w(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$x() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$w(o) {
  _getPrototypeOf$w = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$w(o);
}
var EDITOR_TYPE$8 = "password";
var PasswordEditor = /* @__PURE__ */ function(_TextEditor) {
  _inherits$w(PasswordEditor2, _TextEditor);
  var _super = _createSuper$w(PasswordEditor2);
  function PasswordEditor2() {
    _classCallCheck$1f(this, PasswordEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$1a(PasswordEditor2, [{
    key: "createElements",
    value: function createElements() {
      _get$9(_getPrototypeOf$w(PasswordEditor2.prototype), "createElements", this).call(this);
      this.TEXTAREA = this.hot.rootDocument.createElement("input");
      this.TEXTAREA.setAttribute("type", "password");
      this.TEXTAREA.setAttribute("data-hot-input", "");
      this.TEXTAREA.className = "handsontableInput";
      this.textareaStyle = this.TEXTAREA.style;
      this.textareaStyle.width = 0;
      this.textareaStyle.height = 0;
      empty(this.TEXTAREA_PARENT);
      this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE$8;
    }
  }]);
  return PasswordEditor2;
}(TextEditor);

function _typeof$J(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$J = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$J = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$J(obj);
}
function _classCallCheck$1g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1b(Constructor, staticProps);
  return Constructor;
}
function _get$a(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$a = Reflect.get;
  } else {
    _get$a = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$a(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$a(target, property, receiver || target);
}
function _superPropBase$a(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$x(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$x(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$y(subClass, superClass);
}
function _setPrototypeOf$y(o, p) {
  _setPrototypeOf$y = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$y(o, p);
}
function _createSuper$x(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$x(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$x(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$x(this, result);
  };
}
function _possibleConstructorReturn$x(self, call) {
  if (call && (_typeof$J(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$x(self);
}
function _assertThisInitialized$x(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$y() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$x(o) {
  _getPrototypeOf$x = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$x(o);
}
var EDITOR_VISIBLE_CLASS_NAME$1 = "ht_editor_visible";
var EDITOR_TYPE$9 = "select";
var SelectEditor = /* @__PURE__ */ function(_BaseEditor) {
  _inherits$x(SelectEditor2, _BaseEditor);
  var _super = _createSuper$x(SelectEditor2);
  function SelectEditor2() {
    _classCallCheck$1g(this, SelectEditor2);
    return _super.apply(this, arguments);
  }
  _createClass$1b(SelectEditor2, [{
    key: "init",
    value: function init() {
      this.select = this.hot.rootDocument.createElement("SELECT");
      addClass(this.select, "htSelectEditor");
      this.select.style.display = "none";
      this.hot.rootElement.appendChild(this.select);
      this.registerHooks();
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.select.value;
    }
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.select.value = value;
    }
  }, {
    key: "open",
    value: function open() {
      var _this = this;
      this._opened = true;
      this.refreshDimensions();
      this.select.style.display = "";
      this.addHook("beforeKeyDown", function() {
        return _this.onBeforeKeyDown();
      });
    }
  }, {
    key: "close",
    value: function close() {
      this._opened = false;
      this.select.style.display = "none";
      if (hasClass(this.select, EDITOR_VISIBLE_CLASS_NAME$1)) {
        removeClass(this.select, EDITOR_VISIBLE_CLASS_NAME$1);
      }
      this.clearHooks();
    }
  }, {
    key: "focus",
    value: function focus() {
      this.select.focus();
    }
  }, {
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.addHook("afterScrollHorizontally", function() {
        return _this2.refreshDimensions();
      });
      this.addHook("afterScrollVertically", function() {
        return _this2.refreshDimensions();
      });
      this.addHook("afterColumnResize", function() {
        return _this2.refreshDimensions();
      });
      this.addHook("afterRowResize", function() {
        return _this2.refreshDimensions();
      });
    }
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, value, cellProperties) {
      var _this3 = this;
      _get$a(_getPrototypeOf$x(SelectEditor2.prototype), "prepare", this).call(this, row, col, prop, td, value, cellProperties);
      var selectOptions = this.cellProperties.selectOptions;
      var options;
      if (typeof selectOptions === "function") {
        options = this.prepareOptions(selectOptions(this.row, this.col, this.prop));
      } else {
        options = this.prepareOptions(selectOptions);
      }
      empty(this.select);
      objectEach(options, function(optionValue, key) {
        var optionElement = _this3.hot.rootDocument.createElement("OPTION");
        optionElement.value = key;
        fastInnerHTML(optionElement, optionValue);
        _this3.select.appendChild(optionElement);
      });
    }
  }, {
    key: "prepareOptions",
    value: function prepareOptions(optionsToPrepare) {
      var preparedOptions = {};
      if (Array.isArray(optionsToPrepare)) {
        for (var i = 0, len = optionsToPrepare.length; i < len; i++) {
          preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
        }
      } else if (_typeof$J(optionsToPrepare) === "object") {
        preparedOptions = optionsToPrepare;
      }
      return preparedOptions;
    }
  }, {
    key: "refreshValue",
    value: function refreshValue() {
      var sourceData = this.hot.getSourceDataAtCell(this.row, this.prop);
      this.originalValue = sourceData;
      this.setValue(sourceData);
      this.refreshDimensions();
    }
  }, {
    key: "refreshDimensions",
    value: function refreshDimensions() {
      if (this.state !== EDITOR_STATE.EDITING) {
        return;
      }
      this.TD = this.getEditedCell();
      if (!this.TD) {
        this.close();
        return;
      }
      var wtOverlays = this.hot.view.wt.wtOverlays;
      var currentOffset = offset$1(this.TD);
      var containerOffset = offset$1(this.hot.rootElement);
      var scrollableContainer = wtOverlays.scrollableElement;
      var editorSection = this.checkEditorSection();
      var width = outerWidth(this.TD) + 1;
      var height = outerHeight(this.TD) + 1;
      var editTop = currentOffset.top - containerOffset.top - 1 - (scrollableContainer.scrollTop || 0);
      var editLeft = currentOffset.left - containerOffset.left - 1 - (scrollableContainer.scrollLeft || 0);
      var cssTransformOffset;
      switch (editorSection) {
        case "top":
          cssTransformOffset = getCssTransform(wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
          break;
        case "left":
          cssTransformOffset = getCssTransform(wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
          break;
        case "top-left-corner":
          cssTransformOffset = getCssTransform(wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
          break;
        case "bottom-left-corner":
          cssTransformOffset = getCssTransform(wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
          break;
        case "bottom":
          cssTransformOffset = getCssTransform(wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
          break;
      }
      var renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);
      var renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);
      var nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();
      var firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view.wt.getSetting("fixedRowsBottom");
      if (renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {
        editTop += 1;
      }
      if (renderableColumn <= 0) {
        editLeft += 1;
      }
      var selectStyle = this.select.style;
      if (cssTransformOffset && cssTransformOffset !== -1) {
        selectStyle[cssTransformOffset[0]] = cssTransformOffset[1];
      } else {
        resetCssTransform(this.select);
      }
      var cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);
      if (parseInt(cellComputedStyle.borderTopWidth, 10) > 0) {
        height -= 1;
      }
      if (parseInt(cellComputedStyle.borderLeftWidth, 10) > 0) {
        width -= 1;
      }
      selectStyle.height = "".concat(height, "px");
      selectStyle.minWidth = "".concat(width, "px");
      selectStyle.top = "".concat(editTop, "px");
      selectStyle.left = "".concat(editLeft, "px");
      selectStyle.margin = "0px";
      addClass(this.select, EDITOR_VISIBLE_CLASS_NAME$1);
    }
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown() {
      var previousOptionIndex = this.select.selectedIndex - 1;
      var nextOptionIndex = this.select.selectedIndex + 1;
      switch (event.keyCode) {
        case KEY_CODES.ARROW_UP:
          if (previousOptionIndex >= 0) {
            this.select[previousOptionIndex].selected = true;
          }
          stopImmediatePropagation(event);
          event.preventDefault();
          break;
        case KEY_CODES.ARROW_DOWN:
          if (nextOptionIndex <= this.select.length - 1) {
            this.select[nextOptionIndex].selected = true;
          }
          stopImmediatePropagation(event);
          event.preventDefault();
          break;
      }
    }
  }], [{
    key: "EDITOR_TYPE",
    get: function get() {
      return EDITOR_TYPE$9;
    }
  }]);
  return SelectEditor2;
}(BaseEditor);

var RENDERER_TYPE$2 = "html";
function htmlRenderer(instance, TD, row, col, prop, value, cellProperties) {
  baseRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  fastInnerHTML(TD, value === null || value === void 0 ? "" : value, false);
}
htmlRenderer.RENDERER_TYPE = RENDERER_TYPE$2;

var RENDERER_TYPE$3 = "autocomplete";
function autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var rootDocument = instance.rootDocument;
  var rendererFunc = cellProperties.allowHtml ? htmlRenderer : textRenderer;
  var ARROW = rootDocument.createElement("DIV");
  ARROW.className = "htAutocompleteArrow";
  ARROW.appendChild(rootDocument.createTextNode(String.fromCharCode(9660)));
  rendererFunc.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  if (!TD.firstChild) {
    TD.appendChild(rootDocument.createTextNode(String.fromCharCode(160)));
  }
  TD.insertBefore(ARROW, TD.firstChild);
  addClass(TD, "htAutocomplete");
  if (!instance.acArrowListener) {
    var eventManager = new EventManager(instance);
    instance.acArrowListener = function(event) {
      if (hasClass(event.target, "htAutocompleteArrow")) {
        instance.view.wt.getSetting("onCellDblClick", null, new CellCoords(row, col), TD);
      }
    };
    eventManager.addEventListener(instance.rootElement, "mousedown", instance.acArrowListener);
    instance.addHookOnce("afterDestroy", function() {
      eventManager.destroy();
    });
  }
}
autocompleteRenderer.RENDERER_TYPE = RENDERER_TYPE$3;

var isListeningKeyDownEvent = new WeakMap();
var isCheckboxListenerAdded = new WeakMap();
var BAD_VALUE_CLASS = "htBadValue";
var ATTR_ROW = "data-row";
var ATTR_COLUMN = "data-col";
var RENDERER_TYPE$4 = "checkbox";
Hooks.getSingleton().add("modifyAutoColumnSizeSeed", function(bundleSeed, cellMeta, cellValue) {
  var label = cellMeta.label, type = cellMeta.type, row = cellMeta.row, column = cellMeta.column, prop = cellMeta.prop;
  if (type !== RENDERER_TYPE$4) {
    return;
  }
  if (label) {
    var labelValue = label.value, labelProperty = label.property;
    var labelText = cellValue;
    if (labelValue) {
      labelText = typeof labelValue === "function" ? labelValue(row, column, prop, cellValue) : labelValue;
    } else if (labelProperty) {
      var labelData = this.getDataAtRowProp(row, labelProperty);
      labelText = labelData !== null ? labelData : cellValue;
    }
    bundleSeed = labelText;
  }
  return bundleSeed;
});
function checkboxRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var rootDocument = instance.rootDocument;
  baseRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  registerEvents(instance);
  var input = createInput(rootDocument);
  var labelOptions = cellProperties.label;
  var badValue = false;
  if (typeof cellProperties.checkedTemplate === "undefined") {
    cellProperties.checkedTemplate = true;
  }
  if (typeof cellProperties.uncheckedTemplate === "undefined") {
    cellProperties.uncheckedTemplate = false;
  }
  empty(TD);
  if (value === cellProperties.checkedTemplate || equalsIgnoreCase(value, cellProperties.checkedTemplate)) {
    input.checked = true;
  } else if (value === cellProperties.uncheckedTemplate || equalsIgnoreCase(value, cellProperties.uncheckedTemplate)) {
    input.checked = false;
  } else if (isEmpty(value)) {
    addClass(input, "noValue");
  } else {
    input.style.display = "none";
    addClass(input, BAD_VALUE_CLASS);
    badValue = true;
  }
  input.setAttribute(ATTR_ROW, row);
  input.setAttribute(ATTR_COLUMN, col);
  if (!badValue && labelOptions) {
    var labelText = "";
    if (labelOptions.value) {
      labelText = typeof labelOptions.value === "function" ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;
    } else if (labelOptions.property) {
      var labelValue = instance.getDataAtRowProp(row, labelOptions.property);
      labelText = labelValue !== null ? labelValue : "";
    }
    var label = createLabel(rootDocument, labelText, labelOptions.separated !== true);
    if (labelOptions.position === "before") {
      if (labelOptions.separated) {
        TD.appendChild(label);
        TD.appendChild(input);
      } else {
        label.appendChild(input);
        input = label;
      }
    } else if (!labelOptions.position || labelOptions.position === "after") {
      if (labelOptions.separated) {
        TD.appendChild(input);
        TD.appendChild(label);
      } else {
        label.insertBefore(input, label.firstChild);
        input = label;
      }
    }
  }
  if (!labelOptions || labelOptions && !labelOptions.separated) {
    TD.appendChild(input);
  }
  if (badValue) {
    TD.appendChild(rootDocument.createTextNode("#bad-value#"));
  }
  if (!isListeningKeyDownEvent.has(instance)) {
    isListeningKeyDownEvent.set(instance, true);
    instance.addHook("beforeKeyDown", onBeforeKeyDown);
  }
  function onBeforeKeyDown(event) {
    var toggleKeys = "SPACE|ENTER";
    var switchOffKeys = "DELETE|BACKSPACE";
    var isKeyCode = partial(isKey, event.keyCode);
    if (!instance.getSettings().enterBeginsEditing && isKeyCode("ENTER")) {
      return;
    }
    if (isKeyCode("".concat(toggleKeys, "|").concat(switchOffKeys)) && !isImmediatePropagationStopped(event)) {
      eachSelectedCheckboxCell(function() {
        stopImmediatePropagation(event);
        event.preventDefault();
      });
    }
    if (isKeyCode(toggleKeys)) {
      changeSelectedCheckboxesState();
    }
    if (isKeyCode(switchOffKeys)) {
      changeSelectedCheckboxesState(true);
    }
  }
  function changeSelectedCheckboxesState() {
    var uncheckCheckbox = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var selRange = instance.getSelectedRange();
    if (!selRange) {
      return;
    }
    for (var key = 0; key < selRange.length; key++) {
      var _selRange$key$getTopL = selRange[key].getTopLeftCorner(), startRow = _selRange$key$getTopL.row, startColumn = _selRange$key$getTopL.col;
      var _selRange$key$getBott = selRange[key].getBottomRightCorner(), endRow = _selRange$key$getBott.row, endColumn = _selRange$key$getBott.col;
      var changes = [];
      for (var visualRow = startRow; visualRow <= endRow; visualRow += 1) {
        for (var visualColumn = startColumn; visualColumn <= endColumn; visualColumn += 1) {
          var cachedCellProperties = instance.getCellMeta(visualRow, visualColumn);
          if (cachedCellProperties.type !== "checkbox") {
            return;
          }
          if (cachedCellProperties.readOnly === true) {
            continue;
          }
          if (typeof cachedCellProperties.checkedTemplate === "undefined") {
            cachedCellProperties.checkedTemplate = true;
          }
          if (typeof cachedCellProperties.uncheckedTemplate === "undefined") {
            cachedCellProperties.uncheckedTemplate = false;
          }
          var dataAtCell = instance.getDataAtCell(visualRow, visualColumn);
          if (uncheckCheckbox === false) {
            if ([cachedCellProperties.checkedTemplate, cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {
              changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
            } else if ([cachedCellProperties.uncheckedTemplate, cachedCellProperties.uncheckedTemplate.toString(), null, void 0].includes(dataAtCell)) {
              changes.push([visualRow, visualColumn, cachedCellProperties.checkedTemplate]);
            }
          } else {
            changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
          }
        }
      }
      if (changes.length > 0) {
        instance.setDataAtCell(changes);
      }
    }
  }
  function eachSelectedCheckboxCell(callback) {
    var selRange = instance.getSelectedRange();
    if (!selRange) {
      return;
    }
    for (var key = 0; key < selRange.length; key++) {
      var topLeft = selRange[key].getTopLeftCorner();
      var bottomRight = selRange[key].getBottomRightCorner();
      for (var visualRow = topLeft.row; visualRow <= bottomRight.row; visualRow++) {
        for (var visualColumn = topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {
          var cachedCellProperties = instance.getCellMeta(visualRow, visualColumn);
          if (cachedCellProperties.type !== "checkbox") {
            return;
          }
          var cell = instance.getCell(visualRow, visualColumn);
          if (cell === null || cell === void 0) {
            callback(visualRow, visualColumn, cachedCellProperties);
          } else {
            var checkboxes = cell.querySelectorAll("input[type=checkbox]");
            if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {
              callback(checkboxes);
            }
          }
        }
      }
    }
  }
}
checkboxRenderer.RENDERER_TYPE = RENDERER_TYPE$4;
function registerEvents(instance) {
  var eventManager = isCheckboxListenerAdded.get(instance);
  if (!eventManager) {
    var rootElement = instance.rootElement;
    eventManager = new EventManager(instance);
    eventManager.addEventListener(rootElement, "click", function(event) {
      return onClick(event, instance);
    });
    eventManager.addEventListener(rootElement, "mouseup", function(event) {
      return onMouseUp(event, instance);
    });
    eventManager.addEventListener(rootElement, "change", function(event) {
      return onChange(event, instance);
    });
    isCheckboxListenerAdded.set(instance, eventManager);
  }
  return eventManager;
}
function createInput(rootDocument) {
  var input = rootDocument.createElement("input");
  input.className = "htCheckboxRendererInput";
  input.type = "checkbox";
  input.setAttribute("autocomplete", "off");
  input.setAttribute("tabindex", "-1");
  return input.cloneNode(false);
}
function createLabel(rootDocument, text, fullWidth) {
  var label = rootDocument.createElement("label");
  label.className = "htCheckboxRendererLabel ".concat(fullWidth ? "fullWidth" : "");
  label.appendChild(rootDocument.createTextNode(text));
  return label.cloneNode(true);
}
function onMouseUp(event, instance) {
  var target = event.target;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  setTimeout(instance.listen, 10);
}
function onClick(event, instance) {
  var target = event.target;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  var row = parseInt(target.getAttribute(ATTR_ROW), 10);
  var col = parseInt(target.getAttribute(ATTR_COLUMN), 10);
  var cellProperties = instance.getCellMeta(row, col);
  if (cellProperties.readOnly) {
    event.preventDefault();
  }
}
function onChange(event, instance) {
  var target = event.target;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  var row = parseInt(target.getAttribute(ATTR_ROW), 10);
  var col = parseInt(target.getAttribute(ATTR_COLUMN), 10);
  var cellProperties = instance.getCellMeta(row, col);
  if (!cellProperties.readOnly) {
    var newCheckboxValue = null;
    if (event.target.checked) {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? true : cellProperties.checkedTemplate;
    } else {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? false : cellProperties.uncheckedTemplate;
    }
    instance.setDataAtCell(row, col, newCheckboxValue);
  }
}
function isCheckboxInput(element) {
  return element.tagName === "INPUT" && element.getAttribute("type") === "checkbox";
}

var numbro_min = createCommonjsModule$1(function (module, exports) {
!function(e){module.exports=e();}(function(){return function a(o,u,c){function s(t,e){if(!u[t]){if(!o[t]){var r="function"==typeof commonjsRequire&&commonjsRequire;if(!e&&r)return r(t,!0);if(l)return l(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=u[t]={exports:{}};o[t][0].call(i.exports,function(e){return s(o[t][1][e]||e)},i,i.exports,a,o,u,c);}return u[t].exports}for(var l="function"==typeof commonjsRequire&&commonjsRequire,e=0;e<c.length;e++)s(c[e]);return s}({1:[function(e,r,t){!function(e){var t,k=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,_=Math.ceil,L=Math.floor,T="[BigNumber Error] ",P=T+"Number primitive has more than 15 significant digits: ",U=1e14,j=14,C=9007199254740991,R=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],I=1e7,$=1e9;function G(e){var t=0|e;return 0<e||e===t?t:t-1}function V(e){for(var t,r,n=1,i=e.length,a=e[0]+"";n<i;){for(t=e[n++]+"",r=j-t.length;r--;t="0"+t);a+=t;}for(i=a.length;48===a.charCodeAt(--i););return a.slice(0,i+1||1)}function q(e,t){var r,n,i=e.c,a=t.c,o=e.s,u=t.s,c=e.e,s=t.e;if(!o||!u)return null;if(r=i&&!i[0],n=a&&!a[0],r||n)return r?n?0:-u:o;if(o!=u)return o;if(r=o<0,n=c==s,!i||!a)return n?0:!i^r?1:-1;if(!n)return s<c^r?1:-1;for(u=(c=i.length)<(s=a.length)?c:s,o=0;o<u;o++)if(i[o]!=a[o])return i[o]>a[o]^r?1:-1;return c==s?0:s<c^r?1:-1}function Z(e,t,r,n){if(e<t||r<e||e!==(e<0?_(e):L(e)))throw Error(T+(n||"Argument")+("number"==typeof e?e<t||r<e?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function z(e){var t=e.c.length-1;return G(e.e/j)==t&&e.c[t]%2!=0}function W(e,t){return (1<e.length?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function H(e,t,r){var n,i;if(t<0){for(i=r+".";++t;i+=r);e=i+e;}else if(++t>(n=e.length)){for(i=r,t-=n;--t;i+=r);e+=i;}else t<n&&(e=e.slice(0,t)+"."+e.slice(t));return e}(t=function e(t){var y,f,p,r,s,o,u,c,l,g,n=A.prototype={constructor:A,toString:null,valueOf:null},d=new A(1),b=20,w=4,h=-7,v=21,m=-1e7,O=1e7,x=!1,a=1,S=0,N={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:" ",suffix:""},M="0123456789abcdefghijklmnopqrstuvwxyz";function A(e,t){var r,n,i,a,o,u,c,s,l=this;if(!(l instanceof A))return new A(e,t);if(null==t){if(e instanceof A)return l.s=e.s,l.e=e.e,void(l.c=(e=e.c)?e.slice():e);if((u="number"==typeof e)&&0*e==0){if(l.s=1/e<0?(e=-e,-1):1,e===~~e){for(a=0,o=e;10<=o;o/=10,a++);return l.e=a,void(l.c=[e])}s=String(e);}else {if(s=String(e),!k.test(s))return p(l,s,u);l.s=45==s.charCodeAt(0)?(s=s.slice(1),-1):1;}-1<(a=s.indexOf("."))&&(s=s.replace(".","")),0<(o=s.search(/e/i))?(a<0&&(a=o),a+=+s.slice(o+1),s=s.substring(0,o)):a<0&&(a=s.length);}else {if(Z(t,2,M.length,"Base"),s=String(e),10==t)return E(l=new A(e instanceof A?e:s),b+l.e+1,w);if(u="number"==typeof e){if(0*e!=0)return p(l,s,u,t);if(l.s=1/e<0?(s=s.slice(1),-1):1,A.DEBUG&&15<s.replace(/^0\.0*|\./,"").length)throw Error(P+e);u=!1;}else l.s=45===s.charCodeAt(0)?(s=s.slice(1),-1):1;for(r=M.slice(0,t),a=o=0,c=s.length;o<c;o++)if(r.indexOf(n=s.charAt(o))<0){if("."==n){if(a<o){a=c;continue}}else if(!i&&(s==s.toUpperCase()&&(s=s.toLowerCase())||s==s.toLowerCase()&&(s=s.toUpperCase()))){i=!0,o=-1,a=0;continue}return p(l,String(e),u,t)}-1<(a=(s=f(s,t,10,l.s)).indexOf("."))?s=s.replace(".",""):a=s.length;}for(o=0;48===s.charCodeAt(o);o++);for(c=s.length;48===s.charCodeAt(--c););if(s=s.slice(o,++c)){if(c-=o,u&&A.DEBUG&&15<c&&(C<e||e!==L(e)))throw Error(P+l.s*e);if(O<(a=a-o-1))l.c=l.e=null;else if(a<m)l.c=[l.e=0];else {if(l.e=a,l.c=[],o=(a+1)%j,a<0&&(o+=j),o<c){for(o&&l.c.push(+s.slice(0,o)),c-=j;o<c;)l.c.push(+s.slice(o,o+=j));s=s.slice(o),o=j-s.length;}else o-=c;for(;o--;s+="0");l.c.push(+s);}}else l.c=[l.e=0];}function i(e,t,r,n){var i,a,o,u,c;if(null==r?r=w:Z(r,0,8),!e.c)return e.toString();if(i=e.c[0],o=e.e,null==t)c=V(e.c),c=1==n||2==n&&(o<=h||v<=o)?W(c,o):H(c,o,"0");else if(a=(e=E(new A(e),t,r)).e,u=(c=V(e.c)).length,1==n||2==n&&(t<=a||a<=h)){for(;u<t;c+="0",u++);c=W(c,a);}else if(t-=o,c=H(c,a,"0"),u<a+1){if(0<--t)for(c+=".";t--;c+="0");}else if(0<(t+=a-u))for(a+1==u&&(c+=".");t--;c+="0");return e.s<0&&i?"-"+c:c}function B(e,t){for(var r,n=1,i=new A(e[0]);n<e.length;n++){if(!(r=new A(e[n])).s){i=r;break}t.call(i,r)&&(i=r);}return i}function D(e,t,r){for(var n=1,i=t.length;!t[--i];t.pop());for(i=t[0];10<=i;i/=10,n++);return (r=n+r*j-1)>O?e.c=e.e=null:e.c=r<m?[e.e=0]:(e.e=r,t),e}function E(e,t,r,n){var i,a,o,u,c,s,l,f=e.c,p=R;if(f){e:{for(i=1,u=f[0];10<=u;u/=10,i++);if((a=t-i)<0)a+=j,o=t,l=(c=f[s=0])/p[i-o-1]%10|0;else if((s=_((a+1)/j))>=f.length){if(!n)break e;for(;f.length<=s;f.push(0));c=l=0,o=(a%=j)-j+(i=1);}else {for(c=u=f[s],i=1;10<=u;u/=10,i++);l=(o=(a%=j)-j+i)<0?0:c/p[i-o-1]%10|0;}if(n=n||t<0||null!=f[s+1]||(o<0?c:c%p[i-o-1]),n=r<4?(l||n)&&(0==r||r==(e.s<0?3:2)):5<l||5==l&&(4==r||n||6==r&&(0<a?0<o?c/p[i-o]:0:f[s-1])%10&1||r==(e.s<0?8:7)),t<1||!f[0])return f.length=0,n?(t-=e.e+1,f[0]=p[(j-t%j)%j],e.e=-t||0):f[0]=e.e=0,e;if(0==a?(f.length=s,u=1,s--):(f.length=s+1,u=p[j-a],f[s]=0<o?L(c/p[i-o]%p[o])*u:0),n)for(;;){if(0==s){for(a=1,o=f[0];10<=o;o/=10,a++);for(o=f[0]+=u,u=1;10<=o;o/=10,u++);a!=u&&(e.e++,f[0]==U&&(f[0]=1));break}if(f[s]+=u,f[s]!=U)break;f[s--]=0,u=1;}for(a=f.length;0===f[--a];f.pop());}e.e>O?e.c=e.e=null:e.e<m&&(e.c=[e.e=0]);}return e}function F(e){var t,r=e.e;return null===r?e.toString():(t=V(e.c),t=r<=h||v<=r?W(t,r):H(t,r,"0"),e.s<0?"-"+t:t)}return A.clone=e,A.ROUND_UP=0,A.ROUND_DOWN=1,A.ROUND_CEIL=2,A.ROUND_FLOOR=3,A.ROUND_HALF_UP=4,A.ROUND_HALF_DOWN=5,A.ROUND_HALF_EVEN=6,A.ROUND_HALF_CEIL=7,A.ROUND_HALF_FLOOR=8,A.EUCLID=9,A.config=A.set=function(e){var t,r;if(null!=e){if("object"!=typeof e)throw Error(T+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(Z(r=e[t],0,$,t),b=r),e.hasOwnProperty(t="ROUNDING_MODE")&&(Z(r=e[t],0,8,t),w=r),e.hasOwnProperty(t="EXPONENTIAL_AT")&&((r=e[t])&&r.pop?(Z(r[0],-$,0,t),Z(r[1],0,$,t),h=r[0],v=r[1]):(Z(r,-$,$,t),h=-(v=r<0?-r:r))),e.hasOwnProperty(t="RANGE"))if((r=e[t])&&r.pop)Z(r[0],-$,-1,t),Z(r[1],1,$,t),m=r[0],O=r[1];else {if(Z(r,-$,$,t),!r)throw Error(T+t+" cannot be zero: "+r);m=-(O=r<0?-r:r);}if(e.hasOwnProperty(t="CRYPTO")){if((r=e[t])!==!!r)throw Error(T+t+" not true or false: "+r);if(r){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw x=!r,Error(T+"crypto unavailable");x=r;}else x=r;}if(e.hasOwnProperty(t="MODULO_MODE")&&(Z(r=e[t],0,9,t),a=r),e.hasOwnProperty(t="POW_PRECISION")&&(Z(r=e[t],0,$,t),S=r),e.hasOwnProperty(t="FORMAT")){if("object"!=typeof(r=e[t]))throw Error(T+t+" not an object: "+r);N=r;}if(e.hasOwnProperty(t="ALPHABET")){if("string"!=typeof(r=e[t])||/^.$|[+-.\s]|(.).*\1/.test(r))throw Error(T+t+" invalid: "+r);M=r;}}return {DECIMAL_PLACES:b,ROUNDING_MODE:w,EXPONENTIAL_AT:[h,v],RANGE:[m,O],CRYPTO:x,MODULO_MODE:a,POW_PRECISION:S,FORMAT:N,ALPHABET:M}},A.isBigNumber=function(e){return e instanceof A||e&&!0===e._isBigNumber||!1},A.maximum=A.max=function(){return B(arguments,n.lt)},A.minimum=A.min=function(){return B(arguments,n.gt)},A.random=(r=9007199254740992,s=Math.random()*r&2097151?function(){return L(Math.random()*r)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var t,r,n,i,a,o=0,u=[],c=new A(d);if(null==e?e=b:Z(e,0,$),i=_(e/j),x)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(i*=2));o<i;)9e15<=(a=131072*t[o]+(t[o+1]>>>11))?(r=crypto.getRandomValues(new Uint32Array(2)),t[o]=r[0],t[o+1]=r[1]):(u.push(a%1e14),o+=2);o=i/2;}else {if(!crypto.randomBytes)throw x=!1,Error(T+"crypto unavailable");for(t=crypto.randomBytes(i*=7);o<i;)9e15<=(a=281474976710656*(31&t[o])+1099511627776*t[o+1]+4294967296*t[o+2]+16777216*t[o+3]+(t[o+4]<<16)+(t[o+5]<<8)+t[o+6])?crypto.randomBytes(7).copy(t,o):(u.push(a%1e14),o+=7);o=i/7;}if(!x)for(;o<i;)(a=s())<9e15&&(u[o++]=a%1e14);for(i=u[--o],e%=j,i&&e&&(a=R[j-e],u[o]=L(i/a)*a);0===u[o];u.pop(),o--);if(o<0)u=[n=0];else {for(n=-1;0===u[0];u.splice(0,1),n-=j);for(o=1,a=u[0];10<=a;a/=10,o++);o<j&&(n-=j-o);}return c.e=n,c.c=u,c}),A.sum=function(){for(var e=1,t=arguments,r=new A(t[0]);e<t.length;)r=r.plus(t[e++]);return r},f=function(){var v="0123456789";function m(e,t,r,n){for(var i,a,o=[0],u=0,c=e.length;u<c;){for(a=o.length;a--;o[a]*=t);for(o[0]+=n.indexOf(e.charAt(u++)),i=0;i<o.length;i++)o[i]>r-1&&(null==o[i+1]&&(o[i+1]=0),o[i+1]+=o[i]/r|0,o[i]%=r);}return o.reverse()}return function(e,t,r,n,i){var a,o,u,c,s,l,f,p,g=e.indexOf("."),h=b,d=w;for(0<=g&&(c=S,S=0,e=e.replace(".",""),l=(p=new A(t)).pow(e.length-g),S=c,p.c=m(H(V(l.c),l.e,"0"),10,r,v),p.e=p.c.length),u=c=(f=m(e,t,r,i?(a=M,v):(a=v,M))).length;0==f[--c];f.pop());if(!f[0])return a.charAt(0);if(g<0?--u:(l.c=f,l.e=u,l.s=n,f=(l=y(l,p,h,d,r)).c,s=l.r,u=l.e),g=f[o=u+h+1],c=r/2,s=s||o<0||null!=f[o+1],s=d<4?(null!=g||s)&&(0==d||d==(l.s<0?3:2)):c<g||g==c&&(4==d||s||6==d&&1&f[o-1]||d==(l.s<0?8:7)),o<1||!f[0])e=s?H(a.charAt(1),-h,a.charAt(0)):a.charAt(0);else {if(f.length=o,s)for(--r;++f[--o]>r;)f[o]=0,o||(++u,f=[1].concat(f));for(c=f.length;!f[--c];);for(g=0,e="";g<=c;e+=a.charAt(f[g++]));e=H(e,u,a.charAt(0));}return e}}(),y=function(){function M(e,t,r){var n,i,a,o,u=0,c=e.length,s=t%I,l=t/I|0;for(e=e.slice();c--;)u=((i=s*(a=e[c]%I)+(n=l*a+(o=e[c]/I|0)*s)%I*I+u)/r|0)+(n/I|0)+l*o,e[c]=i%r;return u&&(e=[u].concat(e)),e}function B(e,t,r,n){var i,a;if(r!=n)a=n<r?1:-1;else for(i=a=0;i<r;i++)if(e[i]!=t[i]){a=e[i]>t[i]?1:-1;break}return a}function D(e,t,r,n){for(var i=0;r--;)e[r]-=i,i=e[r]<t[r]?1:0,e[r]=i*n+e[r]-t[r];for(;!e[0]&&1<e.length;e.splice(0,1));}return function(e,t,r,n,i){var a,o,u,c,s,l,f,p,g,h,d,v,m,y,b,w,O,x=e.s==t.s?1:-1,S=e.c,N=t.c;if(!(S&&S[0]&&N&&N[0]))return new A(e.s&&t.s&&(S?!N||S[0]!=N[0]:N)?S&&0==S[0]||!N?0*x:x/0:NaN);for(g=(p=new A(x)).c=[],x=r+(o=e.e-t.e)+1,i||(i=U,o=G(e.e/j)-G(t.e/j),x=x/j|0),u=0;N[u]==(S[u]||0);u++);if(N[u]>(S[u]||0)&&o--,x<0)g.push(1),c=!0;else {for(y=S.length,w=N.length,x+=2,1<(s=L(i/(N[u=0]+1)))&&(N=M(N,s,i),S=M(S,s,i),w=N.length,y=S.length),m=w,d=(h=S.slice(0,w)).length;d<w;h[d++]=0);O=N.slice(),O=[0].concat(O),b=N[0],N[1]>=i/2&&b++;do{if(s=0,(a=B(N,h,w,d))<0){if(v=h[0],w!=d&&(v=v*i+(h[1]||0)),1<(s=L(v/b)))for(i<=s&&(s=i-1),f=(l=M(N,s,i)).length,d=h.length;1==B(l,h,f,d);)s--,D(l,w<f?O:N,f,i),f=l.length,a=1;else 0==s&&(a=s=1),f=(l=N.slice()).length;if(f<d&&(l=[0].concat(l)),D(h,l,d,i),d=h.length,-1==a)for(;B(N,h,w,d)<1;)s++,D(h,w<d?O:N,d,i),d=h.length;}else 0===a&&(s++,h=[0]);g[u++]=s,h[0]?h[d++]=S[m]||0:(h=[S[m]],d=1);}while((m++<y||null!=h[0])&&x--);c=null!=h[0],g[0]||g.splice(0,1);}if(i==U){for(u=1,x=g[0];10<=x;x/=10,u++);E(p,r+(p.e=u+o*j-1)+1,n,c);}else p.e=o,p.r=+c;return p}}(),o=/^(-?)0([xbo])(?=\w[\w.]*$)/i,u=/^([^.]+)\.$/,c=/^\.([^.]+)$/,l=/^-?(Infinity|NaN)$/,g=/^\s*\+(?=[\w.])|^\s+|\s+$/g,p=function(e,t,r,n){var i,a=r?t:t.replace(g,"");if(l.test(a))e.s=isNaN(a)?null:a<0?-1:1,e.c=e.e=null;else {if(!r&&(a=a.replace(o,function(e,t,r){return i="x"==(r=r.toLowerCase())?16:"b"==r?2:8,n&&n!=i?e:t}),n&&(i=n,a=a.replace(u,"$1").replace(c,"0.$1")),t!=a))return new A(a,i);if(A.DEBUG)throw Error(T+"Not a"+(n?" base "+n:"")+" number: "+t);e.c=e.e=e.s=null;}},n.absoluteValue=n.abs=function(){var e=new A(this);return e.s<0&&(e.s=1),e},n.comparedTo=function(e,t){return q(this,new A(e,t))},n.decimalPlaces=n.dp=function(e,t){var r,n,i;if(null!=e)return Z(e,0,$),null==t?t=w:Z(t,0,8),E(new A(this),e+this.e+1,t);if(!(r=this.c))return null;if(n=((i=r.length-1)-G(this.e/j))*j,i=r[i])for(;i%10==0;i/=10,n--);return n<0&&(n=0),n},n.dividedBy=n.div=function(e,t){return y(this,new A(e,t),b,w)},n.dividedToIntegerBy=n.idiv=function(e,t){return y(this,new A(e,t),0,1)},n.exponentiatedBy=n.pow=function(e,t){var r,n,i,a,o,u,c,s,l=this;if((e=new A(e)).c&&!e.isInteger())throw Error(T+"Exponent not an integer: "+F(e));if(null!=t&&(t=new A(t)),o=14<e.e,!l.c||!l.c[0]||1==l.c[0]&&!l.e&&1==l.c.length||!e.c||!e.c[0])return s=new A(Math.pow(+F(l),o?2-z(e):+F(e))),t?s.mod(t):s;if(u=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new A(NaN);(n=!u&&l.isInteger()&&t.isInteger())&&(l=l.mod(t));}else {if(9<e.e&&(0<l.e||l.e<-1||(0==l.e?1<l.c[0]||o&&24e7<=l.c[1]:l.c[0]<8e13||o&&l.c[0]<=9999975e7)))return a=l.s<0&&z(e)?-0:0,-1<l.e&&(a=1/a),new A(u?1/a:a);S&&(a=_(S/j+2));}for(c=o?(r=new A(.5),u&&(e.s=1),z(e)):(i=Math.abs(+F(e)))%2,s=new A(d);;){if(c){if(!(s=s.times(l)).c)break;a?s.c.length>a&&(s.c.length=a):n&&(s=s.mod(t));}if(i){if(0===(i=L(i/2)))break;c=i%2;}else if(E(e=e.times(r),e.e+1,1),14<e.e)c=z(e);else {if(0==(i=+F(e)))break;c=i%2;}l=l.times(l),a?l.c&&l.c.length>a&&(l.c.length=a):n&&(l=l.mod(t));}return n?s:(u&&(s=d.div(s)),t?s.mod(t):a?E(s,S,w,void 0):s)},n.integerValue=function(e){var t=new A(this);return null==e?e=w:Z(e,0,8),E(t,t.e+1,e)},n.isEqualTo=n.eq=function(e,t){return 0===q(this,new A(e,t))},n.isFinite=function(){return !!this.c},n.isGreaterThan=n.gt=function(e,t){return 0<q(this,new A(e,t))},n.isGreaterThanOrEqualTo=n.gte=function(e,t){return 1===(t=q(this,new A(e,t)))||0===t},n.isInteger=function(){return !!this.c&&G(this.e/j)>this.c.length-2},n.isLessThan=n.lt=function(e,t){return q(this,new A(e,t))<0},n.isLessThanOrEqualTo=n.lte=function(e,t){return -1===(t=q(this,new A(e,t)))||0===t},n.isNaN=function(){return !this.s},n.isNegative=function(){return this.s<0},n.isPositive=function(){return 0<this.s},n.isZero=function(){return !!this.c&&0==this.c[0]},n.minus=function(e,t){var r,n,i,a,o=this,u=o.s;if(t=(e=new A(e,t)).s,!u||!t)return new A(NaN);if(u!=t)return e.s=-t,o.plus(e);var c=o.e/j,s=e.e/j,l=o.c,f=e.c;if(!c||!s){if(!l||!f)return l?(e.s=-t,e):new A(f?o:NaN);if(!l[0]||!f[0])return f[0]?(e.s=-t,e):new A(l[0]?o:3==w?-0:0)}if(c=G(c),s=G(s),l=l.slice(),u=c-s){for((i=(a=u<0)?(u=-u,l):(s=c,f)).reverse(),t=u;t--;i.push(0));i.reverse();}else for(n=(a=(u=l.length)<(t=f.length))?u:t,u=t=0;t<n;t++)if(l[t]!=f[t]){a=l[t]<f[t];break}if(a&&(i=l,l=f,f=i,e.s=-e.s),0<(t=(n=f.length)-(r=l.length)))for(;t--;l[r++]=0);for(t=U-1;u<n;){if(l[--n]<f[n]){for(r=n;r&&!l[--r];l[r]=t);--l[r],l[n]+=U;}l[n]-=f[n];}for(;0==l[0];l.splice(0,1),--s);return l[0]?D(e,l,s):(e.s=3==w?-1:1,e.c=[e.e=0],e)},n.modulo=n.mod=function(e,t){var r,n,i=this;return e=new A(e,t),!i.c||!e.s||e.c&&!e.c[0]?new A(NaN):!e.c||i.c&&!i.c[0]?new A(i):(9==a?(n=e.s,e.s=1,r=y(i,e,0,3),e.s=n,r.s*=n):r=y(i,e,0,a),(e=i.minus(r.times(e))).c[0]||1!=a||(e.s=i.s),e)},n.multipliedBy=n.times=function(e,t){var r,n,i,a,o,u,c,s,l,f,p,g,h,d,v,m=this,y=m.c,b=(e=new A(e,t)).c;if(!(y&&b&&y[0]&&b[0]))return !m.s||!e.s||y&&!y[0]&&!b||b&&!b[0]&&!y?e.c=e.e=e.s=null:(e.s*=m.s,y&&b?(e.c=[0],e.e=0):e.c=e.e=null),e;for(n=G(m.e/j)+G(e.e/j),e.s*=m.s,(c=y.length)<(f=b.length)&&(h=y,y=b,b=h,i=c,c=f,f=i),i=c+f,h=[];i--;h.push(0));for(d=U,v=I,i=f;0<=--i;){for(r=0,p=b[i]%v,g=b[i]/v|0,a=i+(o=c);i<a;)r=((s=p*(s=y[--o]%v)+(u=g*s+(l=y[o]/v|0)*p)%v*v+h[a]+r)/d|0)+(u/v|0)+g*l,h[a--]=s%d;h[a]=r;}return r?++n:h.splice(0,1),D(e,h,n)},n.negated=function(){var e=new A(this);return e.s=-e.s||null,e},n.plus=function(e,t){var r,n=this,i=n.s;if(t=(e=new A(e,t)).s,!i||!t)return new A(NaN);if(i!=t)return e.s=-t,n.minus(e);var a=n.e/j,o=e.e/j,u=n.c,c=e.c;if(!a||!o){if(!u||!c)return new A(i/0);if(!u[0]||!c[0])return c[0]?e:new A(u[0]?n:0*i)}if(a=G(a),o=G(o),u=u.slice(),i=a-o){for((r=0<i?(o=a,c):(i=-i,u)).reverse();i--;r.push(0));r.reverse();}for((i=u.length)-(t=c.length)<0&&(r=c,c=u,u=r,t=i),i=0;t;)i=(u[--t]=u[t]+c[t]+i)/U|0,u[t]=U===u[t]?0:u[t]%U;return i&&(u=[i].concat(u),++o),D(e,u,o)},n.precision=n.sd=function(e,t){var r,n,i;if(null!=e&&e!==!!e)return Z(e,1,$),null==t?t=w:Z(t,0,8),E(new A(this),e,t);if(!(r=this.c))return null;if(n=(i=r.length-1)*j+1,i=r[i]){for(;i%10==0;i/=10,n--);for(i=r[0];10<=i;i/=10,n++);}return e&&this.e+1>n&&(n=this.e+1),n},n.shiftedBy=function(e){return Z(e,-C,C),this.times("1e"+e)},n.squareRoot=n.sqrt=function(){var e,t,r,n,i,a=this,o=a.c,u=a.s,c=a.e,s=b+4,l=new A("0.5");if(1!==u||!o||!o[0])return new A(!u||u<0&&(!o||o[0])?NaN:o?a:1/0);if((r=0==(u=Math.sqrt(+F(a)))||u==1/0?(((t=V(o)).length+c)%2==0&&(t+="0"),u=Math.sqrt(+t),c=G((c+1)/2)-(c<0||c%2),new A(t=u==1/0?"1e"+c:(t=u.toExponential()).slice(0,t.indexOf("e")+1)+c)):new A(u+"")).c[0])for((u=(c=r.e)+s)<3&&(u=0);;)if(i=r,r=l.times(i.plus(y(a,i,s,1))),V(i.c).slice(0,u)===(t=V(r.c)).slice(0,u)){if(r.e<c&&--u,"9999"!=(t=t.slice(u-3,u+1))&&(n||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(E(r,r.e+b+2,1),e=!r.times(r).eq(a));break}if(!n&&(E(i,i.e+b+2,0),i.times(i).eq(a))){r=i;break}s+=4,u+=4,n=1;}return E(r,r.e+b+1,w,e)},n.toExponential=function(e,t){return null!=e&&(Z(e,0,$),e++),i(this,e,t,1)},n.toFixed=function(e,t){return null!=e&&(Z(e,0,$),e=e+this.e+1),i(this,e,t)},n.toFormat=function(e,t,r){var n;if(null==r)null!=e&&t&&"object"==typeof t?(r=t,t=null):e&&"object"==typeof e?(r=e,e=t=null):r=N;else if("object"!=typeof r)throw Error(T+"Argument not an object: "+r);if(n=this.toFixed(e,t),this.c){var i,a=n.split("."),o=+r.groupSize,u=+r.secondaryGroupSize,c=r.groupSeparator||"",s=a[0],l=a[1],f=this.s<0,p=f?s.slice(1):s,g=p.length;if(u&&(i=o,o=u,g-=u=i),0<o&&0<g){for(i=g%o||o,s=p.substr(0,i);i<g;i+=o)s+=c+p.substr(i,o);0<u&&(s+=c+p.slice(i)),f&&(s="-"+s);}n=l?s+(r.decimalSeparator||"")+((u=+r.fractionGroupSize)?l.replace(new RegExp("\\d{"+u+"}\\B","g"),"$&"+(r.fractionGroupSeparator||"")):l):s;}return (r.prefix||"")+n+(r.suffix||"")},n.toFraction=function(e){var t,r,n,i,a,o,u,c,s,l,f,p,g=this,h=g.c;if(null!=e&&(!(u=new A(e)).isInteger()&&(u.c||1!==u.s)||u.lt(d)))throw Error(T+"Argument "+(u.isInteger()?"out of range: ":"not an integer: ")+F(u));if(!h)return new A(g);for(t=new A(d),s=r=new A(d),n=c=new A(d),p=V(h),a=t.e=p.length-g.e-1,t.c[0]=R[(o=a%j)<0?j+o:o],e=!e||0<u.comparedTo(t)?0<a?t:s:u,o=O,O=1/0,u=new A(p),c.c[0]=0;l=y(u,t,0,1),1!=(i=r.plus(l.times(n))).comparedTo(e);)r=n,n=i,s=c.plus(l.times(i=s)),c=i,t=u.minus(l.times(i=t)),u=i;return i=y(e.minus(r),n,0,1),c=c.plus(i.times(s)),r=r.plus(i.times(n)),c.s=s.s=g.s,f=y(s,n,a*=2,w).minus(g).abs().comparedTo(y(c,r,a,w).minus(g).abs())<1?[s,n]:[c,r],O=o,f},n.toNumber=function(){return +F(this)},n.toPrecision=function(e,t){return null!=e&&Z(e,1,$),i(this,e,t,2)},n.toString=function(e){var t,r=this,n=r.s,i=r.e;return null===i?n?(t="Infinity",n<0&&(t="-"+t)):t="NaN":(t=null==e?i<=h||v<=i?W(V(r.c),i):H(V(r.c),i,"0"):10===e?H(V((r=E(new A(r),b+i+1,w)).c),r.e,"0"):(Z(e,2,M.length,"Base"),f(H(V(r.c),i,"0"),10,e,n,!0)),n<0&&r.c[0]&&(t="-"+t)),t},n.valueOf=n.toJSON=function(){return F(this)},n._isBigNumber=!0,"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator&&(n[Symbol.toStringTag]="BigNumber",n[Symbol.for("nodejs.util.inspect.custom")]=n.valueOf),null!=t&&A.set(t),A}()).default=t.BigNumber=t,void 0!==r&&r.exports?r.exports=t:(e||(e="undefined"!=typeof self&&self?self:window),e.BigNumber=t);}(this);},{}],2:[function(e,t,r){t.exports={languageTag:"en-US",delimiters:{thousands:",",decimal:"."},abbreviations:{thousand:"k",million:"m",billion:"b",trillion:"t"},spaceSeparated:!1,ordinal:function(e){var t=e%10;return 1==~~(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th"},currency:{symbol:"$",position:"prefix",code:"USD"},currencyFormat:{thousandSeparated:!0,totalLength:4,spaceSeparated:!0},formats:{fourDigits:{totalLength:4,spaceSeparated:!0},fullWithTwoDecimals:{output:"currency",thousandSeparated:!0,mantissa:2},fullWithTwoDecimalsNoCurrency:{thousandSeparated:!0,mantissa:2},fullWithNoDecimals:{output:"currency",thousandSeparated:!0,mantissa:0}}};},{}],3:[function(e,t,r){function C(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=[],n=!0,i=!1,a=void 0;try{for(var o,u=e[Symbol.iterator]();!(n=(o=u.next()).done)&&(r.push(o.value),!t||r.length!==t);n=!0);}catch(e){i=!0,a=e;}finally{try{n||null==u.return||u.return();}finally{if(i)throw a}}return r}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var R=e("./globalState"),o=e("./validating"),u=e("./parsing"),n=["B","KB","MB","GB","TB","PB","EB","ZB","YB"],M={general:{scale:1024,suffixes:n,marker:"bd"},binary:{scale:1024,suffixes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],marker:"b"},decimal:{scale:1e3,suffixes:n,marker:"d"}},I={totalLength:0,characteristic:0,forceAverage:!1,average:!1,mantissa:-1,optionalMantissa:!0,thousandSeparated:!1,spaceSeparated:!1,negative:"sign",forceSign:!1};function i(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=2<arguments.length?arguments[2]:void 0;if("string"==typeof t&&(t=u.parseFormat(t)),!o.validateFormat(t))return "ERROR: invalid format";var n=t.prefix||"",i=t.postfix||"",a=function(e,t,r){switch(t.output){case"currency":return t=A(t,R.currentCurrencyDefaultFormat()),function(e,t,r){var n=r.currentCurrency(),i=Object.assign({},I,t),a=void 0,o="",u=!!i.totalLength||!!i.forceAverage||i.average,c=t.currencyPosition||n.position,s=t.currencySymbol||n.symbol;i.spaceSeparated&&(o=" ");"infix"===c&&(a=o+s+o);var l=D({instance:e,providedFormat:t,state:r,decimalSeparator:a});"prefix"===c&&(l=e._value<0&&"sign"===i.negative?"-".concat(o).concat(s).concat(l.slice(1)):s+o+l);c&&"postfix"!==c||(l=l+(o=u?"":o)+s);return l}(e,t,R);case"percent":return t=A(t,R.currentPercentageDefaultFormat()),function(e,t,r,n){var i=t.prefixSymbol,a=D({instance:n(100*e._value),providedFormat:t,state:r}),o=Object.assign({},I,t);if(i)return "%".concat(o.spaceSeparated?" ":"").concat(a);return "".concat(a).concat(o.spaceSeparated?" ":"","%")}(e,t,R,r);case"byte":return t=A(t,R.currentByteDefaultFormat()),h=e,v=R,m=r,y=(d=t).base||"binary",b=M[y],w=B(h._value,b.suffixes,b.scale),O=w.value,x=w.suffix,S=D({instance:m(O),providedFormat:d,state:v,defaults:v.currentByteDefaultFormat()}),N=v.currentAbbreviations(),"".concat(S).concat(N.spaced?" ":"").concat(x);case"time":return t=A(t,R.currentTimeDefaultFormat()),l=e,f=Math.floor(l._value/60/60),p=Math.floor((l._value-60*f*60)/60),g=Math.round(l._value-60*f*60-60*p),"".concat(f,":").concat(p<10?"0":"").concat(p,":").concat(g<10?"0":"").concat(g);case"ordinal":return t=A(t,R.currentOrdinalDefaultFormat()),n=e,i=t,o=(a=R).currentOrdinal(),u=Object.assign({},I,i),c=D({instance:n,providedFormat:i,state:a}),s=o(n._value),"".concat(c).concat(u.spaceSeparated?" ":"").concat(s);case"number":default:return D({instance:e,providedFormat:t,numbro:r})}var n,i,a,o,u,c,s;var l,f,p,g;var h,d,v,m,y,b,w,O,x,S,N;}(e,t,r);return a=(a=n+a)+i}function B(e,t,r){var n=t[0],i=Math.abs(e);if(r<=i){for(var a=1;a<t.length;++a){var o=Math.pow(r,a),u=Math.pow(r,a+1);if(o<=i&&i<u){n=t[a],e/=o;break}}n===t[0]&&(e/=Math.pow(r,t.length-1),n=t[t.length-1]);}return {value:e,suffix:n}}function p(e){for(var t="",r=0;r<e;r++)t+="0";return t}function $(e,t){return -1!==e.toString().indexOf("e")?function(e,t){var r=e.toString(),n=C(r.split("e"),2),i=n[0],a=n[1],o=C(i.split("."),2),u=o[0],c=o[1],s=void 0===c?"":c;if(0<+a)r=u+s+p(a-s.length);else {var l=".";l=+u<0?"-0".concat(l):"0".concat(l);var f=(p(-a-1)+Math.abs(u)+s).substr(0,t);f.length<t&&(f+=p(t-f.length)),r=l+f;}return 0<+a&&0<t&&(r+=".".concat(p(t))),r}(e,t):(Math.round(+"".concat(e,"e+").concat(t))/Math.pow(10,t)).toFixed(t)}function D(e){var t=e.instance,r=e.providedFormat,n=e.state,i=void 0===n?R:n,a=e.decimalSeparator,o=e.defaults,u=void 0===o?i.currentDefaults():o,c=t._value;if(0===c&&i.hasZeroFormat())return i.getZeroFormat();if(!isFinite(c))return c.toString();var s,l,f,p,g,h,d,v,m=Object.assign({},I,u,r),y=m.totalLength,b=y?0:m.characteristic,w=m.optionalCharacteristic,O=m.forceAverage,x=!!y||!!O||m.average,S=y?-1:x&&void 0===r.mantissa?0:m.mantissa,N=!y&&(void 0===r.optionalMantissa?-1===S:m.optionalMantissa),M=m.trimMantissa,B=m.thousandSeparated,D=m.spaceSeparated,A=m.negative,E=m.forceSign,F=m.exponential,k="";if(x){var _=function(e){var t=e.value,r=e.forceAverage,n=e.abbreviations,i=e.spaceSeparated,a=void 0!==i&&i,o=e.totalLength,u=void 0===o?0:o,c="",s=Math.abs(t),l=-1;if(s>=Math.pow(10,12)&&!r||"trillion"===r?(c=n.trillion,t/=Math.pow(10,12)):s<Math.pow(10,12)&&s>=Math.pow(10,9)&&!r||"billion"===r?(c=n.billion,t/=Math.pow(10,9)):s<Math.pow(10,9)&&s>=Math.pow(10,6)&&!r||"million"===r?(c=n.million,t/=Math.pow(10,6)):(s<Math.pow(10,6)&&s>=Math.pow(10,3)&&!r||"thousand"===r)&&(c=n.thousand,t/=Math.pow(10,3)),c&&(c=(a?" ":"")+c),u){var f=t.toString().split(".")[0];l=Math.max(u-f.length,0);}return {value:t,abbreviation:c,mantissaPrecision:l}}({value:c,forceAverage:O,abbreviations:i.currentAbbreviations(),spaceSeparated:D,totalLength:y});c=_.value,k+=_.abbreviation,y&&(S=_.mantissaPrecision);}if(F){var L=(l=(s={value:c,characteristicPrecision:b}).value,f=s.characteristicPrecision,p=void 0===f?0:f,g=C(l.toExponential().split("e"),2),h=g[0],d=g[1],v=+h,p&&1<p&&(v*=Math.pow(10,p-1),d=0<=(d=+d-(p-1))?"+".concat(d):d),{value:v,abbreviation:"e".concat(d)});c=L.value,k=L.abbreviation+k;}var T,P,U,j=function(e,t,r,n,i){if(-1===n)return e;var a=$(t,n),o=C(a.toString().split("."),2),u=o[0],c=o[1],s=void 0===c?"":c;if(s.match(/^0+$/)&&(r||i))return u;var l=s.match(/0+$/);return i&&l?"".concat(u,".").concat(s.toString().slice(0,l.index)):a.toString()}(c.toString(),c,N,S,M);return j=function(e,t,r,n,i){var a=n.currentDelimiters(),o=a.thousands;i=i||a.decimal;var u=a.thousandsSize||3,c=e.toString(),s=c.split(".")[0],l=c.split(".")[1];return r&&(t<0&&(s=s.slice(1)),function(e,t){for(var r=[],n=0,i=e;0<i;i--)n===t&&(r.unshift(i),n=0),n++;return r}(s.length,u).forEach(function(e,t){s=s.slice(0,e+t)+o+s.slice(e+t);}),t<0&&(s="-".concat(s))),c=l?s+i+l:s}(j=function(e,t,r,n){var i=e,a=C(i.toString().split("."),2),o=a[0],u=a[1];if(o.match(/^-?0$/)&&r)return u?"".concat(o.replace("0",""),".").concat(u):o.replace("0","");if(o.length<n)for(var c=n-o.length,s=0;s<c;s++)i="0".concat(i);return i.toString()}(j,0,w,b),c,B,i,a),(x||F)&&(j=j+k),(E||c<0)&&(T=j,U=A,j=0===(P=c)?T:0==+T?T.replace("-",""):0<P?"+".concat(T):"sign"===U?T:"(".concat(T.replace("-",""),")")),j}function A(e,t){if(!e)return t;var r=Object.keys(e);return 1===r.length&&"output"===r[0]?t:e}t.exports=function(n){return {format:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return i.apply(void 0,t.concat([n]))},getByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=M.general;return B(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getBinaryByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=M.binary;return B(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getDecimalByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=M.decimal;return B(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},formatOrDefault:A}};},{"./globalState":4,"./parsing":8,"./validating":10}],4:[function(e,t,r){var i=e("./en-US"),n=e("./validating"),a=e("./parsing"),o={},u=void 0,c={},s=null,l={};function f(e){u=e;}function p(){return c[u]}o.languages=function(){return Object.assign({},c)},o.currentLanguage=function(){return u},o.currentCurrency=function(){return p().currency},o.currentAbbreviations=function(){return p().abbreviations},o.currentDelimiters=function(){return p().delimiters},o.currentOrdinal=function(){return p().ordinal},o.currentDefaults=function(){return Object.assign({},p().defaults,l)},o.currentOrdinalDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().ordinalFormat)},o.currentByteDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().byteFormat)},o.currentPercentageDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().percentageFormat)},o.currentCurrencyDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().currencyFormat)},o.currentTimeDefaultFormat=function(){return Object.assign({},o.currentDefaults(),p().timeFormat)},o.setDefaults=function(e){e=a.parseFormat(e),n.validateFormat(e)&&(l=e);},o.getZeroFormat=function(){return s},o.setZeroFormat=function(e){return s="string"==typeof e?e:null},o.hasZeroFormat=function(){return null!==s},o.languageData=function(e){if(e){if(c[e])return c[e];throw new Error('Unknown tag "'.concat(e,'"'))}return p()},o.registerLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1];if(!n.validateLanguage(e))throw new Error("Invalid language data");c[e.languageTag]=e,t&&f(e.languageTag);},o.setLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:i.languageTag;if(!c[e]){var r=e.split("-")[0],n=Object.keys(c).find(function(e){return e.split("-")[0]===r});return c[n]?void f(n):void f(t)}f(e);},o.registerLanguage(i),u=i.languageTag,t.exports=o;},{"./en-US":2,"./parsing":8,"./validating":10}],5:[function(n,e,t){e.exports=function(t){return {loadLanguagesInNode:function(e){return r=t,void e.forEach(function(t){var e=void 0;try{e=n("../languages/".concat(t));}catch(e){console.error('Unable to load "'.concat(t,'". No matching language file found.'));}e&&r.registerLanguage(e);});var r;}}};},{}],6:[function(e,t,r){var c=e("bignumber.js");function a(e,t,r){var n=new c(e._value),i=t;return r.isNumbro(t)&&(i=t._value),i=new c(i),e._value=n.minus(i).toNumber(),e}t.exports=function(u){return {add:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.plus(o).toNumber(),r;var r,n,i,a,o;},subtract:function(e,t){return a(e,t,u)},multiply:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.times(o).toNumber(),r;var r,n,i,a,o;},divide:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.dividedBy(o).toNumber(),r;var r,n,i,a,o;},set:function(e,t){return r=e,i=n=t,u.isNumbro(n)&&(i=n._value),r._value=i,r;var r,n,i;},difference:function(e,t){return r=t,a(i=(n=u)(e._value),r,n),Math.abs(i._value);var r,n,i;}}};},{"bignumber.js":1}],7:[function(e,t,r){function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}var a=e("./globalState"),n=e("./validating"),o=e("./loading")(g),u=e("./unformatting"),c=e("./formatting")(g),s=e("./manipulating")(g),l=e("./parsing"),f=function(){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._value=e;}var e,r;return e=t,(r=[{key:"clone",value:function(){return g(this._value)}},{key:"format",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return c.format(this,e)}},{key:"formatCurrency",value:function(e){return "string"==typeof e&&(e=l.parseFormat(e)),(e=c.formatOrDefault(e,a.currentCurrencyDefaultFormat())).output="currency",c.format(this,e)}},{key:"formatTime",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return e.output="time",c.format(this,e)}},{key:"binaryByteUnits",value:function(){return c.getBinaryByteUnit(this)}},{key:"decimalByteUnits",value:function(){return c.getDecimalByteUnit(this)}},{key:"byteUnits",value:function(){return c.getByteUnit(this)}},{key:"difference",value:function(e){return s.difference(this,e)}},{key:"add",value:function(e){return s.add(this,e)}},{key:"subtract",value:function(e){return s.subtract(this,e)}},{key:"multiply",value:function(e){return s.multiply(this,e)}},{key:"divide",value:function(e){return s.divide(this,e)}},{key:"set",value:function(e){return s.set(this,p(e))}},{key:"value",value:function(){return this._value}},{key:"valueOf",value:function(){return this._value}}])&&i(e.prototype,r),t}();function p(e){var t=e;return g.isNumbro(e)?t=e._value:"string"==typeof e?t=g.unformat(e):isNaN(e)&&(t=NaN),t}function g(e){return new f(p(e))}g.version="2.1.2",g.isNumbro=function(e){return e instanceof f},g.language=a.currentLanguage,g.registerLanguage=a.registerLanguage,g.setLanguage=a.setLanguage,g.languages=a.languages,g.languageData=a.languageData,g.zeroFormat=a.setZeroFormat,g.defaultFormat=a.currentDefaults,g.setDefaults=a.setDefaults,g.defaultCurrencyFormat=a.currentCurrencyDefaultFormat,g.validate=n.validate,g.loadLanguagesInNode=o.loadLanguagesInNode,g.unformat=u.unformat,t.exports=g;},{"./formatting":3,"./globalState":4,"./loading":5,"./manipulating":6,"./parsing":8,"./unformatting":9,"./validating":10}],8:[function(e,t,r){t.exports={parseFormat:function(e){var t,r,n,i,a,o,u,c,s,l,f,p,g,h,d,v,m,y,b,w,O=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return "string"!=typeof e?e:(r=O,e=(n=(t=e).match(/^{([^}]*)}/))?(r.prefix=n[1],t.slice(n[0].length)):t,a=O,function(e,t){if(-1===e.indexOf("$")){if(-1===e.indexOf("%"))return -1!==e.indexOf("bd")?(t.output="byte",t.base="general"):-1!==e.indexOf("b")?(t.output="byte",t.base="binary"):-1!==e.indexOf("d")?(t.output="byte",t.base="decimal"):-1===e.indexOf(":")?-1!==e.indexOf("o")&&(t.output="ordinal"):t.output="time";t.output="percent";}else t.output="currency";}(e=(o=(i=e).match(/{([^}]*)}$/))?(a.postfix=o[1],i.slice(0,-o[0].length)):i,O),u=O,(c=e.match(/[1-9]+[0-9]*/))&&(u.totalLength=+c[0]),s=O,(l=e.split(".")[0].match(/0+/))&&(s.characteristic=l[0].length),function(e,t){if(-1!==e.indexOf(".")){var r=e.split(".")[0];t.optionalCharacteristic=-1===r.indexOf("0");}}(e,O),f=O,-1!==e.indexOf("a")&&(f.average=!0),g=O,-1!==(p=e).indexOf("K")?g.forceAverage="thousand":-1!==p.indexOf("M")?g.forceAverage="million":-1!==p.indexOf("B")?g.forceAverage="billion":-1!==p.indexOf("T")&&(g.forceAverage="trillion"),function(e,t){var r=e.split(".")[1];if(r){var n=r.match(/0+/);n&&(t.mantissa=n[0].length);}}(e,O),d=O,(h=e).match(/\[\.]/)?d.optionalMantissa=!0:h.match(/\./)&&(d.optionalMantissa=!1),v=O,-1!==e.indexOf(",")&&(v.thousandSeparated=!0),m=O,-1!==e.indexOf(" ")&&(m.spaceSeparated=!0),b=O,(y=e).match(/^\+?\([^)]*\)$/)&&(b.negative="parenthesis"),y.match(/^\+?-/)&&(b.negative="sign"),w=O,e.match(/^\+/)&&(w.forceSign=!0),O)}};},{}],9:[function(p,e,t){var O=[{key:"ZiB",factor:Math.pow(1024,7)},{key:"ZB",factor:Math.pow(1e3,7)},{key:"YiB",factor:Math.pow(1024,8)},{key:"YB",factor:Math.pow(1e3,8)},{key:"TiB",factor:Math.pow(1024,4)},{key:"TB",factor:Math.pow(1e3,4)},{key:"PiB",factor:Math.pow(1024,5)},{key:"PB",factor:Math.pow(1e3,5)},{key:"MiB",factor:Math.pow(1024,2)},{key:"MB",factor:Math.pow(1e3,2)},{key:"KiB",factor:Math.pow(1024,1)},{key:"KB",factor:Math.pow(1e3,1)},{key:"GiB",factor:Math.pow(1024,3)},{key:"GB",factor:Math.pow(1e3,3)},{key:"EiB",factor:Math.pow(1024,6)},{key:"EB",factor:Math.pow(1e3,6)},{key:"B",factor:1}];function x(e){return e.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function g(e,t){var r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:"",n=3<arguments.length?arguments[3]:void 0,i=4<arguments.length?arguments[4]:void 0,a=5<arguments.length?arguments[5]:void 0,o=6<arguments.length?arguments[6]:void 0;if(""!==e)return e===i?0:function e(t,r){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:"",i=3<arguments.length?arguments[3]:void 0,a=4<arguments.length?arguments[4]:void 0,o=5<arguments.length?arguments[5]:void 0,u=6<arguments.length?arguments[6]:void 0;if(!isNaN(+t))return +t;var c="",s=t.replace(/(^[^(]*)\((.*)\)([^)]*$)/,"$1$2$3");if(s!==t)return -1*e(s,r,n,i,a,o,u);for(var l=0;l<O.length;l++){var f=O[l];if((c=t.replace(f.key,""))!==t)return e(c,r,n,i,a,o,u)*f.factor}if((c=t.replace("%",""))!==t)return e(c,r,n,i,a,o,u)/100;var p=parseFloat(t);if(!isNaN(p)){var g=i(p);if(g&&"."!==g&&(c=t.replace(new RegExp("".concat(x(g),"$")),""))!==t)return e(c,r,n,i,a,o,u);var h={};Object.keys(o).forEach(function(e){h[o[e]]=e;});for(var d=Object.keys(h).sort().reverse(),v=d.length,m=0;m<v;m++){var y=d[m],b=h[y];if((c=t.replace(y,""))!==t){var w=void 0;switch(b){case"thousand":w=Math.pow(10,3);break;case"million":w=Math.pow(10,6);break;case"billion":w=Math.pow(10,9);break;case"trillion":w=Math.pow(10,12);}return e(c,r,n,i,a,o,u)*w}}}}(function(e,t){var r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:"",n=e.replace(r,"");return n=(n=n.replace(new RegExp("([0-9])".concat(x(t.thousands),"([0-9])"),"g"),"$1$2")).replace(t.decimal,".")}(e,t,r),t,r,n,i,a,o)}e.exports={unformat:function(e,t){var r,n,i,a=p("./globalState"),o=a.currentDelimiters(),u=a.currentCurrency().symbol,c=a.currentOrdinal(),s=a.getZeroFormat(),l=a.currentAbbreviations(),f=void 0;if("string"==typeof e)f=function(e,t){if(!e.indexOf(":")||":"===t.thousands)return !1;var r=e.split(":");if(3!==r.length)return !1;var n=+r[0],i=+r[1],a=+r[2];return !isNaN(n)&&!isNaN(i)&&!isNaN(a)}(e,o)?(r=e.split(":"),n=+r[0],i=+r[1],+r[2]+60*i+3600*n):g(e,o,u,c,s,l,t);else {if("number"!=typeof e)return;f=e;}if(void 0!==f)return f}};},{"./globalState":4}],10:[function(e,t,r){function n(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function f(e){return (f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var i=e("./unformatting"),a=/^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/,p={output:{type:"string",validValues:["currency","percent","byte","time","ordinal","number"]},base:{type:"string",validValues:["decimal","binary","general"],restriction:function(e,t){return "byte"===t.output},message:"`base` must be provided only when the output is `byte`",mandatory:function(e){return "byte"===e.output}},characteristic:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},prefix:"string",postfix:"string",forceAverage:{type:"string",validValues:["trillion","billion","million","thousand"]},average:"boolean",currencyPosition:{type:"string",validValues:["prefix","infix","postfix"]},currencySymbol:"string",totalLength:{type:"number",restrictions:[{restriction:function(e){return 0<=e},message:"value must be positive"},{restriction:function(e,t){return !t.exponential},message:"`totalLength` is incompatible with `exponential`"}]},mantissa:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},optionalMantissa:"boolean",trimMantissa:"boolean",optionalCharacteristic:"boolean",thousandSeparated:"boolean",spaceSeparated:"boolean",abbreviations:{type:"object",children:{thousand:"string",million:"string",billion:"string",trillion:"string"}},negative:{type:"string",validValues:["sign","parenthesis"]},forceSign:"boolean",exponential:{type:"boolean"},prefixSymbol:{type:"boolean",restriction:function(e,t){return "percent"===t.output},message:"`prefixSymbol` can be provided only when the output is `percent`"}},o={languageTag:{type:"string",mandatory:!0,restriction:function(e){return e.match(a)},message:"the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)"},delimiters:{type:"object",children:{thousands:"string",decimal:"string",thousandsSize:"number"},mandatory:!0},abbreviations:{type:"object",children:{thousand:{type:"string",mandatory:!0},million:{type:"string",mandatory:!0},billion:{type:"string",mandatory:!0},trillion:{type:"string",mandatory:!0}},mandatory:!0},spaceSeparated:"boolean",ordinal:{type:"function",mandatory:!0},currency:{type:"object",children:{symbol:"string",position:"string",code:"string"},mandatory:!0},defaults:"format",ordinalFormat:"format",byteFormat:"format",percentageFormat:"format",currencyFormat:"format",timeDefaults:"format",formats:{type:"object",children:{fourDigits:{type:"format",mandatory:!0},fullWithTwoDecimals:{type:"format",mandatory:!0},fullWithTwoDecimalsNoCurrency:{type:"format",mandatory:!0},fullWithNoDecimals:{type:"format",mandatory:!0}}}};function u(e){return !!i.unformat(e)}function g(c,s,l){var e=3<arguments.length&&void 0!==arguments[3]&&arguments[3],t=Object.keys(c).map(function(e){if(!s[e])return console.error("".concat(l," Invalid key: ").concat(e)),!1;var t=c[e],r=s[e];if("string"==typeof r&&(r={type:r}),"format"===r.type){if(!g(t,p,"[Validate ".concat(e,"]"),!0))return !1}else if(f(t)!==r.type)return console.error("".concat(l," ").concat(e,' type mismatched: "').concat(r.type,'" expected, "').concat(f(t),'" provided')),!1;if(r.restrictions&&r.restrictions.length)for(var n=r.restrictions.length,i=0;i<n;i++){var a=r.restrictions[i],o=a.restriction,u=a.message;if(!o(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(u)),!1}if(r.restriction&&!r.restriction(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(r.message)),!1;if(r.validValues&&-1===r.validValues.indexOf(t))return console.error("".concat(l," ").concat(e," invalid value: must be among ").concat(JSON.stringify(r.validValues),', "').concat(t,'" provided')),!1;if(r.children&&!g(t,r.children,"[Validate ".concat(e,"]")))return !1;return !0});return e||t.push.apply(t,n(Object.keys(s).map(function(e){var t=s[e];if("string"==typeof t&&(t={type:t}),t.mandatory){var r=t.mandatory;if("function"==typeof r&&(r=r(c)),r&&void 0===c[e])return console.error("".concat(l,' Missing mandatory key "').concat(e,'"')),!1}return !0}))),t.reduce(function(e,t){return e&&t},!0)}function c(e){return g(e,p,"[Validate format]")}t.exports={validate:function(e,t){var r=u(e),n=c(t);return r&&n},validateFormat:c,validateInput:u,validateLanguage:function(e){return g(e,o,"[Validate language]")}};},{"./unformatting":9}]},{},[7])(7)});

});

var RENDERER_TYPE$5 = "numeric";
function numericRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var newValue = value;
  if (isNumeric(newValue)) {
    var numericFormat = cellProperties.numericFormat;
    var cellCulture = numericFormat && numericFormat.culture || "-";
    var cellFormatPattern = numericFormat && numericFormat.pattern;
    var className = cellProperties.className || "";
    var classArr = className.length ? className.split(" ") : [];
    if (typeof cellCulture !== "undefined" && !numbro_min.languages()[cellCulture]) {
      var shortTag = cellCulture.replace("-", "");
      var langData = numbro_min.allLanguages ? numbro_min.allLanguages[cellCulture] : numbro_min[shortTag];
      if (langData) {
        numbro_min.registerLanguage(langData);
      }
    }
    numbro_min.setLanguage(cellCulture);
    newValue = numbro_min(newValue).format(cellFormatPattern || "0");
    if (classArr.indexOf("htLeft") < 0 && classArr.indexOf("htCenter") < 0 && classArr.indexOf("htRight") < 0 && classArr.indexOf("htJustify") < 0) {
      classArr.push("htRight");
    }
    if (classArr.indexOf("htNumeric") < 0) {
      classArr.push("htNumeric");
    }
    cellProperties.className = classArr.join(" ");
  }
  textRenderer(instance, TD, row, col, prop, newValue, cellProperties);
}
numericRenderer.RENDERER_TYPE = RENDERER_TYPE$5;

var RENDERER_TYPE$6 = "password";
function passwordRenderer(instance, TD, row, col, prop, value, cellProperties) {
  textRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  var hashLength = cellProperties.hashLength || TD.innerHTML.length;
  var hashSymbol = cellProperties.hashSymbol || "*";
  var hash = "";
  rangeEach(hashLength - 1, function() {
    hash += hashSymbol;
  });
  fastInnerHTML(TD, hash);
}
passwordRenderer.RENDERER_TYPE = RENDERER_TYPE$6;

var VALIDATOR_TYPE = "autocomplete";
function autocompleteValidator(value, callback) {
  var valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
    return;
  }
  if (this.strict && this.source) {
    if (typeof this.source === "function") {
      this.source(valueToValidate, process$1(valueToValidate, callback));
    } else {
      process$1(valueToValidate, callback)(this.source);
    }
  } else {
    callback(true);
  }
}
autocompleteValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;
function process$1(value, callback) {
  var originalVal = value;
  return function(source) {
    var found = false;
    for (var s = 0, slen = source.length; s < slen; s++) {
      if (originalVal === source[s]) {
        found = true;
        break;
      }
    }
    callback(found);
  };
}

// `SameValue` abstract operation
// https://tc39.es/ecma262/#sec-samevalue
// eslint-disable-next-line es/no-object-is -- safe
var sameValue = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

// @@search logic
fixRegexpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.es/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
    function (string) {
      var res = maybeCallNative(nativeSearch, this, string);
      if (res.done) return res.value;

      var rx = anObject(this);
      var S = String(string);

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regexpExecAbstract(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

var VALIDATOR_TYPE$1 = "date";
function dateValidator(value, callback) {
  var dateEditor = _getEditorInstance(EDITOR_TYPE$5, this.instance);
  var valueToValidate = value;
  var valid = true;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  var isValidFormat = hooks(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();
  var isValidDate = hooks(new Date(valueToValidate)).isValid() || isValidFormat;
  if (this.allowEmpty && valueToValidate === "") {
    isValidDate = true;
    isValidFormat = true;
  }
  if (!isValidDate) {
    valid = false;
  }
  if (!isValidDate && isValidFormat) {
    valid = true;
  }
  if (isValidDate && !isValidFormat) {
    if (this.correctFormat === true) {
      var correctedValue = correctFormat(valueToValidate, this.dateFormat);
      var row = this.instance.toVisualRow(this.row);
      var column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "dateValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
dateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE$1;
function correctFormat(value, dateFormat) {
  var dateFromDate = hooks(getNormalizedDate(value));
  var dateFromMoment = hooks(value, dateFormat);
  var isAlphanumeric = value.search(/[A-z]/g) > -1;
  var date;
  if (dateFromDate.isValid() && dateFromDate.format("x") === dateFromMoment.format("x") || !dateFromMoment.isValid() || isAlphanumeric) {
    date = dateFromDate;
  } else {
    date = dateFromMoment;
  }
  return date.format(dateFormat);
}

var VALIDATOR_TYPE$2 = "numeric";
function numericValidator(value, callback) {
  var valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
  } else if (valueToValidate === "") {
    callback(false);
  } else {
    callback(isNumeric(value));
  }
}
numericValidator.VALIDATOR_TYPE = VALIDATOR_TYPE$2;

var STRICT_FORMATS = [
  "YYYY-MM-DDTHH:mm:ss.SSSZ",
  "X",
  "x"
];
var VALIDATOR_TYPE$3 = "time";
function timeValidator(value, callback) {
  var timeFormat = this.timeFormat || "h:mm:ss a";
  var valid = true;
  var valueToValidate = value;
  if (valueToValidate === null) {
    valueToValidate = "";
  }
  valueToValidate = /^\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;
  var twoDigitValue = /^\d{1,2}$/.test(valueToValidate);
  if (twoDigitValue) {
    valueToValidate += ":00";
  }
  var date = hooks(valueToValidate, STRICT_FORMATS, true).isValid() ? hooks(valueToValidate) : hooks(valueToValidate, timeFormat);
  var isValidTime = date.isValid();
  var isValidFormat = hooks(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;
  if (this.allowEmpty && valueToValidate === "") {
    isValidTime = true;
    isValidFormat = true;
  }
  if (!isValidTime) {
    valid = false;
  }
  if (!isValidTime && isValidFormat) {
    valid = true;
  }
  if (isValidTime && !isValidFormat) {
    if (this.correctFormat === true) {
      var correctedValue = date.format(timeFormat);
      var row = this.instance.toVisualRow(this.row);
      var column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "timeValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
timeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE$3;

var CELL_TYPE$2 = "autocomplete";
var AutocompleteCellType = {
  CELL_TYPE: CELL_TYPE$2,
  editor: AutocompleteEditor,
  renderer: autocompleteRenderer,
  validator: autocompleteValidator
};

var CELL_TYPE$3 = "checkbox";
var CheckboxCellType = {
  CELL_TYPE: CELL_TYPE$3,
  editor: CheckboxEditor,
  renderer: checkboxRenderer
};

var CELL_TYPE$4 = "date";
var DateCellType = {
  CELL_TYPE: CELL_TYPE$4,
  editor: DateEditor,
  renderer: autocompleteRenderer,
  validator: dateValidator
};

var CELL_TYPE$5 = "dropdown";
var DropdownCellType = {
  CELL_TYPE: CELL_TYPE$5,
  editor: DropdownEditor,
  renderer: autocompleteRenderer,
  validator: autocompleteValidator
};

var CELL_TYPE$6 = "handsontable";
var HandsontableCellType = {
  CELL_TYPE: CELL_TYPE$6,
  editor: HandsontableEditor,
  renderer: autocompleteRenderer
};

var CELL_TYPE$7 = "numeric";
var NumericCellType = {
  CELL_TYPE: CELL_TYPE$7,
  editor: NumericEditor,
  renderer: numericRenderer,
  validator: numericValidator,
  dataType: "number"
};

var CELL_TYPE$8 = "password";
var PasswordCellType = {
  CELL_TYPE: CELL_TYPE$8,
  editor: PasswordEditor,
  renderer: passwordRenderer,
  copyable: false
};

var CELL_TYPE$9 = "time";
var TimeCellType = {
  CELL_TYPE: CELL_TYPE$9,
  editor: TextEditor,
  renderer: textRenderer,
  validator: timeValidator
};

function _slicedToArray$e(arr, i) {
  return _arrayWithHoles$e(arr) || _iterableToArrayLimit$e(arr, i) || _unsupportedIterableToArray$o(arr, i) || _nonIterableRest$e();
}
function _nonIterableRest$e() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$o(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$o(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$o(o, minLen);
}
function _arrayLikeToArray$o(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$e(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$e(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1c(Constructor, staticProps);
  return Constructor;
}
var DEPS_TYPE_CHECKERS = new Map([["plugin", hasPlugin], ["cell-type", hasItem$3], ["editor", hasItem], ["renderer", hasItem$1], ["validator", hasItem$2]]);
var PLUGIN_KEY = "base";
var privatePool$5 = new WeakMap();
var missingDependeciesMsgs = [];
var initializedPlugins = null;
var BasePlugin = /* @__PURE__ */ function() {
  function BasePlugin2(hotInstance) {
    var _this = this;
    _classCallCheck$1h(this, BasePlugin2);
    defineGetter(this, "hot", hotInstance, {
      writable: false
    });
    privatePool$5.set(this, {
      hooks: {}
    });
    initializedPlugins = null;
    this.pluginName = null;
    this.pluginsInitializedCallbacks = [];
    this.isPluginsReady = false;
    this.enabled = false;
    this.initialized = false;
    this.hot.addHook("afterPluginsInitialized", function() {
      return _this.onAfterPluginsInitialized();
    });
    this.hot.addHook("afterUpdateSettings", function(newSettings) {
      return _this.onUpdateSettings(newSettings);
    });
    this.hot.addHook("beforeInit", function() {
      return _this.init();
    });
  }
  _createClass$1c(BasePlugin2, [{
    key: "init",
    value: function init() {
      var _this2 = this;
      this.pluginName = this.hot.getPluginName(this);
      var pluginDeps = this.constructor.PLUGIN_DEPS;
      var dependecies = Array.isArray(pluginDeps) ? pluginDeps : [];
      if (dependecies.length > 0) {
        var missingDependencies = [];
        dependecies.forEach(function(dependency) {
          var _dependency$split = dependency.split(":"), _dependency$split2 = _slicedToArray$e(_dependency$split, 2), type = _dependency$split2[0], moduleName = _dependency$split2[1];
          if (!DEPS_TYPE_CHECKERS.has(type)) {
            throw new Error('Unknown plugin dependency type "'.concat(type, '" was found.'));
          }
          if (!DEPS_TYPE_CHECKERS.get(type)(moduleName)) {
            missingDependencies.push(" - ".concat(moduleName, " (").concat(type, ")"));
          }
        });
        if (missingDependencies.length > 0) {
          var errorMsg = ["The ".concat(this.pluginName, " plugin requires the following modules:\n"), "".concat(missingDependencies.join("\n"), "\n")].join("");
          missingDependeciesMsgs.push(errorMsg);
        }
      }
      if (!initializedPlugins) {
        initializedPlugins = getPluginsNames();
      }
      if (initializedPlugins.indexOf("UndoRedo") >= 0) {
        initializedPlugins.splice(initializedPlugins.indexOf("UndoRedo"), 1);
      }
      if (initializedPlugins.indexOf(this.pluginName) >= 0) {
        initializedPlugins.splice(initializedPlugins.indexOf(this.pluginName), 1);
      }
      this.hot.addHookOnce("afterPluginsInitialized", function() {
        if (_this2.isEnabled && _this2.isEnabled()) {
          _this2.enablePlugin();
        }
      });
      var isAllPluginsAreInitialized = initializedPlugins.length === 0;
      if (isAllPluginsAreInitialized) {
        if (missingDependeciesMsgs.length > 0) {
          var _errorMsg = ["".concat(missingDependeciesMsgs.join("\n"), "\n"), "You have to import and register them manually."].join("");
          throw new Error(_errorMsg);
        }
        this.hot.runHooks("afterPluginsInitialized");
      }
      this.initialized = true;
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      this.enabled = true;
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      if (this.eventManager) {
        this.eventManager.clear();
      }
      this.clearHooks();
      this.enabled = false;
    }
  }, {
    key: "addHook",
    value: function addHook(name, callback) {
      privatePool$5.get(this).hooks[name] = privatePool$5.get(this).hooks[name] || [];
      var hooks = privatePool$5.get(this).hooks[name];
      this.hot.addHook(name, callback);
      hooks.push(callback);
      privatePool$5.get(this).hooks[name] = hooks;
    }
  }, {
    key: "removeHooks",
    value: function removeHooks(name) {
      var _this3 = this;
      arrayEach(privatePool$5.get(this).hooks[name] || [], function(callback) {
        _this3.hot.removeHook(name, callback);
      });
    }
  }, {
    key: "clearHooks",
    value: function clearHooks() {
      var _this4 = this;
      var hooks = privatePool$5.get(this).hooks;
      objectEach(hooks, function(callbacks, name) {
        return _this4.removeHooks(name);
      });
      hooks.length = 0;
    }
  }, {
    key: "callOnPluginsReady",
    value: function callOnPluginsReady(callback) {
      if (this.isPluginsReady) {
        callback();
      } else {
        this.pluginsInitializedCallbacks.push(callback);
      }
    }
  }, {
    key: "onAfterPluginsInitialized",
    value: function onAfterPluginsInitialized() {
      arrayEach(this.pluginsInitializedCallbacks, function(callback) {
        return callback();
      });
      this.pluginsInitializedCallbacks.length = 0;
      this.isPluginsReady = true;
    }
  }, {
    key: "onUpdateSettings",
    value: function onUpdateSettings(newSettings) {
      if (this.isEnabled) {
        if (this.enabled && !this.isEnabled()) {
          this.disablePlugin();
        }
        if (!this.enabled && this.isEnabled()) {
          this.enablePlugin();
        }
        if (this.enabled && this.isEnabled()) {
          this.updatePlugin(newSettings);
        }
      }
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this5 = this;
      if (this.eventManager) {
        this.eventManager.destroy();
      }
      this.clearHooks();
      objectEach(this, function(value, property) {
        if (property !== "hot") {
          _this5[property] = null;
        }
      });
      delete this.t;
      delete this.hot;
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY;
    }
  }]);
  return BasePlugin2;
}();

function _classCallCheck$1i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1d(Constructor, staticProps);
  return Constructor;
}
var Storage = /* @__PURE__ */ function() {
  function Storage2(prefix) {
    var rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
    _classCallCheck$1i(this, Storage2);
    this.rootWindow = rootWindow;
    this.prefix = prefix;
    this.savedKeys = [];
    this.loadSavedKeys();
  }
  _createClass$1d(Storage2, [{
    key: "saveValue",
    value: function saveValue(key, value) {
      this.rootWindow.localStorage.setItem("".concat(this.prefix, "_").concat(key), JSON.stringify(value));
      if (this.savedKeys.indexOf(key) === -1) {
        this.savedKeys.push(key);
        this.saveSavedKeys();
      }
    }
  }, {
    key: "loadValue",
    value: function loadValue(key, defaultValue) {
      var itemKey = typeof key === "undefined" ? defaultValue : key;
      var value = this.rootWindow.localStorage.getItem("".concat(this.prefix, "_").concat(itemKey));
      return value === null ? void 0 : JSON.parse(value);
    }
  }, {
    key: "reset",
    value: function reset(key) {
      this.rootWindow.localStorage.removeItem("".concat(this.prefix, "_").concat(key));
    }
  }, {
    key: "resetAll",
    value: function resetAll() {
      var _this = this;
      arrayEach(this.savedKeys, function(value, index) {
        _this.rootWindow.localStorage.removeItem("".concat(_this.prefix, "_").concat(_this.savedKeys[index]));
      });
      this.clearSavedKeys();
    }
  }, {
    key: "loadSavedKeys",
    value: function loadSavedKeys() {
      var keysJSON = this.rootWindow.localStorage.getItem("".concat(this.prefix, "__persistentStateKeys"));
      var keys = typeof keysJSON === "string" ? JSON.parse(keysJSON) : void 0;
      this.savedKeys = keys || [];
    }
  }, {
    key: "saveSavedKeys",
    value: function saveSavedKeys() {
      this.rootWindow.localStorage.setItem("".concat(this.prefix, "__persistentStateKeys"), JSON.stringify(this.savedKeys));
    }
  }, {
    key: "clearSavedKeys",
    value: function clearSavedKeys() {
      this.savedKeys.length = 0;
      this.saveSavedKeys();
    }
  }]);
  return Storage2;
}();

function _typeof$K(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$K = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$K = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$K(obj);
}
function _classCallCheck$1j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1e(Constructor, staticProps);
  return Constructor;
}
function _get$b(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$b = Reflect.get;
  } else {
    _get$b = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$b(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$b(target, property, receiver || target);
}
function _superPropBase$b(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$y(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$y(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$z(subClass, superClass);
}
function _setPrototypeOf$z(o, p) {
  _setPrototypeOf$z = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$z(o, p);
}
function _createSuper$y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$y(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$y(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$y(this, result);
  };
}
function _possibleConstructorReturn$y(self, call) {
  if (call && (_typeof$K(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$y(self);
}
function _assertThisInitialized$y(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$z() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$y(o) {
  _getPrototypeOf$y = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$y(o);
}
Hooks.getSingleton().register("persistentStateSave");
Hooks.getSingleton().register("persistentStateLoad");
Hooks.getSingleton().register("persistentStateReset");
var PLUGIN_KEY$1 = "persistentState";
var PLUGIN_PRIORITY = 0;
var PersistentState = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$y(PersistentState2, _BasePlugin);
  var _super = _createSuper$y(PersistentState2);
  function PersistentState2(hotInstance) {
    var _this;
    _classCallCheck$1j(this, PersistentState2);
    _this = _super.call(this, hotInstance);
    _this.storage = void 0;
    return _this;
  }
  _createClass$1e(PersistentState2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$1];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      if (!this.storage) {
        this.storage = new Storage(this.hot.rootElement.id, this.hot.rootWindow);
      }
      this.addHook("persistentStateSave", function(key, value) {
        return _this2.saveValue(key, value);
      });
      this.addHook("persistentStateLoad", function(key, saveTo) {
        return _this2.loadValue(key, saveTo);
      });
      this.addHook("persistentStateReset", function() {
        return _this2.resetValue();
      });
      _get$b(_getPrototypeOf$y(PersistentState2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.storage = void 0;
      _get$b(_getPrototypeOf$y(PersistentState2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$b(_getPrototypeOf$y(PersistentState2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "loadValue",
    value: function loadValue(key, saveTo) {
      saveTo.value = this.storage.loadValue(key);
    }
  }, {
    key: "saveValue",
    value: function saveValue(key, value) {
      this.storage.saveValue(key, value);
    }
  }, {
    key: "resetValue",
    value: function resetValue(key) {
      if (typeof key === "undefined") {
        this.storage.resetAll();
      } else {
        this.storage.reset(key);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$b(_getPrototypeOf$y(PersistentState2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$1;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY;
    }
  }]);
  return PersistentState2;
}(BasePlugin);

function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$1k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1f(Constructor, staticProps);
  return Constructor;
}
var SamplesGenerator = /* @__PURE__ */ function() {
  function SamplesGenerator2(dataFactory) {
    _classCallCheck$1k(this, SamplesGenerator2);
    this.samples = null;
    this.dataFactory = dataFactory;
    this.customSampleCount = null;
    this.allowDuplicates = false;
  }
  _createClass$1f(SamplesGenerator2, [{
    key: "getSampleCount",
    value: function getSampleCount() {
      if (this.customSampleCount) {
        return this.customSampleCount;
      }
      return SamplesGenerator2.SAMPLE_COUNT;
    }
  }, {
    key: "setSampleCount",
    value: function setSampleCount(sampleCount) {
      this.customSampleCount = sampleCount;
    }
  }, {
    key: "setAllowDuplicates",
    value: function setAllowDuplicates(allowDuplicates) {
      this.allowDuplicates = allowDuplicates;
    }
  }, {
    key: "generateRowSamples",
    value: function generateRowSamples(rowRange, colRange) {
      return this.generateSamples("row", colRange, rowRange);
    }
  }, {
    key: "generateColumnSamples",
    value: function generateColumnSamples(colRange, rowRange) {
      return this.generateSamples("col", rowRange, colRange);
    }
  }, {
    key: "generateSamples",
    value: function generateSamples(type, range, specifierRange) {
      var _this = this;
      var samples = new Map();
      var _ref = typeof specifierRange === "number" ? {
        from: specifierRange,
        to: specifierRange
      } : specifierRange, from = _ref.from, to = _ref.to;
      rangeEach(from, to, function(index) {
        var sample = _this.generateSample(type, range, index);
        samples.set(index, sample);
      });
      return samples;
    }
  }, {
    key: "generateSample",
    value: function generateSample(type, range, specifierValue) {
      var _this2 = this;
      if (type !== "row" && type !== "col") {
        throw new Error("Unsupported sample type");
      }
      var samples = new Map();
      var computedKey = type === "row" ? "col" : "row";
      var sampledValues = [];
      rangeEach(range.from, range.to, function(index) {
        var _ref2 = type === "row" ? _this2.dataFactory(specifierValue, index) : _this2.dataFactory(index, specifierValue), value = _ref2.value, bundleSeed = _ref2.bundleSeed;
        var hasCustomBundleSeed = typeof bundleSeed === "string" && bundleSeed.length > 0;
        var seed;
        if (hasCustomBundleSeed) {
          seed = bundleSeed;
        } else if (isObject(value)) {
          seed = "".concat(Object.keys(value).length);
        } else if (Array.isArray(value)) {
          seed = "".concat(value.length);
        } else {
          seed = "".concat(stringify(value).length);
        }
        if (!samples.has(seed)) {
          samples.set(seed, {
            needed: _this2.getSampleCount(),
            strings: []
          });
        }
        var sample = samples.get(seed);
        if (sample.needed) {
          var duplicate = sampledValues.indexOf(value) > -1;
          if (!duplicate || _this2.allowDuplicates || hasCustomBundleSeed) {
            sample.strings.push(_defineProperty$d({
              value
            }, computedKey, index));
            sampledValues.push(value);
            sample.needed -= 1;
          }
        }
      });
      return samples;
    }
  }], [{
    key: "SAMPLE_COUNT",
    get: function get() {
      return 3;
    }
  }]);
  return SamplesGenerator2;
}();

function _typeof$L(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$L = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$L = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$L(obj);
}
function _slicedToArray$f(arr, i) {
  return _arrayWithHoles$f(arr) || _iterableToArrayLimit$f(arr, i) || _unsupportedIterableToArray$p(arr, i) || _nonIterableRest$f();
}
function _nonIterableRest$f() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$p(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$p(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$p(o, minLen);
}
function _arrayLikeToArray$p(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$f(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$f(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1g(Constructor, staticProps);
  return Constructor;
}
function _get$c(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$c = Reflect.get;
  } else {
    _get$c = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$c(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$c(target, property, receiver || target);
}
function _superPropBase$c(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$z(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$z(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$A(subClass, superClass);
}
function _setPrototypeOf$A(o, p) {
  _setPrototypeOf$A = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$A(o, p);
}
function _createSuper$z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$A();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$z(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$z(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$z(this, result);
  };
}
function _possibleConstructorReturn$z(self, call) {
  if (call && (_typeof$L(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$z(self);
}
function _assertThisInitialized$z(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$A() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$z(o) {
  _getPrototypeOf$z = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$z(o);
}
Hooks.getSingleton().register("modifyAutoColumnSizeSeed");
var PLUGIN_KEY$2 = "autoColumnSize";
var PLUGIN_PRIORITY$1 = 10;
var privatePool$6 = new WeakMap();
var COLUMN_SIZE_MAP_NAME = "autoColumnSize";
var AutoColumnSize = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$z(AutoColumnSize2, _BasePlugin);
  var _super = _createSuper$z(AutoColumnSize2);
  function AutoColumnSize2(hotInstance) {
    var _this;
    _classCallCheck$1l(this, AutoColumnSize2);
    _this = _super.call(this, hotInstance);
    privatePool$6.set(_assertThisInitialized$z(_this), {
      cachedColumnHeaders: []
    });
    _this.ghostTable = new GhostTable(_this.hot);
    _this.samplesGenerator = new SamplesGenerator(function(row, column) {
      var cellMeta = _this.hot.getCellMeta(row, column);
      var cellValue = "";
      if (!cellMeta.spanned) {
        cellValue = _this.hot.getDataAtCell(row, column);
      }
      var bundleSeed = "";
      if (_this.hot.hasHook("modifyAutoColumnSizeSeed")) {
        bundleSeed = _this.hot.runHooks("modifyAutoColumnSizeSeed", bundleSeed, cellMeta, cellValue);
      }
      return {
        value: cellValue,
        bundleSeed
      };
    });
    _this.firstCalculation = true;
    _this.inProgress = false;
    _this.measuredColumns = 0;
    _this.columnWidthsMap = new PhysicalIndexToValueMap();
    _this.hot.columnIndexMapper.registerMap(COLUMN_SIZE_MAP_NAME, _this.columnWidthsMap);
    _this.addHook("beforeColumnResize", function(size, column, isDblClick) {
      return _this.onBeforeColumnResize(size, column, isDblClick);
    });
    return _this;
  }
  _createClass$1g(AutoColumnSize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$2] !== false && !this.hot.getSettings().colWidths;
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var setting = this.hot.getSettings()[PLUGIN_KEY$2];
      if (setting && setting.useHeaders !== null && setting.useHeaders !== void 0) {
        this.ghostTable.setSetting("useHeaders", setting.useHeaders);
      }
      this.setSamplingOptions();
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData();
      });
      this.addHook("beforeChange", function(changes) {
        return _this2.onBeforeChange(changes);
      });
      this.addHook("afterFormulasValuesUpdate", function(changes) {
        return _this2.onAfterFormulasValuesUpdate(changes);
      });
      this.addHook("beforeRender", function(force) {
        return _this2.onBeforeRender(force);
      });
      this.addHook("modifyColWidth", function(width, col) {
        return _this2.getColumnWidth(col, width);
      });
      this.addHook("afterInit", function() {
        return _this2.onAfterInit();
      });
      _get$c(_getPrototypeOf$z(AutoColumnSize2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var changedColumns = this.findColumnsWhereHeaderWasChanged();
      if (changedColumns.length) {
        this.clearCache(changedColumns);
        this.calculateVisibleColumnsWidth();
      }
      _get$c(_getPrototypeOf$z(AutoColumnSize2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      _get$c(_getPrototypeOf$z(AutoColumnSize2.prototype), "disablePlugin", this).call(this);
      this.addHook("beforeColumnResize", function(size, column, isDblClick) {
        return _this3.onBeforeColumnResize(size, column, isDblClick);
      });
    }
  }, {
    key: "calculateVisibleColumnsWidth",
    value: function calculateVisibleColumnsWidth() {
      var rowsCount = this.hot.countRows();
      if (!rowsCount) {
        return;
      }
      var force = this.hot.renderCall;
      var firstVisibleColumn = this.getFirstVisibleColumn();
      var lastVisibleColumn = this.getLastVisibleColumn();
      if (firstVisibleColumn === -1 || lastVisibleColumn === -1) {
        return;
      }
      this.calculateColumnsWidth({
        from: firstVisibleColumn,
        to: lastVisibleColumn
      }, void 0, force);
    }
  }, {
    key: "calculateColumnsWidth",
    value: function calculateColumnsWidth() {
      var _this4 = this;
      var colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countCols() - 1
      };
      var rowRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        from: 0,
        to: this.hot.countRows() - 1
      };
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var columnsRange = typeof colRange === "number" ? {
        from: colRange,
        to: colRange
      } : colRange;
      var rowsRange = typeof rowRange === "number" ? {
        from: rowRange,
        to: rowRange
      } : rowRange;
      rangeEach(columnsRange.from, columnsRange.to, function(visualColumn) {
        var physicalColumn = _this4.hot.toPhysicalColumn(visualColumn);
        if (physicalColumn === null) {
          physicalColumn = visualColumn;
        }
        if (force || _this4.columnWidthsMap.getValueAtIndex(physicalColumn) === null && !_this4.hot._getColWidthFromSettings(physicalColumn)) {
          var samples = _this4.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);
          arrayEach(samples, function(_ref) {
            var _ref2 = _slicedToArray$f(_ref, 2), column = _ref2[0], sample = _ref2[1];
            return _this4.ghostTable.addColumn(column, sample);
          });
        }
      });
      if (this.ghostTable.columns.length) {
        this.hot.batchExecution(function() {
          _this4.ghostTable.getWidths(function(visualColumn, width) {
            var physicalColumn = _this4.hot.toPhysicalColumn(visualColumn);
            _this4.columnWidthsMap.setValueAtIndex(physicalColumn, width);
          });
        }, true);
        this.measuredColumns = columnsRange.to + 1;
        this.ghostTable.clean();
      }
    }
  }, {
    key: "calculateAllColumnsWidth",
    value: function calculateAllColumnsWidth() {
      var _this5 = this;
      var rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countRows() - 1
      };
      var current = 0;
      var length = this.hot.countCols() - 1;
      var timer = null;
      this.inProgress = true;
      var loop = function loop2() {
        if (!_this5.hot) {
          cancelAnimationFrame(timer);
          _this5.inProgress = false;
          return;
        }
        _this5.calculateColumnsWidth({
          from: current,
          to: Math.min(current + AutoColumnSize2.CALCULATION_STEP, length)
        }, rowRange);
        current = current + AutoColumnSize2.CALCULATION_STEP + 1;
        if (current < length) {
          timer = requestAnimationFrame(loop2);
        } else {
          cancelAnimationFrame(timer);
          _this5.inProgress = false;
          _this5.hot.view.adjustElementsSize();
        }
      };
      var syncLimit = this.getSyncCalculationLimit();
      if (this.firstCalculation && syncLimit >= 0) {
        this.calculateColumnsWidth({
          from: 0,
          to: syncLimit
        }, rowRange);
        this.firstCalculation = false;
        current = syncLimit + 1;
      }
      if (current < length) {
        loop();
      } else {
        this.inProgress = false;
      }
    }
  }, {
    key: "setSamplingOptions",
    value: function setSamplingOptions() {
      var setting = this.hot.getSettings()[PLUGIN_KEY$2];
      var samplingRatio = setting && hasOwnProperty(setting, "samplingRatio") ? setting.samplingRatio : void 0;
      var allowSampleDuplicates = setting && hasOwnProperty(setting, "allowSampleDuplicates") ? setting.allowSampleDuplicates : void 0;
      if (samplingRatio && !isNaN(samplingRatio)) {
        this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
      }
      if (allowSampleDuplicates) {
        this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
      }
    }
  }, {
    key: "recalculateAllColumnsWidth",
    value: function recalculateAllColumnsWidth() {
      if (this.hot.view && this.hot.view.wt.wtTable.isVisible()) {
        this.clearCache();
        this.calculateAllColumnsWidth();
      }
    }
  }, {
    key: "getSyncCalculationLimit",
    value: function getSyncCalculationLimit() {
      var settings = this.hot.getSettings()[PLUGIN_KEY$2];
      var limit = AutoColumnSize2.SYNC_CALCULATION_LIMIT;
      var colsLimit = this.hot.countCols() - 1;
      if (isObject(settings)) {
        limit = settings.syncLimit;
        if (isPercentValue(limit)) {
          limit = valueAccordingPercent(colsLimit, limit);
        } else {
          limit >>= 0;
        }
      }
      return Math.min(limit, colsLimit);
    }
  }, {
    key: "getColumnWidth",
    value: function getColumnWidth(column) {
      var defaultWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      var keepMinimum = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var width = defaultWidth;
      if (width === void 0) {
        width = this.columnWidthsMap.getValueAtIndex(this.hot.toPhysicalColumn(column));
        if (keepMinimum && typeof width === "number") {
          width = Math.max(width, ViewportColumnsCalculator.DEFAULT_WIDTH);
        }
      }
      return width;
    }
  }, {
    key: "getFirstVisibleColumn",
    value: function getFirstVisibleColumn() {
      var wot = this.hot.view.wt;
      if (wot.wtViewport.columnsVisibleCalculator) {
        var firstFullyVisibleColumn = wot.wtTable.getFirstVisibleColumn();
        if (firstFullyVisibleColumn !== -1) {
          return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstFullyVisibleColumn);
        }
      }
      if (wot.wtViewport.columnsRenderCalculator) {
        var firstRenderedColumn = wot.wtTable.getFirstRenderedColumn();
        if (firstRenderedColumn !== -1) {
          return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstRenderedColumn);
        }
      }
      return -1;
    }
  }, {
    key: "getLastVisibleColumn",
    value: function getLastVisibleColumn() {
      var wot = this.hot.view.wt;
      if (wot.wtViewport.columnsVisibleCalculator) {
        var lastFullyVisibleColumn = wot.wtTable.getLastVisibleColumn();
        if (lastFullyVisibleColumn !== -1) {
          return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastFullyVisibleColumn);
        }
      }
      if (wot.wtViewport.columnsRenderCalculator) {
        var lastRenderedColumn = wot.wtTable.getLastRenderedColumn();
        if (lastRenderedColumn !== -1) {
          return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastRenderedColumn);
        }
      }
      return -1;
    }
  }, {
    key: "findColumnsWhereHeaderWasChanged",
    value: function findColumnsWhereHeaderWasChanged() {
      var columnHeaders = this.hot.getColHeader();
      var _privatePool$get = privatePool$6.get(this), cachedColumnHeaders = _privatePool$get.cachedColumnHeaders;
      var changedColumns = arrayReduce(columnHeaders, function(acc, columnTitle, physicalColumn) {
        var cachedColumnsLength = cachedColumnHeaders.length;
        if (cachedColumnsLength - 1 < physicalColumn || cachedColumnHeaders[physicalColumn] !== columnTitle) {
          acc.push(physicalColumn);
        }
        if (cachedColumnsLength - 1 < physicalColumn) {
          cachedColumnHeaders.push(columnTitle);
        } else {
          cachedColumnHeaders[physicalColumn] = columnTitle;
        }
        return acc;
      }, []);
      return changedColumns;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      var _this6 = this;
      var columns = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (columns.length) {
        this.hot.batchExecution(function() {
          arrayEach(columns, function(physicalIndex) {
            _this6.columnWidthsMap.setValueAtIndex(physicalIndex, null);
          });
        }, true);
      } else {
        this.columnWidthsMap.clear();
      }
    }
  }, {
    key: "isNeedRecalculate",
    value: function isNeedRecalculate() {
      return !!arrayFilter(this.columnWidthsMap.getValues().slice(0, this.measuredColumns), function(item) {
        return item === null;
      }).length;
    }
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender() {
      this.calculateVisibleColumnsWidth();
      if (this.isNeedRecalculate() && !this.inProgress) {
        this.calculateAllColumnsWidth();
      }
    }
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      var _this7 = this;
      if (this.hot.view) {
        this.recalculateAllColumnsWidth();
      } else {
        setTimeout(function() {
          if (_this7.hot) {
            _this7.recalculateAllColumnsWidth();
          }
        }, 0);
      }
    }
  }, {
    key: "onBeforeChange",
    value: function onBeforeChange(changes) {
      var _this8 = this;
      var changedColumns = arrayMap(changes, function(_ref3) {
        var _ref4 = _slicedToArray$f(_ref3, 2), columnProperty = _ref4[1];
        return _this8.hot.toPhysicalColumn(_this8.hot.propToCol(columnProperty));
      });
      this.clearCache(Array.from(new Set(changedColumns)));
    }
  }, {
    key: "onBeforeColumnResize",
    value: function onBeforeColumnResize(size, column, isDblClick) {
      var newSize = size;
      if (isDblClick) {
        this.calculateColumnsWidth(column, void 0, true);
        newSize = this.getColumnWidth(column, void 0, false);
      }
      return newSize;
    }
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      privatePool$6.get(this).cachedColumnHeaders = this.hot.getColHeader();
    }
  }, {
    key: "onAfterFormulasValuesUpdate",
    value: function onAfterFormulasValuesUpdate(changes) {
      var filteredChanges = arrayFilter(changes, function(change) {
        var _change$address;
        return isDefined((_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.col);
      });
      var changedColumns = arrayMap(filteredChanges, function(change) {
        return change.address.col;
      });
      this.clearCache(Array.from(new Set(changedColumns)));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.ghostTable.clean();
      _get$c(_getPrototypeOf$z(AutoColumnSize2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$2;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$1;
    }
  }, {
    key: "CALCULATION_STEP",
    get: function get() {
      return 50;
    }
  }, {
    key: "SYNC_CALCULATION_LIMIT",
    get: function get() {
      return 50;
    }
  }]);
  return AutoColumnSize2;
}(BasePlugin);

var DIRECTIONS = {
  horizontal: "horizontal",
  vertical: "vertical"
};
function getDeltas(start, end, data, direction) {
  var rowsLength = data.length;
  var columnsLength = data ? data[0].length : 0;
  var deltas = [];
  var diffRow = end.row - start.row;
  var diffCol = end.col - start.col;
  if (["down", "up"].indexOf(direction) !== -1) {
    var arr = [];
    for (var col = 0; col < diffCol; col++) {
      var startValue = parseInt(data[0][col], 10);
      var endValue = parseInt(data[rowsLength - 1][col], 10);
      var delta = (direction === "down" ? endValue - startValue : startValue - endValue) / (rowsLength - 1) || 0;
      arr.push(delta);
    }
    deltas.push(arr);
  }
  if (["right", "left"].indexOf(direction) !== -1) {
    for (var row = 0; row < diffRow; row++) {
      var _startValue = parseInt(data[row][0], 10);
      var _endValue = parseInt(data[row][columnsLength - 1], 10);
      var _delta = (direction === "right" ? _endValue - _startValue : _startValue - _endValue) / (columnsLength - 1) || 0;
      deltas.push([_delta]);
    }
  }
  return deltas;
}
function getDragDirectionAndRange(startSelection, endSelection) {
  var startOfDragCoords;
  var endOfDragCoords;
  var directionOfDrag;
  if (endSelection[0] === startSelection[0] && endSelection[1] < startSelection[1]) {
    directionOfDrag = "left";
    startOfDragCoords = new CellCoords(endSelection[0], endSelection[1]);
    endOfDragCoords = new CellCoords(endSelection[2], startSelection[1] - 1);
  } else if (endSelection[2] === startSelection[2] && endSelection[0] === startSelection[0] && endSelection[3] > startSelection[3]) {
    directionOfDrag = "right";
    startOfDragCoords = new CellCoords(endSelection[0], startSelection[3] + 1);
    endOfDragCoords = new CellCoords(endSelection[2], endSelection[3]);
  } else if (endSelection[0] < startSelection[0] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "up";
    startOfDragCoords = new CellCoords(endSelection[0], endSelection[1]);
    endOfDragCoords = new CellCoords(startSelection[0] - 1, endSelection[3]);
  } else if (endSelection[2] > startSelection[2] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "down";
    startOfDragCoords = new CellCoords(startSelection[2] + 1, endSelection[1]);
    endOfDragCoords = new CellCoords(endSelection[2], endSelection[3]);
  }
  if (startOfDragCoords) {
    startOfDragCoords.normalize();
  }
  if (endOfDragCoords) {
    endOfDragCoords.normalize();
  }
  return {
    directionOfDrag,
    startOfDragCoords,
    endOfDragCoords
  };
}
function getMappedFillHandleSetting(fillHandle) {
  var mappedSettings = {};
  if (fillHandle === true) {
    mappedSettings.directions = Object.keys(DIRECTIONS);
    mappedSettings.autoInsertRow = true;
  } else if (isObject(fillHandle)) {
    if (isDefined(fillHandle.autoInsertRow)) {
      if (fillHandle.direction === DIRECTIONS.horizontal) {
        mappedSettings.autoInsertRow = false;
      } else {
        mappedSettings.autoInsertRow = fillHandle.autoInsertRow;
      }
    } else {
      mappedSettings.autoInsertRow = false;
    }
    if (isDefined(fillHandle.direction)) {
      mappedSettings.directions = [fillHandle.direction];
    } else {
      mappedSettings.directions = Object.keys(DIRECTIONS);
    }
  } else if (typeof fillHandle === "string") {
    mappedSettings.directions = [fillHandle];
    mappedSettings.autoInsertRow = true;
  } else {
    mappedSettings.directions = [];
    mappedSettings.autoInsertRow = false;
  }
  return mappedSettings;
}

function _typeof$M(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$M = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$M = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$M(obj);
}
function _toConsumableArray$i(arr) {
  return _arrayWithoutHoles$g(arr) || _iterableToArray$g(arr) || _unsupportedIterableToArray$q(arr) || _nonIterableSpread$g();
}
function _nonIterableSpread$g() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$g(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$g(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$q(arr);
}
function _slicedToArray$g(arr, i) {
  return _arrayWithHoles$g(arr) || _iterableToArrayLimit$g(arr, i) || _unsupportedIterableToArray$q(arr, i) || _nonIterableRest$g();
}
function _nonIterableRest$g() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$q(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$q(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$q(o, minLen);
}
function _arrayLikeToArray$q(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$g(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$g(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1h(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1h(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1h(Constructor, staticProps);
  return Constructor;
}
function _get$d(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$d = Reflect.get;
  } else {
    _get$d = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$d(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$d(target, property, receiver || target);
}
function _superPropBase$d(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$A(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$A(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$B(subClass, superClass);
}
function _setPrototypeOf$B(o, p) {
  _setPrototypeOf$B = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$B(o, p);
}
function _createSuper$A(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$B();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$A(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$A(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$A(this, result);
  };
}
function _possibleConstructorReturn$A(self, call) {
  if (call && (_typeof$M(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$A(self);
}
function _assertThisInitialized$A(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$B() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$A(o) {
  _getPrototypeOf$A = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$A(o);
}
Hooks.getSingleton().register("modifyAutofillRange");
Hooks.getSingleton().register("beforeAutofill");
Hooks.getSingleton().register("afterAutofill");
var PLUGIN_KEY$3 = "autofill";
var PLUGIN_PRIORITY$2 = 20;
var INSERT_ROW_ALTER_ACTION_NAME = "insert_row";
var INTERVAL_FOR_ADDING_ROW = 200;
var Autofill = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$A(Autofill2, _BasePlugin);
  var _super = _createSuper$A(Autofill2);
  function Autofill2(hotInstance) {
    var _this;
    _classCallCheck$1m(this, Autofill2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager(_assertThisInitialized$A(_this));
    _this.addingStarted = false;
    _this.mouseDownOnCellCorner = false;
    _this.mouseDragOutside = false;
    _this.handleDraggedCells = 0;
    _this.directions = [];
    _this.autoInsertRow = false;
    return _this;
  }
  _createClass$1h(Autofill2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().fillHandle;
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.mapSettings();
      this.registerEvents();
      this.addHook("afterOnCellCornerMouseDown", function(event) {
        return _this2.onAfterCellCornerMouseDown(event);
      });
      this.addHook("afterOnCellCornerDblClick", function(event) {
        return _this2.onCellCornerDblClick(event);
      });
      this.addHook("beforeOnCellMouseOver", function(_, coords) {
        return _this2.onBeforeCellMouseOver(coords);
      });
      _get$d(_getPrototypeOf$A(Autofill2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$d(_getPrototypeOf$A(Autofill2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.clearMappedSettings();
      _get$d(_getPrototypeOf$A(Autofill2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "getSelectionData",
    value: function getSelectionData() {
      var _this3 = this;
      var selection = this.hot.getSelectedRangeLast();
      var _selection$getTopLeft = selection.getTopLeftCorner(), startRow = _selection$getTopLeft.row, startCol = _selection$getTopLeft.col;
      var _selection$getBottomR = selection.getBottomRightCorner(), endRow = _selection$getBottomR.row, endCol = _selection$getBottomR.col;
      var copyableRanges = this.hot.runHooks("modifyCopyableRange", [{
        startRow,
        startCol,
        endRow,
        endCol
      }]);
      var copyableRows = [];
      var copyableColumns = [];
      var data = [];
      arrayEach(copyableRanges, function(range) {
        for (var visualRow = range.startRow; visualRow <= range.endRow; visualRow += 1) {
          if (copyableRows.indexOf(visualRow) === -1) {
            copyableRows.push(visualRow);
          }
        }
        for (var visualColumn = range.startCol; visualColumn <= range.endCol; visualColumn += 1) {
          if (copyableColumns.indexOf(visualColumn) === -1) {
            copyableColumns.push(visualColumn);
          }
        }
      });
      arrayEach(copyableRows, function(row) {
        var rowSet = [];
        arrayEach(copyableColumns, function(column) {
          rowSet.push(_this3.hot.getCopyableData(row, column));
        });
        data.push(rowSet);
      });
      return data;
    }
  }, {
    key: "fillIn",
    value: function fillIn() {
      if (this.hot.selection.highlight.getFill().isEmpty()) {
        return false;
      }
      var _this$hot$selection$h = this.hot.selection.highlight.getFill().getVisualCorners(), _this$hot$selection$h2 = _slicedToArray$g(_this$hot$selection$h, 4), fillStartRow = _this$hot$selection$h2[0], fillStartColumn = _this$hot$selection$h2[1], fillEndRow = _this$hot$selection$h2[2], fillEndColumn = _this$hot$selection$h2[3];
      var selectionRangeLast = this.hot.getSelectedRangeLast();
      var topLeftCorner = selectionRangeLast.getTopLeftCorner();
      var bottomRightCorner = selectionRangeLast.getBottomRightCorner();
      this.resetSelectionOfDraggedArea();
      var cornersOfSelectedCells = [topLeftCorner.row, topLeftCorner.col, bottomRightCorner.row, bottomRightCorner.col];
      var cornersOfSelectionAndDragAreas = this.hot.runHooks("modifyAutofillRange", [Math.min(topLeftCorner.row, fillStartRow), Math.min(topLeftCorner.col, fillStartColumn), Math.max(bottomRightCorner.row, fillEndRow), Math.max(bottomRightCorner.col, fillEndColumn)], cornersOfSelectedCells);
      var _getDragDirectionAndR = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas), directionOfDrag = _getDragDirectionAndR.directionOfDrag, startOfDragCoords = _getDragDirectionAndR.startOfDragCoords, endOfDragCoords = _getDragDirectionAndR.endOfDragCoords;
      if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {
        var selectionData = this.getSelectionData();
        var sourceRange = selectionRangeLast.clone();
        var targetRange = new CellRange(startOfDragCoords, startOfDragCoords, endOfDragCoords);
        var beforeAutofillHookResult = this.hot.runHooks("beforeAutofill", selectionData, sourceRange, targetRange, directionOfDrag);
        if (beforeAutofillHookResult === false) {
          this.hot.selection.highlight.getFill().clear();
          this.hot.render();
          return false;
        }
        var sourceFrom = sourceRange.from, sourceTo = sourceRange.to;
        var refData = this.hot.getData(sourceFrom.row, sourceFrom.col, sourceTo.row, sourceTo.col);
        var hasFillDataChanged = !isObjectEqual(refData, beforeAutofillHookResult);
        var deltas = getDeltas(startOfDragCoords, endOfDragCoords, selectionData, directionOfDrag);
        var fillData = beforeAutofillHookResult;
        var res = beforeAutofillHookResult;
        if (["up", "left"].indexOf(directionOfDrag) > -1 && !(res.length === 1 && res[0].length === 0)) {
          fillData = [];
          if (directionOfDrag === "up") {
            var dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;
            var fillOffset = dragLength % res.length;
            for (var i = 0; i < dragLength; i++) {
              fillData.push(res[(i + (res.length - fillOffset)) % res.length]);
            }
          } else {
            var _dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;
            var _fillOffset = _dragLength % res[0].length;
            for (var _i2 = 0; _i2 < res.length; _i2++) {
              fillData.push([]);
              for (var j = 0; j < _dragLength; j++) {
                fillData[_i2].push(res[_i2][(j + (res[_i2].length - _fillOffset)) % res[_i2].length]);
              }
            }
          }
        }
        this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, "".concat(this.pluginName, ".fill"), null, directionOfDrag, deltas);
        this.setSelection(cornersOfSelectionAndDragAreas);
        this.hot.runHooks("afterAutofill", fillData, sourceRange, targetRange, directionOfDrag, hasFillDataChanged);
        this.hot.render();
      } else {
        this.hot._refreshBorders();
      }
      return true;
    }
  }, {
    key: "reduceSelectionAreaIfNeeded",
    value: function reduceSelectionAreaIfNeeded(coords) {
      if (coords.row < 0) {
        coords.row = 0;
      }
      if (coords.col < 0) {
        coords.col = 0;
      }
      return coords;
    }
  }, {
    key: "getCoordsOfDragAndDropBorders",
    value: function getCoordsOfDragAndDropBorders(coordsOfSelection) {
      var currentSelection = this.hot.getSelectedRangeLast();
      var bottomRightCorner = currentSelection.getBottomRightCorner();
      var coords = coordsOfSelection;
      if (this.directions.includes(DIRECTIONS.vertical) && this.directions.includes(DIRECTIONS.horizontal)) {
        var topLeftCorner = currentSelection.getTopLeftCorner();
        if (bottomRightCorner.col <= coordsOfSelection.col || topLeftCorner.col >= coordsOfSelection.col) {
          coords = new CellCoords(bottomRightCorner.row, coordsOfSelection.col);
        }
        if (bottomRightCorner.row < coordsOfSelection.row || topLeftCorner.row > coordsOfSelection.row) {
          coords = new CellCoords(coordsOfSelection.row, bottomRightCorner.col);
        }
      } else if (this.directions.includes(DIRECTIONS.vertical)) {
        coords = new CellCoords(coordsOfSelection.row, bottomRightCorner.col);
      } else if (this.directions.includes(DIRECTIONS.horizontal)) {
        coords = new CellCoords(bottomRightCorner.row, coordsOfSelection.col);
      } else {
        return;
      }
      return this.reduceSelectionAreaIfNeeded(coords);
    }
  }, {
    key: "showBorder",
    value: function showBorder(coordsOfSelection) {
      var coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);
      if (coordsOfDragAndDropBorders) {
        this.redrawBorders(coordsOfDragAndDropBorders);
      }
    }
  }, {
    key: "addRow",
    value: function addRow() {
      var _this4 = this;
      this.hot._registerTimeout(function() {
        _this4.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, void 0, 1, "".concat(_this4.pluginName, ".fill"));
        _this4.addingStarted = false;
      }, INTERVAL_FOR_ADDING_ROW);
    }
  }, {
    key: "addNewRowIfNeeded",
    value: function addNewRowIfNeeded() {
      if (!this.hot.selection.highlight.getFill().isEmpty() && this.addingStarted === false && this.autoInsertRow) {
        var cornersOfSelectedCells = this.hot.getSelectedLast();
        var cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getVisualCorners();
        var nrOfTableRows = this.hot.countRows();
        if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {
          this.addingStarted = true;
          this.addRow();
        }
      }
    }
  }, {
    key: "getIndexOfLastAdjacentFilledInRow",
    value: function getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {
      var data = this.hot.getData();
      var nrOfTableRows = this.hot.countRows();
      var lastFilledInRowIndex;
      for (var rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {
        for (var columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {
          var dataInCell = data[rowIndex][columnIndex];
          if (dataInCell) {
            return -1;
          }
        }
        var dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];
        var dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];
        if (!!dataInNextLeftCell || !!dataInNextRightCell) {
          lastFilledInRowIndex = rowIndex;
        }
      }
      return lastFilledInRowIndex;
    }
  }, {
    key: "addSelectionFromStartAreaToSpecificRowIndex",
    value: function addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {
      this.hot.selection.highlight.getFill().clear().add(new CellCoords(selectStartArea[0], selectStartArea[1])).add(new CellCoords(rowIndex, selectStartArea[3])).commit();
    }
  }, {
    key: "setSelection",
    value: function setSelection(cornersOfArea) {
      var _this$hot;
      (_this$hot = this.hot).selectCell.apply(_this$hot, _toConsumableArray$i(arrayMap(cornersOfArea, function(index) {
        return Math.max(index, 0);
      })).concat([false, false]));
    }
  }, {
    key: "selectAdjacent",
    value: function selectAdjacent() {
      var cornersOfSelectedCells = this.hot.getSelectedLast();
      var lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);
      if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === void 0) {
        return false;
      }
      this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);
      return true;
    }
  }, {
    key: "resetSelectionOfDraggedArea",
    value: function resetSelectionOfDraggedArea() {
      this.handleDraggedCells = 0;
      this.hot.selection.highlight.getFill().clear();
    }
  }, {
    key: "redrawBorders",
    value: function redrawBorders(coords) {
      this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords).commit();
      this.hot.view.render();
    }
  }, {
    key: "getIfMouseWasDraggedOutside",
    value: function getIfMouseWasDraggedOutside(event) {
      var documentElement = this.hot.rootDocument.documentElement;
      var tableBottom = offset$1(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);
      var tableRight = offset$1(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);
      return event.clientY > tableBottom && event.clientX <= tableRight;
    }
  }, {
    key: "registerEvents",
    value: function registerEvents() {
      var _this5 = this;
      var documentElement = this.hot.rootDocument.documentElement;
      this.eventManager.addEventListener(documentElement, "mouseup", function() {
        return _this5.onMouseUp();
      });
      this.eventManager.addEventListener(documentElement, "mousemove", function(event) {
        return _this5.onMouseMove(event);
      });
    }
  }, {
    key: "onCellCornerDblClick",
    value: function onCellCornerDblClick() {
      var selectionApplied = this.selectAdjacent();
      if (selectionApplied) {
        this.fillIn();
      }
    }
  }, {
    key: "onAfterCellCornerMouseDown",
    value: function onAfterCellCornerMouseDown() {
      this.handleDraggedCells = 1;
      this.mouseDownOnCellCorner = true;
    }
  }, {
    key: "onBeforeCellMouseOver",
    value: function onBeforeCellMouseOver(coords) {
      if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {
        this.handleDraggedCells += 1;
        this.showBorder(coords);
        this.addNewRowIfNeeded();
      }
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp() {
      if (this.handleDraggedCells) {
        if (this.handleDraggedCells > 1) {
          this.fillIn();
        }
        this.handleDraggedCells = 0;
        this.mouseDownOnCellCorner = false;
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event);
      if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {
        this.mouseDragOutside = true;
        this.addingStarted = true;
      } else {
        this.mouseDragOutside = false;
      }
      if (this.mouseDragOutside && this.autoInsertRow) {
        this.addRow();
      }
    }
  }, {
    key: "clearMappedSettings",
    value: function clearMappedSettings() {
      this.directions.length = 0;
      this.autoInsertRow = false;
    }
  }, {
    key: "mapSettings",
    value: function mapSettings() {
      var mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);
      this.directions = mappedSettings.directions;
      this.autoInsertRow = mappedSettings.autoInsertRow;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$d(_getPrototypeOf$A(Autofill2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$3;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$2;
    }
  }]);
  return Autofill2;
}(BasePlugin);

function _typeof$N(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$N = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$N = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$N(obj);
}
function _classCallCheck$1n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1i(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1i(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1i(Constructor, staticProps);
  return Constructor;
}
function _get$e(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$e = Reflect.get;
  } else {
    _get$e = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$e(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$e(target, property, receiver || target);
}
function _superPropBase$e(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$B(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$B(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$C(subClass, superClass);
}
function _setPrototypeOf$C(o, p) {
  _setPrototypeOf$C = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$C(o, p);
}
function _createSuper$B(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$C();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$B(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$B(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$B(this, result);
  };
}
function _possibleConstructorReturn$B(self, call) {
  if (call && (_typeof$N(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$B(self);
}
function _assertThisInitialized$B(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$C() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$B(o) {
  _getPrototypeOf$B = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$B(o);
}
var PLUGIN_KEY$4 = "manualRowResize";
var PLUGIN_PRIORITY$3 = 30;
var PERSISTENT_STATE_KEY = "manualRowHeights";
var privatePool$7 = new WeakMap();
var ManualRowResize = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$B(ManualRowResize2, _BasePlugin);
  var _super = _createSuper$B(ManualRowResize2);
  function ManualRowResize2(hotInstance) {
    var _this;
    _classCallCheck$1n(this, ManualRowResize2);
    _this = _super.call(this, hotInstance);
    var rootDocument = _this.hot.rootDocument;
    _this.currentTH = null;
    _this.currentRow = null;
    _this.selectedRows = [];
    _this.currentHeight = null;
    _this.newSize = null;
    _this.startY = null;
    _this.startHeight = null;
    _this.startOffset = null;
    _this.handle = rootDocument.createElement("DIV");
    _this.guide = rootDocument.createElement("DIV");
    _this.eventManager = new EventManager(_assertThisInitialized$B(_this));
    _this.pressed = null;
    _this.dblclick = 0;
    _this.autoresizeTimeout = null;
    _this.rowHeightsMap = void 0;
    privatePool$7.set(_assertThisInitialized$B(_this), {
      config: void 0
    });
    addClass(_this.handle, "manualRowResizer");
    addClass(_this.guide, "manualRowResizerGuide");
    return _this;
  }
  _createClass$1i(ManualRowResize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$4];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.rowHeightsMap = new PhysicalIndexToValueMap();
      this.rowHeightsMap.addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      this.hot.rowIndexMapper.registerMap(this.pluginName, this.rowHeightsMap);
      this.addHook("modifyRowHeight", function(height, row) {
        return _this2.onModifyRowHeight(height, row);
      });
      this.bindEvents();
      _get$e(_getPrototypeOf$B(ManualRowResize2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$e(_getPrototypeOf$B(ManualRowResize2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var priv = privatePool$7.get(this);
      priv.config = this.rowHeightsMap.getValues();
      this.hot.rowIndexMapper.unregisterMap(this.pluginName);
      _get$e(_getPrototypeOf$B(ManualRowResize2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "saveManualRowHeights",
    value: function saveManualRowHeights() {
      this.hot.runHooks("persistentStateSave", PERSISTENT_STATE_KEY, this.rowHeightsMap.getValues());
    }
  }, {
    key: "loadManualRowHeights",
    value: function loadManualRowHeights() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", PERSISTENT_STATE_KEY, storedState);
      return storedState.value;
    }
  }, {
    key: "setManualSize",
    value: function setManualSize(row, height) {
      var physicalRow = this.hot.toPhysicalRow(row);
      var newHeight = Math.max(height, ViewportRowsCalculator.DEFAULT_HEIGHT);
      this.rowHeightsMap.setValueAtIndex(physicalRow, newHeight);
      return newHeight;
    }
  }, {
    key: "setupHandlePosition",
    value: function setupHandlePosition(TH) {
      var _this3 = this;
      this.currentTH = TH;
      var view = this.hot.view;
      var wt = view.wt;
      var cellCoords = view.wt.wtTable.getCoords(this.currentTH);
      var row = cellCoords.row;
      if (row < 0) {
        return;
      }
      var headerWidth = outerWidth(this.currentTH);
      var box = this.currentTH.getBoundingClientRect();
      var fixedRowTop = row < wt.getSetting("fixedRowsTop");
      var fixedRowBottom = row >= view.countNotHiddenRowIndexes(0, 1) - wt.getSetting("fixedRowsBottom");
      var relativeHeaderPosition;
      if (fixedRowTop) {
        relativeHeaderPosition = wt.wtOverlays.topLeftCornerOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      } else if (fixedRowBottom) {
        relativeHeaderPosition = wt.wtOverlays.bottomLeftCornerOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      }
      if (!relativeHeaderPosition) {
        relativeHeaderPosition = wt.wtOverlays.leftOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      }
      this.currentRow = this.hot.rowIndexMapper.getVisualFromRenderableIndex(row);
      this.selectedRows = [];
      var isFullRowSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByRowHeader();
      if (this.hot.selection.isSelected() && isFullRowSelected) {
        var selectionRanges = this.hot.getSelectedRange();
        arrayEach(selectionRanges, function(selectionRange) {
          var fromRow = selectionRange.getTopLeftCorner().row;
          var toRow = selectionRange.getBottomLeftCorner().row;
          rangeEach(fromRow, toRow, function(rowIndex) {
            if (!_this3.selectedRows.includes(rowIndex)) {
              _this3.selectedRows.push(rowIndex);
            }
          });
        });
      }
      if (!this.selectedRows.includes(this.currentRow)) {
        this.selectedRows = [this.currentRow];
      }
      this.startOffset = relativeHeaderPosition.top - 6;
      this.startHeight = parseInt(box.height, 10);
      this.handle.style.top = "".concat(this.startOffset + this.startHeight, "px");
      this.handle.style.left = "".concat(relativeHeaderPosition.left, "px");
      this.handle.style.width = "".concat(headerWidth, "px");
      this.hot.rootElement.appendChild(this.handle);
    }
  }, {
    key: "refreshHandlePosition",
    value: function refreshHandlePosition() {
      this.handle.style.top = "".concat(this.startOffset + this.currentHeight, "px");
    }
  }, {
    key: "setupGuidePosition",
    value: function setupGuidePosition() {
      var handleWidth = parseInt(outerWidth(this.handle), 10);
      var handleRightPosition = parseInt(this.handle.style.left, 10) + handleWidth;
      var maximumVisibleElementWidth = parseInt(this.hot.view.maximumVisibleElementWidth(0), 10);
      addClass(this.handle, "active");
      addClass(this.guide, "active");
      this.guide.style.top = this.handle.style.top;
      this.guide.style.left = "".concat(handleRightPosition, "px");
      this.guide.style.width = "".concat(maximumVisibleElementWidth - handleWidth, "px");
      this.hot.rootElement.appendChild(this.guide);
    }
  }, {
    key: "refreshGuidePosition",
    value: function refreshGuidePosition() {
      this.guide.style.top = this.handle.style.top;
    }
  }, {
    key: "hideHandleAndGuide",
    value: function hideHandleAndGuide() {
      removeClass(this.handle, "active");
      removeClass(this.guide, "active");
    }
  }, {
    key: "checkIfRowHeader",
    value: function checkIfRowHeader(element) {
      var _element$parentNode, _element$parentNode$p;
      var thElement = closest(element, ["TH"], this.hot.rootElement);
      return thElement && ((_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 ? void 0 : (_element$parentNode$p = _element$parentNode.parentNode) === null || _element$parentNode$p === void 0 ? void 0 : _element$parentNode$p.tagName) === "TBODY";
    }
  }, {
    key: "getClosestTHParent",
    value: function getClosestTHParent(element) {
      if (element.tagName !== "TABLE") {
        if (element.tagName === "TH") {
          return element;
        }
        return this.getClosestTHParent(element.parentNode);
      }
      return null;
    }
  }, {
    key: "getActualRowHeight",
    value: function getActualRowHeight(row) {
      var walkontableHeight = this.hot.view.wt.wtTable.getRowHeight(row);
      if (walkontableHeight !== void 0 && this.newSize < walkontableHeight) {
        return walkontableHeight;
      }
      return this.newSize;
    }
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event) {
      if (isDetached(event.target)) {
        return;
      }
      if (this.checkIfRowHeader(event.target)) {
        var th = this.getClosestTHParent(event.target);
        if (th) {
          if (!this.pressed) {
            this.setupHandlePosition(th);
          }
        }
      }
    }
  }, {
    key: "afterMouseDownTimeout",
    value: function afterMouseDownTimeout() {
      var _this4 = this;
      var render = function render2() {
        _this4.hot.forceFullRender = true;
        _this4.hot.view.render();
        _this4.hot.view.adjustElementsSize(true);
      };
      var resize = function resize2(row, forceRender) {
        var hookNewSize = _this4.hot.runHooks("beforeRowResize", _this4.getActualRowHeight(row), row, true);
        if (hookNewSize !== void 0) {
          _this4.newSize = hookNewSize;
        }
        _this4.setManualSize(row, _this4.newSize);
        _this4.hot.runHooks("afterRowResize", _this4.getActualRowHeight(row), row, true);
        if (forceRender) {
          render();
        }
      };
      if (this.dblclick >= 2) {
        var selectedRowsLength = this.selectedRows.length;
        if (selectedRowsLength > 1) {
          arrayEach(this.selectedRows, function(selectedRow) {
            resize(selectedRow);
          });
          render();
        } else {
          arrayEach(this.selectedRows, function(selectedRow) {
            resize(selectedRow, true);
          });
        }
      }
      this.dblclick = 0;
      this.autoresizeTimeout = null;
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      var _this5 = this;
      if (hasClass(event.target, "manualRowResizer")) {
        this.setupHandlePosition(this.currentTH);
        this.setupGuidePosition();
        this.pressed = true;
        if (this.autoresizeTimeout === null) {
          this.autoresizeTimeout = setTimeout(function() {
            return _this5.afterMouseDownTimeout();
          }, 500);
          this.hot._registerTimeout(this.autoresizeTimeout);
        }
        this.dblclick += 1;
        this.startY = event.pageY;
        this.newSize = this.startHeight;
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var _this6 = this;
      if (this.pressed) {
        this.currentHeight = this.startHeight + (event.pageY - this.startY);
        arrayEach(this.selectedRows, function(selectedRow) {
          _this6.newSize = _this6.setManualSize(selectedRow, _this6.currentHeight);
        });
        this.refreshHandlePosition();
        this.refreshGuidePosition();
      }
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp() {
      var _this7 = this;
      var render = function render2() {
        _this7.hot.forceFullRender = true;
        _this7.hot.view.render();
        _this7.hot.view.adjustElementsSize(true);
      };
      var runHooks = function runHooks2(row, forceRender) {
        _this7.hot.runHooks("beforeRowResize", _this7.getActualRowHeight(row), row, false);
        if (forceRender) {
          render();
        }
        _this7.saveManualRowHeights();
        _this7.hot.runHooks("afterRowResize", _this7.getActualRowHeight(row), row, false);
      };
      if (this.pressed) {
        this.hideHandleAndGuide();
        this.pressed = false;
        if (this.newSize !== this.startHeight) {
          var selectedRowsLength = this.selectedRows.length;
          if (selectedRowsLength > 1) {
            arrayEach(this.selectedRows, function(selectedRow) {
              runHooks(selectedRow);
            });
            render();
          } else {
            arrayEach(this.selectedRows, function(selectedRow) {
              runHooks(selectedRow, true);
            });
          }
        }
        this.setupHandlePosition(this.currentTH);
      }
    }
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      var _this8 = this;
      var _this$hot = this.hot, rootElement = _this$hot.rootElement, rootWindow = _this$hot.rootWindow;
      this.eventManager.addEventListener(rootElement, "mouseover", function(e) {
        return _this8.onMouseOver(e);
      });
      this.eventManager.addEventListener(rootElement, "mousedown", function(e) {
        return _this8.onMouseDown(e);
      });
      this.eventManager.addEventListener(rootWindow, "mousemove", function(e) {
        return _this8.onMouseMove(e);
      });
      this.eventManager.addEventListener(rootWindow, "mouseup", function() {
        return _this8.onMouseUp();
      });
    }
  }, {
    key: "onModifyRowHeight",
    value: function onModifyRowHeight(height, row) {
      var newHeight = height;
      if (this.enabled) {
        var physicalRow = this.hot.toPhysicalRow(row);
        var rowHeight = this.rowHeightsMap.getValueAtIndex(physicalRow);
        if (this.hot.getSettings()[PLUGIN_KEY$4] && rowHeight) {
          newHeight = rowHeight;
        }
      }
      return newHeight;
    }
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      var _this9 = this;
      var priv = privatePool$7.get(this);
      var initialSetting = this.hot.getSettings()[PLUGIN_KEY$4];
      var loadedManualRowHeights = this.loadManualRowHeights();
      this.hot.batchExecution(function() {
        if (typeof loadedManualRowHeights !== "undefined") {
          loadedManualRowHeights.forEach(function(height, index) {
            _this9.rowHeightsMap.setValueAtIndex(index, height);
          });
        } else if (Array.isArray(initialSetting)) {
          initialSetting.forEach(function(height, index) {
            _this9.rowHeightsMap.setValueAtIndex(index, height);
          });
          priv.config = initialSetting;
        } else if (initialSetting === true && Array.isArray(priv.config)) {
          priv.config.forEach(function(height, index) {
            _this9.rowHeightsMap.setValueAtIndex(index, height);
          });
        }
      }, true);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$e(_getPrototypeOf$B(ManualRowResize2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$4;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$3;
    }
  }]);
  return ManualRowResize2;
}(BasePlugin);

function _typeof$O(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$O = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$O = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$O(obj);
}
function _slicedToArray$h(arr, i) {
  return _arrayWithHoles$h(arr) || _iterableToArrayLimit$h(arr, i) || _unsupportedIterableToArray$r(arr, i) || _nonIterableRest$h();
}
function _nonIterableRest$h() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$r(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$r(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$r(o, minLen);
}
function _arrayLikeToArray$r(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$h(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$h(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1j(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1j(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1j(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1j(Constructor, staticProps);
  return Constructor;
}
function _get$f(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$f = Reflect.get;
  } else {
    _get$f = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$f(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$f(target, property, receiver || target);
}
function _superPropBase$f(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$C(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$C(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$D(subClass, superClass);
}
function _setPrototypeOf$D(o, p) {
  _setPrototypeOf$D = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$D(o, p);
}
function _createSuper$C(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$D();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$C(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$C(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$C(this, result);
  };
}
function _possibleConstructorReturn$C(self, call) {
  if (call && (_typeof$O(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$C(self);
}
function _assertThisInitialized$C(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$D() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$C(o) {
  _getPrototypeOf$C = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$C(o);
}
var PLUGIN_KEY$5 = "autoRowSize";
var PLUGIN_PRIORITY$4 = 40;
var ROW_WIDTHS_MAP_NAME = "autoRowSize";
var AutoRowSize = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$C(AutoRowSize2, _BasePlugin);
  var _super = _createSuper$C(AutoRowSize2);
  function AutoRowSize2(hotInstance) {
    var _this;
    _classCallCheck$1o(this, AutoRowSize2);
    _this = _super.call(this, hotInstance);
    _this.rowHeightsMap = void 0;
    _this.headerHeight = null;
    _this.ghostTable = new GhostTable(_this.hot);
    _this.samplesGenerator = new SamplesGenerator(function(row, col) {
      var cellValue;
      if (row >= 0) {
        cellValue = _this.hot.getDataAtCell(row, col);
      } else if (row === -1) {
        cellValue = _this.hot.getColHeader(col);
      }
      return {
        value: cellValue
      };
    });
    _this.firstCalculation = true;
    _this.inProgress = false;
    _this.measuredRows = 0;
    _this.rowHeightsMap = new PhysicalIndexToValueMap();
    _this.hot.rowIndexMapper.registerMap(ROW_WIDTHS_MAP_NAME, _this.rowHeightsMap);
    _this.addHook("beforeRowResize", function(size, row, isDblClick) {
      return _this.onBeforeRowResize(size, row, isDblClick);
    });
    return _this;
  }
  _createClass$1j(AutoRowSize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      var settings = this.hot.getSettings()[PLUGIN_KEY$5];
      return settings === true || isObject(settings);
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.setSamplingOptions();
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData();
      });
      this.addHook("beforeChange", function(changes) {
        return _this2.onBeforeChange(changes);
      });
      this.addHook("beforeColumnResize", function() {
        return _this2.recalculateAllRowsHeight();
      });
      this.addHook("beforeRender", function(force) {
        return _this2.onBeforeRender(force);
      });
      this.addHook("modifyRowHeight", function(height, row) {
        return _this2.getRowHeight(row, height);
      });
      this.addHook("modifyColumnHeaderHeight", function() {
        return _this2.getColumnHeaderHeight();
      });
      _get$f(_getPrototypeOf$C(AutoRowSize2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      this.headerHeight = null;
      _get$f(_getPrototypeOf$C(AutoRowSize2.prototype), "disablePlugin", this).call(this);
      this.addHook("beforeRowResize", function(size, row, isDblClick) {
        return _this3.onBeforeRowResize(size, row, isDblClick);
      });
    }
  }, {
    key: "calculateRowsHeight",
    value: function calculateRowsHeight() {
      var _this4 = this;
      var rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countRows() - 1
      };
      var colRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        from: 0,
        to: this.hot.countCols() - 1
      };
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var rowsRange = typeof rowRange === "number" ? {
        from: rowRange,
        to: rowRange
      } : rowRange;
      var columnsRange = typeof colRange === "number" ? {
        from: colRange,
        to: colRange
      } : colRange;
      if (this.hot.getColHeader(0) !== null) {
        var samples = this.samplesGenerator.generateRowSamples(-1, columnsRange);
        this.ghostTable.addColumnHeadersRow(samples.get(-1));
      }
      rangeEach(rowsRange.from, rowsRange.to, function(row) {
        if (force || _this4.rowHeightsMap.getValueAtIndex(row) === null) {
          var _samples = _this4.samplesGenerator.generateRowSamples(row, columnsRange);
          arrayEach(_samples, function(_ref) {
            var _ref2 = _slicedToArray$h(_ref, 2), rowIndex = _ref2[0], sample = _ref2[1];
            return _this4.ghostTable.addRow(rowIndex, sample);
          });
        }
      });
      if (this.ghostTable.rows.length) {
        this.hot.batchExecution(function() {
          _this4.ghostTable.getHeights(function(row, height) {
            if (row < 0) {
              _this4.headerHeight = height;
            } else {
              _this4.rowHeightsMap.setValueAtIndex(_this4.hot.toPhysicalRow(row), height);
            }
          });
        }, true);
        this.measuredRows = rowsRange.to + 1;
        this.ghostTable.clean();
      }
    }
  }, {
    key: "calculateAllRowsHeight",
    value: function calculateAllRowsHeight() {
      var _this5 = this;
      var colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countCols() - 1
      };
      var current = 0;
      var length = this.hot.countRows() - 1;
      var timer = null;
      this.inProgress = true;
      var loop = function loop2() {
        if (!_this5.hot) {
          cancelAnimationFrame(timer);
          _this5.inProgress = false;
          return;
        }
        _this5.calculateRowsHeight({
          from: current,
          to: Math.min(current + AutoRowSize2.CALCULATION_STEP, length)
        }, colRange);
        current = current + AutoRowSize2.CALCULATION_STEP + 1;
        if (current < length) {
          timer = requestAnimationFrame(loop2);
        } else {
          cancelAnimationFrame(timer);
          _this5.inProgress = false;
          _this5.hot.view.adjustElementsSize(true);
          if (_this5.hot.view.wt.wtOverlays.leftOverlay.needFullRender) {
            _this5.hot.view.wt.wtOverlays.leftOverlay.clone.draw();
          }
        }
      };
      var syncLimit = this.getSyncCalculationLimit();
      if (this.firstCalculation && syncLimit >= 0) {
        this.calculateRowsHeight({
          from: 0,
          to: syncLimit
        }, colRange);
        this.firstCalculation = false;
        current = syncLimit + 1;
      }
      if (current < length) {
        loop();
      } else {
        this.inProgress = false;
        this.hot.view.adjustElementsSize(false);
      }
    }
  }, {
    key: "setSamplingOptions",
    value: function setSamplingOptions() {
      var setting = this.hot.getSettings()[PLUGIN_KEY$5];
      var samplingRatio = setting && hasOwnProperty(setting, "samplingRatio") ? setting.samplingRatio : void 0;
      var allowSampleDuplicates = setting && hasOwnProperty(setting, "allowSampleDuplicates") ? setting.allowSampleDuplicates : void 0;
      if (samplingRatio && !isNaN(samplingRatio)) {
        this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
      }
      if (allowSampleDuplicates) {
        this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
      }
    }
  }, {
    key: "recalculateAllRowsHeight",
    value: function recalculateAllRowsHeight() {
      if (isVisible(this.hot.view.wt.wtTable.TABLE)) {
        this.clearCache();
        this.calculateAllRowsHeight();
      }
    }
  }, {
    key: "getSyncCalculationLimit",
    value: function getSyncCalculationLimit() {
      var settings = this.hot.getSettings()[PLUGIN_KEY$5];
      var limit = AutoRowSize2.SYNC_CALCULATION_LIMIT;
      var rowsLimit = this.hot.countRows() - 1;
      if (isObject(settings)) {
        limit = settings.syncLimit;
        if (isPercentValue(limit)) {
          limit = valueAccordingPercent(rowsLimit, limit);
        } else {
          limit >>= 0;
        }
      }
      return Math.min(limit, rowsLimit);
    }
  }, {
    key: "getRowHeight",
    value: function getRowHeight(row) {
      var defaultHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      var cachedHeight = row < 0 ? this.headerHeight : this.rowHeightsMap.getValueAtIndex(this.hot.toPhysicalRow(row));
      var height = defaultHeight;
      if (cachedHeight !== null && cachedHeight > (defaultHeight || 0)) {
        height = cachedHeight;
      }
      return height;
    }
  }, {
    key: "getColumnHeaderHeight",
    value: function getColumnHeaderHeight() {
      return this.headerHeight;
    }
  }, {
    key: "getFirstVisibleRow",
    value: function getFirstVisibleRow() {
      var wot = this.hot.view.wt;
      if (wot.wtViewport.rowsVisibleCalculator) {
        return wot.wtTable.getFirstVisibleRow();
      }
      if (wot.wtViewport.rowsRenderCalculator) {
        return wot.wtTable.getFirstRenderedRow();
      }
      return -1;
    }
  }, {
    key: "getLastVisibleRow",
    value: function getLastVisibleRow() {
      var wot = this.hot.view.wt;
      if (wot.wtViewport.rowsVisibleCalculator) {
        return wot.wtTable.getLastVisibleRow();
      }
      if (wot.wtViewport.rowsRenderCalculator) {
        return wot.wtTable.getLastRenderedRow();
      }
      return -1;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.headerHeight = null;
      this.rowHeightsMap.init();
    }
  }, {
    key: "clearCacheByRange",
    value: function clearCacheByRange(range) {
      var _this6 = this;
      var _ref3 = typeof range === "number" ? {
        from: range,
        to: range
      } : range, from = _ref3.from, to = _ref3.to;
      this.hot.batchExecution(function() {
        rangeEach(Math.min(from, to), Math.max(from, to), function(row) {
          _this6.rowHeightsMap.setValueAtIndex(row, null);
        });
      }, true);
    }
  }, {
    key: "isNeedRecalculate",
    value: function isNeedRecalculate() {
      return !!arrayFilter(this.rowHeightsMap.getValues().slice(0, this.measuredRows), function(item) {
        return item === null;
      }).length;
    }
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender() {
      var force = this.hot.renderCall;
      var fixedRowsBottom = this.hot.getSettings().fixedRowsBottom;
      var firstVisibleRow = this.getFirstVisibleRow();
      var lastVisibleRow = this.getLastVisibleRow();
      if (firstVisibleRow === -1 || lastVisibleRow === -1) {
        return;
      }
      this.calculateRowsHeight({
        from: firstVisibleRow,
        to: lastVisibleRow
      }, void 0, force);
      if (fixedRowsBottom) {
        var totalRows = this.hot.countRows() - 1;
        this.calculateRowsHeight({
          from: totalRows - fixedRowsBottom,
          to: totalRows
        });
      }
      if (this.isNeedRecalculate() && !this.inProgress) {
        this.calculateAllRowsHeight();
      }
    }
  }, {
    key: "onBeforeRowMove",
    value: function onBeforeRowMove(from, to) {
      this.clearCacheByRange({
        from,
        to
      });
      this.calculateAllRowsHeight();
    }
  }, {
    key: "onBeforeRowResize",
    value: function onBeforeRowResize(size, row, isDblClick) {
      var newSize = size;
      if (isDblClick) {
        this.calculateRowsHeight(row, void 0, true);
        newSize = this.getRowHeight(row);
      }
      return newSize;
    }
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      var _this7 = this;
      if (this.hot.view) {
        this.recalculateAllRowsHeight();
      } else {
        setTimeout(function() {
          if (_this7.hot) {
            _this7.recalculateAllRowsHeight();
          }
        }, 0);
      }
    }
  }, {
    key: "onBeforeChange",
    value: function onBeforeChange(changes) {
      var range = null;
      if (changes.length === 1) {
        range = changes[0][0];
      } else if (changes.length > 1) {
        range = {
          from: changes[0][0],
          to: changes[changes.length - 1][0]
        };
      }
      if (range !== null) {
        this.clearCacheByRange(range);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.ghostTable.clean();
      _get$f(_getPrototypeOf$C(AutoRowSize2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$5;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$4;
    }
  }, {
    key: "CALCULATION_STEP",
    get: function get() {
      return 50;
    }
  }, {
    key: "SYNC_CALCULATION_LIMIT",
    get: function get() {
      return 500;
    }
  }]);
  return AutoRowSize2;
}(BasePlugin);

function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty$e(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$i(arr, i) {
  return _arrayWithHoles$i(arr) || _iterableToArrayLimit$i(arr, i) || _unsupportedIterableToArray$s(arr, i) || _nonIterableRest$i();
}
function _nonIterableRest$i() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$s(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$s(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$s(o, minLen);
}
function _arrayLikeToArray$s(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$i(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$i(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1k(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1k(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1k(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1k(Constructor, staticProps);
  return Constructor;
}
var inheritedColumnProperties = ["sortEmptyCells", "indicator", "headerAction", "compareFunctionFactory"];
var SORT_EMPTY_CELLS_DEFAULT = false;
var SHOW_SORT_INDICATOR_DEFAULT = true;
var HEADER_ACTION_DEFAULT = true;
var ColumnStatesManager = /* @__PURE__ */ function() {
  function ColumnStatesManager2(hot, mapName) {
    _classCallCheck$1p(this, ColumnStatesManager2);
    this.hot = hot;
    this.sortingStates = new LinkedPhysicalIndexToValueMap();
    this.sortEmptyCells = SORT_EMPTY_CELLS_DEFAULT;
    this.indicator = SHOW_SORT_INDICATOR_DEFAULT;
    this.headerAction = HEADER_ACTION_DEFAULT;
    this.compareFunctionFactory = void 0;
    this.mapName = mapName;
    this.hot.columnIndexMapper.registerMap(mapName, this.sortingStates);
  }
  _createClass$1k(ColumnStatesManager2, [{
    key: "updateAllColumnsProperties",
    value: function updateAllColumnsProperties(allSortSettings) {
      var _this = this;
      if (!isObject(allSortSettings)) {
        return;
      }
      objectEach(allSortSettings, function(newValue, propertyName) {
        if (inheritedColumnProperties.includes(propertyName)) {
          _this[propertyName] = newValue;
        }
      });
    }
  }, {
    key: "getAllColumnsProperties",
    value: function getAllColumnsProperties() {
      var columnProperties = {
        sortEmptyCells: this.sortEmptyCells,
        indicator: this.indicator,
        headerAction: this.headerAction
      };
      if (typeof this.compareFunctionFactory === "function") {
        columnProperties.compareFunctionFactory = this.compareFunctionFactory;
      }
      return columnProperties;
    }
  }, {
    key: "getSortOrderOfColumn",
    value: function getSortOrderOfColumn(searchedColumn) {
      var _this$sortingStates$g;
      return (_this$sortingStates$g = this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(searchedColumn))) === null || _this$sortingStates$g === void 0 ? void 0 : _this$sortingStates$g.sortOrder;
    }
  }, {
    key: "getIndexOfColumnInSortQueue",
    value: function getIndexOfColumnInSortQueue(column) {
      column = this.hot.toPhysicalColumn(column);
      return this.sortingStates.getEntries().findIndex(function(_ref) {
        var _ref2 = _slicedToArray$i(_ref, 1), physicalColumn = _ref2[0];
        return physicalColumn === column;
      });
    }
  }, {
    key: "getNumberOfSortedColumns",
    value: function getNumberOfSortedColumns() {
      return this.sortingStates.getLength();
    }
  }, {
    key: "isListOfSortedColumnsEmpty",
    value: function isListOfSortedColumnsEmpty() {
      return this.getNumberOfSortedColumns() === 0;
    }
  }, {
    key: "isColumnSorted",
    value: function isColumnSorted(column) {
      return isObject(this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(column)));
    }
  }, {
    key: "getSortStates",
    value: function getSortStates() {
      var _this2 = this;
      if (this.sortingStates === null) {
        return [];
      }
      var sortingStatesQueue = this.sortingStates.getEntries();
      return sortingStatesQueue.map(function(_ref3) {
        var _ref4 = _slicedToArray$i(_ref3, 2), physicalColumn = _ref4[0], value = _ref4[1];
        return _objectSpread$8({
          column: _this2.hot.toVisualColumn(physicalColumn)
        }, value);
      });
    }
  }, {
    key: "getColumnSortState",
    value: function getColumnSortState(column) {
      var sortOrder = this.getSortOrderOfColumn(column);
      if (isDefined(sortOrder)) {
        return {
          column,
          sortOrder
        };
      }
    }
  }, {
    key: "setSortStates",
    value: function setSortStates(sortStates) {
      this.sortingStates.clear();
      for (var i = 0; i < sortStates.length; i += 1) {
        this.sortingStates.setValueAtIndex(this.hot.toPhysicalColumn(sortStates[i].column), {
          sortOrder: sortStates[i].sortOrder
        });
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.hot.columnIndexMapper.unregisterMap(this.mapName);
      this.sortingStates = null;
    }
  }]);
  return ColumnStatesManager2;
}();

var ASC_SORT_STATE = "asc";
var DESC_SORT_STATE = "desc";
var HEADER_SPAN_CLASS = "colHeader";
function isValidColumnState(columnState) {
  if (isObject(columnState) === false) {
    return false;
  }
  var column = columnState.column, sortOrder = columnState.sortOrder;
  return Number.isInteger(column) && [ASC_SORT_STATE, DESC_SORT_STATE].includes(sortOrder);
}
function areValidSortStates(sortStates) {
  if (sortStates.some(function(columnState) {
    return isValidColumnState(columnState) === false;
  })) {
    return false;
  }
  var sortedColumns = sortStates.map(function(_ref) {
    var column = _ref.column;
    return column;
  });
  return new Set(sortedColumns).size === sortedColumns.length;
}
function getNextSortOrder(sortOrder) {
  if (sortOrder === DESC_SORT_STATE) {
    return;
  } else if (sortOrder === ASC_SORT_STATE) {
    return DESC_SORT_STATE;
  }
  return ASC_SORT_STATE;
}
function getHeaderSpanElement(TH) {
  var headerSpanElement = TH.querySelector(".".concat(HEADER_SPAN_CLASS));
  return headerSpanElement;
}
function isFirstLevelColumnHeader(column, TH) {
  if (column < 0 || !TH.parentNode) {
    return false;
  }
  var TRs = TH.parentNode.parentNode.childNodes;
  var headerLevel = Array.from(TRs).indexOf(TH.parentNode) - TRs.length;
  if (headerLevel !== -1) {
    return false;
  }
  return true;
}
function wasHeaderClickedProperly(row, column, clickEvent) {
  return row === -1 && column >= 0 && isRightClick(clickEvent) === false;
}

var HEADER_CLASS_ASC_SORT = "ascending";
var HEADER_CLASS_DESC_SORT = "descending";
var HEADER_CLASS_INDICATOR_DISABLED = "indicatorDisabled";
var HEADER_SORT_CLASS = "columnSorting";
var HEADER_ACTION_CLASS = "sortAction";
var orderToCssClass = new Map([[ASC_SORT_STATE, HEADER_CLASS_ASC_SORT], [DESC_SORT_STATE, HEADER_CLASS_DESC_SORT]]);
function getClassesToAdd(columnStatesManager, column, showSortIndicator, headerAction) {
  var cssClasses = [HEADER_SORT_CLASS];
  if (headerAction) {
    cssClasses.push(HEADER_ACTION_CLASS);
  }
  if (showSortIndicator === false) {
    cssClasses.push(HEADER_CLASS_INDICATOR_DISABLED);
    return cssClasses;
  }
  var columnOrder = columnStatesManager.getSortOrderOfColumn(column);
  if (isDefined(columnOrder)) {
    cssClasses.push(orderToCssClass.get(columnOrder));
  }
  return cssClasses;
}
function getClassesToRemove() {
  return Array.from(orderToCssClass.values()).concat(HEADER_ACTION_CLASS, HEADER_CLASS_INDICATOR_DISABLED, HEADER_SORT_CLASS);
}

function compareFunctionFactory(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    var sortEmptyCells = columnPluginSettings.sortEmptyCells;
    if (typeof value === "string") {
      value = value.toLowerCase();
    }
    if (typeof nextValue === "string") {
      nextValue = nextValue.toLowerCase();
    }
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    if (isNaN(value) && !isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    } else if (!isNaN(value) && isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (!(isNaN(value) || isNaN(nextValue))) {
      value = parseFloat(value);
      nextValue = parseFloat(nextValue);
    }
    if (value < nextValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (value > nextValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE = "default";

function compareFunctionFactory$1(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    var parsedFirstValue = parseFloat(value);
    var parsedSecondValue = parseFloat(nextValue);
    var sortEmptyCells = columnPluginSettings.sortEmptyCells;
    if (parsedFirstValue === parsedSecondValue || isNaN(parsedFirstValue) && isNaN(parsedSecondValue)) {
      return DO_NOT_SWAP;
    }
    if (sortEmptyCells) {
      if (isEmpty(value)) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      if (isEmpty(nextValue)) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
    }
    if (isNaN(parsedFirstValue)) {
      return FIRST_AFTER_SECOND;
    }
    if (isNaN(parsedSecondValue)) {
      return FIRST_BEFORE_SECOND;
    }
    if (parsedFirstValue < parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (parsedFirstValue > parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE$1 = "numeric";

function compareFunctionFactory$2(sortOrder, columnMeta, columnPluginSettings) {
  var checkedTemplate = columnMeta.checkedTemplate;
  var uncheckedTemplate = columnMeta.uncheckedTemplate;
  var sortEmptyCells = columnPluginSettings.sortEmptyCells;
  return function(value, nextValue) {
    var isEmptyValue = isEmpty(value);
    var isEmptyNextValue = isEmpty(nextValue);
    var unifiedValue = isEmptyValue ? uncheckedTemplate : value;
    var unifiedNextValue = isEmptyNextValue ? uncheckedTemplate : nextValue;
    var isValueFromTemplate = unifiedValue === uncheckedTemplate || unifiedValue === checkedTemplate;
    var isNextValueFromTemplate = unifiedNextValue === uncheckedTemplate || unifiedNextValue === checkedTemplate;
    if (sortEmptyCells === false) {
      if (isEmptyValue && isEmptyNextValue === false) {
        return FIRST_AFTER_SECOND;
      }
      if (isEmptyValue === false && isEmptyNextValue) {
        return FIRST_BEFORE_SECOND;
      }
    }
    if (isValueFromTemplate === false && isNextValueFromTemplate) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (isValueFromTemplate && isNextValueFromTemplate === false) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    if (isValueFromTemplate === false && isNextValueFromTemplate === false) {
      return compareFunctionFactory(sortOrder, columnMeta, columnPluginSettings)(value, nextValue);
    }
    if (unifiedValue === uncheckedTemplate && unifiedNextValue === checkedTemplate) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (unifiedValue === checkedTemplate && unifiedNextValue === uncheckedTemplate) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE$2 = "checkbox";

function compareFunctionFactory$3(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    var sortEmptyCells = columnPluginSettings.sortEmptyCells;
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    var dateFormat = columnMeta.dateFormat;
    var firstDate = hooks(value, dateFormat);
    var nextDate = hooks(nextValue, dateFormat);
    if (!firstDate.isValid()) {
      return FIRST_AFTER_SECOND;
    }
    if (!nextDate.isValid()) {
      return FIRST_BEFORE_SECOND;
    }
    if (nextDate.isAfter(firstDate)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (nextDate.isBefore(firstDate)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE$3 = "date";

var _staticRegister$7 = staticRegister("sorting.compareFunctionFactory"), registerCompareFunctionFactory = _staticRegister$7.register, getGloballyCompareFunctionFactory = _staticRegister$7.getItem, hasGloballyCompareFunctionFactory = _staticRegister$7.hasItem;
var _staticRegister2 = staticRegister("sorting.mainSortComparator"), registerRootComparator = _staticRegister2.register, getRootComparator = _staticRegister2.getItem;
function getCompareFunctionFactory(type) {
  if (hasGloballyCompareFunctionFactory(type)) {
    return getGloballyCompareFunctionFactory(type);
  }
  return getGloballyCompareFunctionFactory(COLUMN_DATA_TYPE);
}
registerCompareFunctionFactory(COLUMN_DATA_TYPE$1, compareFunctionFactory$1);
registerCompareFunctionFactory(COLUMN_DATA_TYPE$2, compareFunctionFactory$2);
registerCompareFunctionFactory(COLUMN_DATA_TYPE$3, compareFunctionFactory$3);
registerCompareFunctionFactory(COLUMN_DATA_TYPE, compareFunctionFactory);

function _defineProperties$1l(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1l(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1l(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1l(Constructor, staticProps);
  return Constructor;
}
function _classCallCheck$1q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var NodeStructure = function NodeStructure2(data) {
  _classCallCheck$1q(this, NodeStructure2);
  this.data = data;
  this.next = null;
  this.prev = null;
};
var LinkedList = /* @__PURE__ */ function() {
  function LinkedList2() {
    _classCallCheck$1q(this, LinkedList2);
    this.first = null;
    this.last = null;
  }
  _createClass$1l(LinkedList2, [{
    key: "push",
    value: function push(data) {
      var node = new NodeStructure(data);
      if (this.first === null) {
        this.first = node;
        this.last = node;
      } else {
        var temp = this.last;
        this.last = node;
        node.prev = temp;
        temp.next = node;
      }
    }
  }, {
    key: "unshift",
    value: function unshift(data) {
      var node = new NodeStructure(data);
      if (this.first === null) {
        this.first = node;
        this.last = node;
      } else {
        var temp = this.first;
        this.first = node;
        node.next = temp;
        temp.prev = node;
      }
    }
  }, {
    key: "inorder",
    value: function inorder(callback) {
      var temp = this.first;
      while (temp) {
        callback(temp);
        temp = temp.next;
      }
    }
  }, {
    key: "remove",
    value: function remove(data) {
      if (this.first === null) {
        return false;
      }
      var temp = this.first;
      var next;
      var prev;
      while (temp) {
        if (temp.data === data) {
          next = temp.next;
          prev = temp.prev;
          if (next) {
            next.prev = prev;
          }
          if (prev) {
            prev.next = next;
          }
          if (temp === this.first) {
            this.first = next;
          }
          if (temp === this.last) {
            this.last = prev;
          }
          return true;
        }
        temp = temp.next;
      }
      return false;
    }
  }, {
    key: "hasCycle",
    value: function hasCycle() {
      var fast = this.first;
      var slow = this.first;
      while (true) {
        if (fast === null) {
          return false;
        }
        fast = fast.next;
        if (fast === null) {
          return false;
        }
        fast = fast.next;
        slow = slow.next;
        if (fast === slow) {
          return true;
        }
      }
    }
  }, {
    key: "pop",
    value: function pop() {
      if (this.last === null) {
        return null;
      }
      var temp = this.last;
      this.last = this.last.prev;
      return temp;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.first === null) {
        return null;
      }
      var temp = this.first;
      this.first = this.first.next;
      return temp;
    }
  }, {
    key: "recursiveReverse",
    value: function recursiveReverse() {
      function inverse(current, next) {
        if (!next) {
          return;
        }
        inverse(next, next.next);
        next.next = current;
      }
      if (!this.first) {
        return;
      }
      inverse(this.first, this.first.next);
      this.first.next = null;
      var temp = this.first;
      this.first = this.last;
      this.last = temp;
    }
  }, {
    key: "reverse",
    value: function reverse() {
      if (!this.first || !this.first.next) {
        return;
      }
      var current = this.first.next;
      var prev = this.first;
      var temp;
      while (current) {
        temp = current.next;
        current.next = prev;
        prev.prev = current;
        prev = current;
        current = temp;
      }
      this.first.next = null;
      this.last.prev = null;
      temp = this.first;
      this.first = prev;
      this.last = temp;
    }
  }]);
  return LinkedList2;
}();

var defaultCompareFunction = function defaultCompareFunction2(a, b) {
  var firstValue = a.toString();
  var secondValue = b.toString();
  if (firstValue === secondValue) {
    return 0;
  } else if (firstValue < secondValue) {
    return -1;
  }
  return 1;
};
function mergeSort(array) {
  var compareFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultCompareFunction;
  var startIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var endIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : array.length;
  if (Math.abs(endIndex - startIndex) <= 1) {
    return [];
  }
  var middleIndex = Math.ceil((startIndex + endIndex) / 2);
  mergeSort(array, compareFunction, startIndex, middleIndex);
  mergeSort(array, compareFunction, middleIndex, endIndex);
  return merge(array, compareFunction, startIndex, middleIndex, endIndex);
}
function merge(array, compareFunction, startIndex, middleIndex, endIndex) {
  var leftElements = new LinkedList();
  var rightElements = new LinkedList();
  var leftSize = middleIndex - startIndex;
  var rightSize = endIndex - middleIndex;
  var maxSize = Math.max(leftSize, rightSize);
  var size = endIndex - startIndex;
  for (var _i = 0; _i < maxSize; _i += 1) {
    if (_i < leftSize) {
      leftElements.push(array[startIndex + _i]);
    }
    if (_i < rightSize) {
      rightElements.push(array[middleIndex + _i]);
    }
  }
  var i = 0;
  while (i < size) {
    if (leftElements.first && rightElements.first) {
      if (compareFunction(leftElements.first.data, rightElements.first.data) > 0) {
        array[startIndex + i] = rightElements.shift().data;
      } else {
        array[startIndex + i] = leftElements.shift().data;
      }
    } else if (leftElements.first) {
      array[startIndex + i] = leftElements.shift().data;
    } else {
      array[startIndex + i] = rightElements.shift().data;
    }
    i += 1;
  }
  return array;
}

var DO_NOT_SWAP = 0;
var FIRST_BEFORE_SECOND = -1;
var FIRST_AFTER_SECOND = 1;
function sort(indexesWithData, rootComparatorId) {
  var rootComparator = getRootComparator(rootComparatorId);
  for (var _len = arguments.length, argsForRootComparator = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    argsForRootComparator[_key - 2] = arguments[_key];
  }
  mergeSort(indexesWithData, rootComparator.apply(void 0, argsForRootComparator));
}

function _toArray(arr) {
  return _arrayWithHoles$j(arr) || _iterableToArray$h(arr) || _unsupportedIterableToArray$t(arr) || _nonIterableRest$j();
}
function _nonIterableRest$j() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$t(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$t(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$t(o, minLen);
}
function _arrayLikeToArray$t(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArray$h(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithHoles$j(arr) {
  if (Array.isArray(arr))
    return arr;
}
function rootComparator(sortingOrders, columnMetas) {
  return function(rowIndexWithValues, nextRowIndexWithValues) {
    var _rowIndexWithValues = _toArray(rowIndexWithValues), values = _rowIndexWithValues.slice(1);
    var _nextRowIndexWithValu = _toArray(nextRowIndexWithValues), nextValues = _nextRowIndexWithValu.slice(1);
    return function getCompareResult(column) {
      var sortingOrder = sortingOrders[column];
      var columnMeta = columnMetas[column];
      var value = values[column];
      var nextValue = nextValues[column];
      var pluginSettings = columnMeta.columnSorting;
      var compareFunctionFactory = pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory : getCompareFunctionFactory(columnMeta.type);
      var compareResult = compareFunctionFactory(sortingOrder, columnMeta, pluginSettings)(value, nextValue);
      return compareResult;
    }(0);
  };
}

function _typeof$P(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$P = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$P = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$P(obj);
}
var _excluded$5 = ["column"], _excluded2 = ["column"];
function _toConsumableArray$j(arr) {
  return _arrayWithoutHoles$h(arr) || _iterableToArray$i(arr) || _unsupportedIterableToArray$u(arr) || _nonIterableSpread$h();
}
function _nonIterableSpread$h() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$u(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$u(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$u(o, minLen);
}
function _iterableToArray$i(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$h(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$u(arr);
}
function _arrayLikeToArray$u(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys$9(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty$f(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$1r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1m(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1m(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1m(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1m(Constructor, staticProps);
  return Constructor;
}
function _get$g(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$g = Reflect.get;
  } else {
    _get$g = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$g(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$g(target, property, receiver || target);
}
function _superPropBase$g(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$D(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$D(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$E(subClass, superClass);
}
function _setPrototypeOf$E(o, p) {
  _setPrototypeOf$E = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$E(o, p);
}
function _createSuper$D(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$E();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$D(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$D(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$D(this, result);
  };
}
function _possibleConstructorReturn$D(self, call) {
  if (call && (_typeof$P(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$D(self);
}
function _assertThisInitialized$D(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$E() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$D(o) {
  _getPrototypeOf$D = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$D(o);
}
var PLUGIN_KEY$6 = "columnSorting";
var PLUGIN_PRIORITY$5 = 50;
var APPEND_COLUMN_CONFIG_STRATEGY = "append";
var REPLACE_COLUMN_CONFIG_STRATEGY = "replace";
registerRootComparator(PLUGIN_KEY$6, rootComparator);
Hooks.getSingleton().register("beforeColumnSort");
Hooks.getSingleton().register("afterColumnSort");
var ColumnSorting = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$D(ColumnSorting2, _BasePlugin);
  var _super = _createSuper$D(ColumnSorting2);
  function ColumnSorting2(hotInstance) {
    var _this;
    _classCallCheck$1r(this, ColumnSorting2);
    _this = _super.call(this, hotInstance);
    _this.columnStatesManager = null;
    _this.columnMetaCache = null;
    _this.pluginKey = PLUGIN_KEY$6;
    _this.indexesSequenceCache = null;
    return _this;
  }
  _createClass$1m(ColumnSorting2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[this.pluginKey];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.columnStatesManager = new ColumnStatesManager(this.hot, "".concat(this.pluginKey, ".sortingStates"));
      this.columnMetaCache = new PhysicalIndexToValueMap(function(physicalIndex) {
        var visualIndex = _this2.hot.toVisualColumn(physicalIndex);
        if (visualIndex === null) {
          visualIndex = physicalIndex;
        }
        return _this2.getMergedPluginSettings(visualIndex);
      });
      this.hot.columnIndexMapper.registerMap("".concat(this.pluginKey, ".columnMeta"), this.columnMetaCache);
      this.addHook("afterGetColHeader", function(column, TH) {
        return _this2.onAfterGetColHeader(column, TH);
      });
      this.addHook("beforeOnCellMouseDown", function(event, coords, TD, controller) {
        return _this2.onBeforeOnCellMouseDown(event, coords, TD, controller);
      });
      this.addHook("afterOnCellMouseDown", function(event, target) {
        return _this2.onAfterOnCellMouseDown(event, target);
      });
      this.addHook("afterInit", function() {
        return _this2.loadOrSortBySettings();
      });
      this.addHook("afterLoadData", function(sourceData, initialLoad) {
        return _this2.onAfterLoadData(initialLoad);
      });
      if (this.hot.view) {
        this.loadOrSortBySettings();
      }
      _get$g(_getPrototypeOf$D(ColumnSorting2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      var clearColHeader = function clearColHeader2(column, TH) {
        var headerSpanElement = getHeaderSpanElement(TH);
        if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
          return;
        }
        _this3.updateHeaderClasses(headerSpanElement);
      };
      this.hot.addHook("afterGetColHeader", clearColHeader);
      this.hot.addHookOnce("afterRender", function() {
        _this3.hot.removeHook("afterGetColHeader", clearColHeader);
      });
      this.hot.batchExecution(function() {
        if (_this3.indexesSequenceCache !== null) {
          _this3.hot.rowIndexMapper.setIndexesSequence(_this3.indexesSequenceCache.getValues());
          _this3.hot.rowIndexMapper.unregisterMap(_this3.pluginKey);
        }
      }, true);
      this.hot.columnIndexMapper.unregisterMap("".concat(this.pluginKey, ".columnMeta"));
      this.columnStatesManager.destroy();
      this.columnMetaCache = null;
      this.columnStatesManager = null;
      _get$g(_getPrototypeOf$D(ColumnSorting2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "sort",
    value: function sort2(sortConfig) {
      var currentSortConfig = this.getSortConfig();
      var destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
      var sortPossible = this.areValidSortConfigs(destinationSortConfigs);
      var allowSort = this.hot.runHooks("beforeColumnSort", currentSortConfig, destinationSortConfigs, sortPossible);
      if (allowSort === false) {
        return;
      }
      if (currentSortConfig.length === 0 && this.indexesSequenceCache === null) {
        this.indexesSequenceCache = this.hot.rowIndexMapper.registerMap(this.pluginKey, new IndexesSequence());
        this.indexesSequenceCache.setValues(this.hot.rowIndexMapper.getIndexesSequence());
      }
      if (sortPossible) {
        this.columnStatesManager.setSortStates(destinationSortConfigs);
        this.sortByPresetSortStates(destinationSortConfigs);
        this.saveAllSortSettings(destinationSortConfigs);
      }
      this.hot.runHooks("afterColumnSort", currentSortConfig, sortPossible ? destinationSortConfigs : currentSortConfig, sortPossible);
      if (sortPossible) {
        this.hot.render();
        this.hot.forceFullRender = false;
        this.hot.view.render();
      }
    }
  }, {
    key: "clearSort",
    value: function clearSort() {
      this.sort([]);
    }
  }, {
    key: "isSorted",
    value: function isSorted() {
      return this.enabled && !this.columnStatesManager.isListOfSortedColumnsEmpty();
    }
  }, {
    key: "getSortConfig",
    value: function getSortConfig(column) {
      if (isDefined(column)) {
        return this.columnStatesManager.getColumnSortState(column);
      }
      return this.columnStatesManager.getSortStates();
    }
  }, {
    key: "setSortConfig",
    value: function setSortConfig(sortConfig) {
      var destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
      if (this.areValidSortConfigs(destinationSortConfigs)) {
        this.columnStatesManager.setSortStates(destinationSortConfigs);
      }
    }
  }, {
    key: "getNormalizedSortConfigs",
    value: function getNormalizedSortConfigs() {
      var sortConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (Array.isArray(sortConfig)) {
        return sortConfig.slice(0, 1);
      }
      return [sortConfig];
    }
  }, {
    key: "areValidSortConfigs",
    value: function areValidSortConfigs(sortConfigs) {
      var numberOfColumns = this.hot.countCols();
      return areValidSortStates(sortConfigs) && sortConfigs.every(function(_ref) {
        var column = _ref.column;
        return column <= numberOfColumns && column >= 0;
      });
    }
  }, {
    key: "saveAllSortSettings",
    value: function saveAllSortSettings(sortConfigs) {
      var _this4 = this;
      var allSortSettings = this.columnStatesManager.getAllColumnsProperties();
      var translateColumnToPhysical = function translateColumnToPhysical2(_ref2) {
        var visualColumn = _ref2.column, restOfProperties = _objectWithoutProperties$5(_ref2, _excluded$5);
        return _objectSpread$9({
          column: _this4.hot.toPhysicalColumn(visualColumn)
        }, restOfProperties);
      };
      allSortSettings.initialConfig = arrayMap(sortConfigs, translateColumnToPhysical);
      this.hot.runHooks("persistentStateSave", "columnSorting", allSortSettings);
    }
  }, {
    key: "getAllSavedSortSettings",
    value: function getAllSavedSortSettings() {
      var _this5 = this;
      var storedAllSortSettings = {};
      this.hot.runHooks("persistentStateLoad", "columnSorting", storedAllSortSettings);
      var allSortSettings = storedAllSortSettings.value;
      var translateColumnToVisual = function translateColumnToVisual2(_ref3) {
        var physicalColumn = _ref3.column, restOfProperties = _objectWithoutProperties$5(_ref3, _excluded2);
        return _objectSpread$9({
          column: _this5.hot.toVisualColumn(physicalColumn)
        }, restOfProperties);
      };
      if (isDefined(allSortSettings) && Array.isArray(allSortSettings.initialConfig)) {
        allSortSettings.initialConfig = arrayMap(allSortSettings.initialConfig, translateColumnToVisual);
      }
      return allSortSettings;
    }
  }, {
    key: "getColumnNextConfig",
    value: function getColumnNextConfig(column) {
      var sortOrder = this.columnStatesManager.getSortOrderOfColumn(column);
      if (isDefined(sortOrder)) {
        var nextSortOrder = getNextSortOrder(sortOrder);
        if (isDefined(nextSortOrder)) {
          return {
            column,
            sortOrder: nextSortOrder
          };
        }
        return;
      }
      var nrOfColumns = this.hot.countCols();
      if (Number.isInteger(column) && column >= 0 && column < nrOfColumns) {
        return {
          column,
          sortOrder: getNextSortOrder()
        };
      }
    }
  }, {
    key: "getNextSortConfig",
    value: function getNextSortConfig(columnToChange) {
      var strategyId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : APPEND_COLUMN_CONFIG_STRATEGY;
      var indexOfColumnToChange = this.columnStatesManager.getIndexOfColumnInSortQueue(columnToChange);
      var isColumnSorted = indexOfColumnToChange !== -1;
      var currentSortConfig = this.getSortConfig();
      var nextColumnConfig = this.getColumnNextConfig(columnToChange);
      if (isColumnSorted) {
        if (isUndefined$1(nextColumnConfig)) {
          return [].concat(_toConsumableArray$j(currentSortConfig.slice(0, indexOfColumnToChange)), _toConsumableArray$j(currentSortConfig.slice(indexOfColumnToChange + 1)));
        }
        if (strategyId === APPEND_COLUMN_CONFIG_STRATEGY) {
          return [].concat(_toConsumableArray$j(currentSortConfig.slice(0, indexOfColumnToChange)), _toConsumableArray$j(currentSortConfig.slice(indexOfColumnToChange + 1)), [nextColumnConfig]);
        } else if (strategyId === REPLACE_COLUMN_CONFIG_STRATEGY) {
          return [].concat(_toConsumableArray$j(currentSortConfig.slice(0, indexOfColumnToChange)), [nextColumnConfig], _toConsumableArray$j(currentSortConfig.slice(indexOfColumnToChange + 1)));
        }
      }
      if (isDefined(nextColumnConfig)) {
        return currentSortConfig.concat(nextColumnConfig);
      }
      return currentSortConfig;
    }
  }, {
    key: "getPluginColumnConfig",
    value: function getPluginColumnConfig(columnConfig) {
      if (isObject(columnConfig)) {
        var pluginColumnConfig = columnConfig[this.pluginKey];
        if (isObject(pluginColumnConfig)) {
          return pluginColumnConfig;
        }
      }
      return {};
    }
  }, {
    key: "getMergedPluginSettings",
    value: function getMergedPluginSettings(column) {
      var pluginMainSettings = this.hot.getSettings()[this.pluginKey];
      var storedColumnProperties = this.columnStatesManager.getAllColumnsProperties();
      var cellMeta = this.hot.getCellMeta(0, column);
      var columnMeta = Object.getPrototypeOf(cellMeta);
      if (Array.isArray(columnMeta.columns)) {
        return Object.assign(storedColumnProperties, pluginMainSettings, this.getPluginColumnConfig(columnMeta.columns[column]));
      } else if (isFunction$1(columnMeta.columns)) {
        return Object.assign(storedColumnProperties, pluginMainSettings, this.getPluginColumnConfig(columnMeta.columns(column)));
      }
      return Object.assign(storedColumnProperties, pluginMainSettings);
    }
  }, {
    key: "getFirstCellSettings",
    value: function getFirstCellSettings(column) {
      var cellMeta = this.hot.getCellMeta(0, column);
      var cellMetaCopy = Object.create(cellMeta);
      cellMetaCopy[this.pluginKey] = this.columnMetaCache.getValueAtIndex(this.hot.toPhysicalColumn(column));
      return cellMetaCopy;
    }
  }, {
    key: "getNumberOfRowsToSort",
    value: function getNumberOfRowsToSort(numberOfRows) {
      var settings = this.hot.getSettings();
      if (settings.maxRows <= numberOfRows) {
        return settings.maxRows;
      }
      return numberOfRows - settings.minSpareRows;
    }
  }, {
    key: "sortByPresetSortStates",
    value: function sortByPresetSortStates(sortConfigs) {
      var _this6 = this;
      if (sortConfigs.length === 0) {
        this.hot.rowIndexMapper.setIndexesSequence(this.indexesSequenceCache.getValues());
        return;
      }
      var indexesWithData = [];
      var numberOfRows = this.hot.countRows();
      var getDataForSortedColumns = function getDataForSortedColumns2(visualRowIndex2) {
        return arrayMap(sortConfigs, function(sortConfig) {
          return _this6.hot.getDataAtCell(visualRowIndex2, sortConfig.column);
        });
      };
      for (var visualRowIndex = 0; visualRowIndex < this.getNumberOfRowsToSort(numberOfRows); visualRowIndex += 1) {
        indexesWithData.push([this.hot.toPhysicalRow(visualRowIndex)].concat(getDataForSortedColumns(visualRowIndex)));
      }
      var indexesBefore = arrayMap(indexesWithData, function(indexWithData) {
        return indexWithData[0];
      });
      sort(indexesWithData, this.pluginKey, arrayMap(sortConfigs, function(sortConfig) {
        return sortConfig.sortOrder;
      }), arrayMap(sortConfigs, function(sortConfig) {
        return _this6.getFirstCellSettings(sortConfig.column);
      }));
      for (var _visualRowIndex = indexesWithData.length; _visualRowIndex < numberOfRows; _visualRowIndex += 1) {
        indexesWithData.push([_visualRowIndex].concat(getDataForSortedColumns(_visualRowIndex)));
      }
      var indexesAfter = arrayMap(indexesWithData, function(indexWithData) {
        return indexWithData[0];
      });
      var indexMapping = new Map(arrayMap(indexesBefore, function(indexBefore, indexInsideArray) {
        return [indexBefore, indexesAfter[indexInsideArray]];
      }));
      var newIndexesSequence = arrayMap(this.hot.rowIndexMapper.getIndexesSequence(), function(physicalIndex) {
        if (indexMapping.has(physicalIndex)) {
          return indexMapping.get(physicalIndex);
        }
        return physicalIndex;
      });
      this.hot.rowIndexMapper.setIndexesSequence(newIndexesSequence);
    }
  }, {
    key: "loadOrSortBySettings",
    value: function loadOrSortBySettings() {
      var storedAllSortSettings = this.getAllSavedSortSettings();
      if (isObject(storedAllSortSettings)) {
        this.sortBySettings(storedAllSortSettings);
      } else {
        var allSortSettings = this.hot.getSettings()[this.pluginKey];
        this.sortBySettings(allSortSettings);
      }
    }
  }, {
    key: "sortBySettings",
    value: function sortBySettings(allSortSettings) {
      if (isObject(allSortSettings)) {
        this.columnStatesManager.updateAllColumnsProperties(allSortSettings);
        var initialConfig = allSortSettings.initialConfig;
        if (Array.isArray(initialConfig) || isObject(initialConfig)) {
          this.sort(initialConfig);
        }
      } else {
        this.hot.render();
      }
    }
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(column, TH) {
      var headerSpanElement = getHeaderSpanElement(TH);
      if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
        return;
      }
      var pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
      var showSortIndicator = pluginSettingsForColumn.indicator;
      var headerActionEnabled = pluginSettingsForColumn.headerAction;
      this.updateHeaderClasses(headerSpanElement, this.columnStatesManager, column, showSortIndicator, headerActionEnabled);
    }
  }, {
    key: "updateHeaderClasses",
    value: function updateHeaderClasses(headerSpanElement) {
      removeClass(headerSpanElement, getClassesToRemove());
      if (this.enabled !== false) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        addClass(headerSpanElement, getClassesToAdd.apply(void 0, args));
      }
    }
  }, {
    key: "onUpdateSettings",
    value: function onUpdateSettings(newSettings) {
      _get$g(_getPrototypeOf$D(ColumnSorting2.prototype), "onUpdateSettings", this).call(this);
      if (this.columnMetaCache !== null) {
        this.columnMetaCache.init(this.hot.columnIndexMapper.getNumberOfIndexes());
      }
      if (isDefined(newSettings[this.pluginKey])) {
        this.sortBySettings(newSettings[this.pluginKey]);
      }
    }
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(initialLoad) {
      if (initialLoad === true) {
        if (this.hot.view) {
          this.loadOrSortBySettings();
        }
      }
    }
  }, {
    key: "wasClickableHeaderClicked",
    value: function wasClickableHeaderClicked(event, column) {
      var pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
      var headerActionEnabled = pluginSettingsForColumn.headerAction;
      return headerActionEnabled && event.target.nodeName === "SPAN";
    }
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event, coords, TD, blockCalculations) {
      if (wasHeaderClickedProperly(coords.row, coords.col, event) === false) {
        return;
      }
      if (this.wasClickableHeaderClicked(event, coords.col) && isPressedCtrlKey()) {
        blockCalculations.column = true;
      }
    }
  }, {
    key: "onAfterOnCellMouseDown",
    value: function onAfterOnCellMouseDown(event, coords) {
      if (wasHeaderClickedProperly(coords.row, coords.col, event) === false) {
        return;
      }
      if (this.wasClickableHeaderClicked(event, coords.col)) {
        if (isPressedCtrlKey()) {
          this.hot.deselectCell();
          this.hot.selectColumns(coords.col);
        }
        this.sort(this.getColumnNextConfig(coords.col));
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$columnStatesMan;
      (_this$columnStatesMan = this.columnStatesManager) === null || _this$columnStatesMan === void 0 ? void 0 : _this$columnStatesMan.destroy();
      _get$g(_getPrototypeOf$D(ColumnSorting2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$6;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$5;
    }
  }]);
  return ColumnSorting2;
}(BasePlugin);

function _classCallCheck$1s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1n(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1n(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1n(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1n(Constructor, staticProps);
  return Constructor;
}
var CommentEditor = /* @__PURE__ */ function() {
  function CommentEditor2(rootDocument) {
    _classCallCheck$1s(this, CommentEditor2);
    this.container = null;
    this.rootDocument = rootDocument;
    this.editor = this.createEditor();
    this.editorStyle = this.editor.style;
    this.hidden = true;
    this.hide();
  }
  _createClass$1n(CommentEditor2, [{
    key: "setPosition",
    value: function setPosition(x, y) {
      this.editorStyle.left = "".concat(x, "px");
      this.editorStyle.top = "".concat(y, "px");
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      if (width && height) {
        var input = this.getInputElement();
        input.style.width = "".concat(width, "px");
        input.style.height = "".concat(height, "px");
      }
    }
  }, {
    key: "resetSize",
    value: function resetSize() {
      var input = this.getInputElement();
      input.style.width = "";
      input.style.height = "";
    }
  }, {
    key: "setReadOnlyState",
    value: function setReadOnlyState(state) {
      var input = this.getInputElement();
      input.readOnly = state;
    }
  }, {
    key: "show",
    value: function show() {
      this.editorStyle.display = "block";
      this.hidden = false;
    }
  }, {
    key: "hide",
    value: function hide() {
      this.editorStyle.display = "none";
      this.hidden = true;
    }
  }, {
    key: "isVisible",
    value: function isVisible() {
      return this.editorStyle.display === "block";
    }
  }, {
    key: "setValue",
    value: function setValue() {
      var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var comment = value || "";
      this.getInputElement().value = comment;
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.getInputElement().value;
    }
  }, {
    key: "isFocused",
    value: function isFocused() {
      return this.rootDocument.activeElement === this.getInputElement();
    }
  }, {
    key: "focus",
    value: function focus() {
      this.getInputElement().focus();
    }
  }, {
    key: "createEditor",
    value: function createEditor() {
      var editor = this.rootDocument.createElement("div");
      var textArea = this.rootDocument.createElement("textarea");
      this.container = this.rootDocument.createElement("div");
      addClass(this.container, CommentEditor2.CLASS_EDITOR_CONTAINER);
      this.rootDocument.body.appendChild(this.container);
      addClass(editor, CommentEditor2.CLASS_EDITOR);
      addClass(textArea, CommentEditor2.CLASS_INPUT);
      editor.appendChild(textArea);
      this.container.appendChild(editor);
      return editor;
    }
  }, {
    key: "getInputElement",
    value: function getInputElement() {
      return this.editor.querySelector(".".concat(CommentEditor2.CLASS_INPUT));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var containerParentElement = this.container ? this.container.parentNode : null;
      this.editor.parentNode.removeChild(this.editor);
      this.editor = null;
      this.editorStyle = null;
      if (containerParentElement) {
        containerParentElement.removeChild(this.container);
      }
    }
  }], [{
    key: "CLASS_EDITOR_CONTAINER",
    get: function get() {
      return "htCommentsContainer";
    }
  }, {
    key: "CLASS_EDITOR",
    get: function get() {
      return "htComments";
    }
  }, {
    key: "CLASS_INPUT",
    get: function get() {
      return "htCommentTextArea";
    }
  }, {
    key: "CLASS_CELL",
    get: function get() {
      return "htCommentCell";
    }
  }]);
  return CommentEditor2;
}();

var KEY = "---------";
function separatorItem() {
  return {
    name: KEY
  };
}

function normalizeSelection(selRanges) {
  return arrayMap(selRanges, function(range) {
    return {
      start: range.getTopLeftCorner(),
      end: range.getBottomRightCorner()
    };
  });
}
function isSeparator(cell) {
  return hasClass(cell, "htSeparator");
}
function hasSubMenu(cell) {
  return hasClass(cell, "htSubmenu");
}
function isDisabled(cell) {
  return hasClass(cell, "htDisabled");
}
function isSelectionDisabled(cell) {
  return hasClass(cell, "htSelectionDisabled");
}
function getValidSelection(hot) {
  var selected = hot.getSelected();
  if (!selected) {
    return null;
  }
  if (selected[0] < 0) {
    return null;
  }
  return selected;
}
function prepareVerticalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  var replacedClassName = className.replace("htTop", "").replace("htMiddle", "").replace("htBottom", "").replace("  ", "");
  return "".concat(replacedClassName, " ").concat(alignment);
}
function prepareHorizontalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  var replacedClassName = className.replace("htLeft", "").replace("htCenter", "").replace("htRight", "").replace("htJustify", "").replace("  ", "");
  return "".concat(replacedClassName, " ").concat(alignment);
}
function getAlignmentClasses(ranges, callback) {
  var classes = {};
  arrayEach(ranges, function(range) {
    range.forAll(function(row, col) {
      if (row >= 0 && col >= 0) {
        if (!classes[row]) {
          classes[row] = [];
        }
        classes[row][col] = callback(row, col);
      }
    });
  });
  return classes;
}
function align(ranges, type, alignment, cellDescriptor, propertySetter) {
  arrayEach(ranges, function(range) {
    range.forAll(function(row, col) {
      if (row >= 0 && col >= 0) {
        applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter);
      }
    });
  });
}
function applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter) {
  var cellMeta = cellDescriptor(row, col);
  var className = alignment;
  if (cellMeta.className) {
    if (type === "vertical") {
      className = prepareVerticalAlignClass(cellMeta.className, alignment);
    } else {
      className = prepareHorizontalAlignClass(cellMeta.className, alignment);
    }
  }
  propertySetter(row, col, "className", className);
}
function checkSelectionConsistency(ranges, comparator) {
  var result = false;
  if (Array.isArray(ranges)) {
    arrayEach(ranges, function(range) {
      range.forAll(function(row, col) {
        if (row >= 0 && col >= 0 && comparator(row, col)) {
          result = true;
          return false;
        }
      });
      return result;
    });
  }
  return result;
}
function markLabelAsSelected(label) {
  return '<span class="selected">'.concat(String.fromCharCode(10003), "</span>").concat(label);
}
function isItemHidden(item, instance) {
  return !item.hidden || !(typeof item.hidden === "function" && item.hidden.call(instance));
}
function shiftSeparators(items, separator) {
  var result = items.slice(0);
  for (var i = 0; i < result.length; ) {
    if (result[i].name === separator) {
      result.shift();
    } else {
      break;
    }
  }
  return result;
}
function popSeparators(items, separator) {
  var result = items.slice(0);
  result.reverse();
  result = shiftSeparators(result, separator);
  result.reverse();
  return result;
}
function removeDuplicatedSeparators(items) {
  var result = [];
  arrayEach(items, function(value, index) {
    if (index > 0) {
      if (result[result.length - 1].name !== value.name) {
        result.push(value);
      }
    } else {
      result.push(value);
    }
  });
  return result;
}
function filterSeparators(items) {
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : KEY;
  var result = items.slice(0);
  result = shiftSeparators(result, separator);
  result = popSeparators(result, separator);
  result = removeDuplicatedSeparators(result);
  return result;
}

function _classCallCheck$1t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1o(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1o(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1o(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1o(Constructor, staticProps);
  return Constructor;
}
var DEFAULT_DISPLAY_DELAY = 250;
var DEFAULT_HIDE_DELAY = 250;
var DisplaySwitch = /* @__PURE__ */ function() {
  function DisplaySwitch2(displayDelay) {
    _classCallCheck$1t(this, DisplaySwitch2);
    this.wasLastActionShow = true;
    this.showDebounced = null;
    this.hidingTimer = null;
    this.updateDelay(displayDelay);
  }
  _createClass$1o(DisplaySwitch2, [{
    key: "hide",
    value: function hide() {
      var _this = this;
      this.wasLastActionShow = false;
      this.hidingTimer = setTimeout(function() {
        if (_this.wasLastActionShow === false) {
          _this.runLocalHooks("hide");
        }
      }, DEFAULT_HIDE_DELAY);
    }
  }, {
    key: "show",
    value: function show(range) {
      this.wasLastActionShow = true;
      this.showDebounced(range);
    }
  }, {
    key: "cancelHiding",
    value: function cancelHiding() {
      this.wasLastActionShow = true;
      clearTimeout(this.hidingTimer);
      this.hidingTimer = null;
    }
  }, {
    key: "updateDelay",
    value: function updateDelay() {
      var _this2 = this;
      var displayDelay = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_DISPLAY_DELAY;
      this.showDebounced = debounce(function(range) {
        if (_this2.wasLastActionShow) {
          _this2.runLocalHooks("show", range.from.row, range.from.col);
        }
      }, displayDelay);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clearLocalHooks();
    }
  }]);
  return DisplaySwitch2;
}();
mixin(DisplaySwitch, localHooks);

function _typeof$Q(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$Q = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$Q = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$Q(obj);
}
function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$1u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1p(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1p(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1p(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1p(Constructor, staticProps);
  return Constructor;
}
function _get$h(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$h = Reflect.get;
  } else {
    _get$h = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$h(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$h(target, property, receiver || target);
}
function _superPropBase$h(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$E(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$E(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$F(subClass, superClass);
}
function _setPrototypeOf$F(o, p) {
  _setPrototypeOf$F = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$F(o, p);
}
function _createSuper$E(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$F();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$E(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$E(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$E(this, result);
  };
}
function _possibleConstructorReturn$E(self, call) {
  if (call && (_typeof$Q(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$E(self);
}
function _assertThisInitialized$E(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$F() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$E(o) {
  _getPrototypeOf$E = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$E(o);
}
var PLUGIN_KEY$7 = "comments";
var PLUGIN_PRIORITY$6 = 60;
var privatePool$8 = new WeakMap();
var META_COMMENT = "comment";
var META_COMMENT_VALUE = "value";
var META_STYLE = "style";
var META_READONLY = "readOnly";
var Comments = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$E(Comments2, _BasePlugin);
  var _super = _createSuper$E(Comments2);
  function Comments2(hotInstance) {
    var _this;
    _classCallCheck$1u(this, Comments2);
    _this = _super.call(this, hotInstance);
    _this.editor = null;
    _this.displaySwitch = null;
    _this.eventManager = null;
    _this.range = {};
    _this.mouseDown = false;
    _this.contextMenuEvent = false;
    _this.timer = null;
    privatePool$8.set(_assertThisInitialized$E(_this), {
      tempEditorDimensions: {},
      cellBelowCursor: null
    });
    return _this;
  }
  _createClass$1p(Comments2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$7];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      if (!this.editor) {
        this.editor = new CommentEditor(this.hot.rootDocument);
      }
      if (!this.eventManager) {
        this.eventManager = new EventManager(this);
      }
      if (!this.displaySwitch) {
        this.displaySwitch = new DisplaySwitch(this.getDisplayDelaySetting());
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.addToContextMenu(options);
      });
      this.addHook("afterRenderer", function(TD, row, col, prop, value, cellProperties) {
        return _this2.onAfterRenderer(TD, cellProperties);
      });
      this.addHook("afterScrollHorizontally", function() {
        return _this2.hide();
      });
      this.addHook("afterScrollVertically", function() {
        return _this2.hide();
      });
      this.addHook("afterBeginEditing", function() {
        return _this2.onAfterBeginEditing();
      });
      this.displaySwitch.addLocalHook("hide", function() {
        return _this2.hide();
      });
      this.displaySwitch.addLocalHook("show", function(row, col) {
        return _this2.showAtCell(row, col);
      });
      this.registerListeners();
      _get$h(_getPrototypeOf$E(Comments2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$h(_getPrototypeOf$E(Comments2.prototype), "updatePlugin", this).call(this);
      this.displaySwitch.updateDelay(this.getDisplayDelaySetting());
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get$h(_getPrototypeOf$E(Comments2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this3 = this;
      var rootDocument = this.hot.rootDocument;
      this.eventManager.addEventListener(rootDocument, "mouseover", function(event) {
        return _this3.onMouseOver(event);
      });
      this.eventManager.addEventListener(rootDocument, "mousedown", function(event) {
        return _this3.onMouseDown(event);
      });
      this.eventManager.addEventListener(rootDocument, "mouseup", function() {
        return _this3.onMouseUp();
      });
      this.eventManager.addEventListener(this.editor.getInputElement(), "blur", function() {
        return _this3.onEditorBlur();
      });
      this.eventManager.addEventListener(this.editor.getInputElement(), "mousedown", function(event) {
        return _this3.onEditorMouseDown(event);
      });
      this.eventManager.addEventListener(this.editor.getInputElement(), "mouseup", function(event) {
        return _this3.onEditorMouseUp(event);
      });
    }
  }, {
    key: "setRange",
    value: function setRange(range) {
      this.range = range;
    }
  }, {
    key: "clearRange",
    value: function clearRange() {
      this.range = {};
    }
  }, {
    key: "targetIsCellWithComment",
    value: function targetIsCellWithComment(event) {
      var closestCell = closest(event.target, "TD", "TBODY");
      return !!(closestCell && hasClass(closestCell, "htCommentCell") && closest(closestCell, [this.hot.rootElement]));
    }
  }, {
    key: "targetIsCommentTextArea",
    value: function targetIsCommentTextArea(event) {
      return this.editor.getInputElement() === event.target;
    }
  }, {
    key: "setComment",
    value: function setComment(value) {
      if (!this.range.from) {
        throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
      }
      var editorValue = this.editor.getValue();
      var comment = "";
      if (value !== null && value !== void 0) {
        comment = value;
      } else if (editorValue !== null && editorValue !== void 0) {
        comment = editorValue;
      }
      var row = this.range.from.row;
      var col = this.range.from.col;
      this.updateCommentMeta(row, col, _defineProperty$g({}, META_COMMENT_VALUE, comment));
      this.hot.render();
    }
  }, {
    key: "setCommentAtCell",
    value: function setCommentAtCell(row, column, value) {
      this.setRange({
        from: new CellCoords(row, column)
      });
      this.setComment(value);
    }
  }, {
    key: "removeComment",
    value: function removeComment() {
      var forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!this.range.from) {
        throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
      }
      this.hot.setCellMeta(this.range.from.row, this.range.from.col, META_COMMENT, void 0);
      if (forceRender) {
        this.hot.render();
      }
      this.hide();
    }
  }, {
    key: "removeCommentAtCell",
    value: function removeCommentAtCell(row, column) {
      var forceRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      this.setRange({
        from: new CellCoords(row, column)
      });
      this.removeComment(forceRender);
    }
  }, {
    key: "getComment",
    value: function getComment() {
      var row = this.range.from.row;
      var column = this.range.from.col;
      return this.getCommentMeta(row, column, META_COMMENT_VALUE);
    }
  }, {
    key: "getCommentAtCell",
    value: function getCommentAtCell(row, column) {
      return this.getCommentMeta(row, column, META_COMMENT_VALUE);
    }
  }, {
    key: "show",
    value: function show() {
      if (!this.range.from) {
        throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
      }
      var _this$range$from = this.range.from, row = _this$range$from.row, col = _this$range$from.col;
      if (row < 0 || row > this.hot.countSourceRows() - 1 || col < 0 || col > this.hot.countSourceCols() - 1) {
        return false;
      }
      var meta = this.hot.getCellMeta(this.range.from.row, this.range.from.col);
      this.refreshEditor(true);
      this.editor.setValue(meta[META_COMMENT] ? meta[META_COMMENT][META_COMMENT_VALUE] : "");
      if (this.editor.hidden) {
        this.editor.show();
      }
      return true;
    }
  }, {
    key: "showAtCell",
    value: function showAtCell(row, column) {
      this.setRange({
        from: new CellCoords(row, column)
      });
      return this.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      if (!this.editor.hidden) {
        this.editor.hide();
      }
    }
  }, {
    key: "refreshEditor",
    value: function refreshEditor() {
      var _renderableRow, _renderableColumn;
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!force && (!this.range.from || !this.editor.isVisible())) {
        return;
      }
      var _this$hot = this.hot, rowIndexMapper = _this$hot.rowIndexMapper, columnIndexMapper = _this$hot.columnIndexMapper;
      var _this$range$from2 = this.range.from, visualRow = _this$range$from2.row, visualColumn = _this$range$from2.col;
      var renderableRow = rowIndexMapper.getRenderableFromVisualIndex(visualRow);
      var renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(visualColumn);
      var targetingPreviousRow = renderableRow === null;
      if (renderableRow === null) {
        renderableRow = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getFirstNotHiddenIndex(visualRow, -1));
      }
      if (renderableColumn === null) {
        renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getFirstNotHiddenIndex(visualColumn, -1));
      }
      var isBeforeRenderedRows = renderableRow === null;
      var isBeforeRenderedColumns = renderableColumn === null;
      renderableRow = (_renderableRow = renderableRow) !== null && _renderableRow !== void 0 ? _renderableRow : 0;
      renderableColumn = (_renderableColumn = renderableColumn) !== null && _renderableColumn !== void 0 ? _renderableColumn : 0;
      var _this$hot2 = this.hot, rootWindow = _this$hot2.rootWindow, wt = _this$hot2.view.wt;
      var wtTable = wt.wtTable, wtOverlays = wt.wtOverlays, wtViewport = wt.wtViewport;
      var scrollableElement = wtOverlays.scrollableElement;
      var TD = wtTable.getCell({
        row: renderableRow,
        col: renderableColumn
      });
      var cellOffset = offset$1(TD);
      var lastColWidth = isBeforeRenderedColumns ? 0 : wtTable.getStretchedColumnWidth(renderableColumn);
      var lastRowHeight = targetingPreviousRow && !isBeforeRenderedRows ? outerHeight(TD) : 0;
      var cellTopOffset = cellOffset.top;
      var cellLeftOffset = cellOffset.left;
      if (wtViewport.hasVerticalScroll() && scrollableElement !== rootWindow) {
        cellTopOffset -= wtOverlays.topOverlay.getScrollPosition();
      }
      if (wtViewport.hasHorizontalScroll() && scrollableElement !== rootWindow) {
        cellLeftOffset -= wtOverlays.leftOverlay.getScrollPosition();
      }
      var x = cellLeftOffset + lastColWidth;
      var y = cellTopOffset + lastRowHeight;
      var commentStyle = this.getCommentMeta(visualRow, visualColumn, META_STYLE);
      var readOnly = this.getCommentMeta(visualRow, visualColumn, META_READONLY);
      if (commentStyle) {
        this.editor.setSize(commentStyle.width, commentStyle.height);
      } else {
        this.editor.resetSize();
      }
      this.editor.setReadOnlyState(readOnly);
      this.editor.setPosition(x, y);
    }
  }, {
    key: "checkSelectionCommentsConsistency",
    value: function checkSelectionCommentsConsistency() {
      var selected = this.hot.getSelectedRangeLast();
      if (!selected) {
        return false;
      }
      var hasComment = false;
      var cell = selected.getTopLeftCorner();
      if (this.getCommentMeta(cell.row, cell.col, META_COMMENT_VALUE)) {
        hasComment = true;
      }
      return hasComment;
    }
  }, {
    key: "updateCommentMeta",
    value: function updateCommentMeta(row, column, metaObject) {
      var oldComment = this.hot.getCellMeta(row, column)[META_COMMENT];
      var newComment;
      if (oldComment) {
        newComment = deepClone(oldComment);
        deepExtend(newComment, metaObject);
      } else {
        newComment = metaObject;
      }
      this.hot.setCellMeta(row, column, META_COMMENT, newComment);
    }
  }, {
    key: "getCommentMeta",
    value: function getCommentMeta(row, column, property) {
      var cellMeta = this.hot.getCellMeta(row, column);
      if (!cellMeta[META_COMMENT]) {
        return void 0;
      }
      return cellMeta[META_COMMENT][property];
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      this.mouseDown = true;
      if (!this.hot.view || !this.hot.view.wt) {
        return;
      }
      if (!this.contextMenuEvent && !this.targetIsCommentTextArea(event)) {
        var eventCell = closest(event.target, "TD", "TBODY");
        var coordinates = null;
        if (eventCell) {
          coordinates = this.hot.view.wt.wtTable.getCoords(eventCell);
          coordinates = {
            row: this.hot.rowIndexMapper.getVisualFromRenderableIndex(coordinates.row),
            col: this.hot.columnIndexMapper.getVisualFromRenderableIndex(coordinates.col)
          };
        }
        if (!eventCell || this.range.from && coordinates && (this.range.from.row !== coordinates.row || this.range.from.col !== coordinates.col)) {
          this.hide();
        }
      }
      this.contextMenuEvent = false;
    }
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event) {
      var priv = privatePool$8.get(this);
      var rootDocument = this.hot.rootDocument;
      priv.cellBelowCursor = rootDocument.elementFromPoint(event.clientX, event.clientY);
      if (this.mouseDown || this.editor.isFocused() || hasClass(event.target, "wtBorder") || priv.cellBelowCursor !== event.target || !this.editor) {
        return;
      }
      if (this.targetIsCellWithComment(event)) {
        var coordinates = this.hot.view.wt.wtTable.getCoords(event.target);
        var range = {
          from: new CellCoords(this.hot.rowIndexMapper.getVisualFromRenderableIndex(coordinates.row), this.hot.columnIndexMapper.getVisualFromRenderableIndex(coordinates.col))
        };
        this.displaySwitch.show(range);
      } else if (isChildOf(event.target, rootDocument) && !this.targetIsCommentTextArea(event)) {
        this.displaySwitch.hide();
      }
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp() {
      this.mouseDown = false;
    }
  }, {
    key: "onAfterRenderer",
    value: function onAfterRenderer(TD, cellProperties) {
      if (cellProperties[META_COMMENT] && cellProperties[META_COMMENT][META_COMMENT_VALUE]) {
        addClass(TD, cellProperties.commentedCellClassName);
      }
    }
  }, {
    key: "onEditorBlur",
    value: function onEditorBlur() {
      this.setComment();
    }
  }, {
    key: "onEditorMouseDown",
    value: function onEditorMouseDown(event) {
      var priv = privatePool$8.get(this);
      priv.tempEditorDimensions = {
        width: outerWidth(event.target),
        height: outerHeight(event.target)
      };
    }
  }, {
    key: "onEditorMouseUp",
    value: function onEditorMouseUp(event) {
      var priv = privatePool$8.get(this);
      var currentWidth = outerWidth(event.target);
      var currentHeight = outerHeight(event.target);
      if (currentWidth !== priv.tempEditorDimensions.width + 1 || currentHeight !== priv.tempEditorDimensions.height + 2) {
        this.updateCommentMeta(this.range.from.row, this.range.from.col, _defineProperty$g({}, META_STYLE, {
          width: currentWidth,
          height: currentHeight
        }));
      }
    }
  }, {
    key: "onContextMenuAddComment",
    value: function onContextMenuAddComment() {
      var _this4 = this;
      this.displaySwitch.cancelHiding();
      var coords = this.hot.getSelectedRangeLast();
      this.contextMenuEvent = true;
      this.setRange({
        from: coords.highlight
      });
      this.show();
      setTimeout(function() {
        if (_this4.hot) {
          _this4.hot.deselectCell();
          _this4.editor.focus();
        }
      }, 10);
    }
  }, {
    key: "onContextMenuRemoveComment",
    value: function onContextMenuRemoveComment() {
      var _this5 = this;
      var coords = this.hot.getSelectedRangeLast();
      this.contextMenuEvent = true;
      coords.forAll(function(row, column) {
        if (row >= 0 && column >= 0) {
          _this5.removeCommentAtCell(row, column, false);
        }
      });
      this.hot.render();
    }
  }, {
    key: "onContextMenuMakeReadOnly",
    value: function onContextMenuMakeReadOnly() {
      var _this6 = this;
      var coords = this.hot.getSelectedRangeLast();
      this.contextMenuEvent = true;
      coords.forAll(function(row, column) {
        if (row >= 0 && column >= 0) {
          var currentState = !!_this6.getCommentMeta(row, column, META_READONLY);
          _this6.updateCommentMeta(row, column, _defineProperty$g({}, META_READONLY, !currentState));
        }
      });
    }
  }, {
    key: "addToContextMenu",
    value: function addToContextMenu(defaultOptions) {
      var _this7 = this;
      var isThereAnyCellRendered = function isThereAnyCellRendered2() {
        return _this7.hot.rowIndexMapper.getRenderableIndexesLength() > 0 && _this7.hot.columnIndexMapper.getRenderableIndexesLength() > 0;
      };
      defaultOptions.items.push({
        name: "---------"
      }, {
        key: "commentsAddEdit",
        name: function name() {
          if (_this7.checkSelectionCommentsConsistency()) {
            return _this7.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_EDIT_COMMENT);
          }
          return _this7.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_ADD_COMMENT);
        },
        callback: function callback() {
          return _this7.onContextMenuAddComment();
        },
        disabled: function disabled() {
          if (!isThereAnyCellRendered()) {
            return true;
          }
          return !(_this7.hot.getSelectedLast() && !_this7.hot.selection.isSelectedByCorner());
        }
      }, {
        key: "commentsRemove",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COMMENT);
        },
        callback: function callback() {
          return _this7.onContextMenuRemoveComment();
        },
        disabled: function disabled() {
          if (!isThereAnyCellRendered()) {
            return true;
          }
          return !(_this7.hot.getSelectedLast() && !_this7.hot.selection.isSelectedByCorner());
        }
      }, {
        key: "commentsReadOnly",
        name: function name() {
          var _this8 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY_COMMENT);
          var hasProperty = checkSelectionConsistency(this.getSelectedRangeLast(), function(row, col) {
            var readOnlyProperty = _this8.getCellMeta(row, col)[META_COMMENT];
            if (readOnlyProperty) {
              readOnlyProperty = readOnlyProperty[META_READONLY];
            }
            if (readOnlyProperty) {
              return true;
            }
          });
          if (hasProperty) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          return _this7.onContextMenuMakeReadOnly();
        },
        disabled: function disabled() {
          if (!isThereAnyCellRendered()) {
            return true;
          }
          return !(_this7.hot.getSelectedLast() && !_this7.hot.selection.isSelectedByCorner()) || !_this7.checkSelectionCommentsConsistency();
        }
      });
    }
  }, {
    key: "getDisplayDelaySetting",
    value: function getDisplayDelaySetting() {
      var commentSetting = this.hot.getSettings()[PLUGIN_KEY$7];
      if (isObject(commentSetting)) {
        return commentSetting.displayDelay;
      }
      return void 0;
    }
  }, {
    key: "onAfterBeginEditing",
    value: function onAfterBeginEditing() {
      this.hide();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.editor) {
        this.editor.destroy();
      }
      if (this.displaySwitch) {
        this.displaySwitch.destroy();
      }
      _get$h(_getPrototypeOf$E(Comments2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$7;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$6;
    }
  }]);
  return Comments2;
}(BasePlugin);

function _classCallCheck$1v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1q(Constructor, staticProps);
  return Constructor;
}
var CommandExecutor = /* @__PURE__ */ function() {
  function CommandExecutor2(hotInstance) {
    _classCallCheck$1v(this, CommandExecutor2);
    this.hot = hotInstance;
    this.commands = {};
    this.commonCallback = null;
  }
  _createClass$1q(CommandExecutor2, [{
    key: "registerCommand",
    value: function registerCommand(name, commandDescriptor) {
      this.commands[name] = commandDescriptor;
    }
  }, {
    key: "setCommonCallback",
    value: function setCommonCallback(callback) {
      this.commonCallback = callback;
    }
  }, {
    key: "execute",
    value: function execute(commandName) {
      var _this = this;
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      var commandSplit = commandName.split(":");
      var commandNamePrimary = commandSplit[0];
      var subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;
      var command = this.commands[commandNamePrimary];
      if (!command) {
        throw new Error("Menu command '".concat(commandNamePrimary, "' not exists."));
      }
      if (subCommandName && command.submenu) {
        command = findSubCommand(subCommandName, command.submenu.items);
      }
      if (command.disabled === true) {
        return;
      }
      if (typeof command.disabled === "function" && command.disabled.call(this.hot) === true) {
        return;
      }
      if (hasOwnProperty(command, "submenu")) {
        return;
      }
      var callbacks = [];
      if (typeof command.callback === "function") {
        callbacks.push(command.callback);
      }
      if (typeof this.commonCallback === "function") {
        callbacks.push(this.commonCallback);
      }
      params.unshift(commandSplit.join(":"));
      arrayEach(callbacks, function(callback) {
        return callback.apply(_this.hot, params);
      });
    }
  }]);
  return CommandExecutor2;
}();
function findSubCommand(subCommandName, subCommands) {
  var command;
  arrayEach(subCommands, function(cmd) {
    var cmds = cmd.key ? cmd.key.split(":") : null;
    if (Array.isArray(cmds) && cmds[1] === subCommandName) {
      command = cmd;
      return false;
    }
  });
  return command;
}

var KEY$1 = "alignment";
function alignmentItem() {
  return {
    key: KEY$1,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT);
    },
    disabled: function disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      return !(this.getSelectedRange() && !this.selection.isSelectedByCorner());
    },
    submenu: {
      items: [{
        key: "".concat(KEY$1, ":left"),
        name: function name() {
          var _this = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);
          var hasClass = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this.getCellMeta(row, col).className;
            if (className && className.indexOf("htLeft") !== -1) {
              return true;
            }
          });
          if (hasClass) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this2 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this2.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htLeft";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this2.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this2.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$1, ":center"),
        name: function name() {
          var _this3 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);
          var hasClass = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this3.getCellMeta(row, col).className;
            if (className && className.indexOf("htCenter") !== -1) {
              return true;
            }
          });
          if (hasClass) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this4 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this4.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htCenter";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this4.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this4.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$1, ":right"),
        name: function name() {
          var _this5 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);
          var hasClass = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this5.getCellMeta(row, col).className;
            if (className && className.indexOf("htRight") !== -1) {
              return true;
            }
          });
          if (hasClass) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this6 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this6.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htRight";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this6.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this6.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$1, ":justify"),
        name: function name() {
          var _this7 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);
          var hasClass = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this7.getCellMeta(row, col).className;
            if (className && className.indexOf("htJustify") !== -1) {
              return true;
            }
          });
          if (hasClass) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this8 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this8.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htJustify";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this8.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this8.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        name: KEY
      }, {
        key: "".concat(KEY$1, ":top"),
        name: function name() {
          var _this9 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_TOP);
          var hasClass = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this9.getCellMeta(row, col).className;
            if (className && className.indexOf("htTop") !== -1) {
              return true;
            }
          });
          if (hasClass) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this10 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this10.getCellMeta(row, col).className;
          });
          var type = "vertical";
          var alignment = "htTop";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this10.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this10.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$1, ":middle"),
        name: function name() {
          var _this11 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);
          var hasClass = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this11.getCellMeta(row, col).className;
            if (className && className.indexOf("htMiddle") !== -1) {
              return true;
            }
          });
          if (hasClass) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this12 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this12.getCellMeta(row, col).className;
          });
          var type = "vertical";
          var alignment = "htMiddle";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this12.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this12.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY$1, ":bottom"),
        name: function name() {
          var _this13 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);
          var hasClass = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this13.getCellMeta(row, col).className;
            if (className && className.indexOf("htBottom") !== -1) {
              return true;
            }
          });
          if (hasClass) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this14 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this14.getCellMeta(row, col).className;
          });
          var type = "vertical";
          var alignment = "htBottom";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this14.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this14.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }]
    }
  };
}

var KEY$2 = "clear_column";
function clearColumnItem() {
  return {
    key: KEY$2,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CLEAR_COLUMN);
    },
    callback: function callback(key, selection) {
      var startColumn = selection[0].start.col;
      var endColumn = selection[0].end.col;
      if (this.countRows()) {
        this.populateFromArray(0, startColumn, [[null]], Math.max(selection[0].start.row, selection[0].end.row), endColumn, "ContextMenu.clearColumn");
      }
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      return !this.selection.isSelectedByColumnHeader();
    }
  };
}

var KEY$3 = "col_left";
function columnLeftItem() {
  return {
    key: KEY$3,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_LEFT);
    },
    callback: function callback(key, normalizedSelection) {
      var isSelectedByCorner = this.selection.isSelectedByCorner();
      var columnLeft = 0;
      if (!isSelectedByCorner) {
        var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
        columnLeft = latestSelection.start.col;
      }
      this.alter("insert_col", columnLeft, 1, "ContextMenu.columnLeft");
      if (isSelectedByCorner) {
        this.selectAll();
      }
    },
    disabled: function disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        var totalColumns = this.countCols();
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

var KEY$4 = "col_right";
function columnRightItem() {
  return {
    key: KEY$4,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_RIGHT);
    },
    callback: function callback(key, normalizedSelection) {
      var isSelectedByCorner = this.selection.isSelectedByCorner();
      var columnRight = 0;
      if (isSelectedByCorner) {
        columnRight = this.countCols();
      } else {
        var _latestSelection$end;
        var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
        var selectedColumn = latestSelection === null || latestSelection === void 0 ? void 0 : (_latestSelection$end = latestSelection.end) === null || _latestSelection$end === void 0 ? void 0 : _latestSelection$end.col;
        columnRight = isDefined(selectedColumn) ? selectedColumn + 1 : 0;
      }
      this.alter("insert_col", columnRight, 1, "ContextMenu.columnRight");
      if (isSelectedByCorner) {
        this.selectAll();
      }
    },
    disabled: function disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

var KEY$5 = "make_read_only";
function readOnlyItem() {
  return {
    key: KEY$5,
    name: function name() {
      var _this = this;
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY);
      var atLeastOneReadOnly = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
        return _this.getCellMeta(row, col).readOnly;
      });
      if (atLeastOneReadOnly) {
        label = markLabelAsSelected(label);
      }
      return label;
    },
    callback: function callback() {
      var _this2 = this;
      var ranges = this.getSelectedRange();
      var atLeastOneReadOnly = checkSelectionConsistency(ranges, function(row, col) {
        return _this2.getCellMeta(row, col).readOnly;
      });
      arrayEach(ranges, function(range) {
        range.forAll(function(row, col) {
          if (row >= 0 && col >= 0) {
            _this2.setCellMeta(row, col, "readOnly", !atLeastOneReadOnly);
          }
        });
      });
      this.render();
    },
    disabled: function disabled() {
      if (this.selection.isSelectedByCorner()) {
        return true;
      }
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      if (!this.getSelectedRange() || this.getSelectedRange().length === 0) {
        return true;
      }
      return false;
    }
  };
}

var KEY$6 = "redo";
function redoItem() {
  return {
    key: KEY$6,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REDO);
    },
    callback: function callback() {
      this.redo();
    },
    hidden: function hidden() {
      var undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled: function disabled() {
      return !this.getPlugin("undoRedo").isRedoAvailable();
    }
  };
}

function _slicedToArray$j(arr, i) {
  return _arrayWithHoles$k(arr) || _iterableToArrayLimit$j(arr, i) || _unsupportedIterableToArray$v(arr, i) || _nonIterableRest$k();
}
function _nonIterableRest$k() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$v(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$v(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$v(o, minLen);
}
function _arrayLikeToArray$v(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$j(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$k(arr) {
  if (Array.isArray(arr))
    return arr;
}
var KEY$7 = "remove_col";
function removeColumnItem() {
  return {
    key: KEY$7,
    name: function name() {
      var selection = this.getSelected();
      var pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          var _selection$ = _slicedToArray$j(selection[0], 4), fromColumn = _selection$[1], toColumn = _selection$[3];
          if (fromColumn - toColumn !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COLUMN, pluralForm);
    },
    callback: function callback() {
      this.alter("remove_col", transformSelectionToColumnDistance(this.getSelected()), null, "ContextMenu.removeColumn");
    },
    disabled: function disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      var totalColumns = this.countCols();
      if (this.selection.isSelectedByCorner()) {
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || totalColumns === 0;
    },
    hidden: function hidden() {
      return !this.getSettings().allowRemoveColumn;
    }
  };
}

function _slicedToArray$k(arr, i) {
  return _arrayWithHoles$l(arr) || _iterableToArrayLimit$k(arr, i) || _unsupportedIterableToArray$w(arr, i) || _nonIterableRest$l();
}
function _nonIterableRest$l() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$w(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$w(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$w(o, minLen);
}
function _arrayLikeToArray$w(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$k(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$l(arr) {
  if (Array.isArray(arr))
    return arr;
}
var KEY$8 = "remove_row";
function removeRowItem() {
  return {
    key: KEY$8,
    name: function name() {
      var selection = this.getSelected();
      var pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          var _selection$ = _slicedToArray$k(selection[0], 3), fromRow = _selection$[0], toRow = _selection$[2];
          if (fromRow - toRow !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_ROW, pluralForm);
    },
    callback: function callback() {
      this.alter("remove_row", transformSelectionToRowDistance(this.getSelected()), 1, "ContextMenu.removeRow");
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      var totalRows = this.countRows();
      if (this.selection.isSelectedByCorner()) {
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || totalRows === 0;
    },
    hidden: function hidden() {
      return !this.getSettings().allowRemoveRow;
    }
  };
}

var KEY$9 = "row_above";
function rowAboveItem() {
  return {
    key: KEY$9,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_ABOVE);
    },
    callback: function callback(key, normalizedSelection) {
      var isSelectedByCorner = this.selection.isSelectedByCorner();
      var rowAbove = 0;
      if (!isSelectedByCorner) {
        var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
        rowAbove = latestSelection.start.row;
      }
      this.alter("insert_row", rowAbove, 1, "ContextMenu.rowAbove");
      if (isSelectedByCorner) {
        this.selectAll();
      }
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        var totalRows = this.countRows();
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

var KEY$a = "row_below";
function rowBelowItem() {
  return {
    key: KEY$a,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_BELOW);
    },
    callback: function callback(key, normalizedSelection) {
      var isSelectedByCorner = this.selection.isSelectedByCorner();
      var rowBelow = 0;
      if (isSelectedByCorner) {
        rowBelow = this.countRows();
      } else {
        var _latestSelection$end;
        var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
        var selectedRow = latestSelection === null || latestSelection === void 0 ? void 0 : (_latestSelection$end = latestSelection.end) === null || _latestSelection$end === void 0 ? void 0 : _latestSelection$end.row;
        rowBelow = isDefined(selectedRow) ? selectedRow + 1 : 0;
      }
      this.alter("insert_row", rowBelow, 1, "ContextMenu.rowBelow");
      if (isSelectedByCorner) {
        this.selectAll();
      }
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

var KEY$b = "no_items";
function noItemsItem() {
  return {
    key: KEY$b,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NO_ITEMS);
    },
    disabled: true,
    isCommand: false
  };
}

var KEY$c = "undo";
function undoItem() {
  return {
    key: KEY$c,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNDO);
    },
    callback: function callback() {
      this.undo();
    },
    hidden: function hidden() {
      var undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled: function disabled() {
      return !this.getPlugin("undoRedo").isUndoAvailable();
    }
  };
}

var _predefinedItems2;
function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var ITEMS = [KEY$9, KEY$a, KEY$3, KEY$4, KEY$2, KEY$8, KEY$7, KEY$c, KEY$6, KEY$5, KEY$1, KEY, KEY$b];
var _predefinedItems = (_predefinedItems2 = {}, _defineProperty$h(_predefinedItems2, KEY, separatorItem), _defineProperty$h(_predefinedItems2, KEY$b, noItemsItem), _defineProperty$h(_predefinedItems2, KEY$9, rowAboveItem), _defineProperty$h(_predefinedItems2, KEY$a, rowBelowItem), _defineProperty$h(_predefinedItems2, KEY$3, columnLeftItem), _defineProperty$h(_predefinedItems2, KEY$4, columnRightItem), _defineProperty$h(_predefinedItems2, KEY$2, clearColumnItem), _defineProperty$h(_predefinedItems2, KEY$8, removeRowItem), _defineProperty$h(_predefinedItems2, KEY$7, removeColumnItem), _defineProperty$h(_predefinedItems2, KEY$c, undoItem), _defineProperty$h(_predefinedItems2, KEY$6, redoItem), _defineProperty$h(_predefinedItems2, KEY$5, readOnlyItem), _defineProperty$h(_predefinedItems2, KEY$1, alignmentItem), _predefinedItems2);
function predefinedItems() {
  var items = {};
  objectEach(_predefinedItems, function(itemFactory, key) {
    items[key] = itemFactory();
  });
  return items;
}

function _classCallCheck$1w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1r(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1r(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1r(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1r(Constructor, staticProps);
  return Constructor;
}
var ItemsFactory = /* @__PURE__ */ function() {
  function ItemsFactory2(hotInstance) {
    var orderPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    _classCallCheck$1w(this, ItemsFactory2);
    this.hot = hotInstance;
    this.predefinedItems = predefinedItems();
    this.defaultOrderPattern = orderPattern;
  }
  _createClass$1r(ItemsFactory2, [{
    key: "setPredefinedItems",
    value: function setPredefinedItems(predefinedItemsCollection) {
      var _this = this;
      var items = {};
      this.defaultOrderPattern.length = 0;
      objectEach(predefinedItemsCollection, function(value, key) {
        var menuItemKey = "";
        if (value.name === KEY) {
          items[KEY] = value;
          menuItemKey = KEY;
        } else if (isNaN(parseInt(key, 10))) {
          value.key = value.key === void 0 ? key : value.key;
          items[key] = value;
          menuItemKey = value.key;
        } else {
          items[value.key] = value;
          menuItemKey = value.key;
        }
        _this.defaultOrderPattern.push(menuItemKey);
      });
      this.predefinedItems = items;
    }
  }, {
    key: "getItems",
    value: function getItems() {
      var pattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return _getItems(pattern, this.defaultOrderPattern, this.predefinedItems);
    }
  }]);
  return ItemsFactory2;
}();
function _getItems() {
  var itemsPattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
  var defaultPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var items = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var result = [];
  var pattern = itemsPattern;
  if (pattern && pattern.items) {
    pattern = pattern.items;
  } else if (!Array.isArray(pattern)) {
    pattern = defaultPattern;
  }
  if (isObject(pattern)) {
    objectEach(pattern, function(value, key) {
      var item = items[typeof value === "string" ? value : key];
      if (!item) {
        item = value;
      }
      if (isObject(value)) {
        extend(item, value);
      } else if (typeof item === "string") {
        item = {
          name: item
        };
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  } else {
    arrayEach(pattern, function(name, key) {
      var item = items[name];
      if (!item && ITEMS.indexOf(name) >= 0) {
        return;
      }
      if (!item) {
        item = {
          name,
          key: "".concat(key)
        };
      }
      if (isObject(name)) {
        extend(item, name);
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  }
  return result;
}

function _classCallCheck$1x(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1s(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1s(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1s(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1s(Constructor, staticProps);
  return Constructor;
}
var Cursor = /* @__PURE__ */ function() {
  function Cursor2(object, rootWindow) {
    _classCallCheck$1x(this, Cursor2);
    var windowScrollTop = getWindowScrollTop(rootWindow);
    var windowScrollLeft = getWindowScrollLeft(rootWindow);
    var top;
    var topRelative;
    var left;
    var leftRelative;
    var cellHeight;
    var cellWidth;
    this.rootWindow = rootWindow;
    this.type = this.getSourceType(object);
    if (this.type === "literal") {
      top = parseInt(object.top, 10);
      left = parseInt(object.left, 10);
      cellHeight = object.height || 0;
      cellWidth = object.width || 0;
      topRelative = top;
      leftRelative = left;
      top += windowScrollTop;
      left += windowScrollLeft;
    } else if (this.type === "event") {
      top = parseInt(object.pageY, 10);
      left = parseInt(object.pageX, 10);
      cellHeight = object.target.clientHeight;
      cellWidth = object.target.clientWidth;
      topRelative = top - windowScrollTop;
      leftRelative = left - windowScrollLeft;
    }
    this.top = top;
    this.topRelative = topRelative;
    this.left = left;
    this.leftRelative = leftRelative;
    this.scrollTop = windowScrollTop;
    this.scrollLeft = windowScrollLeft;
    this.cellHeight = cellHeight;
    this.cellWidth = cellWidth;
  }
  _createClass$1s(Cursor2, [{
    key: "getSourceType",
    value: function getSourceType(object) {
      var type = "literal";
      if (object instanceof Event) {
        type = "event";
      }
      return type;
    }
  }, {
    key: "fitsAbove",
    value: function fitsAbove(element) {
      return this.topRelative >= element.offsetHeight;
    }
  }, {
    key: "fitsBelow",
    value: function fitsBelow(element) {
      var viewportHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerHeight;
      return this.topRelative + element.offsetHeight <= viewportHeight;
    }
  }, {
    key: "fitsOnRight",
    value: function fitsOnRight(element) {
      var viewportWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerWidth;
      return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;
    }
  }, {
    key: "fitsOnLeft",
    value: function fitsOnLeft(element) {
      return this.leftRelative >= element.offsetWidth;
    }
  }]);
  return Cursor2;
}();

function _classCallCheck$1y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1t(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1t(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1t(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1t(Constructor, staticProps);
  return Constructor;
}
var MIN_WIDTH = 215;
var Menu = /* @__PURE__ */ function() {
  function Menu2(hotInstance, options) {
    _classCallCheck$1y(this, Menu2);
    this.hot = hotInstance;
    this.options = options || {
      parent: null,
      name: null,
      className: "",
      keepInViewport: true,
      standalone: false,
      minWidth: MIN_WIDTH,
      container: this.hot.rootDocument.documentElement
    };
    this.eventManager = new EventManager(this);
    this.container = this.createContainer(this.options.name);
    this.hotMenu = null;
    this.hotSubMenus = {};
    this.parentMenu = this.options.parent || null;
    this.menuItems = null;
    this.origOutsideClickDeselects = null;
    this.keyEvent = false;
    this.offset = {
      above: 0,
      below: 0,
      left: 0,
      right: 0
    };
    this._afterScrollCallback = null;
    this.registerEvents();
  }
  _createClass$1t(Menu2, [{
    key: "registerEvents",
    value: function registerEvents() {
      var _this = this;
      var frame = this.hot.rootWindow;
      while (frame) {
        this.eventManager.addEventListener(frame.document, "mousedown", function(event) {
          return _this.onDocumentMouseDown(event);
        });
        this.eventManager.addEventListener(frame.document, "contextmenu", function(event) {
          return _this.onDocumentContextMenu(event);
        });
        frame = getParentWindow(frame);
      }
    }
  }, {
    key: "setMenuItems",
    value: function setMenuItems(menuItems) {
      this.menuItems = menuItems;
    }
  }, {
    key: "getSelectedItem",
    value: function getSelectedItem() {
      return this.hasSelectedItem() ? this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelectedLast()[0]) : null;
    }
  }, {
    key: "hasSelectedItem",
    value: function hasSelectedItem() {
      return Array.isArray(this.hotMenu.getSelectedLast());
    }
  }, {
    key: "setOffset",
    value: function setOffset(area) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      this.offset[area] = offset;
    }
  }, {
    key: "isSubMenu",
    value: function isSubMenu() {
      return this.parentMenu !== null;
    }
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;
      this.runLocalHooks("beforeOpen");
      this.container.removeAttribute("style");
      this.container.style.display = "block";
      var delayedOpenSubMenu = debounce(function(row) {
        return _this2.openSubMenu(row);
      }, 300);
      var minWidthOfMenu = this.options.minWidth || MIN_WIDTH;
      var noItemsDefined = false;
      var filteredItems = arrayFilter(this.menuItems, function(item) {
        if (item.key === KEY$b) {
          noItemsDefined = true;
        }
        return isItemHidden(item, _this2.hot);
      });
      if (filteredItems.length < 1 && !noItemsDefined) {
        filteredItems.push(predefinedItems()[KEY$b]);
      } else if (filteredItems.length === 0) {
        return;
      }
      filteredItems = filterSeparators(filteredItems, KEY);
      var shouldAutoCloseMenu = false;
      var settings = {
        data: filteredItems,
        colHeaders: false,
        autoColumnSize: true,
        autoWrapRow: false,
        modifyColWidth: function modifyColWidth(width) {
          if (isDefined(width) && width < minWidthOfMenu) {
            return minWidthOfMenu;
          }
          return width;
        },
        autoRowSize: false,
        readOnly: true,
        editor: false,
        copyPaste: false,
        maxCols: 1,
        columns: [{
          data: "name",
          renderer: function renderer(hot, TD, row, col, prop, value) {
            return _this2.menuItemRenderer(hot, TD, row, col, prop, value);
          }
        }],
        renderAllRows: true,
        fragmentSelection: false,
        outsideClickDeselects: false,
        disableVisualSelection: "area",
        beforeKeyDown: function beforeKeyDown(event) {
          return _this2.onBeforeKeyDown(event);
        },
        afterOnCellMouseOver: function afterOnCellMouseOver(event, coords) {
          if (_this2.isAllSubMenusClosed()) {
            delayedOpenSubMenu(coords.row);
          } else {
            _this2.openSubMenu(coords.row);
          }
        },
        rowHeights: function rowHeights(row) {
          return filteredItems[row].name === KEY ? 1 : 23;
        },
        afterOnCellContextMenu: function afterOnCellContextMenu(event) {
          event.preventDefault();
          if (isWindowsOS() && shouldAutoCloseMenu && _this2.hasSelectedItem()) {
            _this2.close(true);
          }
        },
        beforeOnCellMouseUp: function beforeOnCellMouseUp(event) {
          if (_this2.hasSelectedItem()) {
            shouldAutoCloseMenu = !_this2.isCommandPassive(_this2.getSelectedItem());
            _this2.executeCommand(event);
          }
        },
        afterOnCellMouseUp: function afterOnCellMouseUp(event) {
          if ((!isWindowsOS() || !isRightClick(event)) && shouldAutoCloseMenu && _this2.hasSelectedItem()) {
            if (isMobileBrowser() || isIpadOS()) {
              setTimeout(function() {
                return _this2.close(true);
              }, 325);
            } else {
              _this2.close(true);
            }
          }
        },
        afterUnlisten: function afterUnlisten() {
          if (!_this2.hasSelectedItem() && _this2.isOpened()) {
            _this2.hotMenu.listen();
          }
        }
      };
      this.origOutsideClickDeselects = this.hot.getSettings().outsideClickDeselects;
      this.hot.getSettings().outsideClickDeselects = false;
      this.hotMenu = new Core(this.container, settings);
      this.hotMenu.addHook("afterInit", function() {
        return _this2.onAfterInit();
      });
      this.hotMenu.addHook("afterSelection", function() {
        return _this2.onAfterSelection.apply(_this2, arguments);
      });
      this.hotMenu.init();
      this.hotMenu.listen();
      this.blockMainTableCallbacks();
      this.runLocalHooks("afterOpen");
    }
  }, {
    key: "close",
    value: function close() {
      var closeParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!this.isOpened()) {
        return;
      }
      if (closeParent && this.parentMenu) {
        this.parentMenu.close();
      } else {
        this.closeAllSubMenus();
        this.container.style.display = "none";
        this.releaseMainTableCallbacks();
        this.hotMenu.destroy();
        this.hotMenu = null;
        this.hot.getSettings().outsideClickDeselects = this.origOutsideClickDeselects;
        this.runLocalHooks("afterClose");
        if (this.parentMenu) {
          this.parentMenu.hotMenu.listen();
        }
      }
    }
  }, {
    key: "openSubMenu",
    value: function openSubMenu(row) {
      if (!this.hotMenu) {
        return false;
      }
      var cell = this.hotMenu.getCell(row, 0);
      this.closeAllSubMenus();
      if (!cell || !hasSubMenu(cell)) {
        return false;
      }
      var dataItem = this.hotMenu.getSourceDataAtRow(row);
      var subMenu = new Menu2(this.hot, {
        parent: this,
        name: dataItem.name,
        className: this.options.className,
        keepInViewport: true,
        container: this.options.container
      });
      subMenu.setMenuItems(dataItem.submenu.items);
      subMenu.open();
      subMenu.setPosition(cell.getBoundingClientRect());
      this.hotSubMenus[dataItem.key] = subMenu;
      return subMenu;
    }
  }, {
    key: "closeSubMenu",
    value: function closeSubMenu(row) {
      var dataItem = this.hotMenu.getSourceDataAtRow(row);
      var menus = this.hotSubMenus[dataItem.key];
      if (menus) {
        menus.destroy();
        delete this.hotSubMenus[dataItem.key];
      }
    }
  }, {
    key: "closeAllSubMenus",
    value: function closeAllSubMenus() {
      var _this3 = this;
      arrayEach(this.hotMenu.getData(), function(value, row) {
        return _this3.closeSubMenu(row);
      });
    }
  }, {
    key: "isAllSubMenusClosed",
    value: function isAllSubMenusClosed() {
      return Object.keys(this.hotSubMenus).length === 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var menuContainerParentElement = this.container.parentNode;
      this.clearLocalHooks();
      this.close();
      this.parentMenu = null;
      this.eventManager.destroy();
      if (menuContainerParentElement) {
        menuContainerParentElement.removeChild(this.container);
      }
    }
  }, {
    key: "isOpened",
    value: function isOpened() {
      return this.hotMenu !== null;
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(event) {
      if (!this.isOpened() || !this.hasSelectedItem()) {
        return;
      }
      var selectedItem = this.getSelectedItem();
      this.runLocalHooks("select", selectedItem, event);
      if (this.isCommandPassive(selectedItem)) {
        return;
      }
      var selRanges = this.hot.getSelectedRange();
      var normalizedSelection = selRanges ? normalizeSelection(selRanges) : [];
      this.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event);
      if (this.isSubMenu()) {
        this.parentMenu.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event);
      }
    }
  }, {
    key: "isCommandPassive",
    value: function isCommandPassive(commandDescriptor) {
      var isCommand = commandDescriptor.isCommand, commandName = commandDescriptor.name, disabled = commandDescriptor.disabled, submenu = commandDescriptor.submenu;
      var isItemDisabled = disabled === true || typeof disabled === "function" && disabled.call(this.hot) === true;
      return isCommand === false || commandName === KEY || isItemDisabled === true || submenu;
    }
  }, {
    key: "setPosition",
    value: function setPosition(coords) {
      var cursor = new Cursor(coords, this.container.ownerDocument.defaultView);
      if (this.options.keepInViewport) {
        if (cursor.fitsBelow(this.container)) {
          this.setPositionBelowCursor(cursor);
        } else if (cursor.fitsAbove(this.container)) {
          this.setPositionAboveCursor(cursor);
        } else {
          this.setPositionBelowCursor(cursor);
        }
        if (cursor.fitsOnRight(this.container)) {
          this.setPositionOnRightOfCursor(cursor);
        } else {
          this.setPositionOnLeftOfCursor(cursor);
        }
      } else {
        this.setPositionBelowCursor(cursor);
        this.setPositionOnRightOfCursor(cursor);
      }
    }
  }, {
    key: "setPositionAboveCursor",
    value: function setPositionAboveCursor(cursor) {
      var top = this.offset.above + cursor.top - this.container.offsetHeight;
      if (this.isSubMenu()) {
        top = cursor.top + cursor.cellHeight - this.container.offsetHeight + 3;
      }
      this.container.style.top = "".concat(top, "px");
    }
  }, {
    key: "setPositionBelowCursor",
    value: function setPositionBelowCursor(cursor) {
      var top = this.offset.below + cursor.top + 1;
      if (this.isSubMenu()) {
        top = cursor.top - 1;
      }
      this.container.style.top = "".concat(top, "px");
    }
  }, {
    key: "setPositionOnRightOfCursor",
    value: function setPositionOnRightOfCursor(cursor) {
      var left;
      if (this.isSubMenu()) {
        left = 1 + cursor.left + cursor.cellWidth;
      } else {
        left = this.offset.right + 1 + cursor.left;
      }
      this.container.style.left = "".concat(left, "px");
    }
  }, {
    key: "setPositionOnLeftOfCursor",
    value: function setPositionOnLeftOfCursor(cursor) {
      var scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);
      var left = this.offset.left + cursor.left - this.container.offsetWidth + scrollbarWidth + 4;
      this.container.style.left = "".concat(left, "px");
    }
  }, {
    key: "selectFirstCell",
    value: function selectFirstCell() {
      var cell = this.hotMenu.getCell(0, 0);
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectNextCell(0, 0);
      } else {
        this.hotMenu.selectCell(0, 0);
      }
    }
  }, {
    key: "selectLastCell",
    value: function selectLastCell() {
      var lastRow = this.hotMenu.countRows() - 1;
      var cell = this.hotMenu.getCell(lastRow, 0);
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectPrevCell(lastRow, 0);
      } else {
        this.hotMenu.selectCell(lastRow, 0);
      }
    }
  }, {
    key: "selectNextCell",
    value: function selectNextCell(row, col) {
      var nextRow = row + 1;
      var cell = nextRow < this.hotMenu.countRows() ? this.hotMenu.getCell(nextRow, col) : null;
      if (!cell) {
        return;
      }
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectNextCell(nextRow, col);
      } else {
        this.hotMenu.selectCell(nextRow, col);
      }
    }
  }, {
    key: "selectPrevCell",
    value: function selectPrevCell(row, col) {
      var prevRow = row - 1;
      var cell = prevRow >= 0 ? this.hotMenu.getCell(prevRow, col) : null;
      if (!cell) {
        return;
      }
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectPrevCell(prevRow, col);
      } else {
        this.hotMenu.selectCell(prevRow, col);
      }
    }
  }, {
    key: "menuItemRenderer",
    value: function menuItemRenderer(hot, TD, row, col, prop, value) {
      var _this4 = this;
      var item = hot.getSourceDataAtRow(row);
      var wrapper = this.hot.rootDocument.createElement("div");
      var isSubMenu = function isSubMenu2(itemToTest) {
        return hasOwnProperty(itemToTest, "submenu");
      };
      var itemIsSeparator = function itemIsSeparator2(itemToTest) {
        return new RegExp(KEY, "i").test(itemToTest.name);
      };
      var itemIsDisabled = function itemIsDisabled2(itemToTest) {
        return itemToTest.disabled === true || typeof itemToTest.disabled === "function" && itemToTest.disabled.call(_this4.hot) === true;
      };
      var itemIsSelectionDisabled = function itemIsSelectionDisabled2(itemToTest) {
        return itemToTest.disableSelection;
      };
      var itemValue = value;
      if (typeof itemValue === "function") {
        itemValue = itemValue.call(this.hot);
      }
      empty(TD);
      addClass(wrapper, "htItemWrapper");
      TD.appendChild(wrapper);
      if (itemIsSeparator(item)) {
        addClass(TD, "htSeparator");
      } else if (typeof item.renderer === "function") {
        addClass(TD, "htCustomMenuRenderer");
        TD.appendChild(item.renderer(hot, wrapper, row, col, prop, itemValue));
      } else {
        fastInnerHTML(wrapper, itemValue);
      }
      if (itemIsDisabled(item)) {
        addClass(TD, "htDisabled");
        this.eventManager.addEventListener(TD, "mouseenter", function() {
          return hot.deselectCell();
        });
      } else if (itemIsSelectionDisabled(item)) {
        addClass(TD, "htSelectionDisabled");
        this.eventManager.addEventListener(TD, "mouseenter", function() {
          return hot.deselectCell();
        });
      } else if (isSubMenu(item)) {
        addClass(TD, "htSubmenu");
        if (itemIsSelectionDisabled(item)) {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.deselectCell();
          });
        } else {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.selectCell(row, col, void 0, void 0, false, false);
          });
        }
      } else {
        removeClass(TD, ["htSubmenu", "htDisabled"]);
        if (itemIsSelectionDisabled(item)) {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.deselectCell();
          });
        } else {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.selectCell(row, col, void 0, void 0, false, false);
          });
        }
      }
    }
  }, {
    key: "createContainer",
    value: function createContainer() {
      var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      var doc = this.options.container.ownerDocument;
      var className = name;
      var container;
      if (className) {
        if (isFunction$1(className)) {
          className = className.call(this.hot);
          if (className === null || isUndefined$1(className)) {
            className = "";
          } else {
            className = className.toString();
          }
        }
        className = className.replace(/[^A-z0-9]/g, "_");
        className = "".concat(this.options.className, "Sub_").concat(className);
        container = doc.querySelector(".".concat(this.options.className, ".").concat(className));
      }
      if (!container) {
        container = doc.createElement("div");
        addClass(container, "htMenu ".concat(this.options.className));
        if (className) {
          addClass(container, className);
        }
        this.options.container.appendChild(container);
      }
      return container;
    }
  }, {
    key: "blockMainTableCallbacks",
    value: function blockMainTableCallbacks() {
      this._afterScrollCallback = function() {
      };
      this.hot.addHook("afterScrollVertically", this._afterScrollCallback);
      this.hot.addHook("afterScrollHorizontally", this._afterScrollCallback);
    }
  }, {
    key: "releaseMainTableCallbacks",
    value: function releaseMainTableCallbacks() {
      if (this._afterScrollCallback) {
        this.hot.removeHook("afterScrollVertically", this._afterScrollCallback);
        this.hot.removeHook("afterScrollHorizontally", this._afterScrollCallback);
        this._afterScrollCallback = null;
      }
    }
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown(event) {
      if (isInput(event.target) && this.container.contains(event.target)) {
        stopImmediatePropagation(event);
        return;
      }
      var selection = this.hotMenu.getSelectedLast();
      var stopEvent = false;
      this.keyEvent = true;
      switch (event.keyCode) {
        case KEY_CODES.ESCAPE:
          this.close();
          stopEvent = true;
          break;
        case KEY_CODES.ENTER:
          if (selection) {
            if (this.hotMenu.getSourceDataAtRow(selection[0]).submenu) {
              stopEvent = true;
            } else {
              this.executeCommand(event);
              this.close(true);
            }
          }
          break;
        case KEY_CODES.ARROW_DOWN:
          if (selection) {
            this.selectNextCell(selection[0], selection[1]);
          } else {
            this.selectFirstCell();
          }
          stopEvent = true;
          break;
        case KEY_CODES.ARROW_UP:
          if (selection) {
            this.selectPrevCell(selection[0], selection[1]);
          } else {
            this.selectLastCell();
          }
          stopEvent = true;
          break;
        case KEY_CODES.ARROW_RIGHT:
          if (selection) {
            var menu = this.openSubMenu(selection[0]);
            if (menu) {
              menu.selectFirstCell();
            }
          }
          stopEvent = true;
          break;
        case KEY_CODES.ARROW_LEFT:
          if (selection && this.isSubMenu()) {
            this.close();
            if (this.parentMenu) {
              this.parentMenu.hotMenu.listen();
            }
            stopEvent = true;
          }
          break;
      }
      if (stopEvent) {
        event.preventDefault();
        stopImmediatePropagation(event);
      }
      this.keyEvent = false;
    }
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      var wtTable = this.hotMenu.view.wt.wtTable;
      var data = this.hotMenu.getSettings().data;
      var hiderStyle = wtTable.hider.style;
      var holderStyle = wtTable.holder.style;
      var currentHiderWidth = parseInt(hiderStyle.width, 10);
      var realHeight = arrayReduce(data, function(accumulator, value) {
        return accumulator + (value.name === KEY ? 1 : 26);
      }, 0);
      holderStyle.width = "".concat(currentHiderWidth + 3, "px");
      holderStyle.height = "".concat(realHeight + 3, "px");
      hiderStyle.height = holderStyle.height;
    }
  }, {
    key: "onAfterSelection",
    value: function onAfterSelection(r, c, r2, c2, preventScrolling) {
      if (this.keyEvent === false) {
        preventScrolling.value = true;
      }
    }
  }, {
    key: "onDocumentMouseDown",
    value: function onDocumentMouseDown(event) {
      if (!this.isOpened()) {
        return;
      }
      if (this.options.standalone && this.hotMenu && !isChildOf(event.target, this.hotMenu.rootElement)) {
        this.close(true);
      } else if ((this.isAllSubMenusClosed() || this.isSubMenu()) && !isChildOf(event.target, ".htMenu") && (isChildOf(event.target, this.container.ownerDocument) || isChildOf(event.target, this.hot.rootDocument))) {
        this.close(true);
      }
    }
  }, {
    key: "onDocumentContextMenu",
    value: function onDocumentContextMenu(event) {
      if (!this.isOpened()) {
        return;
      }
      if (hasClass(event.target, "htCore") && isChildOf(event.target, this.hotMenu.rootElement)) {
        event.preventDefault();
      }
    }
  }]);
  return Menu2;
}();
mixin(Menu, localHooks);

function _typeof$R(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$R = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$R = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$R(obj);
}
function _classCallCheck$1z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1u(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1u(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1u(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1u(Constructor, staticProps);
  return Constructor;
}
function _get$i(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$i = Reflect.get;
  } else {
    _get$i = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$i(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$i(target, property, receiver || target);
}
function _superPropBase$i(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$F(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$F(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$G(subClass, superClass);
}
function _setPrototypeOf$G(o, p) {
  _setPrototypeOf$G = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$G(o, p);
}
function _createSuper$F(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$G();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$F(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$F(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$F(this, result);
  };
}
function _possibleConstructorReturn$F(self, call) {
  if (call && (_typeof$R(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$F(self);
}
function _assertThisInitialized$F(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$G() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$F(o) {
  _getPrototypeOf$F = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$F(o);
}
var PLUGIN_KEY$8 = "contextMenu";
var PLUGIN_PRIORITY$7 = 70;
Hooks.getSingleton().register("afterContextMenuDefaultOptions");
Hooks.getSingleton().register("beforeContextMenuShow");
Hooks.getSingleton().register("afterContextMenuShow");
Hooks.getSingleton().register("afterContextMenuHide");
Hooks.getSingleton().register("afterContextMenuExecute");
var ContextMenu = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$F(ContextMenu2, _BasePlugin);
  var _super = _createSuper$F(ContextMenu2);
  function ContextMenu2(hotInstance) {
    var _this;
    _classCallCheck$1z(this, ContextMenu2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager(_assertThisInitialized$F(_this));
    _this.commandExecutor = new CommandExecutor(_this.hot);
    _this.itemsFactory = null;
    _this.menu = null;
    return _this;
  }
  _createClass$1u(ContextMenu2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$8];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var settings = this.hot.getSettings()[PLUGIN_KEY$8];
      if (typeof settings.callback === "function") {
        this.commandExecutor.setCommonCallback(settings.callback);
      }
      this.menu = new Menu(this.hot, {
        className: "htContextMenu",
        keepInViewport: true,
        container: settings.uiContainer || this.hot.rootDocument.body
      });
      this.menu.addLocalHook("beforeOpen", function() {
        return _this2.onMenuBeforeOpen();
      });
      this.menu.addLocalHook("afterOpen", function() {
        return _this2.onMenuAfterOpen();
      });
      this.menu.addLocalHook("afterClose", function() {
        return _this2.onMenuAfterClose();
      });
      this.menu.addLocalHook("executeCommand", function() {
        var _this2$executeCommand;
        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }
        return (_this2$executeCommand = _this2.executeCommand).call.apply(_this2$executeCommand, [_this2].concat(params));
      });
      this.addHook("afterOnCellContextMenu", function(event) {
        return _this2.onAfterOnCellContextMenu(event);
      });
      _get$i(_getPrototypeOf$F(ContextMenu2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$i(_getPrototypeOf$F(ContextMenu2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
        this.menu = null;
      }
      _get$i(_getPrototypeOf$F(ContextMenu2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "open",
    value: function open(event) {
      if (!this.menu) {
        return;
      }
      this.prepareMenuItems();
      this.menu.open();
      if (!this.menu.isOpened()) {
        return;
      }
      var offsetTop = 0;
      var offsetLeft = 0;
      if (this.hot.rootDocument !== this.menu.container.ownerDocument) {
        var frameElement = this.hot.rootWindow.frameElement;
        var _frameElement$getBoun = frameElement.getBoundingClientRect(), top = _frameElement$getBoun.top, left = _frameElement$getBoun.left;
        offsetTop = top - getWindowScrollTop(event.view);
        offsetLeft = left - getWindowScrollLeft(event.view);
      } else {
        offsetTop = -1 * getWindowScrollTop(this.menu.hotMenu.rootWindow);
        offsetLeft = -1 * getWindowScrollLeft(this.menu.hotMenu.rootWindow);
      }
      this.menu.setPosition({
        top: parseInt(event.pageY, 10) + offsetTop,
        left: parseInt(event.pageX, 10) + offsetLeft
      });
    }
  }, {
    key: "close",
    value: function close() {
      if (!this.menu) {
        return;
      }
      this.menu.close();
      this.itemsFactory = null;
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(commandName) {
      var _this$commandExecutor;
      if (this.itemsFactory === null) {
        this.prepareMenuItems();
      }
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      (_this$commandExecutor = this.commandExecutor).execute.apply(_this$commandExecutor, [commandName].concat(params));
    }
  }, {
    key: "prepareMenuItems",
    value: function prepareMenuItems() {
      var _this3 = this;
      this.itemsFactory = new ItemsFactory(this.hot, ContextMenu2.DEFAULT_ITEMS);
      var settings = this.hot.getSettings()[PLUGIN_KEY$8];
      var predefinedItems = {
        items: this.itemsFactory.getItems(settings)
      };
      this.hot.runHooks("afterContextMenuDefaultOptions", predefinedItems);
      this.itemsFactory.setPredefinedItems(predefinedItems.items);
      var menuItems = this.itemsFactory.getItems(settings);
      this.hot.runHooks("beforeContextMenuSetItems", menuItems);
      this.menu.setMenuItems(menuItems);
      arrayEach(menuItems, function(command) {
        return _this3.commandExecutor.registerCommand(command.key, command);
      });
    }
  }, {
    key: "onAfterOnCellContextMenu",
    value: function onAfterOnCellContextMenu(event) {
      var settings = this.hot.getSettings();
      var showRowHeaders = settings.rowHeaders;
      var showColHeaders = settings.colHeaders;
      function isValidElement(element2) {
        return element2.nodeName === "TD" || element2.parentNode.nodeName === "TD";
      }
      var element = event.target;
      this.close();
      if (hasClass(element, "handsontableInput")) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      if (!(showRowHeaders || showColHeaders)) {
        if (!isValidElement(element) && !(hasClass(element, "current") && hasClass(element, "wtBorder"))) {
          return;
        }
      }
      this.open(event);
    }
  }, {
    key: "onMenuBeforeOpen",
    value: function onMenuBeforeOpen() {
      this.hot.runHooks("beforeContextMenuShow", this);
    }
  }, {
    key: "onMenuAfterOpen",
    value: function onMenuAfterOpen() {
      this.hot.runHooks("afterContextMenuShow", this);
    }
  }, {
    key: "onMenuAfterClose",
    value: function onMenuAfterClose() {
      this.hot.listen();
      this.hot.runHooks("afterContextMenuHide", this);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
      }
      _get$i(_getPrototypeOf$F(ContextMenu2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$8;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$7;
    }
  }, {
    key: "PLUGIN_DEPS",
    get: function get() {
      return ["plugin:AutoColumnSize"];
    }
  }, {
    key: "DEFAULT_ITEMS",
    get: function get() {
      return [KEY$9, KEY$a, KEY, KEY$3, KEY$4, KEY, KEY$8, KEY$7, KEY, KEY$c, KEY$6, KEY, KEY$5, KEY, KEY$1];
    }
  }]);
  return ContextMenu2;
}(BasePlugin);
ContextMenu.SEPARATOR = {
  name: KEY
};

function copyItem(copyPastePlugin) {
  return {
    key: "copy",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY);
    },
    callback: function callback() {
      copyPastePlugin.copy();
    },
    disabled: function disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      var selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

function cutItem(copyPastePlugin) {
  return {
    key: "cut",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CUT);
    },
    callback: function callback() {
      copyPastePlugin.cut();
    },
    disabled: function disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      var selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

function _classCallCheck$1A(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1v(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1v(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1v(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1v(Constructor, staticProps);
  return Constructor;
}
var ClipboardData = /* @__PURE__ */ function() {
  function ClipboardData2() {
    _classCallCheck$1A(this, ClipboardData2);
    this.data = {};
  }
  _createClass$1v(ClipboardData2, [{
    key: "setData",
    value: function setData(type, value) {
      this.data[type] = value;
    }
  }, {
    key: "getData",
    value: function getData(type) {
      return this.data[type] || void 0;
    }
  }]);
  return ClipboardData2;
}();

function _classCallCheck$1B(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var PasteEvent = function PasteEvent2() {
  _classCallCheck$1B(this, PasteEvent2);
  this.clipboardData = new ClipboardData();
};

// `WeakSet` constructor
// https://tc39.es/ecma262/#sec-weakset-constructor
collection$1('WeakSet', function (init) {
  return function WeakSet() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionWeak);

function _classCallCheck$1C(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1w(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1w(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1w(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1w(Constructor, staticProps);
  return Constructor;
}
var FocusableWrapper = /* @__PURE__ */ function() {
  function FocusableWrapper2(container) {
    _classCallCheck$1C(this, FocusableWrapper2);
    this.rootDocument = container.defaultView ? container : container.ownerDocument;
    this.mainElement = null;
    this.eventManager = new EventManager(this);
    this.listenersCount = new WeakSet();
    this.container = container;
  }
  _createClass$1w(FocusableWrapper2, [{
    key: "useSecondaryElement",
    value: function useSecondaryElement() {
      var el = createOrGetSecondaryElement(this.container);
      if (!this.listenersCount.has(el)) {
        this.listenersCount.add(el);
        forwardEventsToLocalHooks(this.eventManager, el, this);
      }
      this.mainElement = el;
    }
  }, {
    key: "setFocusableElement",
    value: function setFocusableElement(element) {
      if (!this.listenersCount.has(element)) {
        this.listenersCount.add(element);
        forwardEventsToLocalHooks(this.eventManager, element, this);
      }
      this.mainElement = element;
    }
  }, {
    key: "getFocusableElement",
    value: function getFocusableElement() {
      return this.mainElement;
    }
  }, {
    key: "focus",
    value: function focus() {
      this.mainElement.value = " ";
      if (!isMobileBrowser()) {
        selectElementIfAllowed(this.mainElement);
      }
    }
  }]);
  return FocusableWrapper2;
}();
mixin(FocusableWrapper, localHooks);
var refCounter = new WeakMap();
function createElement(container) {
  var focusableWrapper = new FocusableWrapper(container);
  var counter = refCounter.get(container);
  counter = isNaN(counter) ? 0 : counter;
  refCounter.set(container, counter + 1);
  return focusableWrapper;
}
function deactivateElement(wrapper) {
  wrapper.eventManager.clear();
}
var runLocalHooks = function runLocalHooks2(eventName, subject) {
  return function(event) {
    return subject.runLocalHooks(eventName, event);
  };
};
function forwardEventsToLocalHooks(eventManager, element, subject) {
  eventManager.addEventListener(element, "copy", runLocalHooks("copy", subject));
  eventManager.addEventListener(element, "cut", runLocalHooks("cut", subject));
  eventManager.addEventListener(element, "paste", runLocalHooks("paste", subject));
}
var secondaryElements = new WeakMap();
function createOrGetSecondaryElement(container) {
  var secondaryElement = secondaryElements.get(container);
  if (secondaryElement) {
    if (!secondaryElement.parentElement) {
      container.appendChild(secondaryElement);
    }
    return secondaryElement;
  }
  var doc = container.defaultView ? container : container.ownerDocument;
  var element = doc.createElement("textarea");
  secondaryElements.set(container, element);
  element.setAttribute("data-hot-input", "");
  element.className = "HandsontableCopyPaste";
  element.tabIndex = -1;
  element.autocomplete = "off";
  element.wrap = "hard";
  element.value = " ";
  container.appendChild(element);
  return element;
}
function destroyElement(wrapper) {
  if (!(wrapper instanceof FocusableWrapper)) {
    return;
  }
  var counter = refCounter.get(wrapper.container);
  counter = isNaN(counter) ? 0 : counter;
  if (counter > 0) {
    counter -= 1;
  }
  deactivateElement(wrapper);
  if (counter <= 0) {
    counter = 0;
    var secondaryElement = secondaryElements.get(wrapper.container);
    if (secondaryElement && secondaryElement.parentNode) {
      secondaryElement.parentNode.removeChild(secondaryElement);
      secondaryElements.delete(wrapper.container);
    }
    wrapper.mainElement = null;
  }
  refCounter.set(wrapper.container, counter);
}

function _slicedToArray$l(arr, i) {
  return _arrayWithHoles$m(arr) || _iterableToArrayLimit$l(arr, i) || _unsupportedIterableToArray$x(arr, i) || _nonIterableRest$m();
}
function _nonIterableRest$m() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$x(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$x(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$x(o, minLen);
}
function _arrayLikeToArray$x(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$l(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$m(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof$S(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$S = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$S = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$S(obj);
}
function _classCallCheck$1D(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1x(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1x(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1x(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1x(Constructor, staticProps);
  return Constructor;
}
function _get$j(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$j = Reflect.get;
  } else {
    _get$j = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$j(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$j(target, property, receiver || target);
}
function _superPropBase$j(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$G(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$G(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$H(subClass, superClass);
}
function _setPrototypeOf$H(o, p) {
  _setPrototypeOf$H = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$H(o, p);
}
function _createSuper$G(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$H();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$G(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$G(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$G(this, result);
  };
}
function _possibleConstructorReturn$G(self, call) {
  if (call && (_typeof$S(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$G(self);
}
function _assertThisInitialized$G(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$H() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$G(o) {
  _getPrototypeOf$G = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$G(o);
}
Hooks.getSingleton().register("afterCopyLimit");
Hooks.getSingleton().register("modifyCopyableRange");
Hooks.getSingleton().register("beforeCut");
Hooks.getSingleton().register("afterCut");
Hooks.getSingleton().register("beforePaste");
Hooks.getSingleton().register("afterPaste");
Hooks.getSingleton().register("beforeCopy");
Hooks.getSingleton().register("afterCopy");
var PLUGIN_KEY$9 = "copyPaste";
var PLUGIN_PRIORITY$8 = 80;
var ROWS_LIMIT = 1e3;
var COLUMNS_LIMIT = 1e3;
var privatePool$9 = new WeakMap();
var META_HEAD = ['<meta name="generator" content="Handsontable"/>', '<style type="text/css">td{white-space:normal}br{mso-data-placement:same-cell}</style>'].join("");
var CopyPaste = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$G(CopyPaste2, _BasePlugin);
  var _super = _createSuper$G(CopyPaste2);
  function CopyPaste2(hotInstance) {
    var _this;
    _classCallCheck$1D(this, CopyPaste2);
    _this = _super.call(this, hotInstance);
    _this.columnsLimit = COLUMNS_LIMIT;
    _this.copyableRanges = [];
    _this.focusableElement = void 0;
    _this.pasteMode = "overwrite";
    _this.rowsLimit = ROWS_LIMIT;
    _this.uiContainer = _this.hot.rootDocument.body;
    privatePool$9.set(_assertThisInitialized$G(_this), {
      isTriggeredByCopy: false,
      isTriggeredByCut: false,
      isBeginEditing: false,
      isFragmentSelectionEnabled: false
    });
    return _this;
  }
  _createClass$1x(CopyPaste2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$9];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var _this$hot$getSettings = this.hot.getSettings(), settings = _this$hot$getSettings[PLUGIN_KEY$9], fragmentSelection = _this$hot$getSettings.fragmentSelection;
      var priv = privatePool$9.get(this);
      priv.isFragmentSelectionEnabled = !!fragmentSelection;
      if (_typeof$S(settings) === "object") {
        this.pasteMode = settings.pasteMode || this.pasteMode;
        this.rowsLimit = isNaN(settings.rowsLimit) ? this.rowsLimit : settings.rowsLimit;
        this.columnsLimit = isNaN(settings.columnsLimit) ? this.columnsLimit : settings.columnsLimit;
        this.uiContainer = settings.uiContainer || this.uiContainer;
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.onAfterContextMenuDefaultOptions(options);
      });
      this.addHook("afterOnCellMouseUp", function() {
        return _this2.onAfterOnCellMouseUp();
      });
      this.addHook("afterSelectionEnd", function() {
        return _this2.onAfterSelectionEnd();
      });
      this.addHook("beforeKeyDown", function() {
        return _this2.onBeforeKeyDown();
      });
      this.focusableElement = createElement(this.uiContainer);
      this.focusableElement.addLocalHook("copy", function(event) {
        return _this2.onCopy(event);
      }).addLocalHook("cut", function(event) {
        return _this2.onCut(event);
      }).addLocalHook("paste", function(event) {
        return _this2.onPaste(event);
      });
      _get$j(_getPrototypeOf$G(CopyPaste2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.getOrCreateFocusableElement();
      _get$j(_getPrototypeOf$G(CopyPaste2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      if (this.focusableElement) {
        destroyElement(this.focusableElement);
      }
      _get$j(_getPrototypeOf$G(CopyPaste2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "copy",
    value: function copy() {
      var priv = privatePool$9.get(this);
      priv.isTriggeredByCopy = true;
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
      this.hot.rootDocument.execCommand("copy");
    }
  }, {
    key: "cut",
    value: function cut() {
      var priv = privatePool$9.get(this);
      priv.isTriggeredByCut = true;
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
      this.hot.rootDocument.execCommand("cut");
    }
  }, {
    key: "getRangedCopyableData",
    value: function getRangedCopyableData(ranges) {
      var _this3 = this;
      var dataSet = [];
      var copyableRows = [];
      var copyableColumns = [];
      arrayEach(ranges, function(range) {
        rangeEach(range.startRow, range.endRow, function(row) {
          if (copyableRows.indexOf(row) === -1) {
            copyableRows.push(row);
          }
        });
        rangeEach(range.startCol, range.endCol, function(column) {
          if (copyableColumns.indexOf(column) === -1) {
            copyableColumns.push(column);
          }
        });
      });
      arrayEach(copyableRows, function(row) {
        var rowSet = [];
        arrayEach(copyableColumns, function(column) {
          rowSet.push(_this3.hot.getCopyableData(row, column));
        });
        dataSet.push(rowSet);
      });
      return stringify$1(dataSet);
    }
  }, {
    key: "getRangedData",
    value: function getRangedData(ranges) {
      var _this4 = this;
      var dataSet = [];
      var copyableRows = [];
      var copyableColumns = [];
      arrayEach(ranges, function(range) {
        rangeEach(range.startRow, range.endRow, function(row) {
          if (copyableRows.indexOf(row) === -1) {
            copyableRows.push(row);
          }
        });
        rangeEach(range.startCol, range.endCol, function(column) {
          if (copyableColumns.indexOf(column) === -1) {
            copyableColumns.push(column);
          }
        });
      });
      arrayEach(copyableRows, function(row) {
        var rowSet = [];
        arrayEach(copyableColumns, function(column) {
          rowSet.push(_this4.hot.getCopyableData(row, column));
        });
        dataSet.push(rowSet);
      });
      return dataSet;
    }
  }, {
    key: "paste",
    value: function paste() {
      var pastableText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var pastableHtml = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pastableText;
      if (!pastableText && !pastableHtml) {
        return;
      }
      var pasteData = new PasteEvent();
      if (pastableText) {
        pasteData.clipboardData.setData("text/plain", pastableText);
      }
      if (pastableHtml) {
        pasteData.clipboardData.setData("text/html", pastableHtml);
      }
      this.getOrCreateFocusableElement();
      this.onPaste(pasteData);
    }
  }, {
    key: "setCopyableText",
    value: function setCopyableText() {
      var selRange = this.hot.getSelectedRangeLast();
      if (!selRange) {
        return;
      }
      var topLeft = selRange.getTopLeftCorner();
      var bottomRight = selRange.getBottomRightCorner();
      var startRow = topLeft.row;
      var startCol = topLeft.col;
      var endRow = bottomRight.row;
      var endCol = bottomRight.col;
      var finalEndRow = Math.min(endRow, startRow + this.rowsLimit - 1);
      var finalEndCol = Math.min(endCol, startCol + this.columnsLimit - 1);
      this.copyableRanges.length = 0;
      this.copyableRanges.push({
        startRow,
        startCol,
        endRow: finalEndRow,
        endCol: finalEndCol
      });
      this.copyableRanges = this.hot.runHooks("modifyCopyableRange", this.copyableRanges);
      if (endRow !== finalEndRow || endCol !== finalEndCol) {
        this.hot.runHooks("afterCopyLimit", endRow - startRow + 1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);
      }
    }
  }, {
    key: "getOrCreateFocusableElement",
    value: function getOrCreateFocusableElement() {
      var editor = this.hot.getActiveEditor();
      var editableElement = editor ? editor.TEXTAREA : void 0;
      if (editableElement) {
        this.focusableElement.setFocusableElement(editableElement);
      } else {
        this.focusableElement.useSecondaryElement();
      }
    }
  }, {
    key: "isEditorOpened",
    value: function isEditorOpened() {
      var editor = this.hot.getActiveEditor();
      return editor && editor.isOpened();
    }
  }, {
    key: "populateValues",
    value: function populateValues(inputArray) {
      var selection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.hot.getSelectedRangeLast();
      if (!inputArray.length) {
        return;
      }
      var populatedRowsLength = inputArray.length;
      var populatedColumnsLength = inputArray[0].length;
      var newRows = [];
      var _selection$getTopLeft = selection.getTopLeftCorner(), startRow = _selection$getTopLeft.row, startColumn = _selection$getTopLeft.col;
      var _selection$getBottomR = selection.getBottomRightCorner(), endRowFromSelection = _selection$getBottomR.row, endColumnFromSelection = _selection$getBottomR.col;
      var visualRowForPopulatedData = startRow;
      var visualColumnForPopulatedData = startColumn;
      var lastVisualRow = startRow;
      var lastVisualColumn = startColumn;
      while (newRows.length < populatedRowsLength || visualRowForPopulatedData <= endRowFromSelection) {
        var _this$hot$getCellMeta = this.hot.getCellMeta(visualRowForPopulatedData, startColumn), skipRowOnPaste = _this$hot$getCellMeta.skipRowOnPaste, visualRow = _this$hot$getCellMeta.visualRow;
        visualRowForPopulatedData = visualRow + 1;
        if (skipRowOnPaste === true) {
          continue;
        }
        lastVisualRow = visualRow;
        visualColumnForPopulatedData = startColumn;
        var newRow = [];
        var insertedRow = newRows.length % populatedRowsLength;
        while (newRow.length < populatedColumnsLength || visualColumnForPopulatedData <= endColumnFromSelection) {
          var _this$hot$getCellMeta2 = this.hot.getCellMeta(startRow, visualColumnForPopulatedData), skipColumnOnPaste = _this$hot$getCellMeta2.skipColumnOnPaste, visualCol = _this$hot$getCellMeta2.visualCol;
          visualColumnForPopulatedData = visualCol + 1;
          if (skipColumnOnPaste === true) {
            continue;
          }
          lastVisualColumn = visualCol;
          var insertedColumn = newRow.length % populatedColumnsLength;
          newRow.push(inputArray[insertedRow][insertedColumn]);
        }
        newRows.push(newRow);
      }
      this.hot.populateFromArray(startRow, startColumn, newRows, void 0, void 0, "CopyPaste.paste", this.pasteMode);
      return [startRow, startColumn, lastVisualRow, lastVisualColumn];
    }
  }, {
    key: "onCopy",
    value: function onCopy(event) {
      var priv = privatePool$9.get(this);
      if (!this.hot.isListening() && !priv.isTriggeredByCopy || this.isEditorOpened()) {
        return;
      }
      this.setCopyableText();
      priv.isTriggeredByCopy = false;
      var rangedData = this.getRangedData(this.copyableRanges);
      var allowCopying = !!this.hot.runHooks("beforeCopy", rangedData, this.copyableRanges);
      if (allowCopying) {
        var textPlain = stringify$1(rangedData);
        if (event && event.clipboardData) {
          var textHTML = _dataToHTML(rangedData, this.hot.rootDocument);
          event.clipboardData.setData("text/plain", textPlain);
          event.clipboardData.setData("text/html", [META_HEAD, textHTML].join(""));
        } else if (typeof ClipboardEvent === "undefined") {
          this.hot.rootWindow.clipboardData.setData("Text", textPlain);
        }
        this.hot.runHooks("afterCopy", rangedData, this.copyableRanges);
      }
      event.preventDefault();
    }
  }, {
    key: "onCut",
    value: function onCut(event) {
      var priv = privatePool$9.get(this);
      if (!this.hot.isListening() && !priv.isTriggeredByCut || this.isEditorOpened()) {
        return;
      }
      this.setCopyableText();
      priv.isTriggeredByCut = false;
      var rangedData = this.getRangedData(this.copyableRanges);
      var allowCuttingOut = !!this.hot.runHooks("beforeCut", rangedData, this.copyableRanges);
      if (allowCuttingOut) {
        var textPlain = stringify$1(rangedData);
        if (event && event.clipboardData) {
          var textHTML = _dataToHTML(rangedData, this.hot.rootDocument);
          event.clipboardData.setData("text/plain", textPlain);
          event.clipboardData.setData("text/html", [META_HEAD, textHTML].join(""));
        } else if (typeof ClipboardEvent === "undefined") {
          this.hot.rootWindow.clipboardData.setData("Text", textPlain);
        }
        this.hot.emptySelectedCells("CopyPaste.cut");
        this.hot.runHooks("afterCut", rangedData, this.copyableRanges);
      }
      event.preventDefault();
    }
  }, {
    key: "onPaste",
    value: function onPaste(event) {
      if (!this.hot.isListening() || this.isEditorOpened()) {
        return;
      }
      if (event && event.preventDefault) {
        event.preventDefault();
      }
      var pastedData;
      if (event && typeof event.clipboardData !== "undefined") {
        var textHTML = sanitize(event.clipboardData.getData("text/html"), {
          ADD_TAGS: ["meta"],
          ADD_ATTR: ["content"],
          FORCE_BODY: true
        });
        if (textHTML && /(<table)|(<TABLE)/g.test(textHTML)) {
          var parsedConfig = htmlToGridSettings(textHTML, this.hot.rootDocument);
          pastedData = parsedConfig.data;
        } else {
          pastedData = event.clipboardData.getData("text/plain");
        }
      } else if (typeof ClipboardEvent === "undefined" && typeof this.hot.rootWindow.clipboardData !== "undefined") {
        pastedData = this.hot.rootWindow.clipboardData.getData("Text");
      }
      if (typeof pastedData === "string") {
        pastedData = parse(pastedData);
      }
      if (pastedData && pastedData.length === 0) {
        return;
      }
      if (this.hot.runHooks("beforePaste", pastedData, this.copyableRanges) === false) {
        return;
      }
      var _this$populateValues = this.populateValues(pastedData), _this$populateValues2 = _slicedToArray$l(_this$populateValues, 4), startRow = _this$populateValues2[0], startColumn = _this$populateValues2[1], endRow = _this$populateValues2[2], endColumn = _this$populateValues2[3];
      this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, endRow), Math.min(this.hot.countCols() - 1, endColumn));
      this.hot.runHooks("afterPaste", pastedData, this.copyableRanges);
    }
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(options) {
      options.items.push({
        name: "---------"
      }, copyItem(this), cutItem(this));
    }
  }, {
    key: "onAfterOnCellMouseUp",
    value: function onAfterOnCellMouseUp() {
      if (!this.hot.isListening() || this.isEditorOpened() || this.hot.getSettings().fragmentSelection) {
        return;
      }
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
    }
  }, {
    key: "onAfterSelectionEnd",
    value: function onAfterSelectionEnd() {
      var _privatePool$get = privatePool$9.get(this), isFragmentSelectionEnabled = _privatePool$get.isFragmentSelectionEnabled;
      if (this.isEditorOpened()) {
        return;
      }
      this.getOrCreateFocusableElement();
      if (isFragmentSelectionEnabled && this.focusableElement.getFocusableElement() !== this.hot.rootDocument.activeElement && getSelectionText()) {
        return;
      }
      this.setCopyableText();
      this.focusableElement.focus();
    }
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown() {
      if (!this.hot.isListening() || this.isEditorOpened()) {
        return;
      }
      var activeElement = this.hot.rootDocument.activeElement;
      var activeEditor = this.hot.getActiveEditor();
      if (!activeEditor || activeElement !== this.focusableElement.getFocusableElement() && activeElement !== activeEditor.select) {
        return;
      }
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.focusableElement) {
        destroyElement(this.focusableElement);
        this.focusableElement = null;
      }
      _get$j(_getPrototypeOf$G(CopyPaste2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$9;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$8;
    }
  }]);
  return CopyPaste2;
}(BasePlugin);

function createId(row, col) {
  return "border_row".concat(row, "col").concat(col);
}
function createDefaultCustomBorder() {
  return {
    width: 1,
    color: "#000"
  };
}
function createSingleEmptyBorder() {
  return {
    hide: true
  };
}
function createDefaultHtBorder() {
  return {
    width: 1,
    color: "#000",
    cornerVisible: false
  };
}
function createEmptyBorders(row, col) {
  return {
    id: createId(row, col),
    border: createDefaultHtBorder(),
    row,
    col,
    top: createSingleEmptyBorder(),
    right: createSingleEmptyBorder(),
    bottom: createSingleEmptyBorder(),
    left: createSingleEmptyBorder()
  };
}
function extendDefaultBorder(defaultBorder, customBorder) {
  if (hasOwnProperty(customBorder, "border")) {
    defaultBorder.border = customBorder.border;
  }
  if (hasOwnProperty(customBorder, "top")) {
    if (customBorder.top) {
      if (!isObject(customBorder.top)) {
        customBorder.top = createDefaultCustomBorder();
      }
      defaultBorder.top = customBorder.top;
    } else {
      customBorder.top = createSingleEmptyBorder();
      defaultBorder.top = customBorder.top;
    }
  }
  if (hasOwnProperty(customBorder, "right")) {
    if (customBorder.right) {
      if (!isObject(customBorder.right)) {
        customBorder.right = createDefaultCustomBorder();
      }
      defaultBorder.right = customBorder.right;
    } else {
      customBorder.right = createSingleEmptyBorder();
      defaultBorder.right = customBorder.right;
    }
  }
  if (hasOwnProperty(customBorder, "bottom")) {
    if (customBorder.bottom) {
      if (!isObject(customBorder.bottom)) {
        customBorder.bottom = createDefaultCustomBorder();
      }
      defaultBorder.bottom = customBorder.bottom;
    } else {
      customBorder.bottom = createSingleEmptyBorder();
      defaultBorder.bottom = customBorder.bottom;
    }
  }
  if (hasOwnProperty(customBorder, "left")) {
    if (customBorder.left) {
      if (!isObject(customBorder.left)) {
        customBorder.left = createDefaultCustomBorder();
      }
      defaultBorder.left = customBorder.left;
    } else {
      customBorder.left = createSingleEmptyBorder();
      defaultBorder.left = customBorder.left;
    }
  }
  return defaultBorder;
}
function checkSelectionBorders(hot, direction) {
  var atLeastOneHasBorder = false;
  arrayEach(hot.getSelectedRange(), function(range) {
    range.forAll(function(r, c) {
      if (r < 0 || c < 0) {
        return;
      }
      var metaBorders = hot.getCellMeta(r, c).borders;
      if (metaBorders) {
        if (direction) {
          if (!hasOwnProperty(metaBorders[direction], "hide") || metaBorders[direction].hide === false) {
            atLeastOneHasBorder = true;
            return false;
          }
        } else {
          atLeastOneHasBorder = true;
          return false;
        }
      }
    });
  });
  return atLeastOneHasBorder;
}
function markSelected(label) {
  return '<span class="selected">'.concat(String.fromCharCode(10003), "</span>").concat(label);
}

function bottom(customBordersPlugin) {
  return {
    key: "borders:bottom",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_BOTTOM);
      var hasBorder = checkSelectionBorders(this, "bottom");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "bottom");
      customBordersPlugin.prepareBorder(selected, "bottom", hasBorder);
    }
  };
}

function left(customBordersPlugin) {
  return {
    key: "borders:left",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_LEFT);
      var hasBorder = checkSelectionBorders(this, "left");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "left");
      customBordersPlugin.prepareBorder(selected, "left", hasBorder);
    }
  };
}

function noBorders(customBordersPlugin) {
  return {
    key: "borders:no_borders",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_BORDERS);
    },
    callback: function callback(key, selected) {
      customBordersPlugin.prepareBorder(selected, "noBorders");
    },
    disabled: function disabled() {
      return !checkSelectionBorders(this);
    }
  };
}

function right(customBordersPlugin) {
  return {
    key: "borders:right",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_RIGHT);
      var hasBorder = checkSelectionBorders(this, "right");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "right");
      customBordersPlugin.prepareBorder(selected, "right", hasBorder);
    }
  };
}

function top(customBordersPlugin) {
  return {
    key: "borders:top",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_TOP);
      var hasBorder = checkSelectionBorders(this, "top");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "top");
      customBordersPlugin.prepareBorder(selected, "top", hasBorder);
    }
  };
}

function _typeof$T(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$T = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$T = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$T(obj);
}
function _slicedToArray$m(arr, i) {
  return _arrayWithHoles$n(arr) || _iterableToArrayLimit$m(arr, i) || _unsupportedIterableToArray$y(arr, i) || _nonIterableRest$n();
}
function _nonIterableRest$n() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$y(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$y(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$y(o, minLen);
}
function _arrayLikeToArray$y(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$m(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$n(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1E(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1y(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1y(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1y(Constructor, staticProps);
  return Constructor;
}
function _get$k(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$k = Reflect.get;
  } else {
    _get$k = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$k(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$k(target, property, receiver || target);
}
function _superPropBase$k(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$H(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$H(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$I(subClass, superClass);
}
function _setPrototypeOf$I(o, p) {
  _setPrototypeOf$I = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$I(o, p);
}
function _createSuper$H(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$I();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$H(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$H(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$H(this, result);
  };
}
function _possibleConstructorReturn$H(self, call) {
  if (call && (_typeof$T(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$H(self);
}
function _assertThisInitialized$H(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$I() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$H(o) {
  _getPrototypeOf$H = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$H(o);
}
var PLUGIN_KEY$a = "customBorders";
var PLUGIN_PRIORITY$9 = 90;
var CustomBorders = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$H(CustomBorders2, _BasePlugin);
  var _super = _createSuper$H(CustomBorders2);
  function CustomBorders2(hotInstance) {
    var _this;
    _classCallCheck$1E(this, CustomBorders2);
    _this = _super.call(this, hotInstance);
    _this.savedBorders = [];
    return _this;
  }
  _createClass$1y(CustomBorders2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$a];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.onAfterContextMenuDefaultOptions(options);
      });
      this.addHook("init", function() {
        return _this2.onAfterInit();
      });
      _get$k(_getPrototypeOf$H(CustomBorders2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hideBorders();
      _get$k(_getPrototypeOf$H(CustomBorders2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.changeBorderSettings();
      _get$k(_getPrototypeOf$H(CustomBorders2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "setBorders",
    value: function setBorders(selectionRanges, borderObject) {
      var _this3 = this;
      var defaultBorderKeys = ["top", "right", "bottom", "left"];
      var borderKeys = borderObject ? Object.keys(borderObject) : defaultBorderKeys;
      var selectionType = detectSelectionType(selectionRanges);
      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
      arrayEach(selectionRanges, function(selection) {
        var _selectionSchemaNorma = selectionSchemaNormalizer(selection), _selectionSchemaNorma2 = _slicedToArray$m(_selectionSchemaNorma, 4), rowStart = _selectionSchemaNorma2[0], columnStart = _selectionSchemaNorma2[1], rowEnd = _selectionSchemaNorma2[2], columnEnd = _selectionSchemaNorma2[3];
        var _loop = function _loop2(row2) {
          var _loop22 = function _loop23(col2) {
            arrayEach(borderKeys, function(borderKey) {
              _this3.prepareBorderFromCustomAdded(row2, col2, borderObject, borderKey);
            });
          };
          for (var col = columnStart; col <= columnEnd; col += 1) {
            _loop22(col);
          }
        };
        for (var row = rowStart; row <= rowEnd; row += 1) {
          _loop(row);
        }
      });
      this.hot.view.render();
    }
  }, {
    key: "getBorders",
    value: function getBorders(selectionRanges) {
      var _this4 = this;
      if (!Array.isArray(selectionRanges)) {
        return this.savedBorders;
      }
      var selectionType = detectSelectionType(selectionRanges);
      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
      var selectedBorders = [];
      arrayEach(selectionRanges, function(selection) {
        var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection), _selectionSchemaNorma4 = _slicedToArray$m(_selectionSchemaNorma3, 4), rowStart = _selectionSchemaNorma4[0], columnStart = _selectionSchemaNorma4[1], rowEnd = _selectionSchemaNorma4[2], columnEnd = _selectionSchemaNorma4[3];
        var _loop3 = function _loop32(row2) {
          var _loop4 = function _loop42(col2) {
            arrayEach(_this4.savedBorders, function(border) {
              if (border.row === row2 && border.col === col2) {
                selectedBorders.push(border);
              }
            });
          };
          for (var col = columnStart; col <= columnEnd; col += 1) {
            _loop4(col);
          }
        };
        for (var row = rowStart; row <= rowEnd; row += 1) {
          _loop3(row);
        }
      });
      return selectedBorders;
    }
  }, {
    key: "clearBorders",
    value: function clearBorders(selectionRanges) {
      var _this5 = this;
      if (selectionRanges) {
        this.setBorders(selectionRanges);
      } else {
        arrayEach(this.savedBorders, function(border) {
          _this5.clearBordersFromSelectionSettings(border.id);
          _this5.clearNullCellRange();
          _this5.hot.removeCellMeta(border.row, border.col, "borders");
        });
        this.savedBorders.length = 0;
      }
    }
  }, {
    key: "insertBorderIntoSettings",
    value: function insertBorderIntoSettings(border, place) {
      var hasSavedBorders = this.checkSavedBorders(border);
      if (!hasSavedBorders) {
        this.savedBorders.push(border);
      }
      var visualCellRange = new CellRange(new CellCoords(border.row, border.col));
      var hasCustomSelections = this.checkCustomSelections(border, visualCellRange, place);
      if (!hasCustomSelections) {
        this.hot.selection.highlight.addCustomSelection({
          border,
          visualCellRange
        });
      }
    }
  }, {
    key: "prepareBorderFromCustomAdded",
    value: function prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {
      var nrOfRows = this.hot.countRows();
      var nrOfColumns = this.hot.countCols();
      if (row >= nrOfRows || column >= nrOfColumns) {
        return;
      }
      var border = createEmptyBorders(row, column);
      if (borderDescriptor) {
        border = extendDefaultBorder(border, borderDescriptor);
        arrayEach(this.hot.selection.highlight.customSelections, function(customSelection) {
          if (border.id === customSelection.settings.id) {
            Object.assign(customSelection.settings, borderDescriptor);
            border.id = customSelection.settings.id;
            border.left = customSelection.settings.left;
            border.right = customSelection.settings.right;
            border.top = customSelection.settings.top;
            border.bottom = customSelection.settings.bottom;
            return false;
          }
        });
      }
      this.hot.setCellMeta(row, column, "borders", border);
      this.insertBorderIntoSettings(border, place);
    }
  }, {
    key: "prepareBorderFromCustomAddedRange",
    value: function prepareBorderFromCustomAddedRange(rowDecriptor) {
      var _this6 = this;
      var range = rowDecriptor.range;
      var lastRowIndex = Math.min(range.to.row, this.hot.countRows() - 1);
      var lastColumnIndex = Math.min(range.to.col, this.hot.countCols() - 1);
      rangeEach(range.from.row, lastRowIndex, function(rowIndex) {
        rangeEach(range.from.col, lastColumnIndex, function(colIndex) {
          var border = createEmptyBorders(rowIndex, colIndex);
          var add = 0;
          if (rowIndex === range.from.row) {
            if (hasOwnProperty(rowDecriptor, "top")) {
              add += 1;
              border.top = rowDecriptor.top;
            }
          }
          if (rowIndex === range.to.row) {
            if (hasOwnProperty(rowDecriptor, "bottom")) {
              add += 1;
              border.bottom = rowDecriptor.bottom;
            }
          }
          if (colIndex === range.from.col) {
            if (hasOwnProperty(rowDecriptor, "left")) {
              add += 1;
              border.left = rowDecriptor.left;
            }
          }
          if (colIndex === range.to.col) {
            if (hasOwnProperty(rowDecriptor, "right")) {
              add += 1;
              border.right = rowDecriptor.right;
            }
          }
          if (add > 0) {
            _this6.hot.setCellMeta(rowIndex, colIndex, "borders", border);
            _this6.insertBorderIntoSettings(border);
          }
        });
      });
    }
  }, {
    key: "removeAllBorders",
    value: function removeAllBorders(row, column) {
      var borderId = createId(row, column);
      this.spliceBorder(borderId);
      this.clearBordersFromSelectionSettings(borderId);
      this.clearNullCellRange();
      this.hot.removeCellMeta(row, column, "borders");
    }
  }, {
    key: "setBorder",
    value: function setBorder(row, column, place, remove) {
      var bordersMeta = this.hot.getCellMeta(row, column).borders;
      if (!bordersMeta || bordersMeta.border === void 0) {
        bordersMeta = createEmptyBorders(row, column);
      }
      if (remove) {
        bordersMeta[place] = createSingleEmptyBorder();
        var hideCount = this.countHide(bordersMeta);
        if (hideCount === 4) {
          this.removeAllBorders(row, column);
        } else {
          var customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
          if (!customSelectionsChecker) {
            this.insertBorderIntoSettings(bordersMeta);
          }
          this.hot.setCellMeta(row, column, "borders", bordersMeta);
        }
      } else {
        bordersMeta[place] = createDefaultCustomBorder();
        var _customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
        if (!_customSelectionsChecker) {
          this.insertBorderIntoSettings(bordersMeta);
        }
        this.hot.setCellMeta(row, column, "borders", bordersMeta);
      }
    }
  }, {
    key: "prepareBorder",
    value: function prepareBorder(selected, place, remove) {
      var _this7 = this;
      arrayEach(selected, function(_ref) {
        var start = _ref.start, end = _ref.end;
        if (start.row === end.row && start.col === end.col) {
          if (place === "noBorders") {
            _this7.removeAllBorders(start.row, start.col);
          } else {
            _this7.setBorder(start.row, start.col, place, remove);
          }
        } else {
          switch (place) {
            case "noBorders":
              rangeEach(start.col, end.col, function(colIndex) {
                rangeEach(start.row, end.row, function(rowIndex) {
                  _this7.removeAllBorders(rowIndex, colIndex);
                });
              });
              break;
            case "top":
              rangeEach(start.col, end.col, function(topCol) {
                _this7.setBorder(start.row, topCol, place, remove);
              });
              break;
            case "right":
              rangeEach(start.row, end.row, function(rowRight) {
                _this7.setBorder(rowRight, end.col, place, remove);
              });
              break;
            case "bottom":
              rangeEach(start.col, end.col, function(bottomCol) {
                _this7.setBorder(end.row, bottomCol, place, remove);
              });
              break;
            case "left":
              rangeEach(start.row, end.row, function(rowLeft) {
                _this7.setBorder(rowLeft, start.col, place, remove);
              });
              break;
          }
        }
      });
    }
  }, {
    key: "createCustomBorders",
    value: function createCustomBorders(customBorders) {
      var _this8 = this;
      arrayEach(customBorders, function(customBorder) {
        if (customBorder.range) {
          _this8.prepareBorderFromCustomAddedRange(customBorder);
        } else {
          _this8.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, customBorder);
        }
      });
    }
  }, {
    key: "countHide",
    value: function countHide(border) {
      var values = Object.values(border);
      return arrayReduce(values, function(accumulator, value) {
        var result = accumulator;
        if (value.hide) {
          result += 1;
        }
        return result;
      }, 0);
    }
  }, {
    key: "clearBordersFromSelectionSettings",
    value: function clearBordersFromSelectionSettings(borderId) {
      var index = arrayMap(this.hot.selection.highlight.customSelections, function(customSelection) {
        return customSelection.settings.id;
      }).indexOf(borderId);
      if (index > -1) {
        this.hot.selection.highlight.customSelections[index].clear();
      }
    }
  }, {
    key: "clearNullCellRange",
    value: function clearNullCellRange() {
      var _this9 = this;
      arrayEach(this.hot.selection.highlight.customSelections, function(customSelection, index) {
        if (customSelection.cellRange === null) {
          _this9.hot.selection.highlight.customSelections[index].destroy();
          _this9.hot.selection.highlight.customSelections.splice(index, 1);
          return false;
        }
      });
    }
  }, {
    key: "hideBorders",
    value: function hideBorders() {
      var _this10 = this;
      arrayEach(this.savedBorders, function(border) {
        _this10.clearBordersFromSelectionSettings(border.id);
        _this10.clearNullCellRange();
      });
    }
  }, {
    key: "spliceBorder",
    value: function spliceBorder(borderId) {
      var index = arrayMap(this.savedBorders, function(border) {
        return border.id;
      }).indexOf(borderId);
      if (index > -1) {
        this.savedBorders.splice(index, 1);
      }
    }
  }, {
    key: "checkSavedBorders",
    value: function checkSavedBorders(border) {
      var _this11 = this;
      var check = false;
      var hideCount = this.countHide(border);
      if (hideCount === 4) {
        this.spliceBorder(border.id);
        check = true;
      } else {
        arrayEach(this.savedBorders, function(savedBorder, index) {
          if (border.id === savedBorder.id) {
            _this11.savedBorders[index] = border;
            check = true;
            return false;
          }
        });
      }
      return check;
    }
  }, {
    key: "checkCustomSelectionsFromContextMenu",
    value: function checkCustomSelectionsFromContextMenu(border, place, remove) {
      var check = false;
      arrayEach(this.hot.selection.highlight.customSelections, function(customSelection) {
        if (border.id === customSelection.settings.id) {
          objectEach(customSelection.instanceBorders, function(borderObject) {
            borderObject.toggleHiddenClass(place, remove);
          });
          check = true;
          return false;
        }
      });
      return check;
    }
  }, {
    key: "checkCustomSelections",
    value: function checkCustomSelections(border, cellRange, place) {
      var hideCount = this.countHide(border);
      var check = false;
      if (hideCount === 4) {
        this.removeAllBorders(border.row, border.col);
        check = true;
      } else {
        arrayEach(this.hot.selection.highlight.customSelections, function(customSelection) {
          if (border.id === customSelection.settings.id) {
            customSelection.visualCellRange = cellRange;
            customSelection.commit();
            if (place) {
              objectEach(customSelection.instanceBorders, function(borderObject) {
                borderObject.changeBorderStyle(place, border);
              });
            }
            check = true;
            return false;
          }
        });
      }
      return check;
    }
  }, {
    key: "changeBorderSettings",
    value: function changeBorderSettings() {
      var customBorders = this.hot.getSettings()[PLUGIN_KEY$a];
      if (Array.isArray(customBorders)) {
        if (!customBorders.length) {
          this.savedBorders = customBorders;
        }
        this.createCustomBorders(customBorders);
      } else if (customBorders !== void 0) {
        this.createCustomBorders(this.savedBorders);
      }
    }
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(defaultOptions) {
      if (!this.hot.getSettings()[PLUGIN_KEY$a]) {
        return;
      }
      defaultOptions.items.push({
        name: "---------"
      }, {
        key: "borders",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS);
        },
        disabled: function disabled() {
          return this.selection.isSelectedByCorner();
        },
        submenu: {
          items: [top(this), right(this), bottom(this), left(this), noBorders(this)]
        }
      });
    }
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      this.changeBorderSettings();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$k(_getPrototypeOf$H(CustomBorders2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$a;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$9;
    }
  }]);
  return CustomBorders2;
}(BasePlugin);

function _typeof$U(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$U = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$U = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$U(obj);
}
function _classCallCheck$1F(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1z(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1z(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1z(Constructor, staticProps);
  return Constructor;
}
function _get$l(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$l = Reflect.get;
  } else {
    _get$l = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$l(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$l(target, property, receiver || target);
}
function _superPropBase$l(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$I(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$I(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$J(subClass, superClass);
}
function _setPrototypeOf$J(o, p) {
  _setPrototypeOf$J = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$J(o, p);
}
function _createSuper$I(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$J();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$I(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$I(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$I(this, result);
  };
}
function _possibleConstructorReturn$I(self, call) {
  if (call && (_typeof$U(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$I(self);
}
function _assertThisInitialized$I(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$J() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$I(o) {
  _getPrototypeOf$I = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$I(o);
}
var PLUGIN_KEY$b = "dragToScroll";
var PLUGIN_PRIORITY$a = 100;
var DragToScroll = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$I(DragToScroll2, _BasePlugin);
  var _super = _createSuper$I(DragToScroll2);
  function DragToScroll2(hotInstance) {
    var _this;
    _classCallCheck$1F(this, DragToScroll2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager(_assertThisInitialized$I(_this));
    _this.boundaries = null;
    _this.callback = null;
    _this.listening = false;
    return _this;
  }
  _createClass$1z(DragToScroll2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$b];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterOnCellMouseDown", function(event) {
        return _this2.setupListening(event);
      });
      this.addHook("afterOnCellCornerMouseDown", function(event) {
        return _this2.setupListening(event);
      });
      this.registerEvents();
      _get$l(_getPrototypeOf$I(DragToScroll2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$l(_getPrototypeOf$I(DragToScroll2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.unregisterEvents();
      _get$l(_getPrototypeOf$I(DragToScroll2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "setBoundaries",
    value: function setBoundaries(boundaries) {
      this.boundaries = boundaries;
    }
  }, {
    key: "setCallback",
    value: function setCallback(callback) {
      this.callback = callback;
    }
  }, {
    key: "check",
    value: function check(x, y) {
      var diffX = 0;
      var diffY = 0;
      if (y < this.boundaries.top) {
        diffY = y - this.boundaries.top;
      } else if (y > this.boundaries.bottom) {
        diffY = y - this.boundaries.bottom;
      }
      if (x < this.boundaries.left) {
        diffX = x - this.boundaries.left;
      } else if (x > this.boundaries.right) {
        diffX = x - this.boundaries.right;
      }
      this.callback(diffX, diffY);
    }
  }, {
    key: "listen",
    value: function listen() {
      this.listening = true;
    }
  }, {
    key: "unlisten",
    value: function unlisten() {
      this.listening = false;
    }
  }, {
    key: "isListening",
    value: function isListening() {
      return this.listening;
    }
  }, {
    key: "registerEvents",
    value: function registerEvents() {
      var _this3 = this;
      var rootWindow = this.hot.rootWindow;
      var frame = rootWindow;
      while (frame) {
        this.eventManager.addEventListener(frame.document, "contextmenu", function() {
          return _this3.unlisten();
        });
        this.eventManager.addEventListener(frame.document, "mouseup", function() {
          return _this3.unlisten();
        });
        this.eventManager.addEventListener(frame.document, "mousemove", function(event) {
          return _this3.onMouseMove(event);
        });
        frame = getParentWindow(frame);
      }
    }
  }, {
    key: "unregisterEvents",
    value: function unregisterEvents() {
      this.eventManager.clear();
    }
  }, {
    key: "setupListening",
    value: function setupListening(event) {
      if (isRightClick(event)) {
        return;
      }
      var scrollHandler = this.hot.view.wt.wtTable.holder;
      if (scrollHandler === this.hot.rootWindow) {
        return;
      }
      this.setBoundaries(scrollHandler.getBoundingClientRect());
      this.setCallback(function(scrollX, scrollY) {
        if (scrollX < 0) {
          scrollHandler.scrollLeft -= 50;
        } else if (scrollX > 0) {
          scrollHandler.scrollLeft += 50;
        }
        if (scrollY < 0) {
          scrollHandler.scrollTop -= 20;
        } else if (scrollY > 0) {
          scrollHandler.scrollTop += 20;
        }
      });
      this.listen();
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      if (!this.isListening()) {
        return;
      }
      this.check(event.clientX, event.clientY);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$l(_getPrototypeOf$I(DragToScroll2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$b;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$a;
    }
  }]);
  return DragToScroll2;
}(BasePlugin);

function _slicedToArray$n(arr, i) {
  return _arrayWithHoles$o(arr) || _iterableToArrayLimit$n(arr, i) || _unsupportedIterableToArray$z(arr, i) || _nonIterableRest$o();
}
function _nonIterableRest$o() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$z(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$z(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$z(o, minLen);
}
function _arrayLikeToArray$z(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$n(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$o(arr) {
  if (Array.isArray(arr))
    return arr;
}
function freezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "freeze_column",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_FREEZE_COLUMN);
    },
    callback: function callback(key, selected) {
      var _selected = _slicedToArray$n(selected, 1), selectedColumn = _selected[0].start.col;
      manualColumnFreezePlugin.freezeColumn(selectedColumn);
      this.render();
      this.view.adjustElementsSize(true);
    },
    hidden: function hidden() {
      var selection = this.getSelectedRange();
      var hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col <= this.getSettings().fixedColumnsLeft - 1) {
        hide = true;
      }
      return hide;
    }
  };
}

function _slicedToArray$o(arr, i) {
  return _arrayWithHoles$p(arr) || _iterableToArrayLimit$o(arr, i) || _unsupportedIterableToArray$A(arr, i) || _nonIterableRest$p();
}
function _nonIterableRest$p() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$A(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$A(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$A(o, minLen);
}
function _arrayLikeToArray$A(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$o(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$p(arr) {
  if (Array.isArray(arr))
    return arr;
}
function unfreezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "unfreeze_column",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNFREEZE_COLUMN);
    },
    callback: function callback(key, selected) {
      var _selected = _slicedToArray$o(selected, 1), selectedColumn = _selected[0].start.col;
      manualColumnFreezePlugin.unfreezeColumn(selectedColumn);
      this.render();
      this.view.adjustElementsSize(true);
    },
    hidden: function hidden() {
      var selection = this.getSelectedRange();
      var hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col >= this.getSettings().fixedColumnsLeft) {
        hide = true;
      }
      return hide;
    }
  };
}

function _typeof$V(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$V = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$V = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$V(obj);
}
function _classCallCheck$1G(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1A(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1A(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1A(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1A(Constructor, staticProps);
  return Constructor;
}
function _get$m(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$m = Reflect.get;
  } else {
    _get$m = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$m(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$m(target, property, receiver || target);
}
function _superPropBase$m(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$J(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$J(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$K(subClass, superClass);
}
function _setPrototypeOf$K(o, p) {
  _setPrototypeOf$K = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$K(o, p);
}
function _createSuper$J(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$K();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$J(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$J(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$J(this, result);
  };
}
function _possibleConstructorReturn$J(self, call) {
  if (call && (_typeof$V(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$J(self);
}
function _assertThisInitialized$J(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$K() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$J(o) {
  _getPrototypeOf$J = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$J(o);
}
var PLUGIN_KEY$c = "manualColumnFreeze";
var PLUGIN_PRIORITY$b = 110;
var privatePool$a = new WeakMap();
var ManualColumnFreeze = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$J(ManualColumnFreeze2, _BasePlugin);
  var _super = _createSuper$J(ManualColumnFreeze2);
  function ManualColumnFreeze2(hotInstance) {
    var _this;
    _classCallCheck$1G(this, ManualColumnFreeze2);
    _this = _super.call(this, hotInstance);
    privatePool$a.set(_assertThisInitialized$J(_this), {
      afterFirstUse: false
    });
    return _this;
  }
  _createClass$1A(ManualColumnFreeze2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$c];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.addContextMenuEntry(options);
      });
      this.addHook("beforeColumnMove", function(columns, finalIndex) {
        return _this2.onBeforeColumnMove(columns, finalIndex);
      });
      _get$m(_getPrototypeOf$J(ManualColumnFreeze2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var priv = privatePool$a.get(this);
      priv.afterFirstUse = false;
      _get$m(_getPrototypeOf$J(ManualColumnFreeze2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$m(_getPrototypeOf$J(ManualColumnFreeze2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "freezeColumn",
    value: function freezeColumn(column) {
      var priv = privatePool$a.get(this);
      var settings = this.hot.getSettings();
      if (!priv.afterFirstUse) {
        priv.afterFirstUse = true;
      }
      if (settings.fixedColumnsLeft === this.hot.countCols() || column <= settings.fixedColumnsLeft - 1) {
        return;
      }
      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsLeft);
      settings.fixedColumnsLeft += 1;
    }
  }, {
    key: "unfreezeColumn",
    value: function unfreezeColumn(column) {
      var priv = privatePool$a.get(this);
      var settings = this.hot.getSettings();
      if (!priv.afterFirstUse) {
        priv.afterFirstUse = true;
      }
      if (settings.fixedColumnsLeft <= 0 || column > settings.fixedColumnsLeft - 1) {
        return;
      }
      settings.fixedColumnsLeft -= 1;
      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsLeft);
    }
  }, {
    key: "addContextMenuEntry",
    value: function addContextMenuEntry(options) {
      options.items.push({
        name: "---------"
      }, freezeColumnItem(this), unfreezeColumnItem(this));
    }
  }, {
    key: "onBeforeColumnMove",
    value: function onBeforeColumnMove(columns, finalIndex) {
      var priv = privatePool$a.get(this);
      if (priv.afterFirstUse) {
        var freezeLine = this.hot.getSettings().fixedColumnsLeft;
        if (finalIndex < freezeLine) {
          return false;
        }
        if (columns.some(function(column) {
          return column < freezeLine;
        })) {
          return false;
        }
      }
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$c;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$b;
    }
  }]);
  return ManualColumnFreeze2;
}(BasePlugin);

function _classCallCheck$1H(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1B(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1B(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1B(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1B(Constructor, staticProps);
  return Constructor;
}
var STATE_INITIALIZED = 0;
var STATE_BUILT = 1;
var STATE_APPENDED = 2;
var UNIT = "px";
var BaseUI = /* @__PURE__ */ function() {
  function BaseUI2(hotInstance) {
    _classCallCheck$1H(this, BaseUI2);
    this.hot = hotInstance;
    this._element = null;
    this.state = STATE_INITIALIZED;
  }
  _createClass$1B(BaseUI2, [{
    key: "appendTo",
    value: function appendTo(wrapper) {
      wrapper.appendChild(this._element);
      this.state = STATE_APPENDED;
    }
  }, {
    key: "build",
    value: function build() {
      if (this.state !== STATE_INITIALIZED) {
        return;
      }
      this._element = this.hot.rootDocument.createElement("div");
      this.state = STATE_BUILT;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.isAppended()) {
        this._element.parentElement.removeChild(this._element);
      }
      this._element = null;
      this.state = STATE_INITIALIZED;
    }
  }, {
    key: "isAppended",
    value: function isAppended() {
      return this.state === STATE_APPENDED;
    }
  }, {
    key: "isBuilt",
    value: function isBuilt() {
      return this.state >= STATE_BUILT;
    }
  }, {
    key: "setPosition",
    value: function setPosition(top, left) {
      if (isNumeric(top)) {
        this._element.style.top = top + UNIT;
      }
      if (isNumeric(left)) {
        this._element.style.left = left + UNIT;
      }
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return {
        top: this._element.style.top ? parseInt(this._element.style.top, 10) : 0,
        left: this._element.style.left ? parseInt(this._element.style.left, 10) : 0
      };
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      if (isNumeric(width)) {
        this._element.style.width = width + UNIT;
      }
      if (isNumeric(height)) {
        this._element.style.height = height + UNIT;
      }
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return {
        width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
        height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
      };
    }
  }, {
    key: "setOffset",
    value: function setOffset(top, left) {
      if (isNumeric(top)) {
        this._element.style.marginTop = top + UNIT;
      }
      if (isNumeric(left)) {
        this._element.style.marginLeft = left + UNIT;
      }
    }
  }, {
    key: "getOffset",
    value: function getOffset() {
      return {
        top: this._element.style.marginTop ? parseInt(this._element.style.marginTop, 10) : 0,
        left: this._element.style.marginLeft ? parseInt(this._element.style.marginLeft, 10) : 0
      };
    }
  }]);
  return BaseUI2;
}();

function _typeof$W(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$W = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$W = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$W(obj);
}
function _classCallCheck$1I(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1C(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1C(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1C(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1C(Constructor, staticProps);
  return Constructor;
}
function _get$n(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$n = Reflect.get;
  } else {
    _get$n = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$n(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$n(target, property, receiver || target);
}
function _superPropBase$n(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$K(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$K(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$L(subClass, superClass);
}
function _setPrototypeOf$L(o, p) {
  _setPrototypeOf$L = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$L(o, p);
}
function _createSuper$K(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$L();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$K(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$K(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$K(this, result);
  };
}
function _possibleConstructorReturn$K(self, call) {
  if (call && (_typeof$W(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$K(self);
}
function _assertThisInitialized$K(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$L() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$K(o) {
  _getPrototypeOf$K = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$K(o);
}
var CSS_CLASSNAME = "ht__manualColumnMove--backlight";
var BacklightUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$K(BacklightUI2, _BaseUI);
  var _super = _createSuper$K(BacklightUI2);
  function BacklightUI2() {
    _classCallCheck$1I(this, BacklightUI2);
    return _super.apply(this, arguments);
  }
  _createClass$1C(BacklightUI2, [{
    key: "build",
    value: function build() {
      _get$n(_getPrototypeOf$K(BacklightUI2.prototype), "build", this).call(this);
      addClass(this._element, CSS_CLASSNAME);
    }
  }]);
  return BacklightUI2;
}(BaseUI);

function _typeof$X(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$X = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$X = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$X(obj);
}
function _classCallCheck$1J(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1D(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1D(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1D(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1D(Constructor, staticProps);
  return Constructor;
}
function _get$o(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$o = Reflect.get;
  } else {
    _get$o = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$o(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$o(target, property, receiver || target);
}
function _superPropBase$o(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$L(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$L(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$M(subClass, superClass);
}
function _setPrototypeOf$M(o, p) {
  _setPrototypeOf$M = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$M(o, p);
}
function _createSuper$L(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$M();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$L(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$L(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$L(this, result);
  };
}
function _possibleConstructorReturn$L(self, call) {
  if (call && (_typeof$X(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$L(self);
}
function _assertThisInitialized$L(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$M() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$L(o) {
  _getPrototypeOf$L = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$L(o);
}
var CSS_CLASSNAME$1 = "ht__manualColumnMove--guideline";
var GuidelineUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$L(GuidelineUI2, _BaseUI);
  var _super = _createSuper$L(GuidelineUI2);
  function GuidelineUI2() {
    _classCallCheck$1J(this, GuidelineUI2);
    return _super.apply(this, arguments);
  }
  _createClass$1D(GuidelineUI2, [{
    key: "build",
    value: function build() {
      _get$o(_getPrototypeOf$L(GuidelineUI2.prototype), "build", this).call(this);
      addClass(this._element, CSS_CLASSNAME$1);
    }
  }]);
  return GuidelineUI2;
}(BaseUI);

function _typeof$Y(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$Y = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$Y = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$Y(obj);
}
function _classCallCheck$1K(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1E(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1E(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1E(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1E(Constructor, staticProps);
  return Constructor;
}
function _get$p(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$p = Reflect.get;
  } else {
    _get$p = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$p(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$p(target, property, receiver || target);
}
function _superPropBase$p(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$M(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$M(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$N(subClass, superClass);
}
function _setPrototypeOf$N(o, p) {
  _setPrototypeOf$N = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$N(o, p);
}
function _createSuper$M(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$N();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$M(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$M(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$M(this, result);
  };
}
function _possibleConstructorReturn$M(self, call) {
  if (call && (_typeof$Y(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$M(self);
}
function _assertThisInitialized$M(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$N() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$M(o) {
  _getPrototypeOf$M = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$M(o);
}
Hooks.getSingleton().register("beforeColumnMove");
Hooks.getSingleton().register("afterColumnMove");
var PLUGIN_KEY$d = "manualColumnMove";
var PLUGIN_PRIORITY$c = 120;
var privatePool$b = new WeakMap();
var CSS_PLUGIN = "ht__manualColumnMove";
var CSS_SHOW_UI = "show-ui";
var CSS_ON_MOVING = "on-moving--columns";
var CSS_AFTER_SELECTION = "after-selection--columns";
var ManualColumnMove = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$M(ManualColumnMove2, _BasePlugin);
  var _super = _createSuper$M(ManualColumnMove2);
  function ManualColumnMove2(hotInstance) {
    var _this;
    _classCallCheck$1K(this, ManualColumnMove2);
    _this = _super.call(this, hotInstance);
    privatePool$b.set(_assertThisInitialized$M(_this), {
      columnsToMove: [],
      countCols: 0,
      fixedColumns: 0,
      pressed: void 0,
      target: {
        eventPageX: void 0,
        coords: void 0,
        TD: void 0,
        col: void 0
      },
      cachedDropIndex: void 0
    });
    _this.eventManager = new EventManager(_assertThisInitialized$M(_this));
    _this.backlight = new BacklightUI(hotInstance);
    _this.guideline = new GuidelineUI(hotInstance);
    return _this;
  }
  _createClass$1E(ManualColumnMove2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$d];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("beforeOnCellMouseDown", function(event, coords, TD, blockCalculations) {
        return _this2.onBeforeOnCellMouseDown(event, coords, TD, blockCalculations);
      });
      this.addHook("beforeOnCellMouseOver", function(event, coords, TD, blockCalculations) {
        return _this2.onBeforeOnCellMouseOver(event, coords, TD, blockCalculations);
      });
      this.addHook("afterScrollVertically", function() {
        return _this2.onAfterScrollVertically();
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData();
      });
      this.buildPluginUI();
      this.registerEvents();
      addClass(this.hot.rootElement, CSS_PLUGIN);
      _get$p(_getPrototypeOf$M(ManualColumnMove2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.moveBySettingsOrLoad();
      _get$p(_getPrototypeOf$M(ManualColumnMove2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      removeClass(this.hot.rootElement, CSS_PLUGIN);
      this.unregisterEvents();
      this.backlight.destroy();
      this.guideline.destroy();
      _get$p(_getPrototypeOf$M(ManualColumnMove2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "moveColumn",
    value: function moveColumn(column, finalIndex) {
      return this.moveColumns([column], finalIndex);
    }
  }, {
    key: "moveColumns",
    value: function moveColumns(columns, finalIndex) {
      var priv = privatePool$b.get(this);
      var dropIndex = priv.cachedDropIndex;
      var movePossible = this.isMovePossible(columns, finalIndex);
      var beforeMoveHook = this.hot.runHooks("beforeColumnMove", columns, finalIndex, dropIndex, movePossible);
      priv.cachedDropIndex = void 0;
      if (beforeMoveHook === false) {
        return;
      }
      if (movePossible) {
        this.hot.columnIndexMapper.moveIndexes(columns, finalIndex);
      }
      var movePerformed = movePossible && this.isColumnOrderChanged(columns, finalIndex);
      this.hot.runHooks("afterColumnMove", columns, finalIndex, dropIndex, movePossible, movePerformed);
      return movePerformed;
    }
  }, {
    key: "dragColumn",
    value: function dragColumn(column, dropIndex) {
      return this.dragColumns([column], dropIndex);
    }
  }, {
    key: "dragColumns",
    value: function dragColumns(columns, dropIndex) {
      var finalIndex = this.countFinalIndex(columns, dropIndex);
      var priv = privatePool$b.get(this);
      priv.cachedDropIndex = dropIndex;
      return this.moveColumns(columns, finalIndex);
    }
  }, {
    key: "isMovePossible",
    value: function isMovePossible(movedColumns, finalIndex) {
      var length = this.hot.columnIndexMapper.getNotTrimmedIndexesLength();
      var tooHighDestinationIndex = movedColumns.length + finalIndex > length;
      var tooLowDestinationIndex = finalIndex < 0;
      var tooLowMovedColumnIndex = movedColumns.some(function(movedColumn) {
        return movedColumn < 0;
      });
      var tooHighMovedColumnIndex = movedColumns.some(function(movedColumn) {
        return movedColumn >= length;
      });
      if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedColumnIndex || tooHighMovedColumnIndex) {
        return false;
      }
      return true;
    }
  }, {
    key: "isColumnOrderChanged",
    value: function isColumnOrderChanged(movedColumns, finalIndex) {
      return movedColumns.some(function(column, nrOfMovedElement) {
        return column - nrOfMovedElement !== finalIndex;
      });
    }
  }, {
    key: "countFinalIndex",
    value: function countFinalIndex(movedColumns, dropIndex) {
      var numberOfColumnsLowerThanDropIndex = arrayReduce(movedColumns, function(numberOfColumns, currentColumnIndex) {
        if (currentColumnIndex < dropIndex) {
          numberOfColumns += 1;
        }
        return numberOfColumns;
      }, 0);
      return dropIndex - numberOfColumnsLowerThanDropIndex;
    }
  }, {
    key: "getColumnsWidth",
    value: function getColumnsWidth(fromColumn, toColumn) {
      var columnMapper = this.hot.columnIndexMapper;
      var columnsWidth = 0;
      for (var visualColumnIndex = fromColumn; visualColumnIndex <= toColumn; visualColumnIndex += 1) {
        var renderableIndex = columnMapper.getRenderableFromVisualIndex(visualColumnIndex);
        if (visualColumnIndex < 0) {
          columnsWidth += this.hot.view.wt.wtViewport.getRowHeaderWidth() || 0;
        } else if (renderableIndex !== null) {
          columnsWidth += this.hot.view.wt.wtTable.getStretchedColumnWidth(renderableIndex) || 0;
        }
      }
      return columnsWidth;
    }
  }, {
    key: "moveBySettingsOrLoad",
    value: function moveBySettingsOrLoad() {
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$d];
      if (Array.isArray(pluginSettings)) {
        this.moveColumns(pluginSettings, 0);
      } else if (pluginSettings !== void 0) {
        var persistentState = this.persistentStateLoad();
        if (persistentState.length) {
          this.moveColumns(persistentState, 0);
        }
      }
    }
  }, {
    key: "isFixedColumnsLeft",
    value: function isFixedColumnsLeft(column) {
      return column < this.hot.getSettings().fixedColumnsLeft;
    }
  }, {
    key: "persistentStateSave",
    value: function persistentStateSave() {
      this.hot.runHooks("persistentStateSave", "manualColumnMove", this.hot.columnIndexMapper.getIndexesSequence());
    }
  }, {
    key: "persistentStateLoad",
    value: function persistentStateLoad() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", "manualColumnMove", storedState);
      return storedState.value ? storedState.value : [];
    }
  }, {
    key: "prepareColumnsToMoving",
    value: function prepareColumnsToMoving(start, end) {
      var selectedColumns = [];
      rangeEach(start, end, function(i) {
        selectedColumns.push(i);
      });
      return selectedColumns;
    }
  }, {
    key: "refreshPositions",
    value: function refreshPositions() {
      var priv = privatePool$b.get(this);
      var firstVisible = this.hot.view.wt.wtTable.getFirstVisibleColumn();
      var lastVisible = this.hot.view.wt.wtTable.getLastVisibleColumn();
      var wtTable = this.hot.view.wt.wtTable;
      var scrollableElement = this.hot.view.wt.wtOverlays.scrollableElement;
      var scrollLeft = typeof scrollableElement.scrollX === "number" ? scrollableElement.scrollX : scrollableElement.scrollLeft;
      var tdOffsetLeft = this.hot.view.THEAD.offsetLeft + this.getColumnsWidth(0, priv.coords - 1);
      var mouseOffsetLeft = priv.target.eventPageX - (priv.rootElementOffset - (scrollableElement.scrollX === void 0 ? scrollLeft : 0));
      var hiderWidth = wtTable.hider.offsetWidth;
      var tbodyOffsetLeft = wtTable.TBODY.offsetLeft;
      var backlightElemMarginLeft = this.backlight.getOffset().left;
      var backlightElemWidth = this.backlight.getSize().width;
      var rowHeaderWidth = 0;
      if (priv.rootElementOffset + wtTable.holder.offsetWidth + scrollLeft < priv.target.eventPageX) {
        if (priv.coords < priv.countCols) {
          priv.coords += 1;
        }
      }
      if (priv.hasRowHeaders) {
        rowHeaderWidth = this.hot.view.wt.wtOverlays.leftOverlay.clone.wtTable.getColumnHeader(-1).offsetWidth;
      }
      if (this.isFixedColumnsLeft(priv.coords)) {
        tdOffsetLeft += scrollLeft;
      }
      tdOffsetLeft += rowHeaderWidth;
      if (priv.coords < 0) {
        if (priv.fixedColumns > 0) {
          priv.target.col = 0;
        } else {
          priv.target.col = firstVisible > 0 ? firstVisible - 1 : firstVisible;
        }
      } else if (priv.target.TD.offsetWidth / 2 + tdOffsetLeft <= mouseOffsetLeft) {
        var newCoordsCol = priv.coords >= priv.countCols ? priv.countCols - 1 : priv.coords;
        priv.target.col = newCoordsCol + 1;
        tdOffsetLeft += priv.target.TD.offsetWidth;
        if (priv.target.col > lastVisible && lastVisible < priv.countCols) {
          this.hot.scrollViewportTo(void 0, lastVisible + 1, void 0, true);
        }
      } else {
        priv.target.col = priv.coords;
        if (priv.target.col <= firstVisible && priv.target.col >= priv.fixedColumns && firstVisible > 0) {
          this.hot.scrollViewportTo(void 0, firstVisible - 1);
        }
      }
      if (priv.target.col <= firstVisible && priv.target.col >= priv.fixedColumns && firstVisible > 0) {
        this.hot.scrollViewportTo(void 0, firstVisible - 1);
      }
      var backlightLeft = mouseOffsetLeft;
      var guidelineLeft = tdOffsetLeft;
      if (mouseOffsetLeft + backlightElemWidth + backlightElemMarginLeft >= hiderWidth) {
        backlightLeft = hiderWidth - backlightElemWidth - backlightElemMarginLeft;
      } else if (mouseOffsetLeft + backlightElemMarginLeft < tbodyOffsetLeft + rowHeaderWidth) {
        backlightLeft = tbodyOffsetLeft + rowHeaderWidth + Math.abs(backlightElemMarginLeft);
      }
      if (tdOffsetLeft >= hiderWidth - 1) {
        guidelineLeft = hiderWidth - 1;
      } else if (guidelineLeft === 0) {
        guidelineLeft = 1;
      } else if (scrollableElement.scrollX !== void 0 && priv.coords < priv.fixedColumns) {
        guidelineLeft -= priv.rootElementOffset <= scrollableElement.scrollX ? priv.rootElementOffset : 0;
      }
      this.backlight.setPosition(null, backlightLeft);
      this.guideline.setPosition(null, guidelineLeft);
    }
  }, {
    key: "registerEvents",
    value: function registerEvents() {
      var _this3 = this;
      var documentElement = this.hot.rootDocument.documentElement;
      this.eventManager.addEventListener(documentElement, "mousemove", function(event) {
        return _this3.onMouseMove(event);
      });
      this.eventManager.addEventListener(documentElement, "mouseup", function() {
        return _this3.onMouseUp();
      });
    }
  }, {
    key: "unregisterEvents",
    value: function unregisterEvents() {
      this.eventManager.clear();
    }
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event, coords, TD, blockCalculations) {
      var wtTable = this.hot.view.wt.wtTable;
      var isHeaderSelection = this.hot.selection.isSelectedByColumnHeader();
      var selection = this.hot.getSelectedRangeLast();
      var priv = privatePool$b.get(this);
      var isSortingElement = hasClass(event.target, "sortAction");
      if (!selection || !isHeaderSelection || priv.pressed || event.button !== 0 || isSortingElement) {
        priv.pressed = false;
        priv.columnsToMove.length = 0;
        removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);
        return;
      }
      var guidelineIsNotReady = this.guideline.isBuilt() && !this.guideline.isAppended();
      var backlightIsNotReady = this.backlight.isBuilt() && !this.backlight.isAppended();
      if (guidelineIsNotReady && backlightIsNotReady) {
        this.guideline.appendTo(wtTable.hider);
        this.backlight.appendTo(wtTable.hider);
      }
      var from = selection.from, to = selection.to;
      var start = Math.min(from.col, to.col);
      var end = Math.max(from.col, to.col);
      if (coords.row < 0 && coords.col >= start && coords.col <= end) {
        blockCalculations.column = true;
        priv.pressed = true;
        priv.target.eventPageX = event.pageX;
        priv.coords = coords.col;
        priv.target.TD = TD;
        priv.target.col = coords.col;
        priv.columnsToMove = this.prepareColumnsToMoving(start, end);
        priv.hasRowHeaders = !!this.hot.getSettings().rowHeaders;
        priv.countCols = this.hot.countCols();
        priv.fixedColumns = this.hot.getSettings().fixedColumnsLeft;
        priv.rootElementOffset = offset$1(this.hot.rootElement).left;
        var countColumnsFrom = priv.hasRowHeaders ? -1 : 0;
        var topPos = wtTable.holder.scrollTop + wtTable.getColumnHeaderHeight(0) + 1;
        var fixedColumns = coords.col < priv.fixedColumns;
        var scrollableElement = this.hot.view.wt.wtOverlays.scrollableElement;
        var wrapperIsWindow = scrollableElement.scrollX ? scrollableElement.scrollX - priv.rootElementOffset : 0;
        var mouseOffset = event.offsetX - (fixedColumns ? wrapperIsWindow : 0);
        var leftOffset = Math.abs(this.getColumnsWidth(start, coords.col - 1) + mouseOffset);
        this.backlight.setPosition(topPos, this.getColumnsWidth(countColumnsFrom, start - 1) + leftOffset);
        this.backlight.setSize(this.getColumnsWidth(start, end), wtTable.hider.offsetHeight - topPos);
        this.backlight.setOffset(null, leftOffset * -1);
        addClass(this.hot.rootElement, CSS_ON_MOVING);
      } else {
        removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);
        priv.pressed = false;
        priv.columnsToMove.length = 0;
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var priv = privatePool$b.get(this);
      if (!priv.pressed) {
        return;
      }
      if (event.target === this.backlight.element) {
        var width = this.backlight.getSize().width;
        this.backlight.setSize(0);
        setTimeout(function() {
          this.backlight.setPosition(width);
        });
      }
      priv.target.eventPageX = event.pageX;
      this.refreshPositions();
    }
  }, {
    key: "onBeforeOnCellMouseOver",
    value: function onBeforeOnCellMouseOver(event, coords, TD, blockCalculations) {
      var selectedRange = this.hot.getSelectedRangeLast();
      var priv = privatePool$b.get(this);
      if (!selectedRange || !priv.pressed) {
        return;
      }
      if (priv.columnsToMove.indexOf(coords.col) > -1) {
        removeClass(this.hot.rootElement, CSS_SHOW_UI);
      } else {
        addClass(this.hot.rootElement, CSS_SHOW_UI);
      }
      blockCalculations.row = true;
      blockCalculations.column = true;
      blockCalculations.cell = true;
      priv.coords = coords.col;
      priv.target.TD = TD;
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp() {
      var priv = privatePool$b.get(this);
      var target = priv.target.col;
      var columnsLen = priv.columnsToMove.length;
      priv.coords = void 0;
      priv.pressed = false;
      priv.backlightWidth = 0;
      removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);
      if (this.hot.selection.isSelectedByColumnHeader()) {
        addClass(this.hot.rootElement, CSS_AFTER_SELECTION);
      }
      if (columnsLen < 1 || target === void 0) {
        return;
      }
      var firstMovedVisualColumn = priv.columnsToMove[0];
      var firstMovedPhysicalColumn = this.hot.toPhysicalColumn(firstMovedVisualColumn);
      var movePerformed = this.dragColumns(priv.columnsToMove, target);
      priv.columnsToMove.length = 0;
      if (movePerformed === true) {
        this.persistentStateSave();
        this.hot.render();
        this.hot.view.adjustElementsSize(true);
        var selectionStart = this.hot.toVisualColumn(firstMovedPhysicalColumn);
        var selectionEnd = selectionStart + columnsLen - 1;
        this.hot.selectColumns(selectionStart, selectionEnd);
      }
    }
  }, {
    key: "onAfterScrollVertically",
    value: function onAfterScrollVertically() {
      var wtTable = this.hot.view.wt.wtTable;
      var headerHeight = wtTable.getColumnHeaderHeight(0) + 1;
      var scrollTop = wtTable.holder.scrollTop;
      var posTop = headerHeight + scrollTop;
      this.backlight.setPosition(posTop);
      this.backlight.setSize(null, wtTable.hider.offsetHeight - posTop);
    }
  }, {
    key: "buildPluginUI",
    value: function buildPluginUI() {
      this.backlight.build();
      this.guideline.build();
    }
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      this.moveBySettingsOrLoad();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.backlight.destroy();
      this.guideline.destroy();
      _get$p(_getPrototypeOf$M(ManualColumnMove2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$d;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$c;
    }
  }]);
  return ManualColumnMove2;
}(BasePlugin);

function _typeof$Z(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$Z = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$Z = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$Z(obj);
}
function _classCallCheck$1L(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1F(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1F(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1F(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1F(Constructor, staticProps);
  return Constructor;
}
function _get$q(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$q = Reflect.get;
  } else {
    _get$q = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$q(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$q(target, property, receiver || target);
}
function _superPropBase$q(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$N(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$N(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$O(subClass, superClass);
}
function _setPrototypeOf$O(o, p) {
  _setPrototypeOf$O = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$O(o, p);
}
function _createSuper$N(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$O();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$N(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$N(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$N(this, result);
  };
}
function _possibleConstructorReturn$N(self, call) {
  if (call && (_typeof$Z(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$N(self);
}
function _assertThisInitialized$N(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$O() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$N(o) {
  _getPrototypeOf$N = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$N(o);
}
var PLUGIN_KEY$e = "manualColumnResize";
var PLUGIN_PRIORITY$d = 130;
var PERSISTENT_STATE_KEY$1 = "manualColumnWidths";
var privatePool$c = new WeakMap();
var ManualColumnResize = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$N(ManualColumnResize2, _BasePlugin);
  var _super = _createSuper$N(ManualColumnResize2);
  function ManualColumnResize2(hotInstance) {
    var _this;
    _classCallCheck$1L(this, ManualColumnResize2);
    _this = _super.call(this, hotInstance);
    var rootDocument = _this.hot.rootDocument;
    _this.currentTH = null;
    _this.currentCol = null;
    _this.selectedCols = [];
    _this.currentWidth = null;
    _this.newSize = null;
    _this.startY = null;
    _this.startWidth = null;
    _this.startOffset = null;
    _this.handle = rootDocument.createElement("DIV");
    _this.guide = rootDocument.createElement("DIV");
    _this.eventManager = new EventManager(_assertThisInitialized$N(_this));
    _this.pressed = null;
    _this.dblclick = 0;
    _this.autoresizeTimeout = null;
    _this.columnWidthsMap = void 0;
    privatePool$c.set(_assertThisInitialized$N(_this), {
      config: void 0
    });
    addClass(_this.handle, "manualColumnResizer");
    addClass(_this.guide, "manualColumnResizerGuide");
    return _this;
  }
  _createClass$1F(ManualColumnResize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$e];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.columnWidthsMap = new PhysicalIndexToValueMap();
      this.columnWidthsMap.addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      this.hot.columnIndexMapper.registerMap(this.pluginName, this.columnWidthsMap);
      this.addHook("modifyColWidth", function(width, col) {
        return _this2.onModifyColWidth(width, col);
      });
      this.addHook("beforeStretchingColumnWidth", function(stretchedWidth, column) {
        return _this2.onBeforeStretchingColumnWidth(stretchedWidth, column);
      });
      this.addHook("beforeColumnResize", function(newSize, column, isDoubleClick) {
        return _this2.onBeforeColumnResize(newSize, column, isDoubleClick);
      });
      this.bindEvents();
      _get$q(_getPrototypeOf$N(ManualColumnResize2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$q(_getPrototypeOf$N(ManualColumnResize2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var priv = privatePool$c.get(this);
      priv.config = this.columnWidthsMap.getValues();
      this.hot.columnIndexMapper.unregisterMap(this.pluginName);
      _get$q(_getPrototypeOf$N(ManualColumnResize2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "saveManualColumnWidths",
    value: function saveManualColumnWidths() {
      this.hot.runHooks("persistentStateSave", PERSISTENT_STATE_KEY$1, this.columnWidthsMap.getValues());
    }
  }, {
    key: "loadManualColumnWidths",
    value: function loadManualColumnWidths() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", PERSISTENT_STATE_KEY$1, storedState);
      return storedState.value;
    }
  }, {
    key: "setManualSize",
    value: function setManualSize(column, width) {
      var newWidth = Math.max(width, 20);
      var physicalColumn = this.hot.toPhysicalColumn(column);
      this.columnWidthsMap.setValueAtIndex(physicalColumn, newWidth);
      return newWidth;
    }
  }, {
    key: "clearManualSize",
    value: function clearManualSize(column) {
      var physicalColumn = this.hot.toPhysicalColumn(column);
      this.columnWidthsMap.setValueAtIndex(physicalColumn, null);
    }
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      var _this3 = this;
      var priv = privatePool$c.get(this);
      var initialSetting = this.hot.getSettings()[PLUGIN_KEY$e];
      var loadedManualColumnWidths = this.loadManualColumnWidths();
      if (typeof loadedManualColumnWidths !== "undefined") {
        this.hot.batchExecution(function() {
          loadedManualColumnWidths.forEach(function(width, physicalIndex) {
            _this3.columnWidthsMap.setValueAtIndex(physicalIndex, width);
          });
        }, true);
      } else if (Array.isArray(initialSetting)) {
        this.hot.batchExecution(function() {
          initialSetting.forEach(function(width, physicalIndex) {
            _this3.columnWidthsMap.setValueAtIndex(physicalIndex, width);
          });
        }, true);
        priv.config = initialSetting;
      } else if (initialSetting === true && Array.isArray(priv.config)) {
        this.hot.batchExecution(function() {
          priv.config.forEach(function(width, physicalIndex) {
            _this3.columnWidthsMap.setValueAtIndex(physicalIndex, width);
          });
        }, true);
      }
    }
  }, {
    key: "setupHandlePosition",
    value: function setupHandlePosition(TH) {
      var _this4 = this;
      if (!TH.parentNode) {
        return;
      }
      this.currentTH = TH;
      var wt = this.hot.view.wt;
      var cellCoords = wt.wtTable.getCoords(this.currentTH);
      var col = cellCoords.col;
      if (col < 0) {
        return;
      }
      var headerHeight = outerHeight(this.currentTH);
      var box = this.currentTH.getBoundingClientRect();
      var fixedColumn = col < wt.getSetting("fixedColumnsLeft");
      var relativeHeaderPosition;
      if (fixedColumn) {
        relativeHeaderPosition = wt.wtOverlays.topLeftCornerOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      }
      if (!relativeHeaderPosition) {
        relativeHeaderPosition = wt.wtOverlays.topOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
      }
      this.currentCol = this.hot.columnIndexMapper.getVisualFromRenderableIndex(col);
      this.selectedCols = [];
      var isFullColumnSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByColumnHeader();
      if (this.hot.selection.isSelected() && isFullColumnSelected) {
        var selectionRanges = this.hot.getSelectedRange();
        arrayEach(selectionRanges, function(selectionRange) {
          var fromColumn = selectionRange.getTopLeftCorner().col;
          var toColumn = selectionRange.getBottomRightCorner().col;
          rangeEach(fromColumn, toColumn, function(columnIndex) {
            if (!_this4.selectedCols.includes(columnIndex)) {
              _this4.selectedCols.push(columnIndex);
            }
          });
        });
      }
      if (!this.selectedCols.includes(this.currentCol)) {
        this.selectedCols = [this.currentCol];
      }
      this.startOffset = relativeHeaderPosition.left - 6;
      this.startWidth = parseInt(box.width, 10);
      this.handle.style.top = "".concat(relativeHeaderPosition.top, "px");
      this.handle.style.left = "".concat(this.startOffset + this.startWidth, "px");
      this.handle.style.height = "".concat(headerHeight, "px");
      this.hot.rootElement.appendChild(this.handle);
    }
  }, {
    key: "refreshHandlePosition",
    value: function refreshHandlePosition() {
      this.handle.style.left = "".concat(this.startOffset + this.currentWidth, "px");
    }
  }, {
    key: "setupGuidePosition",
    value: function setupGuidePosition() {
      var handleHeight = parseInt(outerHeight(this.handle), 10);
      var handleBottomPosition = parseInt(this.handle.style.top, 10) + handleHeight;
      var maximumVisibleElementHeight = parseInt(this.hot.view.maximumVisibleElementHeight(0), 10);
      addClass(this.handle, "active");
      addClass(this.guide, "active");
      this.guide.style.top = "".concat(handleBottomPosition, "px");
      this.guide.style.left = this.handle.style.left;
      this.guide.style.height = "".concat(maximumVisibleElementHeight - handleHeight, "px");
      this.hot.rootElement.appendChild(this.guide);
    }
  }, {
    key: "refreshGuidePosition",
    value: function refreshGuidePosition() {
      this.guide.style.left = this.handle.style.left;
    }
  }, {
    key: "hideHandleAndGuide",
    value: function hideHandleAndGuide() {
      removeClass(this.handle, "active");
      removeClass(this.guide, "active");
    }
  }, {
    key: "checkIfColumnHeader",
    value: function checkIfColumnHeader(element) {
      return !!closest(element, ["THEAD"], this.hot.rootElement);
    }
  }, {
    key: "getClosestTHParent",
    value: function getClosestTHParent(element) {
      if (element.tagName !== "TABLE") {
        if (element.tagName === "TH") {
          return element;
        }
        return this.getClosestTHParent(element.parentNode);
      }
      return null;
    }
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event) {
      if (isDetached(event.target)) {
        return;
      }
      if (this.checkIfColumnHeader(event.target)) {
        var th = this.getClosestTHParent(event.target);
        if (!th) {
          return;
        }
        var colspan = th.getAttribute("colspan");
        if (th && (colspan === null || colspan === 1)) {
          if (!this.pressed) {
            this.setupHandlePosition(th);
          }
        }
      }
    }
  }, {
    key: "afterMouseDownTimeout",
    value: function afterMouseDownTimeout() {
      var _this5 = this;
      var render = function render2() {
        _this5.hot.forceFullRender = true;
        _this5.hot.view.render();
        _this5.hot.view.adjustElementsSize(true);
      };
      var resize = function resize2(column, forceRender) {
        var hookNewSize = _this5.hot.runHooks("beforeColumnResize", _this5.newSize, column, true);
        if (hookNewSize !== void 0) {
          _this5.newSize = hookNewSize;
        }
        if (_this5.hot.getSettings().stretchH === "all") {
          _this5.clearManualSize(column);
        } else {
          _this5.setManualSize(column, _this5.newSize);
        }
        _this5.saveManualColumnWidths();
        _this5.hot.runHooks("afterColumnResize", _this5.newSize, column, true);
        if (forceRender) {
          render();
        }
      };
      if (this.dblclick >= 2) {
        var selectedColsLength = this.selectedCols.length;
        if (selectedColsLength > 1) {
          arrayEach(this.selectedCols, function(selectedCol) {
            resize(selectedCol);
          });
          render();
        } else {
          arrayEach(this.selectedCols, function(selectedCol) {
            resize(selectedCol, true);
          });
        }
      }
      this.dblclick = 0;
      this.autoresizeTimeout = null;
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      var _this6 = this;
      if (hasClass(event.target, "manualColumnResizer")) {
        this.setupHandlePosition(this.currentTH);
        this.setupGuidePosition();
        this.pressed = true;
        if (this.autoresizeTimeout === null) {
          this.autoresizeTimeout = setTimeout(function() {
            return _this6.afterMouseDownTimeout();
          }, 500);
          this.hot._registerTimeout(this.autoresizeTimeout);
        }
        this.dblclick += 1;
        this.startX = event.pageX;
        this.newSize = this.startWidth;
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var _this7 = this;
      if (this.pressed) {
        this.currentWidth = this.startWidth + (event.pageX - this.startX);
        arrayEach(this.selectedCols, function(selectedCol) {
          _this7.newSize = _this7.setManualSize(selectedCol, _this7.currentWidth);
        });
        this.refreshHandlePosition();
        this.refreshGuidePosition();
      }
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp() {
      var _this8 = this;
      var render = function render2() {
        _this8.hot.forceFullRender = true;
        _this8.hot.view.render();
        _this8.hot.view.adjustElementsSize(true);
      };
      var resize = function resize2(column, forceRender) {
        _this8.hot.runHooks("beforeColumnResize", _this8.newSize, column, false);
        if (forceRender) {
          render();
        }
        _this8.saveManualColumnWidths();
        _this8.hot.runHooks("afterColumnResize", _this8.newSize, column, false);
      };
      if (this.pressed) {
        this.hideHandleAndGuide();
        this.pressed = false;
        if (this.newSize !== this.startWidth) {
          var selectedColsLength = this.selectedCols.length;
          if (selectedColsLength > 1) {
            arrayEach(this.selectedCols, function(selectedCol) {
              resize(selectedCol);
            });
            render();
          } else {
            arrayEach(this.selectedCols, function(selectedCol) {
              resize(selectedCol, true);
            });
          }
        }
        this.setupHandlePosition(this.currentTH);
      }
    }
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      var _this9 = this;
      var _this$hot = this.hot, rootWindow = _this$hot.rootWindow, rootElement = _this$hot.rootElement;
      this.eventManager.addEventListener(rootElement, "mouseover", function(e) {
        return _this9.onMouseOver(e);
      });
      this.eventManager.addEventListener(rootElement, "mousedown", function(e) {
        return _this9.onMouseDown(e);
      });
      this.eventManager.addEventListener(rootWindow, "mousemove", function(e) {
        return _this9.onMouseMove(e);
      });
      this.eventManager.addEventListener(rootWindow, "mouseup", function() {
        return _this9.onMouseUp();
      });
    }
  }, {
    key: "onModifyColWidth",
    value: function onModifyColWidth(width, column) {
      var newWidth = width;
      if (this.enabled) {
        var physicalColumn = this.hot.toPhysicalColumn(column);
        var columnWidth = this.columnWidthsMap.getValueAtIndex(physicalColumn);
        if (this.hot.getSettings()[PLUGIN_KEY$e] && columnWidth) {
          newWidth = columnWidth;
        }
      }
      return newWidth;
    }
  }, {
    key: "onBeforeStretchingColumnWidth",
    value: function onBeforeStretchingColumnWidth(stretchedWidth, column) {
      var width = this.columnWidthsMap.getValueAtIndex(column);
      if (width === null) {
        width = stretchedWidth;
      }
      return width;
    }
  }, {
    key: "onBeforeColumnResize",
    value: function onBeforeColumnResize() {
      this.hot.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$q(_getPrototypeOf$N(ManualColumnResize2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$e;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$d;
    }
  }]);
  return ManualColumnResize2;
}(BasePlugin);

function _classCallCheck$1M(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1G(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1G(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1G(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1G(Constructor, staticProps);
  return Constructor;
}
var STATE_INITIALIZED$1 = 0;
var STATE_BUILT$1 = 1;
var STATE_APPENDED$1 = 2;
var UNIT$1 = "px";
var BaseUI$1 = /* @__PURE__ */ function() {
  function BaseUI2(hotInstance) {
    _classCallCheck$1M(this, BaseUI2);
    this.hot = hotInstance;
    this._element = null;
    this.state = STATE_INITIALIZED$1;
  }
  _createClass$1G(BaseUI2, [{
    key: "appendTo",
    value: function appendTo(wrapper) {
      wrapper.appendChild(this._element);
      this.state = STATE_APPENDED$1;
    }
  }, {
    key: "build",
    value: function build() {
      if (this.state !== STATE_INITIALIZED$1) {
        return;
      }
      this._element = this.hot.rootDocument.createElement("div");
      this.state = STATE_BUILT$1;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.isAppended()) {
        this._element.parentElement.removeChild(this._element);
      }
      this._element = null;
      this.state = STATE_INITIALIZED$1;
    }
  }, {
    key: "isAppended",
    value: function isAppended() {
      return this.state === STATE_APPENDED$1;
    }
  }, {
    key: "isBuilt",
    value: function isBuilt() {
      return this.state >= STATE_BUILT$1;
    }
  }, {
    key: "setPosition",
    value: function setPosition(top, left) {
      if (top !== void 0) {
        this._element.style.top = top + UNIT$1;
      }
      if (left !== void 0) {
        this._element.style.left = left + UNIT$1;
      }
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return {
        top: this._element.style.top ? parseInt(this._element.style.top, 10) : 0,
        left: this._element.style.left ? parseInt(this._element.style.left, 10) : 0
      };
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      if (width) {
        this._element.style.width = width + UNIT$1;
      }
      if (height) {
        this._element.style.height = height + UNIT$1;
      }
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return {
        width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
        height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
      };
    }
  }, {
    key: "setOffset",
    value: function setOffset(top, left) {
      if (top) {
        this._element.style.marginTop = top + UNIT$1;
      }
      if (left) {
        this._element.style.marginLeft = left + UNIT$1;
      }
    }
  }, {
    key: "getOffset",
    value: function getOffset() {
      return {
        top: this._element.style.marginTop ? parseInt(this._element.style.marginTop, 10) : 0,
        left: this._element.style.marginLeft ? parseInt(this._element.style.marginLeft, 10) : 0
      };
    }
  }]);
  return BaseUI2;
}();

function _typeof$_(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$_ = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$_ = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$_(obj);
}
function _classCallCheck$1N(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1H(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1H(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1H(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1H(Constructor, staticProps);
  return Constructor;
}
function _get$r(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$r = Reflect.get;
  } else {
    _get$r = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$r(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$r(target, property, receiver || target);
}
function _superPropBase$r(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$O(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$O(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$P(subClass, superClass);
}
function _setPrototypeOf$P(o, p) {
  _setPrototypeOf$P = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$P(o, p);
}
function _createSuper$O(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$P();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$O(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$O(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$O(this, result);
  };
}
function _possibleConstructorReturn$O(self, call) {
  if (call && (_typeof$_(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$O(self);
}
function _assertThisInitialized$O(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$P() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$O(o) {
  _getPrototypeOf$O = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$O(o);
}
var CSS_CLASSNAME$2 = "ht__manualRowMove--backlight";
var BacklightUI$1 = /* @__PURE__ */ function(_BaseUI) {
  _inherits$O(BacklightUI2, _BaseUI);
  var _super = _createSuper$O(BacklightUI2);
  function BacklightUI2() {
    _classCallCheck$1N(this, BacklightUI2);
    return _super.apply(this, arguments);
  }
  _createClass$1H(BacklightUI2, [{
    key: "build",
    value: function build() {
      _get$r(_getPrototypeOf$O(BacklightUI2.prototype), "build", this).call(this);
      addClass(this._element, CSS_CLASSNAME$2);
    }
  }]);
  return BacklightUI2;
}(BaseUI$1);

function _typeof$$(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$$ = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$$ = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$$(obj);
}
function _classCallCheck$1O(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1I(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1I(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1I(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1I(Constructor, staticProps);
  return Constructor;
}
function _get$s(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$s = Reflect.get;
  } else {
    _get$s = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$s(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$s(target, property, receiver || target);
}
function _superPropBase$s(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$P(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$P(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$Q(subClass, superClass);
}
function _setPrototypeOf$Q(o, p) {
  _setPrototypeOf$Q = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$Q(o, p);
}
function _createSuper$P(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$P(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$P(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$P(this, result);
  };
}
function _possibleConstructorReturn$P(self, call) {
  if (call && (_typeof$$(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$P(self);
}
function _assertThisInitialized$P(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$Q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$P(o) {
  _getPrototypeOf$P = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$P(o);
}
var CSS_CLASSNAME$3 = "ht__manualRowMove--guideline";
var GuidelineUI$1 = /* @__PURE__ */ function(_BaseUI) {
  _inherits$P(GuidelineUI2, _BaseUI);
  var _super = _createSuper$P(GuidelineUI2);
  function GuidelineUI2() {
    _classCallCheck$1O(this, GuidelineUI2);
    return _super.apply(this, arguments);
  }
  _createClass$1I(GuidelineUI2, [{
    key: "build",
    value: function build() {
      _get$s(_getPrototypeOf$P(GuidelineUI2.prototype), "build", this).call(this);
      addClass(this._element, CSS_CLASSNAME$3);
    }
  }]);
  return GuidelineUI2;
}(BaseUI$1);

function _typeof$10(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$10 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$10 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$10(obj);
}
function _classCallCheck$1P(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1J(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1J(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1J(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1J(Constructor, staticProps);
  return Constructor;
}
function _get$t(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$t = Reflect.get;
  } else {
    _get$t = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$t(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$t(target, property, receiver || target);
}
function _superPropBase$t(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$Q(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$Q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$R(subClass, superClass);
}
function _setPrototypeOf$R(o, p) {
  _setPrototypeOf$R = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$R(o, p);
}
function _createSuper$Q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$R();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$Q(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$Q(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$Q(this, result);
  };
}
function _possibleConstructorReturn$Q(self, call) {
  if (call && (_typeof$10(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$Q(self);
}
function _assertThisInitialized$Q(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$R() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$Q(o) {
  _getPrototypeOf$Q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$Q(o);
}
Hooks.getSingleton().register("beforeRowMove");
Hooks.getSingleton().register("afterRowMove");
var PLUGIN_KEY$f = "manualRowMove";
var PLUGIN_PRIORITY$e = 140;
var privatePool$d = new WeakMap();
var CSS_PLUGIN$1 = "ht__manualRowMove";
var CSS_SHOW_UI$1 = "show-ui";
var CSS_ON_MOVING$1 = "on-moving--rows";
var CSS_AFTER_SELECTION$1 = "after-selection--rows";
var ManualRowMove = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$Q(ManualRowMove2, _BasePlugin);
  var _super = _createSuper$Q(ManualRowMove2);
  function ManualRowMove2(hotInstance) {
    var _this;
    _classCallCheck$1P(this, ManualRowMove2);
    _this = _super.call(this, hotInstance);
    privatePool$d.set(_assertThisInitialized$Q(_this), {
      rowsToMove: [],
      pressed: void 0,
      target: {
        eventPageY: void 0,
        coords: void 0,
        TD: void 0,
        row: void 0
      },
      cachedDropIndex: void 0
    });
    _this.eventManager = new EventManager(_assertThisInitialized$Q(_this));
    _this.backlight = new BacklightUI$1(hotInstance);
    _this.guideline = new GuidelineUI$1(hotInstance);
    return _this;
  }
  _createClass$1J(ManualRowMove2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$f];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("beforeOnCellMouseDown", function(event, coords, TD, blockCalculations) {
        return _this2.onBeforeOnCellMouseDown(event, coords, TD, blockCalculations);
      });
      this.addHook("beforeOnCellMouseOver", function(event, coords, TD, blockCalculations) {
        return _this2.onBeforeOnCellMouseOver(event, coords, TD, blockCalculations);
      });
      this.addHook("afterScrollHorizontally", function() {
        return _this2.onAfterScrollHorizontally();
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData();
      });
      this.buildPluginUI();
      this.registerEvents();
      addClass(this.hot.rootElement, CSS_PLUGIN$1);
      _get$t(_getPrototypeOf$Q(ManualRowMove2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.moveBySettingsOrLoad();
      _get$t(_getPrototypeOf$Q(ManualRowMove2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      removeClass(this.hot.rootElement, CSS_PLUGIN$1);
      this.unregisterEvents();
      this.backlight.destroy();
      this.guideline.destroy();
      _get$t(_getPrototypeOf$Q(ManualRowMove2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "moveRow",
    value: function moveRow(row, finalIndex) {
      return this.moveRows([row], finalIndex);
    }
  }, {
    key: "moveRows",
    value: function moveRows(rows, finalIndex) {
      var priv = privatePool$d.get(this);
      var dropIndex = priv.cachedDropIndex;
      var movePossible = this.isMovePossible(rows, finalIndex);
      var beforeMoveHook = this.hot.runHooks("beforeRowMove", rows, finalIndex, dropIndex, movePossible);
      priv.cachedDropIndex = void 0;
      if (beforeMoveHook === false) {
        return;
      }
      if (movePossible) {
        this.hot.rowIndexMapper.moveIndexes(rows, finalIndex);
      }
      var movePerformed = movePossible && this.isRowOrderChanged(rows, finalIndex);
      this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, movePerformed);
      return movePerformed;
    }
  }, {
    key: "dragRow",
    value: function dragRow(row, dropIndex) {
      return this.dragRows([row], dropIndex);
    }
  }, {
    key: "dragRows",
    value: function dragRows(rows, dropIndex) {
      var finalIndex = this.countFinalIndex(rows, dropIndex);
      var priv = privatePool$d.get(this);
      priv.cachedDropIndex = dropIndex;
      return this.moveRows(rows, finalIndex);
    }
  }, {
    key: "isMovePossible",
    value: function isMovePossible(movedRows, finalIndex) {
      var length = this.hot.rowIndexMapper.getNotTrimmedIndexesLength();
      var tooHighDestinationIndex = movedRows.length + finalIndex > length;
      var tooLowDestinationIndex = finalIndex < 0;
      var tooLowMovedRowIndex = movedRows.some(function(movedRow) {
        return movedRow < 0;
      });
      var tooHighMovedRowIndex = movedRows.some(function(movedRow) {
        return movedRow >= length;
      });
      if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedRowIndex || tooHighMovedRowIndex) {
        return false;
      }
      return true;
    }
  }, {
    key: "isRowOrderChanged",
    value: function isRowOrderChanged(movedRows, finalIndex) {
      return movedRows.some(function(row, nrOfMovedElement) {
        return row - nrOfMovedElement !== finalIndex;
      });
    }
  }, {
    key: "countFinalIndex",
    value: function countFinalIndex(movedRows, dropIndex) {
      var numberOfRowsLowerThanDropIndex = arrayReduce(movedRows, function(numberOfRows, currentRowIndex) {
        if (currentRowIndex < dropIndex) {
          numberOfRows += 1;
        }
        return numberOfRows;
      }, 0);
      return dropIndex - numberOfRowsLowerThanDropIndex;
    }
  }, {
    key: "getRowsHeight",
    value: function getRowsHeight(fromRow, toRow) {
      var rowMapper = this.hot.rowIndexMapper;
      var rowsHeight = 0;
      for (var visualRowIndex = fromRow; visualRowIndex <= toRow; visualRowIndex++) {
        var renderableIndex = rowMapper.getRenderableFromVisualIndex(visualRowIndex);
        if (renderableIndex !== null) {
          rowsHeight += this.hot.view.wt.wtTable.getRowHeight(renderableIndex) || 23;
        }
      }
      return rowsHeight;
    }
  }, {
    key: "moveBySettingsOrLoad",
    value: function moveBySettingsOrLoad() {
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$f];
      if (Array.isArray(pluginSettings)) {
        this.moveRows(pluginSettings, 0);
      } else if (pluginSettings !== void 0) {
        var persistentState = this.persistentStateLoad();
        if (persistentState.length) {
          this.moveRows(persistentState, 0);
        }
      }
    }
  }, {
    key: "isFixedRowTop",
    value: function isFixedRowTop(row) {
      return row < this.hot.getSettings().fixedRowsTop;
    }
  }, {
    key: "isFixedRowBottom",
    value: function isFixedRowBottom(row) {
      return row > this.hot.getSettings().fixedRowsBottom;
    }
  }, {
    key: "persistentStateSave",
    value: function persistentStateSave() {
      this.hot.runHooks("persistentStateSave", "manualRowMove", this.hot.rowIndexMapper.getIndexesSequence());
    }
  }, {
    key: "persistentStateLoad",
    value: function persistentStateLoad() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", "manualRowMove", storedState);
      return storedState.value ? storedState.value : [];
    }
  }, {
    key: "prepareRowsToMoving",
    value: function prepareRowsToMoving() {
      var selection = this.hot.getSelectedRangeLast();
      var selectedRows = [];
      if (!selection) {
        return selectedRows;
      }
      var from = selection.from, to = selection.to;
      var start = Math.min(from.row, to.row);
      var end = Math.max(from.row, to.row);
      rangeEach(start, end, function(i) {
        selectedRows.push(i);
      });
      return selectedRows;
    }
  }, {
    key: "refreshPositions",
    value: function refreshPositions() {
      var priv = privatePool$d.get(this);
      var coords = priv.target.coords;
      var firstVisible = this.hot.view.wt.wtTable.getFirstVisibleRow();
      var lastVisible = this.hot.view.wt.wtTable.getLastVisibleRow();
      var fixedRows = this.hot.getSettings().fixedRowsTop;
      var countRows = this.hot.countRows();
      if (coords.row < fixedRows && firstVisible > 0) {
        this.hot.scrollViewportTo(firstVisible - 1);
      }
      if (coords.row >= lastVisible && lastVisible < countRows) {
        this.hot.scrollViewportTo(lastVisible + 1, void 0, true);
      }
      var wtTable = this.hot.view.wt.wtTable;
      var TD = priv.target.TD;
      var rootElementOffset = offset$1(this.hot.rootElement);
      var tdOffsetTop = this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row - 1);
      var mouseOffsetTop = priv.target.eventPageY - rootElementOffset.top + wtTable.holder.scrollTop;
      var hiderHeight = wtTable.hider.offsetHeight;
      var tbodyOffsetTop = wtTable.TBODY.offsetTop;
      var backlightElemMarginTop = this.backlight.getOffset().top;
      var backlightElemHeight = this.backlight.getSize().height;
      if (this.isFixedRowTop(coords.row)) {
        tdOffsetTop += wtTable.holder.scrollTop;
      }
      if (coords.row < 0) {
        priv.target.row = firstVisible > 0 ? firstVisible - 1 : firstVisible;
      } else if (TD.offsetHeight / 2 + tdOffsetTop <= mouseOffsetTop) {
        priv.target.row = coords.row + 1;
        tdOffsetTop += coords.row === 0 ? TD.offsetHeight - 1 : TD.offsetHeight;
      } else {
        priv.target.row = coords.row;
      }
      var backlightTop = mouseOffsetTop;
      var guidelineTop = tdOffsetTop;
      if (mouseOffsetTop + backlightElemHeight + backlightElemMarginTop >= hiderHeight) {
        backlightTop = hiderHeight - backlightElemHeight - backlightElemMarginTop;
      } else if (mouseOffsetTop + backlightElemMarginTop < tbodyOffsetTop) {
        backlightTop = tbodyOffsetTop + Math.abs(backlightElemMarginTop);
      }
      if (tdOffsetTop >= hiderHeight - 1) {
        guidelineTop = hiderHeight - 1;
      }
      var topOverlayHeight = 0;
      if (this.hot.view.wt.wtOverlays.topOverlay) {
        topOverlayHeight = this.hot.view.wt.wtOverlays.topOverlay.clone.wtTable.TABLE.offsetHeight;
      }
      if (coords.row >= fixedRows && guidelineTop - wtTable.holder.scrollTop < topOverlayHeight) {
        this.hot.scrollViewportTo(coords.row);
      }
      this.backlight.setPosition(backlightTop);
      this.guideline.setPosition(guidelineTop);
    }
  }, {
    key: "registerEvents",
    value: function registerEvents() {
      var _this3 = this;
      var documentElement = this.hot.rootDocument.documentElement;
      this.eventManager.addEventListener(documentElement, "mousemove", function(event) {
        return _this3.onMouseMove(event);
      });
      this.eventManager.addEventListener(documentElement, "mouseup", function() {
        return _this3.onMouseUp();
      });
    }
  }, {
    key: "unregisterEvents",
    value: function unregisterEvents() {
      this.eventManager.clear();
    }
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event, coords, TD, blockCalculations) {
      var _this$hot$view$wt = this.hot.view.wt, wtTable = _this$hot$view$wt.wtTable, wtViewport = _this$hot$view$wt.wtViewport;
      var isHeaderSelection = this.hot.selection.isSelectedByRowHeader();
      var selection = this.hot.getSelectedRangeLast();
      var priv = privatePool$d.get(this);
      if (!selection || !isHeaderSelection || priv.pressed || event.button !== 0) {
        priv.pressed = false;
        priv.rowsToMove.length = 0;
        removeClass(this.hot.rootElement, [CSS_ON_MOVING$1, CSS_SHOW_UI$1]);
        return;
      }
      var guidelineIsNotReady = this.guideline.isBuilt() && !this.guideline.isAppended();
      var backlightIsNotReady = this.backlight.isBuilt() && !this.backlight.isAppended();
      if (guidelineIsNotReady && backlightIsNotReady) {
        this.guideline.appendTo(wtTable.hider);
        this.backlight.appendTo(wtTable.hider);
      }
      var from = selection.from, to = selection.to;
      var start = Math.min(from.row, to.row);
      var end = Math.max(from.row, to.row);
      if (coords.col < 0 && coords.row >= start && coords.row <= end) {
        blockCalculations.row = true;
        priv.pressed = true;
        priv.target.eventPageY = event.pageY;
        priv.target.coords = coords;
        priv.target.TD = TD;
        priv.rowsToMove = this.prepareRowsToMoving();
        var leftPos = wtTable.holder.scrollLeft + wtViewport.getRowHeaderWidth();
        this.backlight.setPosition(null, leftPos);
        this.backlight.setSize(wtTable.hider.offsetWidth - leftPos, this.getRowsHeight(start, end));
        this.backlight.setOffset((this.getRowsHeight(start, coords.row - 1) + event.offsetY) * -1, null);
        addClass(this.hot.rootElement, CSS_ON_MOVING$1);
        this.refreshPositions();
      } else {
        removeClass(this.hot.rootElement, CSS_AFTER_SELECTION$1);
        priv.pressed = false;
        priv.rowsToMove.length = 0;
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var priv = privatePool$d.get(this);
      if (!priv.pressed) {
        return;
      }
      if (event.target === this.backlight.element) {
        var height = this.backlight.getSize().height;
        this.backlight.setSize(null, 0);
        setTimeout(function() {
          this.backlight.setPosition(null, height);
        });
      }
      priv.target.eventPageY = event.pageY;
      this.refreshPositions();
    }
  }, {
    key: "onBeforeOnCellMouseOver",
    value: function onBeforeOnCellMouseOver(event, coords, TD, blockCalculations) {
      var selectedRange = this.hot.getSelectedRangeLast();
      var priv = privatePool$d.get(this);
      if (!selectedRange || !priv.pressed) {
        return;
      }
      if (priv.rowsToMove.indexOf(coords.row) > -1) {
        removeClass(this.hot.rootElement, CSS_SHOW_UI$1);
      } else {
        addClass(this.hot.rootElement, CSS_SHOW_UI$1);
      }
      blockCalculations.row = true;
      blockCalculations.column = true;
      blockCalculations.cell = true;
      priv.target.coords = coords;
      priv.target.TD = TD;
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp() {
      var priv = privatePool$d.get(this);
      var target = priv.target.row;
      var rowsLen = priv.rowsToMove.length;
      priv.pressed = false;
      priv.backlightHeight = 0;
      removeClass(this.hot.rootElement, [CSS_ON_MOVING$1, CSS_SHOW_UI$1, CSS_AFTER_SELECTION$1]);
      if (this.hot.selection.isSelectedByRowHeader()) {
        addClass(this.hot.rootElement, CSS_AFTER_SELECTION$1);
      }
      if (rowsLen < 1 || target === void 0) {
        return;
      }
      var firstMovedVisualRow = priv.rowsToMove[0];
      var firstMovedPhysicalRow = this.hot.toPhysicalRow(firstMovedVisualRow);
      var movePerformed = this.dragRows(priv.rowsToMove, target);
      priv.rowsToMove.length = 0;
      if (movePerformed === true) {
        this.persistentStateSave();
        this.hot.render();
        this.hot.view.adjustElementsSize(true);
        var selectionStart = this.hot.toVisualRow(firstMovedPhysicalRow);
        var selectionEnd = selectionStart + rowsLen - 1;
        this.hot.selectRows(selectionStart, selectionEnd);
      }
    }
  }, {
    key: "onAfterScrollHorizontally",
    value: function onAfterScrollHorizontally() {
      var wtTable = this.hot.view.wt.wtTable;
      var headerWidth = this.hot.view.wt.wtViewport.getRowHeaderWidth();
      var scrollLeft = wtTable.holder.scrollLeft;
      var posLeft = headerWidth + scrollLeft;
      this.backlight.setPosition(null, posLeft);
      this.backlight.setSize(wtTable.hider.offsetWidth - posLeft);
    }
  }, {
    key: "buildPluginUI",
    value: function buildPluginUI() {
      this.backlight.build();
      this.guideline.build();
    }
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      this.moveBySettingsOrLoad();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.backlight.destroy();
      this.guideline.destroy();
      _get$t(_getPrototypeOf$Q(ManualRowMove2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$f;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$e;
    }
  }]);
  return ManualRowMove2;
}(BasePlugin);

var _templateObject$5, _templateObject2$1, _templateObject3$1, _templateObject4$1;
function _taggedTemplateLiteral$5(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _classCallCheck$1Q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1K(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1K(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1K(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1K(Constructor, staticProps);
  return Constructor;
}
var MergedCellCoords = /* @__PURE__ */ function() {
  function MergedCellCoords2(row, column, rowspan, colspan) {
    _classCallCheck$1Q(this, MergedCellCoords2);
    this.row = row;
    this.col = column;
    this.rowspan = rowspan;
    this.colspan = colspan;
    this.removed = false;
  }
  _createClass$1K(MergedCellCoords2, [{
    key: "normalize",
    value: function normalize(hotInstance) {
      var totalRows = hotInstance.countRows();
      var totalColumns = hotInstance.countCols();
      if (this.row < 0) {
        this.row = 0;
      } else if (this.row > totalRows - 1) {
        this.row = totalRows - 1;
      }
      if (this.col < 0) {
        this.col = 0;
      } else if (this.col > totalColumns - 1) {
        this.col = totalColumns - 1;
      }
      if (this.row + this.rowspan > totalRows - 1) {
        this.rowspan = totalRows - this.row;
      }
      if (this.col + this.colspan > totalColumns - 1) {
        this.colspan = totalColumns - this.col;
      }
    }
  }, {
    key: "includes",
    value: function includes(row, column) {
      return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;
    }
  }, {
    key: "includesHorizontally",
    value: function includesHorizontally(column) {
      return this.col <= column && this.col + this.colspan - 1 >= column;
    }
  }, {
    key: "includesVertically",
    value: function includesVertically(row) {
      return this.row <= row && this.row + this.rowspan - 1 >= row;
    }
  }, {
    key: "shift",
    value: function shift(shiftVector, indexOfChange) {
      var shiftValue = shiftVector[0] || shiftVector[1];
      var shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;
      var span = shiftVector[0] ? "colspan" : "rowspan";
      var index = shiftVector[0] ? "col" : "row";
      var changeStart = Math.min(indexOfChange, shiftedIndex);
      var changeEnd = Math.max(indexOfChange, shiftedIndex);
      var mergeStart = this[index];
      var mergeEnd = this[index] + this[span] - 1;
      if (mergeStart >= indexOfChange) {
        this[index] += shiftValue;
      }
      if (shiftValue > 0) {
        if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {
          this[span] += shiftValue;
        }
      } else if (shiftValue < 0) {
        if (changeStart <= mergeStart && changeEnd >= mergeEnd) {
          this.removed = true;
          return false;
        } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {
          var removedOffset = changeEnd - mergeStart + 1;
          var preRemovedOffset = Math.abs(shiftValue) - removedOffset;
          this[index] -= preRemovedOffset + shiftValue;
          this[span] -= removedOffset;
        } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {
          this[span] += shiftValue;
        } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {
          var removedPart = mergeEnd - changeStart + 1;
          this[span] -= removedPart;
        }
      }
      return true;
    }
  }, {
    key: "isFarther",
    value: function isFarther(mergedCell, direction) {
      if (!mergedCell) {
        return true;
      }
      if (direction === "down") {
        return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;
      } else if (direction === "up") {
        return mergedCell.row > this.row;
      } else if (direction === "right") {
        return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;
      } else if (direction === "left") {
        return mergedCell.col > this.col;
      }
      return null;
    }
  }, {
    key: "getLastRow",
    value: function getLastRow() {
      return this.row + this.rowspan - 1;
    }
  }, {
    key: "getLastColumn",
    value: function getLastColumn() {
      return this.col + this.colspan - 1;
    }
  }, {
    key: "getRange",
    value: function getRange() {
      return new CellRange(new CellCoords(this.row, this.col), new CellCoords(this.row, this.col), new CellCoords(this.getLastRow(), this.getLastColumn()));
    }
  }], [{
    key: "NEGATIVE_VALUES_WARNING",
    value: function NEGATIVE_VALUES_WARNING(newMergedCell) {
      return toSingleLine(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral$5(["The merged cell declared with {row: ", ", col: ", ", \n      rowspan: ", ", colspan: ", "} contains negative values, which is \n      not supported. It will not be added to the collection."], ["The merged cell declared with {row: ", ", col: ", ",\\x20\n      rowspan: ", ", colspan: ", "} contains negative values, which is\\x20\n      not supported. It will not be added to the collection."])), newMergedCell.row, newMergedCell.col, newMergedCell.rowspan, newMergedCell.colspan);
    }
  }, {
    key: "IS_OUT_OF_BOUNDS_WARNING",
    value: function IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {
      return toSingleLine(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral$5(["The merged cell declared at [", ", ", "] is positioned \n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup."], ["The merged cell declared at [", ", ", "] is positioned\\x20\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup."])), newMergedCell.row, newMergedCell.col);
    }
  }, {
    key: "IS_SINGLE_CELL",
    value: function IS_SINGLE_CELL(newMergedCell) {
      return toSingleLine(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral$5(["The merged cell declared at [", ", ", '] has both "rowspan" \n      and "colspan" declared as "1", which makes it a single cell. It cannot be added to the collection.'], ["The merged cell declared at [", ", ", '] has both "rowspan"\\x20\n      and "colspan" declared as "1", which makes it a single cell. It cannot be added to the collection.'])), newMergedCell.row, newMergedCell.col);
    }
  }, {
    key: "ZERO_SPAN_WARNING",
    value: function ZERO_SPAN_WARNING(newMergedCell) {
      return toSingleLine(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral$5(["The merged cell declared at [", ", ", '] has "rowspan" \n      or "colspan" declared as "0", which is not supported. It cannot be added to the collection.'], ["The merged cell declared at [", ", ", '] has "rowspan"\\x20\n      or "colspan" declared as "0", which is not supported. It cannot be added to the collection.'])), newMergedCell.row, newMergedCell.col);
    }
  }, {
    key: "containsNegativeValues",
    value: function containsNegativeValues(mergedCellInfo) {
      return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;
    }
  }, {
    key: "isSingleCell",
    value: function isSingleCell(mergedCellInfo) {
      return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;
    }
  }, {
    key: "containsZeroSpan",
    value: function containsZeroSpan(mergedCellInfo) {
      return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;
    }
  }, {
    key: "isOutOfBounds",
    value: function isOutOfBounds(mergeCell, rowCount, columnCount) {
      return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;
    }
  }]);
  return MergedCellCoords2;
}();

function applySpanProperties(TD, mergedCellInfo, row, col) {
  if (mergedCellInfo) {
    if (mergedCellInfo.row === row && mergedCellInfo.col === col) {
      TD.setAttribute("rowspan", mergedCellInfo.rowspan.toString());
      TD.setAttribute("colspan", mergedCellInfo.colspan.toString());
    } else {
      TD.removeAttribute("rowspan");
      TD.removeAttribute("colspan");
      TD.style.display = "none";
    }
  } else {
    TD.removeAttribute("rowspan");
    TD.removeAttribute("colspan");
    TD.style.display = "";
  }
}

var _templateObject$6;
function _taggedTemplateLiteral$6(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _toConsumableArray$k(arr) {
  return _arrayWithoutHoles$i(arr) || _iterableToArray$j(arr) || _unsupportedIterableToArray$B(arr) || _nonIterableSpread$i();
}
function _nonIterableSpread$i() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$B(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$B(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$B(o, minLen);
}
function _iterableToArray$j(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$i(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$B(arr);
}
function _arrayLikeToArray$B(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1R(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1L(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1L(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1L(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1L(Constructor, staticProps);
  return Constructor;
}
var MergedCellsCollection = /* @__PURE__ */ function() {
  function MergedCellsCollection2(plugin) {
    _classCallCheck$1R(this, MergedCellsCollection2);
    this.plugin = plugin;
    this.mergedCells = [];
    this.hot = plugin.hot;
  }
  _createClass$1L(MergedCellsCollection2, [{
    key: "get",
    value: function get(row, column) {
      var mergedCells = this.mergedCells;
      var result = false;
      arrayEach(mergedCells, function(mergedCell) {
        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {
          result = mergedCell;
          return false;
        }
        return true;
      });
      return result;
    }
  }, {
    key: "getByRange",
    value: function getByRange(range) {
      var mergedCells = this.mergedCells;
      var result = false;
      arrayEach(mergedCells, function(mergedCell) {
        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {
          result = mergedCell;
          return result;
        }
        return true;
      });
      return result;
    }
  }, {
    key: "getWithinRange",
    value: function getWithinRange(range) {
      var countPartials = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var mergedCells = this.mergedCells;
      var foundMergedCells = [];
      var testedRange = range;
      if (!testedRange.includesRange) {
        var from = new CellCoords(testedRange.from.row, testedRange.from.col);
        var to = new CellCoords(testedRange.to.row, testedRange.to.col);
        testedRange = new CellRange(from, from, to);
      }
      arrayEach(mergedCells, function(mergedCell) {
        var mergedCellTopLeft = new CellCoords(mergedCell.row, mergedCell.col);
        var mergedCellBottomRight = new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);
        var mergedCellRange = new CellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
        if (countPartials) {
          if (testedRange.overlaps(mergedCellRange)) {
            foundMergedCells.push(mergedCell);
          }
        } else if (testedRange.includesRange(mergedCellRange)) {
          foundMergedCells.push(mergedCell);
        }
      });
      return foundMergedCells.length ? foundMergedCells : false;
    }
  }, {
    key: "add",
    value: function add(mergedCellInfo) {
      var mergedCells = this.mergedCells;
      var row = mergedCellInfo.row;
      var column = mergedCellInfo.col;
      var rowspan = mergedCellInfo.rowspan;
      var colspan = mergedCellInfo.colspan;
      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan);
      var alreadyExists = this.get(row, column);
      var isOverlapping = this.isOverlapping(newMergedCell);
      if (!alreadyExists && !isOverlapping) {
        if (this.hot) {
          newMergedCell.normalize(this.hot);
        }
        mergedCells.push(newMergedCell);
        return newMergedCell;
      }
      warn$1(MergedCellsCollection2.IS_OVERLAPPING_WARNING(newMergedCell));
      return false;
    }
  }, {
    key: "remove",
    value: function remove(row, column) {
      var mergedCells = this.mergedCells;
      var wantedCollection = this.get(row, column);
      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : null;
      if (wantedCollection && wantedCollectionIndex !== false) {
        mergedCells.splice(wantedCollectionIndex, 1);
        return wantedCollection;
      }
      return false;
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this = this;
      var mergedCells = this.mergedCells;
      var mergedCellParentsToClear = [];
      var hiddenCollectionElements = [];
      arrayEach(mergedCells, function(mergedCell) {
        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);
        if (TD) {
          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);
        }
      });
      this.mergedCells.length = 0;
      arrayEach(mergedCellParentsToClear, function(mergedCell, i) {
        rangeEach(0, mergedCell.rowspan - 1, function(j) {
          rangeEach(0, mergedCell.colspan - 1, function(k) {
            if (k !== 0 || j !== 0) {
              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);
              if (TD) {
                hiddenCollectionElements.push([TD, null, null, null]);
              }
            }
          });
        });
        mergedCellParentsToClear[i][1] = null;
      });
      arrayEach(mergedCellParentsToClear, function(mergedCellParents) {
        applySpanProperties.apply(void 0, _toConsumableArray$k(mergedCellParents));
      });
      arrayEach(hiddenCollectionElements, function(hiddenCollectionElement) {
        applySpanProperties.apply(void 0, _toConsumableArray$k(hiddenCollectionElement));
      });
    }
  }, {
    key: "isOverlapping",
    value: function isOverlapping(mergedCell) {
      var mergedCellRange = new CellRange(new CellCoords(0, 0), new CellCoords(mergedCell.row, mergedCell.col), new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));
      var result = false;
      arrayEach(this.mergedCells, function(col) {
        var currentRange = new CellRange(new CellCoords(0, 0), new CellCoords(col.row, col.col), new CellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));
        if (currentRange.overlaps(mergedCellRange)) {
          result = true;
          return false;
        }
        return true;
      });
      return result;
    }
  }, {
    key: "isFirstRenderableMergedCell",
    value: function isFirstRenderableMergedCell(row, column) {
      var mergeParent = this.get(row, column);
      return mergeParent && this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1) === column;
    }
  }, {
    key: "getFirstRenderableCoords",
    value: function getFirstRenderableCoords(row, column) {
      var mergeParent = this.get(row, column);
      if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {
        return new CellCoords(row, column);
      }
      var firstRenderableRow = this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1);
      var firstRenderableColumn = this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1);
      return new CellCoords(firstRenderableRow, firstRenderableColumn);
    }
  }, {
    key: "shiftCollections",
    value: function shiftCollections(direction, index, count) {
      var _this2 = this;
      var shiftVector = [0, 0];
      switch (direction) {
        case "right":
          shiftVector[0] += count;
          break;
        case "left":
          shiftVector[0] -= count;
          break;
        case "down":
          shiftVector[1] += count;
          break;
        case "up":
          shiftVector[1] -= count;
          break;
      }
      arrayEach(this.mergedCells, function(currentMerge) {
        currentMerge.shift(shiftVector, index);
      });
      rangeEachReverse(this.mergedCells.length - 1, 0, function(i) {
        var currentMerge = _this2.mergedCells[i];
        if (currentMerge && currentMerge.removed) {
          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);
        }
      });
    }
  }], [{
    key: "IS_OVERLAPPING_WARNING",
    value: function IS_OVERLAPPING_WARNING(newMergedCell) {
      return toSingleLine(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral$6(["The merged cell declared at [", ", ", "], overlaps \n      with the other declared merged cell. The overlapping merged cell was not added to the table, please \n      fix your setup."], ["The merged cell declared at [", ", ", "], overlaps\\x20\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\x20\n      fix your setup."])), newMergedCell.row, newMergedCell.col);
    }
  }]);
  return MergedCellsCollection2;
}();

function _slicedToArray$p(arr, i) {
  return _arrayWithHoles$q(arr) || _iterableToArrayLimit$p(arr, i) || _unsupportedIterableToArray$C(arr, i) || _nonIterableRest$q();
}
function _nonIterableRest$q() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$C(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$C(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$C(o, minLen);
}
function _arrayLikeToArray$C(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$p(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$q(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$1S(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1M(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1M(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1M(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1M(Constructor, staticProps);
  return Constructor;
}
var AutofillCalculations = /* @__PURE__ */ function() {
  function AutofillCalculations2(plugin) {
    _classCallCheck$1S(this, AutofillCalculations2);
    this.plugin = plugin;
    this.mergedCellsCollection = this.plugin.mergedCellsCollection;
    this.currentFillData = null;
  }
  _createClass$1M(AutofillCalculations2, [{
    key: "correctSelectionAreaSize",
    value: function correctSelectionAreaSize(selectionArea) {
      if (selectionArea[0] === selectionArea[2] && selectionArea[1] === selectionArea[3]) {
        var mergedCell = this.mergedCellsCollection.get(selectionArea[0], selectionArea[1]);
        if (mergedCell) {
          selectionArea[2] = selectionArea[0] + mergedCell.rowspan - 1;
          selectionArea[3] = selectionArea[1] + mergedCell.colspan - 1;
        }
      }
    }
  }, {
    key: "getDirection",
    value: function getDirection(selectionArea, finalArea) {
      var direction = null;
      if (finalArea[0] === selectionArea[0] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
        direction = "down";
      } else if (finalArea[2] === selectionArea[2] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
        direction = "up";
      } else if (finalArea[1] === selectionArea[1] && finalArea[2] === selectionArea[2]) {
        direction = "right";
      } else {
        direction = "left";
      }
      return direction;
    }
  }, {
    key: "snapDragArea",
    value: function snapDragArea(baseArea, dragArea, dragDirection, foundMergedCells) {
      var newDragArea = dragArea.slice(0);
      var fillSize = this.getAutofillSize(baseArea, dragArea, dragDirection);
      var _baseArea = _slicedToArray$p(baseArea, 4), baseAreaStartRow = _baseArea[0], baseAreaStartColumn = _baseArea[1], baseAreaEndRow = _baseArea[2], baseAreaEndColumn = _baseArea[3];
      var verticalDirection = ["up", "down"].indexOf(dragDirection) > -1;
      var fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
      var fulls = Math.floor(fillSize / fullCycle) * fullCycle;
      var partials = fillSize - fulls;
      var farthestCollection = this.getFarthestCollection(baseArea, dragArea, dragDirection, foundMergedCells);
      if (farthestCollection) {
        if (dragDirection === "down") {
          var fill = farthestCollection.row + farthestCollection.rowspan - baseAreaStartRow - partials;
          var newLimit = newDragArea[2] + fill;
          if (newLimit >= this.plugin.hot.countRows()) {
            newDragArea[2] -= partials;
          } else {
            newDragArea[2] += partials ? fill : 0;
          }
        } else if (dragDirection === "right") {
          var _fill = farthestCollection.col + farthestCollection.colspan - baseAreaStartColumn - partials;
          var _newLimit = newDragArea[3] + _fill;
          if (_newLimit >= this.plugin.hot.countCols()) {
            newDragArea[3] -= partials;
          } else {
            newDragArea[3] += partials ? _fill : 0;
          }
        } else if (dragDirection === "up") {
          var _fill2 = baseAreaEndRow - partials - farthestCollection.row + 1;
          var _newLimit2 = newDragArea[0] + _fill2;
          if (_newLimit2 < 0) {
            newDragArea[0] += partials;
          } else {
            newDragArea[0] -= partials ? _fill2 : 0;
          }
        } else if (dragDirection === "left") {
          var _fill3 = baseAreaEndColumn - partials - farthestCollection.col + 1;
          var _newLimit3 = newDragArea[1] + _fill3;
          if (_newLimit3 < 0) {
            newDragArea[1] += partials;
          } else {
            newDragArea[1] -= partials ? _fill3 : 0;
          }
        }
      }
      this.updateCurrentFillCache({
        baseArea,
        dragDirection,
        foundMergedCells,
        fillSize,
        dragArea: newDragArea,
        cycleLength: fullCycle
      });
      return newDragArea;
    }
  }, {
    key: "updateCurrentFillCache",
    value: function updateCurrentFillCache(updateObject) {
      if (!this.currentFillData) {
        this.currentFillData = {};
      }
      extend(this.currentFillData, updateObject);
    }
  }, {
    key: "getAutofillSize",
    value: function getAutofillSize(baseArea, dragArea, direction) {
      var _baseArea2 = _slicedToArray$p(baseArea, 4), baseAreaStartRow = _baseArea2[0], baseAreaStartColumn = _baseArea2[1], baseAreaEndRow = _baseArea2[2], baseAreaEndColumn = _baseArea2[3];
      var _dragArea = _slicedToArray$p(dragArea, 4), dragAreaStartRow = _dragArea[0], dragAreaStartColumn = _dragArea[1], dragAreaEndRow = _dragArea[2], dragAreaEndColumn = _dragArea[3];
      switch (direction) {
        case "up":
          return baseAreaStartRow - dragAreaStartRow;
        case "down":
          return dragAreaEndRow - baseAreaEndRow;
        case "left":
          return baseAreaStartColumn - dragAreaStartColumn;
        case "right":
          return dragAreaEndColumn - baseAreaEndColumn;
        default:
          return null;
      }
    }
  }, {
    key: "getDragArea",
    value: function getDragArea(baseArea, dragArea, direction) {
      var _baseArea3 = _slicedToArray$p(baseArea, 4), baseAreaStartRow = _baseArea3[0], baseAreaStartColumn = _baseArea3[1], baseAreaEndRow = _baseArea3[2], baseAreaEndColumn = _baseArea3[3];
      var _dragArea2 = _slicedToArray$p(dragArea, 4), dragAreaStartRow = _dragArea2[0], dragAreaStartColumn = _dragArea2[1], dragAreaEndRow = _dragArea2[2], dragAreaEndColumn = _dragArea2[3];
      switch (direction) {
        case "up":
          return [dragAreaStartRow, dragAreaStartColumn, baseAreaStartRow - 1, baseAreaEndColumn];
        case "down":
          return [baseAreaEndRow + 1, baseAreaStartColumn, dragAreaEndRow, baseAreaEndColumn];
        case "left":
          return [dragAreaStartRow, dragAreaStartColumn, baseAreaEndRow, baseAreaStartColumn - 1];
        case "right":
          return [baseAreaStartRow, baseAreaEndColumn + 1, dragAreaEndRow, dragAreaEndColumn];
        default:
          return null;
      }
    }
  }, {
    key: "getFarthestCollection",
    value: function getFarthestCollection(baseArea, dragArea, direction, mergedCellArray) {
      var _baseArea4 = _slicedToArray$p(baseArea, 4), baseAreaStartRow = _baseArea4[0], baseAreaStartColumn = _baseArea4[1], baseAreaEndRow = _baseArea4[2], baseAreaEndColumn = _baseArea4[3];
      var verticalDirection = ["up", "down"].indexOf(direction) > -1;
      var baseEnd = verticalDirection ? baseAreaEndRow : baseAreaEndColumn;
      var baseStart = verticalDirection ? baseAreaStartRow : baseAreaStartColumn;
      var fillSize = this.getAutofillSize(baseArea, dragArea, direction);
      var fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
      var fulls = Math.floor(fillSize / fullCycle) * fullCycle;
      var partials = fillSize - fulls;
      var inclusionFunctionName = null;
      var farthestCollection = null;
      var endOfDragRecreationIndex = null;
      switch (direction) {
        case "up":
          inclusionFunctionName = "includesVertically";
          endOfDragRecreationIndex = baseEnd - partials + 1;
          break;
        case "left":
          inclusionFunctionName = "includesHorizontally";
          endOfDragRecreationIndex = baseEnd - partials + 1;
          break;
        case "down":
          inclusionFunctionName = "includesVertically";
          endOfDragRecreationIndex = baseStart + partials - 1;
          break;
        case "right":
          inclusionFunctionName = "includesHorizontally";
          endOfDragRecreationIndex = baseStart + partials - 1;
          break;
      }
      arrayEach(mergedCellArray, function(currentCollection) {
        if (currentCollection[inclusionFunctionName](endOfDragRecreationIndex) && currentCollection.isFarther(farthestCollection, direction)) {
          farthestCollection = currentCollection;
        }
      });
      return farthestCollection;
    }
  }, {
    key: "recreateAfterDataPopulation",
    value: function recreateAfterDataPopulation(changes) {
      if (!this.currentFillData) {
        return;
      }
      var fillRange = this.getRangeFromChanges(changes);
      var foundMergedCells = this.currentFillData.foundMergedCells;
      var dragDirection = this.currentFillData.dragDirection;
      var inBounds = function inBounds2(current2, offset) {
        switch (dragDirection) {
          case "up":
            return current2.row - offset >= fillRange.from.row;
          case "down":
            return current2.row + current2.rowspan - 1 + offset <= fillRange.to.row;
          case "left":
            return current2.col - offset >= fillRange.from.column;
          case "right":
            return current2.col + current2.colspan - 1 + offset <= fillRange.to.column;
          default:
            return null;
        }
      };
      var fillOffset = 0;
      var current = null;
      var multiplier = 1;
      do {
        for (var j = 0; j < foundMergedCells.length; j += 1) {
          current = foundMergedCells[j];
          fillOffset = multiplier * this.currentFillData.cycleLength;
          if (inBounds(current, fillOffset)) {
            switch (dragDirection) {
              case "up":
                this.plugin.mergedCellsCollection.add({
                  row: current.row - fillOffset,
                  rowspan: current.rowspan,
                  col: current.col,
                  colspan: current.colspan
                });
                break;
              case "down":
                this.plugin.mergedCellsCollection.add({
                  row: current.row + fillOffset,
                  rowspan: current.rowspan,
                  col: current.col,
                  colspan: current.colspan
                });
                break;
              case "left":
                this.plugin.mergedCellsCollection.add({
                  row: current.row,
                  rowspan: current.rowspan,
                  col: current.col - fillOffset,
                  colspan: current.colspan
                });
                break;
              case "right":
                this.plugin.mergedCellsCollection.add({
                  row: current.row,
                  rowspan: current.rowspan,
                  col: current.col + fillOffset,
                  colspan: current.colspan
                });
                break;
            }
          }
          if (j === foundMergedCells.length - 1) {
            multiplier += 1;
          }
        }
      } while (inBounds(current, fillOffset));
      this.currentFillData = null;
      this.plugin.hot.render();
    }
  }, {
    key: "getRangeFromChanges",
    value: function getRangeFromChanges(changes) {
      var _this = this;
      var rows = {
        min: null,
        max: null
      };
      var columns = {
        min: null,
        max: null
      };
      arrayEach(changes, function(change) {
        var rowIndex = change[0];
        var columnIndex = _this.plugin.hot.propToCol(change[1]);
        if (rows.min === null || rowIndex < rows.min) {
          rows.min = rowIndex;
        }
        if (rows.max === null || rowIndex > rows.max) {
          rows.max = rowIndex;
        }
        if (columns.min === null || columnIndex < columns.min) {
          columns.min = columnIndex;
        }
        if (columns.max === null || columnIndex > columns.max) {
          columns.max = columnIndex;
        }
      });
      return {
        from: {
          row: rows.min,
          column: columns.min
        },
        to: {
          row: rows.max,
          column: columns.max
        }
      };
    }
  }, {
    key: "dragAreaOverlapsCollections",
    value: function dragAreaOverlapsCollections(baseArea, fullArea, direction) {
      var dragArea = this.getDragArea(baseArea, fullArea, direction);
      var _dragArea3 = _slicedToArray$p(dragArea, 4), dragAreaStartRow = _dragArea3[0], dragAreaStartColumn = _dragArea3[1], dragAreaEndRow = _dragArea3[2], dragAreaEndColumn = _dragArea3[3];
      var topLeft = new CellCoords(dragAreaStartRow, dragAreaStartColumn);
      var bottomRight = new CellCoords(dragAreaEndRow, dragAreaEndColumn);
      var dragRange = new CellRange(topLeft, topLeft, bottomRight);
      return !!this.mergedCellsCollection.getWithinRange(dragRange, true);
    }
  }]);
  return AutofillCalculations2;
}();

function _classCallCheck$1T(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1N(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1N(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1N(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1N(Constructor, staticProps);
  return Constructor;
}
var SelectionCalculations = /* @__PURE__ */ function() {
  function SelectionCalculations2(plugin) {
    _classCallCheck$1T(this, SelectionCalculations2);
    this.plugin = plugin;
    this.fullySelectedMergedCellClassName = "fullySelectedMergedCell";
  }
  _createClass$1N(SelectionCalculations2, [{
    key: "snapDelta",
    value: function snapDelta(delta, selectionRange, mergedCell) {
      var cellCoords = selectionRange.to;
      var newRow = cellCoords.row + delta.row;
      var newColumn = cellCoords.col + delta.col;
      if (delta.row) {
        this.jumpOverMergedCell(delta, mergedCell, newRow);
      } else if (delta.col) {
        this.jumpOverMergedCell(delta, mergedCell, newColumn);
      }
    }
  }, {
    key: "jumpOverMergedCell",
    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {
      var flatDelta = delta.row || delta.col;
      var includesIndex = null;
      var firstIndex = null;
      var lastIndex = null;
      if (delta.row) {
        includesIndex = mergedCell.includesVertically(newIndex);
        firstIndex = mergedCell.row;
        lastIndex = mergedCell.getLastRow();
      } else if (delta.col) {
        includesIndex = mergedCell.includesHorizontally(newIndex);
        firstIndex = mergedCell.col;
        lastIndex = mergedCell.getLastColumn();
      }
      if (flatDelta === 0) {
        return;
      } else if (flatDelta > 0) {
        if (includesIndex && newIndex !== firstIndex) {
          flatDelta += lastIndex - newIndex + 1;
        }
      } else if (includesIndex && newIndex !== lastIndex) {
        flatDelta -= newIndex - firstIndex + 1;
      }
      if (delta.row) {
        delta.row = flatDelta;
      } else if (delta.col) {
        delta.col = flatDelta;
      }
    }
  }, {
    key: "getUpdatedSelectionRange",
    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {
      return new CellRange(oldSelectionRange.highlight, oldSelectionRange.from, new CellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));
    }
  }, {
    key: "getSelectedMergedCellClassName",
    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {
      var startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);
      var startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);
      var endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);
      var endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);
      if (layerLevel === void 0) {
        return;
      }
      var isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn);
      if (!isFirstRenderableMergedCell) {
        return;
      }
      var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);
      if (!mergedCell) {
        return;
      }
      var mergeRowEnd = mergedCell.getLastRow();
      var mergeColumnEnd = mergedCell.getLastColumn();
      var fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;
      if (fullMergeAreaWithinSelection) {
        return "".concat(this.fullySelectedMergedCellClassName, "-").concat(layerLevel);
      } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {
        return "".concat(this.fullySelectedMergedCellClassName, "-multiple");
      }
    }
  }, {
    key: "isMergeCellFullySelected",
    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {
      var mergedCellIndividualCoords = [];
      if (!selectionRangesArray || !mergedCell) {
        return false;
      }
      for (var r = 0; r < mergedCell.rowspan; r += 1) {
        for (var c = 0; c < mergedCell.colspan; c += 1) {
          mergedCellIndividualCoords.push(new CellCoords(mergedCell.row + r, mergedCell.col + c));
        }
      }
      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {
        var insideSelections = [];
        for (var s = 0; s < selectionRangesArray.length; s += 1) {
          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);
        }
        if (!insideSelections.includes(true)) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "getSelectedMergedCellClassNameToRemove",
    value: function getSelectedMergedCellClassNameToRemove() {
      var classNames = [];
      for (var i = 0; i <= 7; i += 1) {
        classNames.push("".concat(this.fullySelectedMergedCellClassName, "-").concat(i));
      }
      classNames.push("".concat(this.fullySelectedMergedCellClassName, "-multiple"));
      return classNames;
    }
  }]);
  return SelectionCalculations2;
}();

function toggleMergeItem(plugin) {
  return {
    key: "mergeCells",
    name: function name() {
      var sel = this.getSelectedLast();
      if (sel) {
        var info = plugin.mergedCellsCollection.get(sel[0], sel[1]);
        if (info.row === sel[0] && info.col === sel[1] && info.row + info.rowspan - 1 === sel[2] && info.col + info.colspan - 1 === sel[3]) {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNMERGE_CELLS);
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_MERGE_CELLS);
    },
    callback: function callback() {
      plugin.toggleMergeOnSelection();
    },
    disabled: function disabled() {
      var sel = this.getSelectedLast();
      if (!sel) {
        return true;
      }
      var isSingleCell = MergedCellCoords.isSingleCell({
        row: sel[0],
        col: sel[1],
        rowspan: sel[2] - sel[0] + 1,
        colspan: sel[3] - sel[1] + 1
      });
      return isSingleCell || this.selection.isSelectedByCorner();
    },
    hidden: false
  };
}

function _typeof$11(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$11 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$11 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$11(obj);
}
function _slicedToArray$q(arr, i) {
  return _arrayWithHoles$r(arr) || _iterableToArrayLimit$q(arr, i) || _unsupportedIterableToArray$D(arr, i) || _nonIterableRest$r();
}
function _nonIterableRest$r() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$q(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$r(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray$l(arr) {
  return _arrayWithoutHoles$j(arr) || _iterableToArray$k(arr) || _unsupportedIterableToArray$D(arr) || _nonIterableSpread$j();
}
function _nonIterableSpread$j() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$D(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$D(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$D(o, minLen);
}
function _iterableToArray$k(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$j(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$D(arr);
}
function _arrayLikeToArray$D(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1U(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1O(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1O(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1O(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1O(Constructor, staticProps);
  return Constructor;
}
function _get$u(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$u = Reflect.get;
  } else {
    _get$u = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$u(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$u(target, property, receiver || target);
}
function _superPropBase$u(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$R(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$R(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$S(subClass, superClass);
}
function _setPrototypeOf$S(o, p) {
  _setPrototypeOf$S = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$S(o, p);
}
function _createSuper$R(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$S();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$R(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$R(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$R(this, result);
  };
}
function _possibleConstructorReturn$R(self, call) {
  if (call && (_typeof$11(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$R(self);
}
function _assertThisInitialized$R(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$S() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$R(o) {
  _getPrototypeOf$R = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$R(o);
}
Hooks.getSingleton().register("beforeMergeCells");
Hooks.getSingleton().register("afterMergeCells");
Hooks.getSingleton().register("beforeUnmergeCells");
Hooks.getSingleton().register("afterUnmergeCells");
var PLUGIN_KEY$g = "mergeCells";
var PLUGIN_PRIORITY$f = 150;
var privatePool$e = new WeakMap();
var MergeCells = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$R(MergeCells2, _BasePlugin);
  var _super = _createSuper$R(MergeCells2);
  function MergeCells2(hotInstance) {
    var _this;
    _classCallCheck$1U(this, MergeCells2);
    _this = _super.call(this, hotInstance);
    privatePool$e.set(_assertThisInitialized$R(_this), {
      lastDesiredCoords: null
    });
    _this.mergedCellsCollection = null;
    _this.autofillCalculations = null;
    _this.selectionCalculations = null;
    return _this;
  }
  _createClass$1O(MergeCells2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$g];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.mergedCellsCollection = new MergedCellsCollection(this);
      this.autofillCalculations = new AutofillCalculations(this);
      this.selectionCalculations = new SelectionCalculations(this);
      this.addHook("afterInit", function() {
        return _this2.onAfterInit.apply(_this2, arguments);
      });
      this.addHook("beforeKeyDown", function() {
        return _this2.onBeforeKeyDown.apply(_this2, arguments);
      });
      this.addHook("modifyTransformStart", function() {
        return _this2.onModifyTransformStart.apply(_this2, arguments);
      });
      this.addHook("afterModifyTransformStart", function() {
        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);
      });
      this.addHook("modifyTransformEnd", function() {
        return _this2.onModifyTransformEnd.apply(_this2, arguments);
      });
      this.addHook("modifyGetCellCoords", function() {
        return _this2.onModifyGetCellCoords.apply(_this2, arguments);
      });
      this.addHook("beforeSetRangeStart", function() {
        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);
      });
      this.addHook("beforeSetRangeStartOnly", function() {
        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);
      });
      this.addHook("beforeSetRangeEnd", function() {
        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);
      });
      this.addHook("afterIsMultipleSelection", function() {
        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);
      });
      this.addHook("afterRenderer", function() {
        return _this2.onAfterRenderer.apply(_this2, arguments);
      });
      this.addHook("afterContextMenuDefaultOptions", function() {
        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);
      });
      this.addHook("afterGetCellMeta", function() {
        return _this2.onAfterGetCellMeta.apply(_this2, arguments);
      });
      this.addHook("afterViewportRowCalculatorOverride", function() {
        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);
      });
      this.addHook("afterViewportColumnCalculatorOverride", function() {
        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);
      });
      this.addHook("modifyAutofillRange", function() {
        return _this2.onModifyAutofillRange.apply(_this2, arguments);
      });
      this.addHook("afterCreateCol", function() {
        return _this2.onAfterCreateCol.apply(_this2, arguments);
      });
      this.addHook("afterRemoveCol", function() {
        return _this2.onAfterRemoveCol.apply(_this2, arguments);
      });
      this.addHook("afterCreateRow", function() {
        return _this2.onAfterCreateRow.apply(_this2, arguments);
      });
      this.addHook("afterRemoveRow", function() {
        return _this2.onAfterRemoveRow.apply(_this2, arguments);
      });
      this.addHook("afterChange", function() {
        return _this2.onAfterChange.apply(_this2, arguments);
      });
      this.addHook("beforeDrawBorders", function() {
        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);
      });
      this.addHook("afterDrawSelection", function() {
        return _this2.onAfterDrawSelection.apply(_this2, arguments);
      });
      this.addHook("beforeRemoveCellClassNames", function() {
        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);
      });
      this.addHook("beforeUndoStackChange", function(action, source) {
        if (source === "MergeCells") {
          return false;
        }
      });
      _get$u(_getPrototypeOf$R(MergeCells2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.clearCollections();
      this.hot.render();
      _get$u(_getPrototypeOf$R(MergeCells2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var settings = this.hot.getSettings()[PLUGIN_KEY$g];
      this.disablePlugin();
      this.enablePlugin();
      this.generateFromSettings(settings);
      _get$u(_getPrototypeOf$R(MergeCells2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "validateSetting",
    value: function validateSetting(setting) {
      var valid = true;
      if (!setting) {
        return false;
      }
      if (MergedCellCoords.containsNegativeValues(setting)) {
        warn$1(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));
        valid = false;
      } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {
        warn$1(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));
        valid = false;
      } else if (MergedCellCoords.isSingleCell(setting)) {
        warn$1(MergedCellCoords.IS_SINGLE_CELL(setting));
        valid = false;
      } else if (MergedCellCoords.containsZeroSpan(setting)) {
        warn$1(MergedCellCoords.ZERO_SPAN_WARNING(setting));
        valid = false;
      }
      return valid;
    }
  }, {
    key: "generateFromSettings",
    value: function generateFromSettings(settings) {
      var _this3 = this;
      if (Array.isArray(settings)) {
        var _this$hot;
        var populationArgumentsList = [];
        arrayEach(settings, function(setting) {
          if (!_this3.validateSetting(setting)) {
            return;
          }
          var highlight = new CellCoords(setting.row, setting.col);
          var rangeEnd = new CellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);
          var mergeRange = new CellRange(highlight, highlight, rangeEnd);
          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));
        });
        populationArgumentsList = populationArgumentsList.filter(function(value) {
          return value !== true;
        });
        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);
        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray$l(bulkPopulationData));
      }
    }
  }, {
    key: "getBulkCollectionData",
    value: function getBulkCollectionData(populationArgumentsList) {
      var _this$hot2;
      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);
      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray$l(populationDataRange));
      var newDataAtRange = dataAtRange.splice(0);
      arrayEach(populationArgumentsList, function(mergedCellArguments) {
        var _mergedCellArguments = _slicedToArray$q(mergedCellArguments, 3), mergedCellRowIndex = _mergedCellArguments[0], mergedCellColumnIndex = _mergedCellArguments[1], mergedCellData = _mergedCellArguments[2];
        arrayEach(mergedCellData, function(mergedCellRow, rowIndex) {
          arrayEach(mergedCellRow, function(mergedCellElement, columnIndex) {
            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement;
          });
        });
      });
      return [populationDataRange[0], populationDataRange[1], newDataAtRange];
    }
  }, {
    key: "getBulkCollectionDataRange",
    value: function getBulkCollectionDataRange(populationArgumentsList) {
      var start = [0, 0];
      var end = [0, 0];
      var mergedCellRow = null;
      var mergedCellColumn = null;
      var mergedCellData = null;
      arrayEach(populationArgumentsList, function(mergedCellArguments) {
        mergedCellRow = mergedCellArguments[0];
        mergedCellColumn = mergedCellArguments[1];
        mergedCellData = mergedCellArguments[2];
        start[0] = Math.min(mergedCellRow, start[0]);
        start[1] = Math.min(mergedCellColumn, start[1]);
        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);
        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);
      });
      return [].concat(start, end);
    }
  }, {
    key: "clearCollections",
    value: function clearCollections() {
      this.mergedCellsCollection.clear();
    }
  }, {
    key: "canMergeRange",
    value: function canMergeRange(newMergedCellInfo) {
      var auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return auto ? true : this.validateSetting(newMergedCellInfo);
    }
  }, {
    key: "toggleMergeOnSelection",
    value: function toggleMergeOnSelection() {
      var currentRange = this.hot.getSelectedRangeLast();
      if (!currentRange) {
        return;
      }
      currentRange.setDirection("NW-SE");
      var from = currentRange.from, to = currentRange.to;
      this.toggleMerge(currentRange);
      this.hot.selectCell(from.row, from.col, to.row, to.col, false);
    }
  }, {
    key: "mergeSelection",
    value: function mergeSelection() {
      var cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
      if (!cellRange) {
        return;
      }
      cellRange.setDirection("NW-SE");
      var from = cellRange.from, to = cellRange.to;
      this.unmergeRange(cellRange, true);
      this.mergeRange(cellRange);
      this.hot.selectCell(from.row, from.col, to.row, to.col, false);
    }
  }, {
    key: "unmergeSelection",
    value: function unmergeSelection() {
      var cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
      if (!cellRange) {
        return;
      }
      var from = cellRange.from, to = cellRange.to;
      this.unmergeRange(cellRange, true);
      this.hot.selectCell(from.row, from.col, to.row, to.col, false);
    }
  }, {
    key: "mergeRange",
    value: function mergeRange(cellRange) {
      var _this4 = this;
      var auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var preventPopulation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var topLeft = cellRange.getTopLeftCorner();
      var bottomRight = cellRange.getBottomRightCorner();
      var mergeParent = {
        row: topLeft.row,
        col: topLeft.col,
        rowspan: bottomRight.row - topLeft.row + 1,
        colspan: bottomRight.col - topLeft.col + 1
      };
      var clearedData = [];
      var populationInfo = null;
      if (!this.canMergeRange(mergeParent, auto)) {
        return false;
      }
      this.hot.runHooks("beforeMergeCells", cellRange, auto);
      rangeEach(0, mergeParent.rowspan - 1, function(i) {
        rangeEach(0, mergeParent.colspan - 1, function(j) {
          var clearedValue = null;
          if (!clearedData[i]) {
            clearedData[i] = [];
          }
          if (i === 0 && j === 0) {
            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);
          } else {
            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, "hidden", true);
          }
          clearedData[i][j] = clearedValue;
        });
      });
      this.hot.setCellMeta(mergeParent.row, mergeParent.col, "spanned", true);
      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);
      if (mergedCellAdded) {
        if (preventPopulation) {
          populationInfo = [mergeParent.row, mergeParent.col, clearedData];
        } else {
          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);
        }
        this.hot.runHooks("afterMergeCells", cellRange, mergeParent, auto);
        return populationInfo;
      }
      return true;
    }
  }, {
    key: "unmergeRange",
    value: function unmergeRange(cellRange) {
      var _this5 = this;
      var auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);
      if (!mergedCells) {
        return;
      }
      this.hot.runHooks("beforeUnmergeCells", cellRange, auto);
      arrayEach(mergedCells, function(currentCollection) {
        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);
        rangeEach(0, currentCollection.rowspan - 1, function(i) {
          rangeEach(0, currentCollection.colspan - 1, function(j) {
            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, "hidden");
          });
        });
        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, "spanned");
      });
      this.hot.runHooks("afterUnmergeCells", cellRange, auto);
      this.hot.render();
    }
  }, {
    key: "toggleMerge",
    value: function toggleMerge(cellRange) {
      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);
      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;
      if (mergedCellCoversWholeRange) {
        this.unmergeRange(cellRange);
      } else {
        this.mergeSelection(cellRange);
      }
    }
  }, {
    key: "merge",
    value: function merge(startRow, startColumn, endRow, endColumn) {
      var start = new CellCoords(startRow, startColumn);
      var end = new CellCoords(endRow, endColumn);
      this.mergeRange(new CellRange(start, start, end));
    }
  }, {
    key: "unmerge",
    value: function unmerge(startRow, startColumn, endRow, endColumn) {
      var start = new CellCoords(startRow, startColumn);
      var end = new CellCoords(endRow, endColumn);
      this.unmergeRange(new CellRange(start, start, end));
    }
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY$g]);
      this.hot.render();
    }
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown(event) {
      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
      if (ctrlDown && event.keyCode === 77) {
        this.toggleMerge(this.hot.getSelectedRangeLast());
        this.hot.render();
        stopImmediatePropagation(event);
      }
    }
  }, {
    key: "onAfterIsMultipleSelection",
    value: function onAfterIsMultipleSelection(isMultiple) {
      if (isMultiple) {
        var mergedCells = this.mergedCellsCollection.mergedCells;
        var selectionRange = this.hot.getSelectedRangeLast();
        for (var group = 0; group < mergedCells.length; group += 1) {
          if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {
            return false;
          }
        }
      }
      return isMultiple;
    }
  }, {
    key: "onModifyTransformStart",
    value: function onModifyTransformStart(delta) {
      var priv = privatePool$e.get(this);
      var currentlySelectedRange = this.hot.getSelectedRangeLast();
      var newDelta = {
        row: delta.row,
        col: delta.col
      };
      var nextPosition = null;
      var currentPosition = new CellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);
      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);
      if (!priv.lastDesiredCoords) {
        priv.lastDesiredCoords = new CellCoords(null, null);
      }
      if (mergedParent) {
        var mergeTopLeft = new CellCoords(mergedParent.row, mergedParent.col);
        var mergeBottomRight = new CellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);
        var mergeRange = new CellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);
        if (!mergeRange.includes(priv.lastDesiredCoords)) {
          priv.lastDesiredCoords = new CellCoords(null, null);
        }
        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;
        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;
        if (delta.row > 0) {
          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;
        } else if (delta.row < 0) {
          newDelta.row = currentPosition.row - mergedParent.row + delta.row;
        }
        if (delta.col > 0) {
          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;
        } else if (delta.col < 0) {
          newDelta.col = currentPosition.col - mergedParent.col + delta.col;
        }
      }
      nextPosition = new CellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);
      var nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);
      if (nextPositionMergedCell) {
        var firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);
        priv.lastDesiredCoords = nextPosition;
        newDelta = {
          row: firstRenderableCoords.row - currentPosition.row,
          col: firstRenderableCoords.col - currentPosition.col
        };
      }
      if (newDelta.row !== 0) {
        delta.row = newDelta.row;
      }
      if (newDelta.col !== 0) {
        delta.col = newDelta.col;
      }
    }
  }, {
    key: "onModifyTransformEnd",
    value: function onModifyTransformEnd(delta) {
      var _this6 = this;
      var currentSelectionRange = this.hot.getSelectedRangeLast();
      var newDelta = clone(delta);
      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);
      var tempDelta = clone(newDelta);
      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);
      do {
        tempDelta = clone(newDelta);
        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);
        arrayEach(mergedCellsWithinRange, function(mergedCell) {
          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);
        });
      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);
      delta.row = newDelta.row;
      delta.col = newDelta.col;
    }
  }, {
    key: "onModifyGetCellCoords",
    value: function onModifyGetCellCoords(row, column) {
      if (row < 0 || column < 0) {
        return;
      }
      var mergeParent = this.mergedCellsCollection.get(row, column);
      if (!mergeParent) {
        return;
      }
      var mergeRow = mergeParent.row, mergeColumn = mergeParent.col, colspan = mergeParent.colspan, rowspan = mergeParent.rowspan;
      return [
        mergeRow,
        mergeColumn,
        mergeRow + rowspan - 1,
        mergeColumn + colspan - 1
      ];
    }
  }, {
    key: "addMergeActionsToContextMenu",
    value: function addMergeActionsToContextMenu(defaultOptions) {
      defaultOptions.items.push({
        name: "---------"
      }, toggleMergeItem(this));
    }
  }, {
    key: "onAfterRenderer",
    value: function onAfterRenderer(TD, row, col) {
      var mergedCell = this.mergedCellsCollection.get(row, col);
      var mergedCellCopy = isObject(mergedCell) ? clone(mergedCell) : void 0;
      if (isObject(mergedCellCopy)) {
        var _this$hot3 = this.hot, rowMapper = _this$hot3.rowIndexMapper, columnMapper = _this$hot3.columnIndexMapper;
        var mergeRow = mergedCellCopy.row, mergeColumn = mergedCellCopy.col, colspan = mergedCellCopy.colspan, rowspan = mergedCellCopy.rowspan;
        var _this$translateMerged = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan), _this$translateMerged2 = _slicedToArray$q(_this$translateMerged, 2), lastMergedRowIndex = _this$translateMerged2[0], lastMergedColumnIndex = _this$translateMerged2[1];
        var renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);
        var renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);
        var maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1;
        var maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1;
        mergedCellCopy.row = rowMapper.getFirstNotHiddenIndex(mergedCellCopy.row, 1);
        mergedCellCopy.col = columnMapper.getFirstNotHiddenIndex(mergedCellCopy.col, 1);
        mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan);
        mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);
      }
      applySpanProperties(TD, mergedCellCopy, row, col);
    }
  }, {
    key: "onBeforeSetRangeStart",
    value: function onBeforeSetRangeStart(coords) {
      if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {
        var mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);
        var _ref = [mergeParent.row, mergeParent.col];
        coords.row = _ref[0];
        coords.col = _ref[1];
      }
    }
  }, {
    key: "onBeforeSetRangeEnd",
    value: function onBeforeSetRangeEnd(coords) {
      var selRange = this.hot.getSelectedRangeLast();
      selRange.highlight = new CellCoords(selRange.highlight.row, selRange.highlight.col);
      selRange.to = coords;
      var rangeExpanded = false;
      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {
        return;
      }
      do {
        rangeExpanded = false;
        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {
          var cellInfo = this.mergedCellsCollection.mergedCells[i];
          var mergedCellRange = cellInfo.getRange();
          if (selRange.expandByRange(mergedCellRange)) {
            coords.row = selRange.to.row;
            coords.col = selRange.to.col;
            rangeExpanded = true;
          }
        }
      } while (rangeExpanded);
    }
  }, {
    key: "onAfterGetCellMeta",
    value: function onAfterGetCellMeta(row, col, cellProperties) {
      var mergeParent = this.mergedCellsCollection.get(row, col);
      if (mergeParent) {
        if (mergeParent.row !== row || mergeParent.col !== col) {
          cellProperties.copyable = false;
        } else {
          cellProperties.rowspan = mergeParent.rowspan;
          cellProperties.colspan = mergeParent.colspan;
        }
      }
    }
  }, {
    key: "onAfterViewportRowCalculatorOverride",
    value: function onAfterViewportRowCalculatorOverride(calc) {
      var nrOfColumns = this.hot.countCols();
      this.modifyViewportRowStart(calc, nrOfColumns);
      this.modifyViewportRowEnd(calc, nrOfColumns);
    }
  }, {
    key: "modifyViewportRowStart",
    value: function modifyViewportRowStart(calc, nrOfColumns) {
      var rowMapper = this.hot.rowIndexMapper;
      var visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);
      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {
        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);
        if (isObject(mergeParentForViewportStart)) {
          var renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.row, 1));
          if (renderableIndexAtMergeStart < calc.startRow) {
            calc.startRow = renderableIndexAtMergeStart;
            this.modifyViewportRowStart(calc, nrOfColumns);
            return;
          }
        }
      }
    }
  }, {
    key: "modifyViewportRowEnd",
    value: function modifyViewportRowEnd(calc, nrOfColumns) {
      var rowMapper = this.hot.rowIndexMapper;
      var visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);
      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {
        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);
        if (isObject(mergeParentForViewportEnd)) {
          var mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;
          var renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeEnd, -1));
          if (renderableIndexAtMergeEnd > calc.endRow) {
            calc.endRow = renderableIndexAtMergeEnd;
            this.modifyViewportRowEnd(calc, nrOfColumns);
            return;
          }
        }
      }
    }
  }, {
    key: "onAfterViewportColumnCalculatorOverride",
    value: function onAfterViewportColumnCalculatorOverride(calc) {
      var nrOfRows = this.hot.countRows();
      this.modifyViewportColumnStart(calc, nrOfRows);
      this.modifyViewportColumnEnd(calc, nrOfRows);
    }
  }, {
    key: "modifyViewportColumnStart",
    value: function modifyViewportColumnStart(calc, nrOfRows) {
      var columnMapper = this.hot.columnIndexMapper;
      var visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);
      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {
        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);
        if (isObject(mergeParentForViewportStart)) {
          var renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.col, 1));
          if (renderableIndexAtMergeStart < calc.startColumn) {
            calc.startColumn = renderableIndexAtMergeStart;
            this.modifyViewportColumnStart(calc, nrOfRows);
            return;
          }
        }
      }
    }
  }, {
    key: "modifyViewportColumnEnd",
    value: function modifyViewportColumnEnd(calc, nrOfRows) {
      var columnMapper = this.hot.columnIndexMapper;
      var visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);
      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {
        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);
        if (isObject(mergeParentForViewportEnd)) {
          var mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;
          var renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeEnd, -1));
          if (renderableIndexAtMergeEnd > calc.endColumn) {
            calc.endColumn = renderableIndexAtMergeEnd;
            this.modifyViewportColumnEnd(calc, nrOfRows);
            return;
          }
        }
      }
    }
  }, {
    key: "translateMergedCellToRenderable",
    value: function translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {
      var _this$hot4 = this.hot, rowMapper = _this$hot4.rowIndexMapper, columnMapper = _this$hot4.columnIndexMapper;
      var firstNonHiddenRow;
      var firstNonHiddenColumn;
      if (rowspan === 0) {
        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow, 1);
      } else {
        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow + rowspan - 1, -1);
      }
      if (colspan === 0) {
        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn, 1);
      } else {
        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn + colspan - 1, -1);
      }
      var renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;
      var renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;
      return [renderableRow, renderableColumn];
    }
  }, {
    key: "onModifyAutofillRange",
    value: function onModifyAutofillRange(drag, select) {
      this.autofillCalculations.correctSelectionAreaSize(select);
      var dragDirection = this.autofillCalculations.getDirection(select, drag);
      var dragArea = drag;
      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {
        dragArea = select;
        return dragArea;
      }
      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({
        from: {
          row: select[0],
          col: select[1]
        },
        to: {
          row: select[2],
          col: select[3]
        }
      });
      if (!mergedCellsWithinSelectionArea) {
        return dragArea;
      }
      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);
      return dragArea;
    }
  }, {
    key: "onAfterCreateCol",
    value: function onAfterCreateCol(column, count) {
      this.mergedCellsCollection.shiftCollections("right", column, count);
    }
  }, {
    key: "onAfterRemoveCol",
    value: function onAfterRemoveCol(column, count) {
      this.mergedCellsCollection.shiftCollections("left", column, count);
    }
  }, {
    key: "onAfterCreateRow",
    value: function onAfterCreateRow(row, count, source) {
      if (source === "auto") {
        return;
      }
      this.mergedCellsCollection.shiftCollections("down", row, count);
    }
  }, {
    key: "onAfterRemoveRow",
    value: function onAfterRemoveRow(row, count) {
      this.mergedCellsCollection.shiftCollections("up", row, count);
    }
  }, {
    key: "onAfterChange",
    value: function onAfterChange(changes, source) {
      if (source !== "Autofill.fill") {
        return;
      }
      this.autofillCalculations.recreateAfterDataPopulation(changes);
    }
  }, {
    key: "onBeforeDrawAreaBorders",
    value: function onBeforeDrawAreaBorders(corners, className) {
      if (className && className === "area") {
        var selectedRange = this.hot.getSelectedRangeLast();
        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);
        arrayEach(mergedCellsWithinRange, function(mergedCell) {
          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {
            corners[2] = mergedCell.row;
            corners[3] = mergedCell.col;
          }
        });
      }
    }
  }, {
    key: "onAfterModifyTransformStart",
    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {
      if (!this.enabled) {
        return;
      }
      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);
      if (!mergedCellAtCoords) {
        return;
      }
      var goingDown = rowTransformDir > 0;
      var goingUp = rowTransformDir < 0;
      var goingLeft = colTransformDir < 0;
      var goingRight = colTransformDir > 0;
      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;
      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;
      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;
      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;
      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {
        coords.row = mergedCellAtCoords.row;
        coords.col = mergedCellAtCoords.col;
      }
    }
  }, {
    key: "onAfterDrawSelection",
    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {
      if (!cornersOfSelection) {
        return;
      }
      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);
    }
  }, {
    key: "onBeforeRemoveCellClassNames",
    value: function onBeforeRemoveCellClassNames() {
      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$g;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$f;
    }
  }]);
  return MergeCells2;
}(BasePlugin);

function _typeof$12(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$12 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$12 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$12(obj);
}
function _classCallCheck$1V(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1P(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1P(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1P(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1P(Constructor, staticProps);
  return Constructor;
}
function _get$v(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$v = Reflect.get;
  } else {
    _get$v = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$v(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$v(target, property, receiver || target);
}
function _superPropBase$v(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$S(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$S(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$T(subClass, superClass);
}
function _setPrototypeOf$T(o, p) {
  _setPrototypeOf$T = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$T(o, p);
}
function _createSuper$S(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$T();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$S(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$S(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$S(this, result);
  };
}
function _possibleConstructorReturn$S(self, call) {
  if (call && (_typeof$12(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$S(self);
}
function _assertThisInitialized$S(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$T() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$S(o) {
  _getPrototypeOf$S = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$S(o);
}
var PLUGIN_KEY$h = "multipleSelectionHandles";
var PLUGIN_PRIORITY$g = 160;
var MultipleSelectionHandles = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$S(MultipleSelectionHandles2, _BasePlugin);
  var _super = _createSuper$S(MultipleSelectionHandles2);
  function MultipleSelectionHandles2(hotInstance) {
    var _this2;
    _classCallCheck$1V(this, MultipleSelectionHandles2);
    _this2 = _super.call(this, hotInstance);
    _this2.dragged = [];
    _this2.eventManager = null;
    _this2.lastSetCell = null;
    return _this2;
  }
  _createClass$1P(MultipleSelectionHandles2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return isMobileBrowser();
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      if (this.enabled) {
        return;
      }
      if (!this.eventManager) {
        this.eventManager = new EventManager(this);
      }
      this.registerListeners();
      _get$v(_getPrototypeOf$S(MultipleSelectionHandles2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this3 = this;
      var _this = this;
      var rootElement = this.hot.rootElement;
      function removeFromDragged(query) {
        if (_this.dragged.length === 1) {
          _this.dragged.splice(0, _this.dragged.length);
          return true;
        }
        var entryPosition = _this.dragged.indexOf(query);
        if (entryPosition === -1) {
          return false;
        } else if (entryPosition === 0) {
          _this.dragged = _this.dragged.slice(0, 1);
        } else if (entryPosition === 1) {
          _this.dragged = _this.dragged.slice(-1);
        }
      }
      this.eventManager.addEventListener(rootElement, "touchstart", function(event) {
        var selectedRange;
        if (hasClass(event.target, "topLeftSelectionHandle-HitArea")) {
          selectedRange = _this.hot.getSelectedRangeLast();
          _this.dragged.push("topLeft");
          _this.touchStartRange = {
            width: selectedRange.getWidth(),
            height: selectedRange.getHeight(),
            direction: selectedRange.getDirection()
          };
          event.preventDefault();
          return false;
        } else if (hasClass(event.target, "bottomRightSelectionHandle-HitArea")) {
          selectedRange = _this.hot.getSelectedRangeLast();
          _this.dragged.push("bottomRight");
          _this.touchStartRange = {
            width: selectedRange.getWidth(),
            height: selectedRange.getHeight(),
            direction: selectedRange.getDirection()
          };
          event.preventDefault();
          return false;
        }
      });
      this.eventManager.addEventListener(rootElement, "touchend", function(event) {
        if (hasClass(event.target, "topLeftSelectionHandle-HitArea")) {
          removeFromDragged.call(_this, "topLeft");
          _this.touchStartRange = void 0;
          event.preventDefault();
          return false;
        } else if (hasClass(event.target, "bottomRightSelectionHandle-HitArea")) {
          removeFromDragged.call(_this, "bottomRight");
          _this.touchStartRange = void 0;
          event.preventDefault();
          return false;
        }
      });
      this.eventManager.addEventListener(rootElement, "touchmove", function(event) {
        var _this3$hot = _this3.hot, rootWindow = _this3$hot.rootWindow, rootDocument = _this3$hot.rootDocument;
        var scrollTop = getWindowScrollTop(rootWindow);
        var scrollLeft = getWindowScrollLeft(rootWindow);
        var targetCoords;
        var selectedRange;
        var rangeWidth;
        var rangeHeight;
        var rangeDirection;
        var newRangeCoords;
        if (_this.dragged.length === 0) {
          return;
        }
        var endTarget = rootDocument.elementFromPoint(event.touches[0].screenX - scrollLeft, event.touches[0].screenY - scrollTop);
        if (!endTarget || endTarget === _this.lastSetCell) {
          return;
        }
        if (endTarget.nodeName === "TD" || endTarget.nodeName === "TH") {
          targetCoords = _this.hot.getCoords(endTarget);
          if (targetCoords.col === -1) {
            targetCoords.col = 0;
          }
          selectedRange = _this.hot.getSelectedRangeLast();
          rangeWidth = selectedRange.getWidth();
          rangeHeight = selectedRange.getHeight();
          rangeDirection = selectedRange.getDirection();
          if (rangeWidth === 1 && rangeHeight === 1) {
            _this.hot.selection.setRangeEnd(targetCoords);
          }
          newRangeCoords = _this.getCurrentRangeCoords(selectedRange, targetCoords, _this.touchStartRange.direction, rangeDirection, _this.dragged[0]);
          if (newRangeCoords.start !== null) {
            _this.hot.selection.setRangeStart(newRangeCoords.start);
          }
          _this.hot.selection.setRangeEnd(newRangeCoords.end);
          _this.lastSetCell = endTarget;
        }
        event.preventDefault();
      });
    }
  }, {
    key: "getCurrentRangeCoords",
    value: function getCurrentRangeCoords(selectedRange, currentTouch, touchStartDirection, currentDirection, draggedHandle) {
      var topLeftCorner = selectedRange.getTopLeftCorner();
      var bottomRightCorner = selectedRange.getBottomRightCorner();
      var bottomLeftCorner = selectedRange.getBottomLeftCorner();
      var topRightCorner = selectedRange.getTopRightCorner();
      var newCoords = {
        start: null,
        end: null
      };
      switch (touchStartDirection) {
        case "NE-SW":
          switch (currentDirection) {
            case "NE-SW":
            case "NW-SE":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: new CellCoords(currentTouch.row, selectedRange.highlight.col),
                  end: new CellCoords(bottomLeftCorner.row, currentTouch.col)
                };
              } else {
                newCoords = {
                  start: new CellCoords(selectedRange.highlight.row, currentTouch.col),
                  end: new CellCoords(currentTouch.row, topLeftCorner.col)
                };
              }
              break;
            case "SE-NW":
              if (draggedHandle === "bottomRight") {
                newCoords = {
                  start: new CellCoords(bottomRightCorner.row, currentTouch.col),
                  end: new CellCoords(currentTouch.row, topLeftCorner.col)
                };
              }
              break;
          }
          break;
        case "NW-SE":
          switch (currentDirection) {
            case "NE-SW":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: currentTouch,
                  end: bottomLeftCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            case "NW-SE":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: currentTouch,
                  end: bottomRightCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            case "SE-NW":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: currentTouch,
                  end: topLeftCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            case "SW-NE":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: currentTouch,
                  end: topRightCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
          }
          break;
        case "SW-NE":
          switch (currentDirection) {
            case "NW-SE":
              if (draggedHandle === "bottomRight") {
                newCoords = {
                  start: new CellCoords(currentTouch.row, topLeftCorner.col),
                  end: new CellCoords(bottomLeftCorner.row, currentTouch.col)
                };
              } else {
                newCoords = {
                  start: new CellCoords(topLeftCorner.row, currentTouch.col),
                  end: new CellCoords(currentTouch.row, bottomRightCorner.col)
                };
              }
              break;
            case "SW-NE":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: new CellCoords(selectedRange.highlight.row, currentTouch.col),
                  end: new CellCoords(currentTouch.row, bottomRightCorner.col)
                };
              } else {
                newCoords = {
                  start: new CellCoords(currentTouch.row, topLeftCorner.col),
                  end: new CellCoords(topLeftCorner.row, currentTouch.col)
                };
              }
              break;
            case "SE-NW":
              if (draggedHandle === "bottomRight") {
                newCoords = {
                  start: new CellCoords(currentTouch.row, topRightCorner.col),
                  end: new CellCoords(topLeftCorner.row, currentTouch.col)
                };
              } else if (draggedHandle === "topLeft") {
                newCoords = {
                  start: bottomLeftCorner,
                  end: currentTouch
                };
              }
              break;
          }
          break;
        case "SE-NW":
          switch (currentDirection) {
            case "NW-SE":
            case "NE-SW":
            case "SW-NE":
              if (draggedHandle === "topLeft") {
                newCoords.end = currentTouch;
              }
              break;
            case "SE-NW":
              if (draggedHandle === "topLeft") {
                newCoords.end = currentTouch;
              } else {
                newCoords = {
                  start: currentTouch,
                  end: topLeftCorner
                };
              }
              break;
          }
          break;
      }
      return newCoords;
    }
  }, {
    key: "isDragged",
    value: function isDragged() {
      return this.dragged.length > 0;
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$h;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$g;
    }
  }]);
  return MultipleSelectionHandles2;
}(BasePlugin);

function _toArray$1(arr) {
  return _arrayWithHoles$s(arr) || _iterableToArray$l(arr) || _unsupportedIterableToArray$E(arr) || _nonIterableRest$s();
}
function _nonIterableRest$s() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$E(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$E(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$E(o, minLen);
}
function _arrayLikeToArray$E(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArray$l(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithHoles$s(arr) {
  if (Array.isArray(arr))
    return arr;
}
function rootComparator$1(sortingOrders, columnMetas) {
  return function(rowIndexWithValues, nextRowIndexWithValues) {
    var _rowIndexWithValues = _toArray$1(rowIndexWithValues), values = _rowIndexWithValues.slice(1);
    var _nextRowIndexWithValu = _toArray$1(nextRowIndexWithValues), nextValues = _nextRowIndexWithValu.slice(1);
    return function getCompareResult(column) {
      var sortingOrder = sortingOrders[column];
      var columnMeta = columnMetas[column];
      var value = values[column];
      var nextValue = nextValues[column];
      var pluginSettings = columnMeta.multiColumnSorting;
      var compareFunctionFactory = pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory : getCompareFunctionFactory(columnMeta.type);
      var compareResult = compareFunctionFactory(sortingOrder, columnMeta, pluginSettings)(value, nextValue);
      if (compareResult === DO_NOT_SWAP) {
        var nextSortedColumn = column + 1;
        if (typeof columnMetas[nextSortedColumn] !== "undefined") {
          return getCompareResult(nextSortedColumn);
        }
      }
      return compareResult;
    }(0);
  };
}

var _templateObject$7;
function _taggedTemplateLiteral$7(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function warnAboutPluginsConflict() {
  warn$1(toSingleLine(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteral$7(["Plugins `columnSorting` and `multiColumnSorting` should not be enabled simultaneously. \n    Only `multiColumnSorting` will work."], ["Plugins \\`columnSorting\\` and \\`multiColumnSorting\\` should not be enabled simultaneously. \n    Only \\`multiColumnSorting\\` will work."]))));
}

var COLUMN_ORDER_PREFIX = "sort";
function getClassesToAdd$1(columnStatesManager, column, showSortIndicator) {
  var cssClasses = [];
  if (showSortIndicator === false) {
    return cssClasses;
  }
  if (columnStatesManager.isColumnSorted(column) && columnStatesManager.getNumberOfSortedColumns() > 1) {
    cssClasses.push("".concat(COLUMN_ORDER_PREFIX, "-").concat(columnStatesManager.getIndexOfColumnInSortQueue(column) + 1));
  }
  return cssClasses;
}
function getClassesToRemove$1(htmlElement) {
  var cssClasses = htmlElement.className.split(" ");
  var sortSequenceRegExp = new RegExp("^".concat(COLUMN_ORDER_PREFIX, "-[0-9]{1,2}$"));
  return cssClasses.filter(function(cssClass) {
    return sortSequenceRegExp.test(cssClass);
  });
}

function _typeof$13(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$13 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$13 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$13(obj);
}
function _classCallCheck$1W(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1Q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1Q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1Q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1Q(Constructor, staticProps);
  return Constructor;
}
function _get$w(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$w = Reflect.get;
  } else {
    _get$w = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$w(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$w(target, property, receiver || target);
}
function _superPropBase$w(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$T(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$T(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$U(subClass, superClass);
}
function _setPrototypeOf$U(o, p) {
  _setPrototypeOf$U = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$U(o, p);
}
function _createSuper$T(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$U();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$T(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$T(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$T(this, result);
  };
}
function _possibleConstructorReturn$T(self, call) {
  if (call && (_typeof$13(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$T(self);
}
function _assertThisInitialized$T(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$U() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$T(o) {
  _getPrototypeOf$T = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$T(o);
}
var PLUGIN_KEY$i = "multiColumnSorting";
var PLUGIN_PRIORITY$h = 170;
var APPEND_COLUMN_CONFIG_STRATEGY$1 = "append";
var CONFLICTED_PLUGIN_KEY = "columnSorting";
registerRootComparator(PLUGIN_KEY$i, rootComparator$1);
var MultiColumnSorting = /* @__PURE__ */ function(_ColumnSorting) {
  _inherits$T(MultiColumnSorting2, _ColumnSorting);
  var _super = _createSuper$T(MultiColumnSorting2);
  function MultiColumnSorting2(hotInstance) {
    var _this;
    _classCallCheck$1W(this, MultiColumnSorting2);
    _this = _super.call(this, hotInstance);
    _this.pluginKey = PLUGIN_KEY$i;
    return _this;
  }
  _createClass$1Q(MultiColumnSorting2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "isEnabled", this).call(this);
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      if (!this.enabled && this.hot.getSettings()[this.pluginKey] && this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {
        warnAboutPluginsConflict();
      }
      _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "sort",
    value: function sort(sortConfig) {
      _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "sort", this).call(this, sortConfig);
    }
  }, {
    key: "clearSort",
    value: function clearSort() {
      _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "clearSort", this).call(this);
    }
  }, {
    key: "isSorted",
    value: function isSorted() {
      return _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "isSorted", this).call(this);
    }
  }, {
    key: "getSortConfig",
    value: function getSortConfig(column) {
      return _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "getSortConfig", this).call(this, column);
    }
  }, {
    key: "setSortConfig",
    value: function setSortConfig(sortConfig) {
      _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "setSortConfig", this).call(this, sortConfig);
    }
  }, {
    key: "getNormalizedSortConfigs",
    value: function getNormalizedSortConfigs() {
      var sortConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (Array.isArray(sortConfig)) {
        return sortConfig;
      }
      return [sortConfig];
    }
  }, {
    key: "updateHeaderClasses",
    value: function updateHeaderClasses(headerSpanElement) {
      var _get2;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      (_get2 = _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "updateHeaderClasses", this)).call.apply(_get2, [this, headerSpanElement].concat(args));
      removeClass(headerSpanElement, getClassesToRemove$1(headerSpanElement));
      if (this.enabled !== false) {
        addClass(headerSpanElement, getClassesToAdd$1.apply(void 0, args));
      }
    }
  }, {
    key: "onUpdateSettings",
    value: function onUpdateSettings(newSettings) {
      if (this.hot.getSettings()[this.pluginKey] && this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {
        warnAboutPluginsConflict();
      }
      _get$w(_getPrototypeOf$T(MultiColumnSorting2.prototype), "onUpdateSettings", this).call(this, newSettings);
    }
  }, {
    key: "onAfterOnCellMouseDown",
    value: function onAfterOnCellMouseDown(event, coords) {
      if (wasHeaderClickedProperly(coords.row, coords.col, event) === false) {
        return;
      }
      if (this.wasClickableHeaderClicked(event, coords.col)) {
        if (isPressedCtrlKey()) {
          this.hot.deselectCell();
          this.hot.selectColumns(coords.col);
          this.sort(this.getNextSortConfig(coords.col, APPEND_COLUMN_CONFIG_STRATEGY$1));
        } else {
          this.sort(this.getColumnNextConfig(coords.col));
        }
      }
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$i;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$h;
    }
  }]);
  return MultiColumnSorting2;
}(ColumnSorting);

function _typeof$14(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$14 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$14 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$14(obj);
}
function _toConsumableArray$m(arr) {
  return _arrayWithoutHoles$k(arr) || _iterableToArray$m(arr) || _unsupportedIterableToArray$F(arr) || _nonIterableSpread$k();
}
function _nonIterableSpread$k() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$F(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$F(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$F(o, minLen);
}
function _iterableToArray$m(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$k(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$F(arr);
}
function _arrayLikeToArray$F(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1X(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1R(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1R(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1R(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1R(Constructor, staticProps);
  return Constructor;
}
function _get$x(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$x = Reflect.get;
  } else {
    _get$x = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$x(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$x(target, property, receiver || target);
}
function _superPropBase$x(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$U(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$U(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$V(subClass, superClass);
}
function _setPrototypeOf$V(o, p) {
  _setPrototypeOf$V = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$V(o, p);
}
function _createSuper$U(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$V();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$U(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$U(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$U(this, result);
  };
}
function _possibleConstructorReturn$U(self, call) {
  if (call && (_typeof$14(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$U(self);
}
function _assertThisInitialized$U(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$V() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$U(o) {
  _getPrototypeOf$U = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$U(o);
}
var PLUGIN_KEY$j = "search";
var PLUGIN_PRIORITY$i = 190;
var DEFAULT_SEARCH_RESULT_CLASS = "htSearchResult";
var DEFAULT_CALLBACK = function DEFAULT_CALLBACK2(instance, row, col, data, testResult) {
  instance.getCellMeta(row, col).isSearchResult = testResult;
};
var DEFAULT_QUERY_METHOD = function DEFAULT_QUERY_METHOD2(query, value) {
  if (isUndefined$1(query) || query === null || !query.toLowerCase || query.length === 0) {
    return false;
  }
  if (isUndefined$1(value) || value === null) {
    return false;
  }
  return value.toString().toLowerCase().indexOf(query.toLowerCase()) !== -1;
};
var Search = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$U(Search2, _BasePlugin);
  var _super = _createSuper$U(Search2);
  function Search2(hotInstance) {
    var _this;
    _classCallCheck$1X(this, Search2);
    _this = _super.call(this, hotInstance);
    _this.callback = DEFAULT_CALLBACK;
    _this.queryMethod = DEFAULT_QUERY_METHOD;
    _this.searchResultClass = DEFAULT_SEARCH_RESULT_CLASS;
    return _this;
  }
  _createClass$1R(Search2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$j];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var searchSettings = this.hot.getSettings()[PLUGIN_KEY$j];
      this.updatePluginSettings(searchSettings);
      this.addHook("beforeRenderer", function() {
        return _this2.onBeforeRenderer.apply(_this2, arguments);
      });
      _get$x(_getPrototypeOf$U(Search2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      var beforeRendererCallback = function beforeRendererCallback2() {
        return _this3.onBeforeRenderer.apply(_this3, arguments);
      };
      this.hot.addHook("beforeRenderer", beforeRendererCallback);
      this.hot.addHookOnce("afterRender", function() {
        _this3.hot.removeHook("beforeRenderer", beforeRendererCallback);
      });
      _get$x(_getPrototypeOf$U(Search2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$x(_getPrototypeOf$U(Search2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "query",
    value: function query(queryStr) {
      var _this4 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getCallback();
      var queryMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getQueryMethod();
      var rowCount = this.hot.countRows();
      var colCount = this.hot.countCols();
      var queryResult = [];
      var instance = this.hot;
      rangeEach(0, rowCount - 1, function(rowIndex) {
        rangeEach(0, colCount - 1, function(colIndex) {
          var cellData = _this4.hot.getDataAtCell(rowIndex, colIndex);
          var cellProperties = _this4.hot.getCellMeta(rowIndex, colIndex);
          var cellCallback = cellProperties.search.callback || callback;
          var cellQueryMethod = cellProperties.search.queryMethod || queryMethod;
          var testResult = cellQueryMethod(queryStr, cellData, cellProperties);
          if (testResult) {
            var singleResult = {
              row: rowIndex,
              col: colIndex,
              data: cellData
            };
            queryResult.push(singleResult);
          }
          if (cellCallback) {
            cellCallback(instance, rowIndex, colIndex, cellData, testResult);
          }
        });
      });
      return queryResult;
    }
  }, {
    key: "getCallback",
    value: function getCallback() {
      return this.callback;
    }
  }, {
    key: "setCallback",
    value: function setCallback(newCallback) {
      this.callback = newCallback;
    }
  }, {
    key: "getQueryMethod",
    value: function getQueryMethod() {
      return this.queryMethod;
    }
  }, {
    key: "setQueryMethod",
    value: function setQueryMethod(newQueryMethod) {
      this.queryMethod = newQueryMethod;
    }
  }, {
    key: "getSearchResultClass",
    value: function getSearchResultClass() {
      return this.searchResultClass;
    }
  }, {
    key: "setSearchResultClass",
    value: function setSearchResultClass(newElementClass) {
      this.searchResultClass = newElementClass;
    }
  }, {
    key: "updatePluginSettings",
    value: function updatePluginSettings(searchSettings) {
      if (isObject(searchSettings)) {
        if (searchSettings.searchResultClass) {
          this.setSearchResultClass(searchSettings.searchResultClass);
        }
        if (searchSettings.queryMethod) {
          this.setQueryMethod(searchSettings.queryMethod);
        }
        if (searchSettings.callback) {
          this.setCallback(searchSettings.callback);
        }
      }
    }
  }, {
    key: "onBeforeRenderer",
    value: function onBeforeRenderer(TD, row, col, prop, value, cellProperties) {
      var className = cellProperties.className || [];
      var classArray = [];
      if (typeof className === "string") {
        classArray = className.split(" ");
      } else {
        var _classArray;
        (_classArray = classArray).push.apply(_classArray, _toConsumableArray$m(className));
      }
      if (this.isEnabled() && cellProperties.isSearchResult) {
        if (!classArray.includes(this.searchResultClass)) {
          classArray.push("".concat(this.searchResultClass));
        }
      } else if (classArray.includes(this.searchResultClass)) {
        classArray.splice(classArray.indexOf(this.searchResultClass), 1);
      }
      cellProperties.className = classArray.join(" ");
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$x(_getPrototypeOf$U(Search2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$j;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$i;
    }
  }]);
  return Search2;
}(BasePlugin);

function _typeof$15(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$15 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$15 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$15(obj);
}
function _classCallCheck$1Y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1S(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1S(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1S(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1S(Constructor, staticProps);
  return Constructor;
}
function _get$y(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$y = Reflect.get;
  } else {
    _get$y = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$y(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$y(target, property, receiver || target);
}
function _superPropBase$y(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$V(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$V(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$W(subClass, superClass);
}
function _setPrototypeOf$W(o, p) {
  _setPrototypeOf$W = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$W(o, p);
}
function _createSuper$V(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$W();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$V(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$V(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$V(this, result);
  };
}
function _possibleConstructorReturn$V(self, call) {
  if (call && (_typeof$15(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$V(self);
}
function _assertThisInitialized$V(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$W() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$V(o) {
  _getPrototypeOf$V = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$V(o);
}
var PLUGIN_KEY$k = "touchScroll";
var PLUGIN_PRIORITY$j = 200;
var TouchScroll = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$V(TouchScroll2, _BasePlugin);
  var _super = _createSuper$V(TouchScroll2);
  function TouchScroll2(hotInstance) {
    var _this;
    _classCallCheck$1Y(this, TouchScroll2);
    _this = _super.call(this, hotInstance);
    _this.scrollbars = [];
    _this.clones = [];
    _this.lockedCollection = false;
    _this.freezeOverlays = false;
    return _this;
  }
  _createClass$1S(TouchScroll2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return isTouchSupported();
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterRender", function() {
        return _this2.onAfterRender();
      });
      this.registerEvents();
      _get$y(_getPrototypeOf$V(TouchScroll2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.lockedCollection = false;
      _get$y(_getPrototypeOf$V(TouchScroll2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get$y(_getPrototypeOf$V(TouchScroll2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "registerEvents",
    value: function registerEvents() {
      var _this3 = this;
      this.addHook("beforeTouchScroll", function() {
        return _this3.onBeforeTouchScroll();
      });
      this.addHook("afterMomentumScroll", function() {
        return _this3.onAfterMomentumScroll();
      });
    }
  }, {
    key: "onAfterRender",
    value: function onAfterRender() {
      if (this.lockedCollection) {
        return;
      }
      var _this$hot$view$wt$wtO = this.hot.view.wt.wtOverlays, topOverlay = _this$hot$view$wt$wtO.topOverlay, bottomOverlay = _this$hot$view$wt$wtO.bottomOverlay, leftOverlay = _this$hot$view$wt$wtO.leftOverlay, topLeftCornerOverlay = _this$hot$view$wt$wtO.topLeftCornerOverlay, bottomLeftCornerOverlay = _this$hot$view$wt$wtO.bottomLeftCornerOverlay;
      this.lockedCollection = true;
      this.scrollbars.length = 0;
      this.scrollbars.push(topOverlay);
      if (bottomOverlay.clone) {
        this.scrollbars.push(bottomOverlay);
      }
      this.scrollbars.push(leftOverlay);
      if (topLeftCornerOverlay) {
        this.scrollbars.push(topLeftCornerOverlay);
      }
      if (bottomLeftCornerOverlay && bottomLeftCornerOverlay.clone) {
        this.scrollbars.push(bottomLeftCornerOverlay);
      }
      this.clones.length = 0;
      if (topOverlay.needFullRender) {
        this.clones.push(topOverlay.clone.wtTable.holder.parentNode);
      }
      if (bottomOverlay.needFullRender) {
        this.clones.push(bottomOverlay.clone.wtTable.holder.parentNode);
      }
      if (leftOverlay.needFullRender) {
        this.clones.push(leftOverlay.clone.wtTable.holder.parentNode);
      }
      if (topLeftCornerOverlay) {
        this.clones.push(topLeftCornerOverlay.clone.wtTable.holder.parentNode);
      }
      if (bottomLeftCornerOverlay && bottomLeftCornerOverlay.clone) {
        this.clones.push(bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
      }
    }
  }, {
    key: "onBeforeTouchScroll",
    value: function onBeforeTouchScroll() {
      this.freezeOverlays = true;
      arrayEach(this.clones, function(clone) {
        addClass(clone, "hide-tween");
      });
    }
  }, {
    key: "onAfterMomentumScroll",
    value: function onAfterMomentumScroll() {
      var _this4 = this;
      this.freezeOverlays = false;
      arrayEach(this.clones, function(clone) {
        removeClass(clone, "hide-tween");
        addClass(clone, "show-tween");
      });
      setTimeout(function() {
        arrayEach(_this4.clones, function(clone) {
          removeClass(clone, "show-tween");
        });
      }, 400);
      arrayEach(this.scrollbars, function(scrollbar) {
        scrollbar.refresh();
        scrollbar.resetFixedPosition();
      });
      this.hot.view.wt.wtOverlays.syncScrollWithMaster();
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$k;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$j;
    }
  }]);
  return TouchScroll2;
}(BasePlugin);

function _typeof$16(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$16 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$16 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$16(obj);
}
function _classCallCheck$1Z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1T(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1T(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1T(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1T(Constructor, staticProps);
  return Constructor;
}
function _inherits$W(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$X(subClass, superClass);
}
function _setPrototypeOf$X(o, p) {
  _setPrototypeOf$X = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$X(o, p);
}
function _createSuper$W(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$X();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$W(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$W(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$W(this, result);
  };
}
function _possibleConstructorReturn$W(self, call) {
  if (call && (_typeof$16(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$W(self);
}
function _assertThisInitialized$W(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$X() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$W(o) {
  _getPrototypeOf$W = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$W(o);
}
function _toConsumableArray$n(arr) {
  return _arrayWithoutHoles$l(arr) || _iterableToArray$n(arr) || _unsupportedIterableToArray$G(arr) || _nonIterableSpread$l();
}
function _nonIterableSpread$l() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$n(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$l(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$G(arr);
}
function _slicedToArray$r(arr, i) {
  return _arrayWithHoles$t(arr) || _iterableToArrayLimit$r(arr, i) || _unsupportedIterableToArray$G(arr, i) || _nonIterableRest$t();
}
function _nonIterableRest$t() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$G(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$G(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$G(o, minLen);
}
function _arrayLikeToArray$G(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$r(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$t(arr) {
  if (Array.isArray(arr))
    return arr;
}
var PLUGIN_KEY$l = "undoRedo";
function UndoRedo(instance) {
  var plugin = this;
  this.instance = instance;
  this.doneActions = [];
  this.undoneActions = [];
  this.ignoreNewActions = false;
  this.enabled = false;
  instance.addHook("afterChange", function(changes, source) {
    var _this = this;
    var changesLen = changes && changes.length;
    if (!changesLen) {
      return;
    }
    var hasDifferences = changes.find(function(change) {
      var _change = _slicedToArray$r(change, 4), oldValue = _change[2], newValue = _change[3];
      return oldValue !== newValue;
    });
    if (!hasDifferences) {
      return;
    }
    var wrappedAction = function wrappedAction2() {
      var clonedChanges = changes.reduce(function(arr, change) {
        arr.push(_toConsumableArray$n(change));
        return arr;
      }, []);
      arrayEach(clonedChanges, function(change) {
        change[1] = instance.propToCol(change[1]);
      });
      var selected = changesLen > 1 ? _this.getSelected() : [[clonedChanges[0][0], clonedChanges[0][1]]];
      return new UndoRedo.ChangeAction(clonedChanges, selected);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("afterCreateRow", function(index, amount, source) {
    plugin.done(function() {
      return new UndoRedo.CreateRowAction(index, amount);
    }, source);
  });
  instance.addHook("beforeRemoveRow", function(index, amount, logicRows, source) {
    var wrappedAction = function wrappedAction2() {
      var originalData = plugin.instance.getSourceDataArray();
      var rowIndex = (originalData.length + index) % originalData.length;
      var physicalRowIndex = instance.toPhysicalRow(rowIndex);
      var removedData = deepClone(originalData.slice(physicalRowIndex, physicalRowIndex + amount));
      return new UndoRedo.RemoveRowAction(rowIndex, removedData, instance.getSettings().fixedRowsBottom, instance.getSettings().fixedRowsTop);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("afterCreateCol", function(index, amount, source) {
    plugin.done(function() {
      return new UndoRedo.CreateColumnAction(index, amount);
    }, source);
  });
  instance.addHook("beforeRemoveCol", function(index, amount, logicColumns, source) {
    var wrappedAction = function wrappedAction2() {
      var originalData = plugin.instance.getSourceDataArray();
      var columnIndex = (plugin.instance.countCols() + index) % plugin.instance.countCols();
      var removedData = [];
      var headers = [];
      var indexes = [];
      rangeEach(originalData.length - 1, function(i) {
        var column = [];
        var origRow = originalData[i];
        rangeEach(columnIndex, columnIndex + (amount - 1), function(j) {
          column.push(origRow[instance.toPhysicalColumn(j)]);
        });
        removedData.push(column);
      });
      rangeEach(amount - 1, function(i) {
        indexes.push(instance.toPhysicalColumn(columnIndex + i));
      });
      if (Array.isArray(instance.getSettings().colHeaders)) {
        rangeEach(amount - 1, function(i) {
          headers.push(instance.getSettings().colHeaders[instance.toPhysicalColumn(columnIndex + i)] || null);
        });
      }
      var columnsMap = instance.columnIndexMapper.getIndexesSequence();
      var rowsMap = instance.rowIndexMapper.getIndexesSequence();
      return new UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, columnsMap, rowsMap, instance.getSettings().fixedColumnsLeft);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("beforeCellAlignment", function(stateBefore, range, type, alignment) {
    plugin.done(function() {
      return new UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment);
    });
  });
  instance.addHook("beforeFilter", function(conditionsStack) {
    plugin.done(function() {
      return new UndoRedo.FiltersAction(conditionsStack);
    });
  });
  instance.addHook("beforeRowMove", function(rows, finalIndex) {
    if (rows === false) {
      return;
    }
    plugin.done(function() {
      return new UndoRedo.RowMoveAction(rows, finalIndex);
    });
  });
  instance.addHook("beforeMergeCells", function(cellRange, auto) {
    if (auto) {
      return;
    }
    plugin.done(function() {
      return new UndoRedo.MergeCellsAction(instance, cellRange);
    });
  });
  instance.addHook("afterUnmergeCells", function(cellRange, auto) {
    if (auto) {
      return;
    }
    plugin.done(function() {
      return new UndoRedo.UnmergeCellsAction(instance, cellRange);
    });
  });
  instance.addHook("afterInit", function() {
    plugin.init();
  });
}
UndoRedo.prototype.done = function(wrappedAction, source) {
  if (this.ignoreNewActions) {
    return;
  }
  var isBlockedByDefault = source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto";
  if (isBlockedByDefault) {
    return;
  }
  var doneActionsCopy = this.doneActions.slice();
  var continueAction = this.instance.runHooks("beforeUndoStackChange", doneActionsCopy, source);
  if (continueAction === false) {
    return;
  }
  var newAction = wrappedAction();
  var undoneActionsCopy = this.undoneActions.slice();
  this.doneActions.push(newAction);
  this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
  this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
  this.undoneActions.length = 0;
  this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
};
UndoRedo.prototype.undo = function() {
  if (this.isUndoAvailable()) {
    var doneActionsCopy = this.doneActions.slice();
    this.instance.runHooks("beforeUndoStackChange", doneActionsCopy);
    var action = this.doneActions.pop();
    this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
    var actionClone = deepClone(action);
    var continueAction = this.instance.runHooks("beforeUndo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    var that = this;
    var undoneActionsCopy = this.undoneActions.slice();
    this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
    action.undo(this.instance, function() {
      that.ignoreNewActions = false;
      that.undoneActions.push(action);
    });
    this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
    this.instance.runHooks("afterUndo", actionClone);
  }
};
UndoRedo.prototype.redo = function() {
  if (this.isRedoAvailable()) {
    var undoneActionsCopy = this.undoneActions.slice();
    this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
    var action = this.undoneActions.pop();
    this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
    var actionClone = deepClone(action);
    var continueAction = this.instance.runHooks("beforeRedo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    var that = this;
    var doneActionsCopy = this.doneActions.slice();
    this.instance.runHooks("beforeUndoStackChange", doneActionsCopy);
    action.redo(this.instance, function() {
      that.ignoreNewActions = false;
      that.doneActions.push(action);
    });
    this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
    this.instance.runHooks("afterRedo", actionClone);
  }
};
UndoRedo.prototype.isUndoAvailable = function() {
  return this.doneActions.length > 0;
};
UndoRedo.prototype.isRedoAvailable = function() {
  return this.undoneActions.length > 0;
};
UndoRedo.prototype.clear = function() {
  this.doneActions.length = 0;
  this.undoneActions.length = 0;
};
UndoRedo.prototype.isEnabled = function() {
  return this.enabled;
};
UndoRedo.prototype.enable = function() {
  if (this.isEnabled()) {
    return;
  }
  var hot = this.instance;
  this.enabled = true;
  exposeUndoRedoMethods(hot);
  hot.addHook("beforeKeyDown", onBeforeKeyDown);
  hot.addHook("afterChange", onAfterChange);
};
UndoRedo.prototype.disable = function() {
  if (!this.isEnabled()) {
    return;
  }
  var hot = this.instance;
  this.enabled = false;
  removeExposedUndoRedoMethods(hot);
  hot.removeHook("beforeKeyDown", onBeforeKeyDown);
  hot.removeHook("afterChange", onAfterChange);
};
UndoRedo.prototype.destroy = function() {
  this.clear();
  this.instance = null;
  this.doneActions = null;
  this.undoneActions = null;
};
UndoRedo.Action = function() {
};
UndoRedo.Action.prototype.undo = function() {
};
UndoRedo.Action.prototype.redo = function() {
};
UndoRedo.ChangeAction = function(changes, selected) {
  this.changes = changes;
  this.selected = selected;
  this.actionType = "change";
};
inherit(UndoRedo.ChangeAction, UndoRedo.Action);
UndoRedo.ChangeAction.prototype.undo = function(instance, undoneCallback) {
  var data = deepClone(this.changes);
  var emptyRowsAtTheEnd = instance.countEmptyRows(true);
  var emptyColsAtTheEnd = instance.countEmptyCols(true);
  for (var i = 0, len = data.length; i < len; i++) {
    data[i].splice(3, 1);
  }
  instance.addHookOnce("afterChange", undoneCallback);
  instance.setDataAtCell(data, null, null, "UndoRedo.undo");
  for (var _i2 = 0, _len = data.length; _i2 < _len; _i2++) {
    var _data$_i = _slicedToArray$r(data[_i2], 2), row = _data$_i[0], column = _data$_i[1];
    if (instance.getSettings().minSpareRows && row + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {
      instance.alter("remove_row", parseInt(row + 1, 10), instance.getSettings().minSpareRows);
      instance.undoRedo.doneActions.pop();
    }
    if (instance.getSettings().minSpareCols && column + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd === instance.getSettings().minSpareCols) {
      instance.alter("remove_col", parseInt(column + 1, 10), instance.getSettings().minSpareCols);
      instance.undoRedo.doneActions.pop();
    }
  }
  instance.selectCells(this.selected, false, false);
};
UndoRedo.ChangeAction.prototype.redo = function(instance, onFinishCallback) {
  var data = deepClone(this.changes);
  for (var i = 0, len = data.length; i < len; i++) {
    data[i].splice(2, 1);
  }
  instance.addHookOnce("afterChange", onFinishCallback);
  instance.setDataAtCell(data, null, null, "UndoRedo.redo");
  if (this.selected) {
    instance.selectCells(this.selected, false, false);
  }
};
UndoRedo.CreateRowAction = function(index, amount) {
  this.index = index;
  this.amount = amount;
  this.actionType = "insert_row";
};
inherit(UndoRedo.CreateRowAction, UndoRedo.Action);
UndoRedo.CreateRowAction.prototype.undo = function(instance, undoneCallback) {
  var rowCount = instance.countRows();
  var minSpareRows = instance.getSettings().minSpareRows;
  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {
    this.index -= minSpareRows;
  }
  instance.addHookOnce("afterRemoveRow", undoneCallback);
  instance.alter("remove_row", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateRow", redoneCallback);
  instance.alter("insert_row", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveRowAction = function(index, data, fixedRowsBottom, fixedRowsTop) {
  this.index = index;
  this.data = data;
  this.actionType = "remove_row";
  this.fixedRowsBottom = fixedRowsBottom;
  this.fixedRowsTop = fixedRowsTop;
};
inherit(UndoRedo.RemoveRowAction, UndoRedo.Action);
UndoRedo.RemoveRowAction.prototype.undo = function(instance, undoneCallback) {
  var settings = instance.getSettings();
  settings.fixedRowsBottom = this.fixedRowsBottom;
  settings.fixedRowsTop = this.fixedRowsTop;
  instance.alter("insert_row", this.index, this.data.length, "UndoRedo.undo");
  instance.addHookOnce("afterRender", undoneCallback);
  instance.populateFromArray(this.index, 0, this.data, void 0, void 0, "UndoRedo.undo");
};
UndoRedo.RemoveRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveRow", redoneCallback);
  instance.alter("remove_row", this.index, this.data.length, "UndoRedo.redo");
};
UndoRedo.CreateColumnAction = function(index, amount) {
  this.index = index;
  this.amount = amount;
  this.actionType = "insert_col";
};
inherit(UndoRedo.CreateColumnAction, UndoRedo.Action);
UndoRedo.CreateColumnAction.prototype.undo = function(instance, undoneCallback) {
  instance.addHookOnce("afterRemoveCol", undoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateCol", redoneCallback);
  instance.alter("insert_col", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveColumnAction = function(index, indexes, data, headers, columnPositions, rowPositions, fixedColumnsLeft) {
  this.index = index;
  this.indexes = indexes;
  this.data = data;
  this.amount = this.data[0].length;
  this.headers = headers;
  this.columnPositions = columnPositions.slice(0);
  this.rowPositions = rowPositions.slice(0);
  this.actionType = "remove_col";
  this.fixedColumnsLeft = fixedColumnsLeft;
};
inherit(UndoRedo.RemoveColumnAction, UndoRedo.Action);
UndoRedo.RemoveColumnAction.prototype.undo = function(instance, undoneCallback) {
  var _this2 = this;
  var settings = instance.getSettings();
  settings.fixedColumnsLeft = this.fixedColumnsLeft;
  var ascendingIndexes = this.indexes.slice(0).sort();
  var sortByIndexes = function sortByIndexes2(elem, j, arr) {
    return arr[_this2.indexes.indexOf(ascendingIndexes[j])];
  };
  var removedDataLength = this.data.length;
  var sortedData = [];
  for (var rowIndex = 0; rowIndex < removedDataLength; rowIndex++) {
    sortedData.push(arrayMap(this.data[rowIndex], sortByIndexes));
  }
  var sortedHeaders = arrayMap(this.headers, sortByIndexes);
  var changes = [];
  instance.alter("insert_col", this.indexes[0], this.indexes.length, "UndoRedo.undo");
  arrayEach(instance.getSourceDataArray(), function(rowData, rowIndex2) {
    arrayEach(ascendingIndexes, function(changedIndex, contiquesIndex) {
      rowData[changedIndex] = sortedData[rowIndex2][contiquesIndex];
      changes.push([rowIndex2, changedIndex, rowData[changedIndex]]);
    });
  });
  instance.setSourceDataAtCell(changes);
  instance.columnIndexMapper.insertIndexes(ascendingIndexes[0], ascendingIndexes.length);
  if (typeof this.headers !== "undefined") {
    arrayEach(sortedHeaders, function(headerData, columnIndex) {
      instance.getSettings().colHeaders[ascendingIndexes[columnIndex]] = headerData;
    });
  }
  instance.batchExecution(function() {
    instance.rowIndexMapper.setIndexesSequence(_this2.rowPositions);
    instance.columnIndexMapper.setIndexesSequence(_this2.columnPositions);
  }, true);
  instance.addHookOnce("afterRender", undoneCallback);
  instance.render();
};
UndoRedo.RemoveColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveCol", redoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.CellAlignmentAction = function(stateBefore, range, type, alignment) {
  this.stateBefore = stateBefore;
  this.range = range;
  this.type = type;
  this.alignment = alignment;
};
UndoRedo.CellAlignmentAction.prototype.undo = function(instance, undoneCallback) {
  var _this3 = this;
  arrayEach(this.range, function(range) {
    range.forAll(function(row, col) {
      if (row >= 0 && col >= 0) {
        instance.setCellMeta(row, col, "className", _this3.stateBefore[row][col] || " htLeft");
      }
    });
  });
  instance.addHookOnce("afterRender", undoneCallback);
  instance.render();
};
UndoRedo.CellAlignmentAction.prototype.redo = function(instance, undoneCallback) {
  align(this.range, this.type, this.alignment, function(row, col) {
    return instance.getCellMeta(row, col);
  }, function(row, col, key, value) {
    return instance.setCellMeta(row, col, key, value);
  });
  instance.addHookOnce("afterRender", undoneCallback);
  instance.render();
};
UndoRedo.FiltersAction = function(conditionsStack) {
  this.conditionsStack = conditionsStack;
  this.actionType = "filter";
};
inherit(UndoRedo.FiltersAction, UndoRedo.Action);
UndoRedo.FiltersAction.prototype.undo = function(instance, undoneCallback) {
  var filters = instance.getPlugin("filters");
  instance.addHookOnce("afterRender", undoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, this.conditionsStack.length - 1));
  filters.filter();
};
UndoRedo.FiltersAction.prototype.redo = function(instance, redoneCallback) {
  var filters = instance.getPlugin("filters");
  instance.addHookOnce("afterRender", redoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack);
  filters.filter();
};
var MergeCellsAction = /* @__PURE__ */ function(_UndoRedo$Action) {
  _inherits$W(MergeCellsAction2, _UndoRedo$Action);
  var _super = _createSuper$W(MergeCellsAction2);
  function MergeCellsAction2(instance, cellRange) {
    var _this4;
    _classCallCheck$1Z(this, MergeCellsAction2);
    _this4 = _super.call(this);
    _this4.cellRange = cellRange;
    var topLeftCorner = _this4.cellRange.getTopLeftCorner();
    var bottomRightCorner = _this4.cellRange.getBottomRightCorner();
    _this4.rangeData = instance.getData(topLeftCorner.row, topLeftCorner.col, bottomRightCorner.row, bottomRightCorner.col);
    return _this4;
  }
  _createClass$1T(MergeCellsAction2, [{
    key: "undo",
    value: function undo(instance, undoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterRender", undoneCallback);
      mergeCellsPlugin.unmergeRange(this.cellRange, true);
      var topLeftCorner = this.cellRange.getTopLeftCorner();
      instance.populateFromArray(topLeftCorner.row, topLeftCorner.col, this.rangeData, void 0, void 0, "MergeCells");
    }
  }, {
    key: "redo",
    value: function redo(instance, redoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterRender", redoneCallback);
      mergeCellsPlugin.mergeRange(this.cellRange);
    }
  }]);
  return MergeCellsAction2;
}(UndoRedo.Action);
UndoRedo.MergeCellsAction = MergeCellsAction;
var UnmergeCellsAction = /* @__PURE__ */ function(_UndoRedo$Action2) {
  _inherits$W(UnmergeCellsAction2, _UndoRedo$Action2);
  var _super2 = _createSuper$W(UnmergeCellsAction2);
  function UnmergeCellsAction2(instance, cellRange) {
    var _this5;
    _classCallCheck$1Z(this, UnmergeCellsAction2);
    _this5 = _super2.call(this);
    _this5.cellRange = cellRange;
    return _this5;
  }
  _createClass$1T(UnmergeCellsAction2, [{
    key: "undo",
    value: function undo(instance, undoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterRender", undoneCallback);
      mergeCellsPlugin.mergeRange(this.cellRange, true);
    }
  }, {
    key: "redo",
    value: function redo(instance, redoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterRender", redoneCallback);
      mergeCellsPlugin.unmergeRange(this.cellRange, true);
      instance.render();
    }
  }]);
  return UnmergeCellsAction2;
}(UndoRedo.Action);
UndoRedo.UnmergeCellsAction = UnmergeCellsAction;
UndoRedo.RowMoveAction = function(rows, finalIndex) {
  this.rows = rows.slice();
  this.finalIndex = finalIndex;
};
inherit(UndoRedo.RowMoveAction, UndoRedo.Action);
UndoRedo.RowMoveAction.prototype.undo = function(instance, undoneCallback) {
  var _this6 = this;
  var manualRowMove = instance.getPlugin("manualRowMove");
  var copyOfRows = [].concat(this.rows);
  var rowsMovedUp = copyOfRows.filter(function(a) {
    return a > _this6.finalIndex;
  });
  var rowsMovedDown = copyOfRows.filter(function(a) {
    return a <= _this6.finalIndex;
  });
  var allMovedRows = rowsMovedUp.sort(function(a, b) {
    return b - a;
  }).concat(rowsMovedDown.sort(function(a, b) {
    return a - b;
  }));
  instance.addHookOnce("afterRender", undoneCallback);
  for (var i = 0; i < allMovedRows.length; i += 1) {
    var newPhysicalRow = instance.toVisualRow(allMovedRows[i]);
    manualRowMove.moveRow(newPhysicalRow, allMovedRows[i]);
  }
  instance.render();
  instance.deselectCell();
  instance.selectRows(this.rows[0], this.rows[0] + this.rows.length - 1);
};
UndoRedo.RowMoveAction.prototype.redo = function(instance, redoneCallback) {
  var manualRowMove = instance.getPlugin("manualRowMove");
  instance.addHookOnce("afterRender", redoneCallback);
  manualRowMove.moveRows(this.rows.slice(), this.finalIndex);
  instance.render();
  instance.deselectCell();
  instance.selectRows(this.finalIndex, this.finalIndex + this.rows.length - 1);
};
UndoRedo.prototype.init = function() {
  var settings = this.instance.getSettings().undo;
  var pluginEnabled = typeof settings === "undefined" || settings;
  if (!this.instance.undoRedo) {
    this.instance.undoRedo = this;
  }
  if (pluginEnabled) {
    this.instance.undoRedo.enable();
  } else {
    this.instance.undoRedo.disable();
  }
};
function onBeforeKeyDown(event) {
  if (isImmediatePropagationStopped(event)) {
    return;
  }
  var instance = this;
  var editor = instance.getActiveEditor();
  if (editor && editor.isOpened()) {
    return;
  }
  var altKey = event.altKey, ctrlKey = event.ctrlKey, keyCode = event.keyCode, metaKey = event.metaKey, shiftKey = event.shiftKey;
  var isCtrlDown = (ctrlKey || metaKey) && !altKey;
  if (!isCtrlDown) {
    return;
  }
  var isRedoHotkey = keyCode === 89 || shiftKey && keyCode === 90;
  if (isRedoHotkey) {
    instance.undoRedo.redo();
    stopImmediatePropagation(event);
  } else if (keyCode === 90) {
    instance.undoRedo.undo();
    stopImmediatePropagation(event);
  }
}
function onAfterChange(changes, source) {
  var instance = this;
  if (source === "loadData") {
    return instance.undoRedo.clear();
  }
}
function exposeUndoRedoMethods(instance) {
  instance.undo = function() {
    return instance.undoRedo.undo();
  };
  instance.redo = function() {
    return instance.undoRedo.redo();
  };
  instance.isUndoAvailable = function() {
    return instance.undoRedo.isUndoAvailable();
  };
  instance.isRedoAvailable = function() {
    return instance.undoRedo.isRedoAvailable();
  };
  instance.clearUndo = function() {
    return instance.undoRedo.clear();
  };
}
function removeExposedUndoRedoMethods(instance) {
  delete instance.undo;
  delete instance.redo;
  delete instance.isUndoAvailable;
  delete instance.isRedoAvailable;
  delete instance.clearUndo;
}
var hook = Hooks.getSingleton();
hook.add("afterUpdateSettings", function() {
  this.getPlugin("undoRedo").init();
});
hook.register("beforeUndo");
hook.register("afterUndo");
hook.register("beforeRedo");
hook.register("afterRedo");
UndoRedo.PLUGIN_KEY = PLUGIN_KEY$l;

function _typeof$17(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$17 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$17 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$17(obj);
}
function _classCallCheck$1_(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1U(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1U(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1U(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1U(Constructor, staticProps);
  return Constructor;
}
function _get$z(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$z = Reflect.get;
  } else {
    _get$z = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$z(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$z(target, property, receiver || target);
}
function _superPropBase$z(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$X(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$X(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$Y(subClass, superClass);
}
function _setPrototypeOf$Y(o, p) {
  _setPrototypeOf$Y = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$Y(o, p);
}
function _createSuper$X(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$X(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$X(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$X(this, result);
  };
}
function _possibleConstructorReturn$X(self, call) {
  if (call && (_typeof$17(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$X(self);
}
function _assertThisInitialized$X(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$Y() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$X(o) {
  _getPrototypeOf$X = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$X(o);
}
var _alterUtilsFactory = alterUtilsFactory("physicallyIndexed"), getListWithInsertedItems$2 = _alterUtilsFactory.getListWithInsertedItems, getListWithRemovedItems$2 = _alterUtilsFactory.getListWithRemovedItems;
var LooseBindsMap = /* @__PURE__ */ function(_IndexMap) {
  _inherits$X(LooseBindsMap2, _IndexMap);
  var _super = _createSuper$X(LooseBindsMap2);
  function LooseBindsMap2() {
    _classCallCheck$1_(this, LooseBindsMap2);
    return _super.call(this, function(index) {
      return index;
    });
  }
  _createClass$1U(LooseBindsMap2, [{
    key: "insert",
    value: function insert(insertionIndex, insertedIndexes) {
      var listAfterUpdate = getIncreasedIndexes(this.indexedValues, insertedIndexes);
      this.indexedValues = getListWithInsertedItems$2(listAfterUpdate, insertionIndex, insertedIndexes, this.initValueOrFn);
      _get$z(_getPrototypeOf$X(LooseBindsMap2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
    }
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      var listAfterUpdate = getListWithRemovedItems$2(this.indexedValues, removedIndexes);
      this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);
      _get$z(_getPrototypeOf$X(LooseBindsMap2.prototype), "remove", this).call(this, removedIndexes);
    }
  }]);
  return LooseBindsMap2;
}(IndexMap);

function _typeof$18(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$18 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$18 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$18(obj);
}
function _toConsumableArray$o(arr) {
  return _arrayWithoutHoles$m(arr) || _iterableToArray$o(arr) || _unsupportedIterableToArray$H(arr) || _nonIterableSpread$m();
}
function _nonIterableSpread$m() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$H(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$H(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$H(o, minLen);
}
function _iterableToArray$o(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$m(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$H(arr);
}
function _arrayLikeToArray$H(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$1$(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1V(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1V(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1V(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1V(Constructor, staticProps);
  return Constructor;
}
function _get$A(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$A = Reflect.get;
  } else {
    _get$A = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$A(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$A(target, property, receiver || target);
}
function _superPropBase$A(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$Y(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$Y(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$Z(subClass, superClass);
}
function _setPrototypeOf$Z(o, p) {
  _setPrototypeOf$Z = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$Z(o, p);
}
function _createSuper$Y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$Y(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$Y(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$Y(this, result);
  };
}
function _possibleConstructorReturn$Y(self, call) {
  if (call && (_typeof$18(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$Y(self);
}
function _assertThisInitialized$Y(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$Z() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$Y(o) {
  _getPrototypeOf$Y = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$Y(o);
}
var _alterUtilsFactory$1 = alterUtilsFactory("physicallyIndexed"), getListWithInsertedItems$3 = _alterUtilsFactory$1.getListWithInsertedItems, getListWithRemovedItems$3 = _alterUtilsFactory$1.getListWithRemovedItems;
var StrictBindsMap = /* @__PURE__ */ function(_IndexMap) {
  _inherits$Y(StrictBindsMap2, _IndexMap);
  var _super = _createSuper$Y(StrictBindsMap2);
  function StrictBindsMap2() {
    _classCallCheck$1$(this, StrictBindsMap2);
    return _super.call(this, function(index) {
      return index;
    });
  }
  _createClass$1V(StrictBindsMap2, [{
    key: "insert",
    value: function insert(insertionIndex, insertedIndexes) {
      var _this = this;
      this.indexedValues = getListWithInsertedItems$3(this.indexedValues, insertionIndex, insertedIndexes, function(_, ordinalNumber) {
        return _this.getNextValue(ordinalNumber);
      });
      _get$A(_getPrototypeOf$Y(StrictBindsMap2.prototype), "insert", this).call(this, insertionIndex, insertedIndexes);
    }
  }, {
    key: "remove",
    value: function remove(removedIndexes) {
      this.indexedValues = getListWithRemovedItems$3(this.indexedValues, removedIndexes);
      _get$A(_getPrototypeOf$Y(StrictBindsMap2.prototype), "remove", this).call(this, removedIndexes);
    }
  }, {
    key: "getNextValue",
    value: function getNextValue(ordinalNumber) {
      return Math.max.apply(Math, _toConsumableArray$o(this.getValues())) + 1 + ordinalNumber;
    }
  }]);
  return StrictBindsMap2;
}(IndexMap);

function _typeof$19(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$19 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$19 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$19(obj);
}
function _classCallCheck$20(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1W(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1W(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1W(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1W(Constructor, staticProps);
  return Constructor;
}
function _get$B(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$B = Reflect.get;
  } else {
    _get$B = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$B(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$B(target, property, receiver || target);
}
function _superPropBase$B(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$Z(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$Z(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$_(subClass, superClass);
}
function _setPrototypeOf$_(o, p) {
  _setPrototypeOf$_ = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$_(o, p);
}
function _createSuper$Z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$_();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$Z(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$Z(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$Z(this, result);
  };
}
function _possibleConstructorReturn$Z(self, call) {
  if (call && (_typeof$19(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$Z(self);
}
function _assertThisInitialized$Z(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$_() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$Z(o) {
  _getPrototypeOf$Z = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$Z(o);
}
var PLUGIN_KEY$m = "bindRowsWithHeaders";
var PLUGIN_PRIORITY$k = 210;
var DEFAULT_BIND = "loose";
var bindTypeToMapStrategy = new Map([["loose", LooseBindsMap], ["strict", StrictBindsMap]]);
var BindRowsWithHeaders = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$Z(BindRowsWithHeaders2, _BasePlugin);
  var _super = _createSuper$Z(BindRowsWithHeaders2);
  function BindRowsWithHeaders2(hotInstance) {
    var _this;
    _classCallCheck$20(this, BindRowsWithHeaders2);
    _this = _super.call(this, hotInstance);
    _this.headerIndexes = null;
    return _this;
  }
  _createClass$1W(BindRowsWithHeaders2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$m];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var bindType = this.hot.getSettings()[PLUGIN_KEY$m];
      if (typeof bindType !== "string") {
        bindType = DEFAULT_BIND;
      }
      var MapStrategy = bindTypeToMapStrategy.get(bindType);
      this.headerIndexes = this.hot.rowIndexMapper.registerMap("bindRowsWithHeaders", new MapStrategy());
      this.addHook("modifyRowHeader", function(row) {
        return _this2.onModifyRowHeader(row);
      });
      _get$B(_getPrototypeOf$Z(BindRowsWithHeaders2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.rowIndexMapper.unregisterMap("bindRowsWithHeaders");
      _get$B(_getPrototypeOf$Z(BindRowsWithHeaders2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "onModifyRowHeader",
    value: function onModifyRowHeader(row) {
      return this.headerIndexes.getValueAtIndex(this.hot.toPhysicalRow(row));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$B(_getPrototypeOf$Z(BindRowsWithHeaders2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$m;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$k;
    }
  }]);
  return BindRowsWithHeaders2;
}(BasePlugin);

function _classCallCheck$21(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1X(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1X(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1X(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1X(Constructor, staticProps);
  return Constructor;
}
var Endpoints = /* @__PURE__ */ function() {
  function Endpoints2(plugin, settings) {
    _classCallCheck$21(this, Endpoints2);
    this.plugin = plugin;
    this.hot = this.plugin.hot;
    this.endpoints = [];
    this.settings = settings;
    this.settingsType = "array";
    this.currentEndpoint = null;
    this.cellsToSetCache = [];
  }
  _createClass$1X(Endpoints2, [{
    key: "getEndpoint",
    value: function getEndpoint(index) {
      if (this.settingsType === "function") {
        return this.fillMissingEndpointData(this.settings)[index];
      }
      return this.endpoints[index];
    }
  }, {
    key: "getAllEndpoints",
    value: function getAllEndpoints() {
      if (this.settingsType === "function") {
        return this.fillMissingEndpointData(this.settings);
      }
      return this.endpoints;
    }
  }, {
    key: "fillMissingEndpointData",
    value: function fillMissingEndpointData(func) {
      return this.parseSettings(func.call(this));
    }
  }, {
    key: "parseSettings",
    value: function parseSettings(settings) {
      var _this = this;
      var endpointsArray = [];
      var settingsArray = settings;
      if (!settingsArray && typeof this.settings === "function") {
        this.settingsType = "function";
        return;
      }
      if (!settingsArray) {
        settingsArray = this.settings;
      }
      arrayEach(settingsArray, function(val) {
        var newEndpoint = {};
        _this.assignSetting(val, newEndpoint, "ranges", [[0, _this.hot.countRows() - 1]]);
        _this.assignSetting(val, newEndpoint, "reversedRowCoords", false);
        _this.assignSetting(val, newEndpoint, "destinationRow", new Error("\n        You must provide a destination row for the Column Summary plugin in order to work properly!\n      "));
        _this.assignSetting(val, newEndpoint, "destinationColumn", new Error("\n        You must provide a destination column for the Column Summary plugin in order to work properly!\n      "));
        _this.assignSetting(val, newEndpoint, "sourceColumn", val.destinationColumn);
        _this.assignSetting(val, newEndpoint, "type", "sum");
        _this.assignSetting(val, newEndpoint, "forceNumeric", false);
        _this.assignSetting(val, newEndpoint, "suppressDataTypeErrors", true);
        _this.assignSetting(val, newEndpoint, "suppressDataTypeErrors", true);
        _this.assignSetting(val, newEndpoint, "customFunction", null);
        _this.assignSetting(val, newEndpoint, "readOnly", true);
        _this.assignSetting(val, newEndpoint, "roundFloat", false);
        endpointsArray.push(newEndpoint);
      });
      return endpointsArray;
    }
  }, {
    key: "assignSetting",
    value: function assignSetting(settings, endpoint, name, defaultValue) {
      if (name === "ranges" && settings[name] === void 0) {
        endpoint[name] = defaultValue;
        return;
      } else if (name === "ranges" && settings[name].length === 0) {
        return;
      }
      if (settings[name] === void 0) {
        if (defaultValue instanceof Error) {
          throw defaultValue;
        }
        endpoint[name] = defaultValue;
      } else {
        if (name === "destinationRow" && endpoint.reversedRowCoords) {
          endpoint[name] = this.hot.countRows() - settings[name] - 1;
        } else {
          endpoint[name] = settings[name];
        }
      }
    }
  }, {
    key: "resetSetupBeforeStructureAlteration",
    value: function resetSetupBeforeStructureAlteration(action, index, number) {
      if (this.settingsType !== "function") {
        return;
      }
      var type = action.indexOf("row") > -1 ? "row" : "col";
      var endpoints = this.getAllEndpoints();
      arrayEach(endpoints, function(val) {
        if (type === "row" && val.destinationRow >= index) {
          if (action === "insert_row") {
            val.alterRowOffset = number;
          } else if (action === "remove_row") {
            val.alterRowOffset = -1 * number;
          }
        }
        if (type === "col" && val.destinationColumn >= index) {
          if (action === "insert_col") {
            val.alterColumnOffset = number;
          } else if (action === "remove_col") {
            val.alterColumnOffset = -1 * number;
          }
        }
      });
      this.resetAllEndpoints(endpoints, false);
    }
  }, {
    key: "resetSetupAfterStructureAlteration",
    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {
      var _this2 = this;
      var forceRefresh = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (this.settingsType === "function") {
        var beforeRenderCallback = function beforeRenderCallback2() {
          _this2.hot.removeHook("beforeRender", beforeRenderCallback2);
          return _this2.refreshAllEndpoints();
        };
        this.hot.addHookOnce("beforeRender", beforeRenderCallback);
        return;
      }
      var type = action.indexOf("row") > -1 ? "row" : "col";
      var multiplier = action.indexOf("remove") > -1 ? -1 : 1;
      var endpoints = this.getAllEndpoints();
      var rowMoving = action.indexOf("move_row") === 0;
      var placeOfAlteration = index;
      arrayEach(endpoints, function(val) {
        if (type === "row" && val.destinationRow >= placeOfAlteration) {
          val.alterRowOffset = multiplier * number;
        }
        if (type === "col" && val.destinationColumn >= placeOfAlteration) {
          val.alterColumnOffset = multiplier * number;
        }
      });
      this.resetAllEndpoints(endpoints, !rowMoving);
      if (rowMoving) {
        arrayEach(endpoints, function(endpoint) {
          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);
          _this2.recreatePhysicalRanges(endpoint);
          _this2.clearOffsetInformation(endpoint);
        });
      } else {
        arrayEach(endpoints, function(endpoint) {
          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);
        });
      }
      if (forceRefresh) {
        this.refreshAllEndpoints();
      }
    }
  }, {
    key: "clearOffsetInformation",
    value: function clearOffsetInformation(endpoint) {
      endpoint.alterRowOffset = void 0;
      endpoint.alterColumnOffset = void 0;
    }
  }, {
    key: "extendEndpointRanges",
    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {
      arrayEach(endpoint.ranges, function(range) {
        if (range[1]) {
          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {
            if (previousPosition > range[1]) {
              range[1] += offset;
            } else if (previousPosition < range[0]) {
              range[0] -= offset;
            }
          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {
            range[1] -= offset;
            if (placeOfAlteration <= range[0]) {
              range[0] += 1;
              range[1] += 1;
            }
          }
        }
      });
    }
  }, {
    key: "recreatePhysicalRanges",
    value: function recreatePhysicalRanges(endpoint) {
      var _this3 = this;
      var ranges = endpoint.ranges;
      var newRanges = [];
      var allIndexes = [];
      arrayEach(ranges, function(range) {
        var newRange = [];
        if (range[1]) {
          for (var i = range[0]; i <= range[1]; i++) {
            newRange.push(_this3.hot.toPhysicalRow(i));
          }
        } else {
          newRange.push(_this3.hot.toPhysicalRow(range[0]));
        }
        allIndexes.push(newRange);
      });
      arrayEach(allIndexes, function(range) {
        var newRange = [];
        arrayEach(range, function(coord, index) {
          if (index === 0) {
            newRange.push(coord);
          } else if (range[index] !== range[index - 1] + 1) {
            newRange.push(range[index - 1]);
            newRanges.push(newRange);
            newRange = [];
            newRange.push(coord);
          }
          if (index === range.length - 1) {
            newRange.push(coord);
            newRanges.push(newRange);
          }
        });
      });
      endpoint.ranges = newRanges;
    }
  }, {
    key: "shiftEndpointCoordinates",
    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {
      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {
        endpoint.destinationRow += endpoint.alterRowOffset || 0;
        arrayEach(endpoint.ranges, function(element) {
          arrayEach(element, function(subElement, j) {
            if (subElement >= offsetStartIndex) {
              element[j] += endpoint.alterRowOffset || 0;
            }
          });
        });
      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {
        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;
        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;
      }
    }
  }, {
    key: "resetAllEndpoints",
    value: function resetAllEndpoints() {
      var _this4 = this;
      var endpoints = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getAllEndpoints();
      var useOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var anyEndpointOutOfRange = endpoints.some(function(endpoint) {
        var alterRowOffset = endpoint.alterRowOffset || 0;
        var alterColOffset = endpoint.alterColumnOffset || 0;
        if (endpoint.destinationRow + alterRowOffset >= _this4.hot.countRows() || endpoint.destinationColumn + alterColOffset >= _this4.hot.countCols()) {
          return true;
        }
        return false;
      });
      if (anyEndpointOutOfRange) {
        return;
      }
      this.cellsToSetCache = [];
      arrayEach(endpoints, function(endpoint) {
        _this4.resetEndpointValue(endpoint, useOffset);
      });
      this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
      this.cellsToSetCache = [];
    }
  }, {
    key: "refreshAllEndpoints",
    value: function refreshAllEndpoints() {
      var _this5 = this;
      this.cellsToSetCache = [];
      arrayEach(this.getAllEndpoints(), function(value) {
        _this5.currentEndpoint = value;
        _this5.plugin.calculate(value);
        _this5.setEndpointValue(value, "init");
      });
      this.currentEndpoint = null;
      this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
      this.cellsToSetCache = [];
    }
  }, {
    key: "refreshChangedEndpoints",
    value: function refreshChangedEndpoints(changes) {
      var _this6 = this;
      var needToRefresh = [];
      this.cellsToSetCache = [];
      arrayEach(changes, function(value, key, changesObj) {
        if ("".concat(value[2] || "") === "".concat(value[3])) {
          return;
        }
        arrayEach(_this6.getAllEndpoints(), function(endpoint, j) {
          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {
            needToRefresh.push(j);
          }
        });
      });
      arrayEach(needToRefresh, function(value) {
        _this6.refreshEndpoint(_this6.getEndpoint(value));
      });
      this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
      this.cellsToSetCache = [];
    }
  }, {
    key: "refreshEndpoint",
    value: function refreshEndpoint(endpoint) {
      this.currentEndpoint = endpoint;
      this.plugin.calculate(endpoint);
      this.setEndpointValue(endpoint);
      this.currentEndpoint = null;
    }
  }, {
    key: "resetEndpointValue",
    value: function resetEndpointValue(endpoint) {
      var useOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var alterRowOffset = endpoint.alterRowOffset || 0;
      var alterColOffset = endpoint.alterColumnOffset || 0;
      var _ref = [this.hot.toVisualRow(endpoint.destinationRow), this.hot.toVisualColumn(endpoint.destinationColumn)], visualRowIndex = _ref[0], visualColumnIndex = _ref[1];
      if (visualColumnIndex !== null && visualRowIndex !== null) {
        var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);
        cellMeta.readOnly = false;
        cellMeta.className = "";
      }
      this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), ""]);
    }
  }, {
    key: "setEndpointValue",
    value: function setEndpointValue(endpoint, source) {
      var render = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;
      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;
      var visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);
      if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {
        this.throwOutOfBoundsWarning();
        return;
      }
      var destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow + reverseRowOffset);
      if (destinationVisualRow !== null) {
        var cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn + reverseColOffset);
        if (source === "init" || cellMeta.readOnly !== endpoint.readOnly) {
          cellMeta.readOnly = endpoint.readOnly;
          cellMeta.className = "columnSummaryResult";
        }
      }
      if (endpoint.roundFloat && !isNaN(endpoint.result)) {
        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);
      }
      if (render) {
        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, "ColumnSummary.set");
      } else {
        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);
      }
      endpoint.alterRowOffset = void 0;
      endpoint.alterColumnOffset = void 0;
    }
  }, {
    key: "throwOutOfBoundsWarning",
    value: function throwOutOfBoundsWarning() {
      warn$1("One of the Column Summary plugins' destination points you provided is beyond the table boundaries!");
    }
  }]);
  return Endpoints2;
}();

function _typeof$1a(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1a = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1a = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1a(obj);
}
var _templateObject$8;
function _taggedTemplateLiteral$8(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _classCallCheck$22(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1Y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1Y(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1Y(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1Y(Constructor, staticProps);
  return Constructor;
}
function _get$C(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$C = Reflect.get;
  } else {
    _get$C = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$C(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$C(target, property, receiver || target);
}
function _superPropBase$C(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$_(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$_(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$$(subClass, superClass);
}
function _setPrototypeOf$$(o, p) {
  _setPrototypeOf$$ = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$$(o, p);
}
function _createSuper$_(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$$();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$_(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$_(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$_(this, result);
  };
}
function _possibleConstructorReturn$_(self, call) {
  if (call && (_typeof$1a(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$_(self);
}
function _assertThisInitialized$_(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$$() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$_(o) {
  _getPrototypeOf$_ = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$_(o);
}
var PLUGIN_KEY$n = "columnSummary";
var PLUGIN_PRIORITY$l = 220;
var ColumnSummary = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$_(ColumnSummary2, _BasePlugin);
  var _super = _createSuper$_(ColumnSummary2);
  function ColumnSummary2(hotInstance) {
    var _this;
    _classCallCheck$22(this, ColumnSummary2);
    _this = _super.call(this, hotInstance);
    _this.endpoints = null;
    return _this;
  }
  _createClass$1Y(ColumnSummary2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$n];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.settings = this.hot.getSettings()[PLUGIN_KEY$n];
      this.endpoints = new Endpoints(this, this.settings);
      this.addHook("afterInit", function() {
        return _this2.onAfterInit.apply(_this2, arguments);
      });
      this.addHook("afterChange", function() {
        return _this2.onAfterChange.apply(_this2, arguments);
      });
      this.addHook("beforeCreateRow", function(index, amount, source) {
        return _this2.endpoints.resetSetupBeforeStructureAlteration("insert_row", index, amount, null, source);
      });
      this.addHook("beforeCreateCol", function(index, amount, source) {
        return _this2.endpoints.resetSetupBeforeStructureAlteration("insert_col", index, amount, null, source);
      });
      this.addHook("beforeRemoveRow", function() {
        var _this2$endpoints;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_this2$endpoints = _this2.endpoints).resetSetupBeforeStructureAlteration.apply(_this2$endpoints, ["remove_row"].concat(args));
      });
      this.addHook("beforeRemoveCol", function() {
        var _this2$endpoints2;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return (_this2$endpoints2 = _this2.endpoints).resetSetupBeforeStructureAlteration.apply(_this2$endpoints2, ["remove_col"].concat(args));
      });
      this.addHook("afterCreateRow", function(index, amount, source) {
        return _this2.endpoints.resetSetupAfterStructureAlteration("insert_row", index, amount, null, source);
      });
      this.addHook("afterCreateCol", function(index, amount, source) {
        return _this2.endpoints.resetSetupAfterStructureAlteration("insert_col", index, amount, null, source);
      });
      this.addHook("afterRemoveRow", function() {
        var _this2$endpoints3;
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return (_this2$endpoints3 = _this2.endpoints).resetSetupAfterStructureAlteration.apply(_this2$endpoints3, ["remove_row"].concat(args));
      });
      this.addHook("afterRemoveCol", function() {
        var _this2$endpoints4;
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return (_this2$endpoints4 = _this2.endpoints).resetSetupAfterStructureAlteration.apply(_this2$endpoints4, ["remove_col"].concat(args));
      });
      this.addHook("afterRowMove", function() {
        return _this2.onAfterRowMove.apply(_this2, arguments);
      });
      _get$C(_getPrototypeOf$_(ColumnSummary2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.endpoints = null;
      this.settings = null;
      this.currentEndpoint = null;
    }
  }, {
    key: "calculate",
    value: function calculate(endpoint) {
      switch (endpoint.type.toLowerCase()) {
        case "sum":
          endpoint.result = this.calculateSum(endpoint);
          break;
        case "min":
          endpoint.result = this.calculateMinMax(endpoint, endpoint.type);
          break;
        case "max":
          endpoint.result = this.calculateMinMax(endpoint, endpoint.type);
          break;
        case "count":
          endpoint.result = this.countEntries(endpoint);
          break;
        case "average":
          endpoint.result = this.calculateAverage(endpoint);
          break;
        case "custom":
          endpoint.result = endpoint.customFunction.call(this, endpoint);
          break;
      }
    }
  }, {
    key: "calculateSum",
    value: function calculateSum(endpoint) {
      var _this3 = this;
      var sum = 0;
      objectEach(endpoint.ranges, function(range) {
        sum += _this3.getPartialSum(range, endpoint.sourceColumn);
      });
      return sum;
    }
  }, {
    key: "getPartialSum",
    value: function getPartialSum(rowRange, col) {
      var sum = 0;
      var i = rowRange[1] || rowRange[0];
      var cellValue = null;
      var biggestDecimalPlacesCount = 0;
      do {
        cellValue = this.getCellValue(i, col) || 0;
        var decimalPlaces = ("".concat(cellValue).split(".")[1] || []).length || 1;
        if (decimalPlaces > biggestDecimalPlacesCount) {
          biggestDecimalPlacesCount = decimalPlaces;
        }
        sum += cellValue || 0;
        i -= 1;
      } while (i >= rowRange[0]);
      return Math.round(sum * Math.pow(10, biggestDecimalPlacesCount)) / Math.pow(10, biggestDecimalPlacesCount);
    }
  }, {
    key: "calculateMinMax",
    value: function calculateMinMax(endpoint, type) {
      var _this4 = this;
      var result = null;
      objectEach(endpoint.ranges, function(range) {
        var partialResult = _this4.getPartialMinMax(range, endpoint.sourceColumn, type);
        if (result === null && partialResult !== null) {
          result = partialResult;
        }
        if (partialResult !== null) {
          switch (type) {
            case "min":
              result = Math.min(result, partialResult);
              break;
            case "max":
              result = Math.max(result, partialResult);
              break;
          }
        }
      });
      return result === null ? "Not enough data" : result;
    }
  }, {
    key: "getPartialMinMax",
    value: function getPartialMinMax(rowRange, col, type) {
      var result = null;
      var i = rowRange[1] || rowRange[0];
      var cellValue;
      do {
        cellValue = this.getCellValue(i, col) || null;
        if (result === null) {
          result = cellValue;
        } else if (cellValue !== null) {
          switch (type) {
            case "min":
              result = Math.min(result, cellValue);
              break;
            case "max":
              result = Math.max(result, cellValue);
              break;
          }
        }
        i -= 1;
      } while (i >= rowRange[0]);
      return result;
    }
  }, {
    key: "countEmpty",
    value: function countEmpty(rowRange, col) {
      var cellValue;
      var counter = 0;
      var i = rowRange[1] || rowRange[0];
      do {
        cellValue = this.getCellValue(i, col);
        if (!cellValue) {
          counter += 1;
        }
        i -= 1;
      } while (i >= rowRange[0]);
      return counter;
    }
  }, {
    key: "countEntries",
    value: function countEntries(endpoint) {
      var _this5 = this;
      var result = 0;
      var ranges = endpoint.ranges;
      objectEach(ranges, function(range) {
        var partial = range[1] === void 0 ? 1 : range[1] - range[0] + 1;
        var emptyCount = _this5.countEmpty(range, endpoint.sourceColumn);
        result += partial;
        result -= emptyCount;
      });
      return result;
    }
  }, {
    key: "calculateAverage",
    value: function calculateAverage(endpoint) {
      var sum = this.calculateSum(endpoint);
      var entriesCount = this.countEntries(endpoint);
      return sum / entriesCount;
    }
  }, {
    key: "getCellValue",
    value: function getCellValue(row, col) {
      var visualRowIndex = this.hot.toVisualRow(row);
      var visualColumnIndex = this.hot.toVisualColumn(col);
      var cellValue = this.hot.getSourceDataAtCell(row, col);
      var cellClassName = "";
      if (visualRowIndex !== null && visualColumnIndex !== null) {
        cellClassName = this.hot.getCellMeta(visualRowIndex, visualColumnIndex).className || "";
      }
      if (cellClassName.indexOf("columnSummaryResult") > -1) {
        return null;
      }
      if (this.endpoints.currentEndpoint.forceNumeric) {
        if (typeof cellValue === "string") {
          cellValue = cellValue.replace(/,/, ".");
        }
        cellValue = parseFloat(cellValue);
      }
      if (isNaN(cellValue)) {
        if (!this.endpoints.currentEndpoint.suppressDataTypeErrors) {
          throw new Error(toSingleLine(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteral$8(["ColumnSummary plugin: cell at (", ", ", ") is not in a \n          numeric format. Cannot do the calculation."], ["ColumnSummary plugin: cell at (", ", ", ") is not in a\\x20\n          numeric format. Cannot do the calculation."])), row, col));
        }
      }
      return cellValue;
    }
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      this.endpoints.endpoints = this.endpoints.parseSettings();
      this.endpoints.refreshAllEndpoints(true);
    }
  }, {
    key: "onAfterChange",
    value: function onAfterChange(changes, source) {
      if (changes && source !== "ColumnSummary.reset" && source !== "ColumnSummary.set" && source !== "loadData") {
        this.endpoints.refreshChangedEndpoints(changes);
      }
    }
  }, {
    key: "onAfterRowMove",
    value: function onAfterRowMove(rows, finalIndex) {
      this.endpoints.resetSetupBeforeStructureAlteration("move_row", rows[0], rows.length, rows, this.pluginName);
      this.endpoints.resetSetupAfterStructureAlteration("move_row", finalIndex, rows.length, rows, this.pluginName);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$n;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$l;
    }
  }]);
  return ColumnSummary2;
}(BasePlugin);

function _typeof$1b(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1b = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1b = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1b(obj);
}
function _classCallCheck$23(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1Z(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1Z(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1Z(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1Z(Constructor, staticProps);
  return Constructor;
}
function _get$D(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$D = Reflect.get;
  } else {
    _get$D = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$D(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$D(target, property, receiver || target);
}
function _superPropBase$D(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$$(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$$(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$10(subClass, superClass);
}
function _setPrototypeOf$10(o, p) {
  _setPrototypeOf$10 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$10(o, p);
}
function _createSuper$$(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$10();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$$(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$$(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$$(this, result);
  };
}
function _possibleConstructorReturn$$(self, call) {
  if (call && (_typeof$1b(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$$(self);
}
function _assertThisInitialized$$(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$10() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$$(o) {
  _getPrototypeOf$$ = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$$(o);
}
Hooks.getSingleton().register("afterDropdownMenuDefaultOptions");
Hooks.getSingleton().register("beforeDropdownMenuShow");
Hooks.getSingleton().register("afterDropdownMenuShow");
Hooks.getSingleton().register("afterDropdownMenuHide");
Hooks.getSingleton().register("afterDropdownMenuExecute");
var PLUGIN_KEY$o = "dropdownMenu";
var PLUGIN_PRIORITY$m = 230;
var BUTTON_CLASS_NAME = "changeType";
var DropdownMenu = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$$(DropdownMenu2, _BasePlugin);
  var _super = _createSuper$$(DropdownMenu2);
  function DropdownMenu2(hotInstance) {
    var _this;
    _classCallCheck$23(this, DropdownMenu2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager(_assertThisInitialized$$(_this));
    _this.commandExecutor = new CommandExecutor(_this.hot);
    _this.itemsFactory = null;
    _this.menu = null;
    _this.hot.addHook("afterGetColHeader", function(col, TH) {
      return _this.onAfterGetColHeader(col, TH);
    });
    return _this;
  }
  _createClass$1Z(DropdownMenu2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$o];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.itemsFactory = new ItemsFactory(this.hot, DropdownMenu2.DEFAULT_ITEMS);
      var settings = this.hot.getSettings()[PLUGIN_KEY$o];
      var predefinedItems = {
        items: this.itemsFactory.getItems(settings)
      };
      this.registerEvents();
      if (typeof settings.callback === "function") {
        this.commandExecutor.setCommonCallback(settings.callback);
      }
      _get$D(_getPrototypeOf$$(DropdownMenu2.prototype), "enablePlugin", this).call(this);
      this.callOnPluginsReady(function() {
        _this2.hot.runHooks("afterDropdownMenuDefaultOptions", predefinedItems);
        _this2.itemsFactory.setPredefinedItems(predefinedItems.items);
        var menuItems = _this2.itemsFactory.getItems(settings);
        if (_this2.menu) {
          _this2.menu.destroy();
        }
        _this2.menu = new Menu(_this2.hot, {
          className: "htDropdownMenu",
          keepInViewport: true,
          container: settings.uiContainer || _this2.hot.rootDocument.body
        });
        _this2.hot.runHooks("beforeDropdownMenuSetItems", menuItems);
        _this2.menu.setMenuItems(menuItems);
        _this2.menu.addLocalHook("beforeOpen", function() {
          return _this2.onMenuBeforeOpen();
        });
        _this2.menu.addLocalHook("afterOpen", function() {
          return _this2.onMenuAfterOpen();
        });
        _this2.menu.addLocalHook("afterClose", function() {
          return _this2.onMenuAfterClose();
        });
        _this2.menu.addLocalHook("executeCommand", function() {
          var _this2$executeCommand;
          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
            params[_key] = arguments[_key];
          }
          return (_this2$executeCommand = _this2.executeCommand).call.apply(_this2$executeCommand, [_this2].concat(params));
        });
        arrayEach(menuItems, function(command) {
          return _this2.commandExecutor.registerCommand(command.key, command);
        });
      });
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$D(_getPrototypeOf$$(DropdownMenu2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
      }
      _get$D(_getPrototypeOf$$(DropdownMenu2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "registerEvents",
    value: function registerEvents() {
      var _this3 = this;
      this.eventManager.addEventListener(this.hot.rootElement, "click", function(event) {
        return _this3.onTableClick(event);
      });
    }
  }, {
    key: "open",
    value: function open(position) {
      if (!this.menu) {
        return;
      }
      this.menu.open();
      if (position.width) {
        this.menu.setOffset("left", position.width);
      }
      this.menu.setPosition(position);
    }
  }, {
    key: "close",
    value: function close() {
      if (!this.menu) {
        return;
      }
      this.menu.close();
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(commandName) {
      var _this$commandExecutor;
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      (_this$commandExecutor = this.commandExecutor).execute.apply(_this$commandExecutor, [commandName].concat(params));
    }
  }, {
    key: "setListening",
    value: function setListening() {
      var listen = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (this.menu.isOpened()) {
        if (listen) {
          this.menu.hotMenu.listen();
        } else {
          this.menu.hotMenu.unlisten();
        }
      }
    }
  }, {
    key: "onTableClick",
    value: function onTableClick(event) {
      event.stopPropagation();
      if (hasClass(event.target, BUTTON_CLASS_NAME) && !this.menu.isOpened()) {
        var offsetTop = 0;
        var offsetLeft = 0;
        if (this.hot.rootDocument !== this.menu.container.ownerDocument) {
          var frameElement = this.hot.rootWindow.frameElement;
          var _frameElement$getBoun = frameElement.getBoundingClientRect(), top = _frameElement$getBoun.top, left = _frameElement$getBoun.left;
          offsetTop = top;
          offsetLeft = left;
        }
        var rect = event.target.getBoundingClientRect();
        this.open({
          left: rect.left + offsetLeft,
          top: rect.top + event.target.offsetHeight + 3 + offsetTop,
          width: rect.width,
          height: rect.height
        });
      }
    }
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(col, TH) {
      var headerRow = TH.parentNode;
      if (!headerRow) {
        return;
      }
      var headerRowList = headerRow.parentNode.childNodes;
      var level = Array.prototype.indexOf.call(headerRowList, headerRow);
      if (col < 0 || level !== headerRowList.length - 1) {
        return;
      }
      var existingButton = TH.querySelector(".".concat(BUTTON_CLASS_NAME));
      if (this.enabled && existingButton) {
        return;
      }
      if (!this.enabled) {
        if (existingButton) {
          existingButton.parentNode.removeChild(existingButton);
        }
        return;
      }
      var button = this.hot.rootDocument.createElement("button");
      button.className = BUTTON_CLASS_NAME;
      button.onclick = function() {
        return false;
      };
      TH.firstChild.insertBefore(button, TH.firstChild.firstChild);
    }
  }, {
    key: "onMenuBeforeOpen",
    value: function onMenuBeforeOpen() {
      this.hot.runHooks("beforeDropdownMenuShow", this);
    }
  }, {
    key: "onMenuAfterOpen",
    value: function onMenuAfterOpen() {
      this.hot.runHooks("afterDropdownMenuShow", this);
    }
  }, {
    key: "onMenuAfterClose",
    value: function onMenuAfterClose() {
      this.hot.listen();
      this.hot.runHooks("afterDropdownMenuHide", this);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
      }
      _get$D(_getPrototypeOf$$(DropdownMenu2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$o;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$m;
    }
  }, {
    key: "PLUGIN_DEPS",
    get: function get() {
      return ["plugin:AutoColumnSize"];
    }
  }, {
    key: "DEFAULT_ITEMS",
    get: function get() {
      return [KEY$3, KEY$4, KEY, KEY$7, KEY, KEY$2, KEY, KEY$5, KEY, KEY$1];
    }
  }]);
  return DropdownMenu2;
}(BasePlugin);
DropdownMenu.SEPARATOR = {
  name: KEY
};

function _slicedToArray$s(arr, i) {
  return _arrayWithHoles$u(arr) || _iterableToArrayLimit$s(arr, i) || _unsupportedIterableToArray$I(arr, i) || _nonIterableRest$u();
}
function _nonIterableRest$u() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$I(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$I(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$I(o, minLen);
}
function _arrayLikeToArray$I(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$s(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$u(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$24(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1_(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1_(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1_(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1_(Constructor, staticProps);
  return Constructor;
}
var DataProvider = /* @__PURE__ */ function() {
  function DataProvider2(hotInstance) {
    _classCallCheck$24(this, DataProvider2);
    this.hot = hotInstance;
    this.options = {};
  }
  _createClass$1_(DataProvider2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
  }, {
    key: "getData",
    value: function getData() {
      var _this = this;
      var _this$_getDataRange = this._getDataRange(), startRow = _this$_getDataRange.startRow, startCol = _this$_getDataRange.startCol, endRow = _this$_getDataRange.endRow, endCol = _this$_getDataRange.endCol;
      var options = this.options;
      var data = [];
      rangeEach(startRow, endRow, function(rowIndex) {
        var row = [];
        if (!options.exportHiddenRows && _this._isHiddenRow(rowIndex)) {
          return;
        }
        rangeEach(startCol, endCol, function(colIndex) {
          if (!options.exportHiddenColumns && _this._isHiddenColumn(colIndex)) {
            return;
          }
          row.push(_this.hot.getDataAtCell(rowIndex, colIndex));
        });
        data.push(row);
      });
      return data;
    }
  }, {
    key: "getRowHeaders",
    value: function getRowHeaders() {
      var _this2 = this;
      var headers = [];
      if (this.options.rowHeaders) {
        var _this$_getDataRange2 = this._getDataRange(), startRow = _this$_getDataRange2.startRow, endRow = _this$_getDataRange2.endRow;
        var rowHeaders = this.hot.getRowHeader();
        rangeEach(startRow, endRow, function(row) {
          if (!_this2.options.exportHiddenRows && _this2._isHiddenRow(row)) {
            return;
          }
          headers.push(rowHeaders[row]);
        });
      }
      return headers;
    }
  }, {
    key: "getColumnHeaders",
    value: function getColumnHeaders() {
      var _this3 = this;
      var headers = [];
      if (this.options.columnHeaders) {
        var _this$_getDataRange3 = this._getDataRange(), startCol = _this$_getDataRange3.startCol, endCol = _this$_getDataRange3.endCol;
        var colHeaders = this.hot.getColHeader();
        rangeEach(startCol, endCol, function(column) {
          if (!_this3.options.exportHiddenColumns && _this3._isHiddenColumn(column)) {
            return;
          }
          headers.push(colHeaders[column]);
        });
      }
      return headers;
    }
  }, {
    key: "_getDataRange",
    value: function _getDataRange() {
      var cols = this.hot.countCols() - 1;
      var rows = this.hot.countRows() - 1;
      var _this$options$range = _slicedToArray$s(this.options.range, 4), _this$options$range$ = _this$options$range[0], startRow = _this$options$range$ === void 0 ? 0 : _this$options$range$, _this$options$range$2 = _this$options$range[1], startCol = _this$options$range$2 === void 0 ? 0 : _this$options$range$2, _this$options$range$3 = _this$options$range[2], endRow = _this$options$range$3 === void 0 ? rows : _this$options$range$3, _this$options$range$4 = _this$options$range[3], endCol = _this$options$range$4 === void 0 ? cols : _this$options$range$4;
      startRow = Math.max(startRow, 0);
      startCol = Math.max(startCol, 0);
      endRow = Math.min(endRow, rows);
      endCol = Math.min(endCol, cols);
      return {
        startRow,
        startCol,
        endRow,
        endCol
      };
    }
  }, {
    key: "_isHiddenRow",
    value: function _isHiddenRow(row) {
      return this.hot.rowIndexMapper.isHidden(this.hot.toPhysicalRow(row));
    }
  }, {
    key: "_isHiddenColumn",
    value: function _isHiddenColumn(column) {
      return this.hot.columnIndexMapper.isHidden(this.hot.toPhysicalColumn(column));
    }
  }]);
  return DataProvider2;
}();

function _classCallCheck$25(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1$(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1$(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1$(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1$(Constructor, staticProps);
  return Constructor;
}
var BaseType = /* @__PURE__ */ function() {
  function BaseType2(dataProvider, options) {
    _classCallCheck$25(this, BaseType2);
    this.dataProvider = dataProvider;
    this.options = this._mergeOptions(options);
    this.dataProvider.setOptions(this.options);
  }
  _createClass$1$(BaseType2, [{
    key: "_mergeOptions",
    value: function _mergeOptions(options) {
      var _options = clone(this.constructor.DEFAULT_OPTIONS);
      var date = new Date();
      _options = extend(clone(BaseType2.DEFAULT_OPTIONS), _options);
      _options = extend(_options, options);
      _options.filename = substitute(_options.filename, {
        YYYY: date.getFullYear(),
        MM: "".concat(date.getMonth() + 1).padStart(2, "0"),
        DD: "".concat(date.getDate()).padStart(2, "0")
      });
      return _options;
    }
  }], [{
    key: "DEFAULT_OPTIONS",
    get: function get() {
      return {
        mimeType: "text/plain",
        fileExtension: "txt",
        filename: "Handsontable [YYYY]-[MM]-[DD]",
        encoding: "utf-8",
        bom: false,
        columnHeaders: false,
        rowHeaders: false,
        exportHiddenColumns: false,
        exportHiddenRows: false,
        range: []
      };
    }
  }]);
  return BaseType2;
}();

function _typeof$1c(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1c = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1c = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1c(obj);
}
function _classCallCheck$26(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$20(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$20(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$20(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$20(Constructor, staticProps);
  return Constructor;
}
function _inherits$10(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$11(subClass, superClass);
}
function _setPrototypeOf$11(o, p) {
  _setPrototypeOf$11 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$11(o, p);
}
function _createSuper$10(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$11();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$10(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$10(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$10(this, result);
  };
}
function _possibleConstructorReturn$10(self, call) {
  if (call && (_typeof$1c(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$10(self);
}
function _assertThisInitialized$10(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$11() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$10(o) {
  _getPrototypeOf$10 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$10(o);
}
var CHAR_CARRIAGE_RETURN = String.fromCharCode(13);
var CHAR_DOUBLE_QUOTES = String.fromCharCode(34);
var CHAR_LINE_FEED = String.fromCharCode(10);
var Csv = /* @__PURE__ */ function(_BaseType) {
  _inherits$10(Csv2, _BaseType);
  var _super = _createSuper$10(Csv2);
  function Csv2() {
    _classCallCheck$26(this, Csv2);
    return _super.apply(this, arguments);
  }
  _createClass$20(Csv2, [{
    key: "export",
    value: function _export() {
      var _this = this;
      var options = this.options;
      var data = this.dataProvider.getData();
      var columnHeaders = this.dataProvider.getColumnHeaders();
      var hasColumnHeaders = columnHeaders.length > 0;
      var rowHeaders = this.dataProvider.getRowHeaders();
      var hasRowHeaders = rowHeaders.length > 0;
      var result = options.bom ? String.fromCharCode(65279) : "";
      if (hasColumnHeaders) {
        columnHeaders = arrayMap(columnHeaders, function(value) {
          return _this._escapeCell(value, true);
        });
        if (hasRowHeaders) {
          result += options.columnDelimiter;
        }
        result += columnHeaders.join(options.columnDelimiter);
        result += options.rowDelimiter;
      }
      arrayEach(data, function(value, index) {
        if (index > 0) {
          result += options.rowDelimiter;
        }
        if (hasRowHeaders) {
          result += _this._escapeCell(rowHeaders[index]) + options.columnDelimiter;
        }
        result += value.map(function(cellValue) {
          return _this._escapeCell(cellValue);
        }).join(options.columnDelimiter);
      });
      return result;
    }
  }, {
    key: "_escapeCell",
    value: function _escapeCell(value) {
      var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var escapedValue = stringify(value);
      if (escapedValue !== "" && (force || escapedValue.indexOf(CHAR_CARRIAGE_RETURN) >= 0 || escapedValue.indexOf(CHAR_DOUBLE_QUOTES) >= 0 || escapedValue.indexOf(CHAR_LINE_FEED) >= 0 || escapedValue.indexOf(this.options.columnDelimiter) >= 0)) {
        escapedValue = escapedValue.replace(new RegExp('"', "g"), '""');
        escapedValue = '"'.concat(escapedValue, '"');
      }
      return escapedValue;
    }
  }], [{
    key: "DEFAULT_OPTIONS",
    get: function get() {
      return {
        mimeType: "text/csv",
        fileExtension: "csv",
        bom: true,
        columnDelimiter: ",",
        rowDelimiter: "\r\n"
      };
    }
  }]);
  return Csv2;
}(BaseType);

function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var TYPE_CSV = "csv";
var EXPORT_TYPES = _defineProperty$i({}, TYPE_CSV, Csv);
function typeFactory(type, dataProvider, options) {
  if (typeof EXPORT_TYPES[type] === "function") {
    return new EXPORT_TYPES[type](dataProvider, options);
  }
  return null;
}

function _typeof$1d(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1d = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1d = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1d(obj);
}
function _classCallCheck$27(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$21(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$21(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$21(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$21(Constructor, staticProps);
  return Constructor;
}
function _inherits$11(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$12(subClass, superClass);
}
function _setPrototypeOf$12(o, p) {
  _setPrototypeOf$12 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$12(o, p);
}
function _createSuper$11(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$12();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$11(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$11(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$11(this, result);
  };
}
function _possibleConstructorReturn$11(self, call) {
  if (call && (_typeof$1d(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$11(self);
}
function _assertThisInitialized$11(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$12() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$11(o) {
  _getPrototypeOf$11 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$11(o);
}
var PLUGIN_KEY$p = "exportFile";
var PLUGIN_PRIORITY$n = 240;
var ExportFile = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$11(ExportFile2, _BasePlugin);
  var _super = _createSuper$11(ExportFile2);
  function ExportFile2() {
    _classCallCheck$27(this, ExportFile2);
    return _super.apply(this, arguments);
  }
  _createClass$21(ExportFile2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return true;
    }
  }, {
    key: "exportAsString",
    value: function exportAsString(format) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._createTypeFormatter(format, options).export();
    }
  }, {
    key: "exportAsBlob",
    value: function exportAsBlob(format) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._createBlob(this._createTypeFormatter(format, options));
    }
  }, {
    key: "downloadFile",
    value: function downloadFile(format) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _this$hot = this.hot, rootDocument = _this$hot.rootDocument, rootWindow = _this$hot.rootWindow;
      var formatter = this._createTypeFormatter(format, options);
      var blob = this._createBlob(formatter);
      var URL = rootWindow.URL || rootWindow.webkitURL;
      var a = rootDocument.createElement("a");
      var name = "".concat(formatter.options.filename, ".").concat(formatter.options.fileExtension);
      if (a.download !== void 0) {
        var url = URL.createObjectURL(blob);
        a.style.display = "none";
        a.setAttribute("href", url);
        a.setAttribute("download", name);
        rootDocument.body.appendChild(a);
        a.dispatchEvent(new MouseEvent("click"));
        rootDocument.body.removeChild(a);
        setTimeout(function() {
          URL.revokeObjectURL(url);
        }, 100);
      } else if (navigator.msSaveOrOpenBlob) {
        navigator.msSaveOrOpenBlob(blob, name);
      }
    }
  }, {
    key: "_createTypeFormatter",
    value: function _createTypeFormatter(format) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!EXPORT_TYPES[format]) {
        throw new Error('Export format type "'.concat(format, '" is not supported.'));
      }
      return typeFactory(format, new DataProvider(this.hot), options);
    }
  }, {
    key: "_createBlob",
    value: function _createBlob(typeFormatter) {
      var formatter = null;
      if (typeof Blob !== "undefined") {
        formatter = new Blob([typeFormatter.export()], {
          type: "".concat(typeFormatter.options.mimeType, ";charset=").concat(typeFormatter.options.encoding)
        });
      }
      return formatter;
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$p;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$n;
    }
  }]);
  return ExportFile2;
}(BasePlugin);

function _classCallCheck$28(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$22(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$22(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$22(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$22(Constructor, staticProps);
  return Constructor;
}
var BaseComponent = /* @__PURE__ */ function() {
  function BaseComponent2(hotInstance, _ref) {
    var id = _ref.id, _ref$stateless = _ref.stateless, stateless = _ref$stateless === void 0 ? true : _ref$stateless;
    _classCallCheck$28(this, BaseComponent2);
    this.hot = hotInstance;
    this.id = id;
    this.elements = [];
    this.hidden = false;
    this.stateId = "Filters.component.".concat(this.id);
    this.state = stateless ? null : this.hot.columnIndexMapper.registerMap(this.stateId, new LinkedPhysicalIndexToValueMap());
  }
  _createClass$22(BaseComponent2, [{
    key: "reset",
    value: function reset() {
      arrayEach(this.elements, function(ui) {
        return ui.reset();
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      this.hidden = true;
    }
  }, {
    key: "show",
    value: function show() {
      this.hidden = false;
    }
  }, {
    key: "isHidden",
    value: function isHidden() {
      return this.hot === null || this.hidden;
    }
  }, {
    key: "restoreState",
    value: function restoreState(physicalColumn) {
      if (this.state) {
        this.setState(this.state.getValueAtIndex(physicalColumn));
      }
    }
  }, {
    key: "setState",
    value: function setState() {
      throw new Error("The state setting logic is not implemented");
    }
  }, {
    key: "saveState",
    value: function saveState(physicalColumn) {
      if (this.state) {
        this.state.setValueAtIndex(physicalColumn, this.getState());
      }
    }
  }, {
    key: "getState",
    value: function getState() {
      throw new Error("The state gathering logic is not implemented");
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.hot.columnIndexMapper.unregisterMap(this.stateId);
      this.clearLocalHooks();
      arrayEach(this.elements, function(ui) {
        return ui.destroy();
      });
      this.state = null;
      this.elements = null;
      this.hot = null;
    }
  }]);
  return BaseComponent2;
}();
mixin(BaseComponent, localHooks);

var conditions = {};
function getCondition(name, args) {
  if (!conditions[name]) {
    throw Error('Filter condition "'.concat(name, '" does not exist.'));
  }
  var _conditions$name = conditions[name], condition = _conditions$name.condition, descriptor = _conditions$name.descriptor;
  var conditionArguments = args;
  if (descriptor.inputValuesDecorator) {
    conditionArguments = descriptor.inputValuesDecorator(conditionArguments);
  }
  return function(dataRow) {
    return condition.apply(dataRow.meta.instance, [].concat([dataRow], [conditionArguments]));
  };
}
function getConditionDescriptor(name) {
  if (!conditions[name]) {
    throw Error('Filter condition "'.concat(name, '" does not exist.'));
  }
  return conditions[name].descriptor;
}
function registerCondition(name, condition, descriptor) {
  descriptor.key = name;
  conditions[name] = {
    condition,
    descriptor
  };
}

var CONDITION_NAME = "none";
function condition() {
  return true;
}
registerCondition(CONDITION_NAME, condition, {
  name: FILTERS_CONDITIONS_NONE,
  inputsCount: 0,
  showOperators: false
});

var CONDITION_NAME$1 = "empty";
function condition$1(dataRow) {
  return isEmpty(dataRow.value);
}
registerCondition(CONDITION_NAME$1, condition$1, {
  name: FILTERS_CONDITIONS_EMPTY,
  inputsCount: 0,
  showOperators: true
});

var CONDITION_NAME$2 = "not_empty";
function condition$2(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME$1, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME$2, condition$2, {
  name: FILTERS_CONDITIONS_NOT_EMPTY,
  inputsCount: 0,
  showOperators: true
});

function _slicedToArray$t(arr, i) {
  return _arrayWithHoles$v(arr) || _iterableToArrayLimit$t(arr, i) || _unsupportedIterableToArray$J(arr, i) || _nonIterableRest$v();
}
function _nonIterableRest$v() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$J(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$J(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$J(o, minLen);
}
function _arrayLikeToArray$J(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$t(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$v(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$3 = "eq";
function condition$3(dataRow, _ref) {
  var _ref2 = _slicedToArray$t(_ref, 1), value = _ref2[0];
  return stringify(dataRow.value).toLowerCase() === stringify(value);
}
registerCondition(CONDITION_NAME$3, condition$3, {
  name: FILTERS_CONDITIONS_EQUAL,
  inputsCount: 1,
  showOperators: true
});

var CONDITION_NAME$4 = "neq";
function condition$4(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME$3, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME$4, condition$4, {
  name: FILTERS_CONDITIONS_NOT_EQUAL,
  inputsCount: 1,
  showOperators: true
});

function _slicedToArray$u(arr, i) {
  return _arrayWithHoles$w(arr) || _iterableToArrayLimit$u(arr, i) || _unsupportedIterableToArray$K(arr, i) || _nonIterableRest$w();
}
function _nonIterableRest$w() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$K(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$K(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$K(o, minLen);
}
function _arrayLikeToArray$K(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$u(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$w(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$5 = "gt";
function condition$5(dataRow, _ref) {
  var _ref2 = _slicedToArray$u(_ref, 1), value = _ref2[0];
  var conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value > conditionValue;
}
registerCondition(CONDITION_NAME$5, condition$5, {
  name: FILTERS_CONDITIONS_GREATER_THAN,
  inputsCount: 1,
  showOperators: true
});

function _slicedToArray$v(arr, i) {
  return _arrayWithHoles$x(arr) || _iterableToArrayLimit$v(arr, i) || _unsupportedIterableToArray$L(arr, i) || _nonIterableRest$x();
}
function _nonIterableRest$x() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$L(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$L(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$L(o, minLen);
}
function _arrayLikeToArray$L(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$v(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$x(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$6 = "gte";
function condition$6(dataRow, _ref) {
  var _ref2 = _slicedToArray$v(_ref, 1), value = _ref2[0];
  var conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value >= conditionValue;
}
registerCondition(CONDITION_NAME$6, condition$6, {
  name: FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,
  inputsCount: 1,
  showOperators: true
});

function _slicedToArray$w(arr, i) {
  return _arrayWithHoles$y(arr) || _iterableToArrayLimit$w(arr, i) || _unsupportedIterableToArray$M(arr, i) || _nonIterableRest$y();
}
function _nonIterableRest$y() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$M(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$M(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$M(o, minLen);
}
function _arrayLikeToArray$M(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$w(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$y(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$7 = "lt";
function condition$7(dataRow, _ref) {
  var _ref2 = _slicedToArray$w(_ref, 1), value = _ref2[0];
  var conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value < conditionValue;
}
registerCondition(CONDITION_NAME$7, condition$7, {
  name: FILTERS_CONDITIONS_LESS_THAN,
  inputsCount: 1,
  showOperators: true
});

function _slicedToArray$x(arr, i) {
  return _arrayWithHoles$z(arr) || _iterableToArrayLimit$x(arr, i) || _unsupportedIterableToArray$N(arr, i) || _nonIterableRest$z();
}
function _nonIterableRest$z() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$N(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$N(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$N(o, minLen);
}
function _arrayLikeToArray$N(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$x(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$z(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$8 = "lte";
function condition$8(dataRow, _ref) {
  var _ref2 = _slicedToArray$x(_ref, 1), value = _ref2[0];
  var conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value <= conditionValue;
}
registerCondition(CONDITION_NAME$8, condition$8, {
  name: FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,
  inputsCount: 1,
  showOperators: true
});

function _slicedToArray$y(arr, i) {
  return _arrayWithHoles$A(arr) || _iterableToArrayLimit$y(arr, i) || _unsupportedIterableToArray$O(arr, i) || _nonIterableRest$A();
}
function _nonIterableRest$A() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$O(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$O(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$O(o, minLen);
}
function _arrayLikeToArray$O(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$y(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$A(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$9 = "date_after";
function condition$9(dataRow, _ref) {
  var _ref2 = _slicedToArray$y(_ref, 1), value = _ref2[0];
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  var inputDate = hooks(value, dataRow.meta.dateFormat);
  if (!date.isValid() || !inputDate.isValid()) {
    return false;
  }
  return date.diff(inputDate) >= 0;
}
registerCondition(CONDITION_NAME$9, condition$9, {
  name: FILTERS_CONDITIONS_AFTER,
  inputsCount: 1,
  showOperators: true
});

function _slicedToArray$z(arr, i) {
  return _arrayWithHoles$B(arr) || _iterableToArrayLimit$z(arr, i) || _unsupportedIterableToArray$P(arr, i) || _nonIterableRest$B();
}
function _nonIterableRest$B() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$P(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$P(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$P(o, minLen);
}
function _arrayLikeToArray$P(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$z(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$B(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$a = "date_before";
function condition$a(dataRow, _ref) {
  var _ref2 = _slicedToArray$z(_ref, 1), value = _ref2[0];
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  var inputDate = hooks(value, dataRow.meta.dateFormat);
  if (!date.isValid() || !inputDate.isValid()) {
    return false;
  }
  return date.diff(inputDate) <= 0;
}
registerCondition(CONDITION_NAME$a, condition$a, {
  name: FILTERS_CONDITIONS_BEFORE,
  inputsCount: 1,
  showOperators: true
});

function _slicedToArray$A(arr, i) {
  return _arrayWithHoles$C(arr) || _iterableToArrayLimit$A(arr, i) || _unsupportedIterableToArray$Q(arr, i) || _nonIterableRest$C();
}
function _nonIterableRest$C() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$Q(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$Q(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$Q(o, minLen);
}
function _arrayLikeToArray$Q(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$A(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$C(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$b = "between";
function condition$b(dataRow, _ref) {
  var _ref2 = _slicedToArray$A(_ref, 2), from = _ref2[0], to = _ref2[1];
  var fromValue = from;
  var toValue = to;
  if (dataRow.meta.type === "numeric") {
    var _from = parseFloat(fromValue, 10);
    var _to = parseFloat(toValue, 10);
    fromValue = Math.min(_from, _to);
    toValue = Math.max(_from, _to);
  } else if (dataRow.meta.type === "date") {
    var dateBefore = getCondition(CONDITION_NAME$a, [toValue]);
    var dateAfter = getCondition(CONDITION_NAME$9, [fromValue]);
    return dateBefore(dataRow) && dateAfter(dataRow);
  }
  return dataRow.value >= fromValue && dataRow.value <= toValue;
}
registerCondition(CONDITION_NAME$b, condition$b, {
  name: FILTERS_CONDITIONS_BETWEEN,
  inputsCount: 2,
  showOperators: true
});

var CONDITION_NAME$c = "not_between";
function condition$c(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME$b, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME$c, condition$c, {
  name: FILTERS_CONDITIONS_NOT_BETWEEN,
  inputsCount: 2,
  showOperators: true
});

function _slicedToArray$B(arr, i) {
  return _arrayWithHoles$D(arr) || _iterableToArrayLimit$B(arr, i) || _unsupportedIterableToArray$R(arr, i) || _nonIterableRest$D();
}
function _nonIterableRest$D() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$R(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$R(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$R(o, minLen);
}
function _arrayLikeToArray$R(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$B(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$D(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$d = "begins_with";
function condition$d(dataRow, _ref) {
  var _ref2 = _slicedToArray$B(_ref, 1), value = _ref2[0];
  return stringify(dataRow.value).toLowerCase().startsWith(stringify(value));
}
registerCondition(CONDITION_NAME$d, condition$d, {
  name: FILTERS_CONDITIONS_BEGINS_WITH,
  inputsCount: 1,
  showOperators: true
});

function _slicedToArray$C(arr, i) {
  return _arrayWithHoles$E(arr) || _iterableToArrayLimit$C(arr, i) || _unsupportedIterableToArray$S(arr, i) || _nonIterableRest$E();
}
function _nonIterableRest$E() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$S(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$S(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$S(o, minLen);
}
function _arrayLikeToArray$S(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$C(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$E(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$e = "ends_with";
function condition$e(dataRow, _ref) {
  var _ref2 = _slicedToArray$C(_ref, 1), value = _ref2[0];
  return stringify(dataRow.value).toLowerCase().endsWith(stringify(value));
}
registerCondition(CONDITION_NAME$e, condition$e, {
  name: FILTERS_CONDITIONS_ENDS_WITH,
  inputsCount: 1,
  showOperators: true
});

function _slicedToArray$D(arr, i) {
  return _arrayWithHoles$F(arr) || _iterableToArrayLimit$D(arr, i) || _unsupportedIterableToArray$T(arr, i) || _nonIterableRest$F();
}
function _nonIterableRest$F() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$T(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$T(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$T(o, minLen);
}
function _arrayLikeToArray$T(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$D(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$F(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$f = "contains";
function condition$f(dataRow, _ref) {
  var _ref2 = _slicedToArray$D(_ref, 1), value = _ref2[0];
  return stringify(dataRow.value).toLowerCase().indexOf(stringify(value)) >= 0;
}
registerCondition(CONDITION_NAME$f, condition$f, {
  name: FILTERS_CONDITIONS_CONTAINS,
  inputsCount: 1,
  showOperators: true
});

var CONDITION_NAME$g = "not_contains";
function condition$g(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME$f, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME$g, condition$g, {
  name: FILTERS_CONDITIONS_NOT_CONTAIN,
  inputsCount: 1,
  showOperators: true
});

var CONDITION_NAME$h = "date_tomorrow";
function condition$h(dataRow) {
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(hooks().subtract(-1, "days").startOf("day"), "d");
}
registerCondition(CONDITION_NAME$h, condition$h, {
  name: FILTERS_CONDITIONS_TOMORROW,
  inputsCount: 0
});

var CONDITION_NAME$i = "date_today";
function condition$i(dataRow) {
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(hooks().startOf("day"), "d");
}
registerCondition(CONDITION_NAME$i, condition$i, {
  name: FILTERS_CONDITIONS_TODAY,
  inputsCount: 0
});

var CONDITION_NAME$j = "date_yesterday";
function condition$j(dataRow) {
  var date = hooks(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(hooks().subtract(1, "days").startOf("day"), "d");
}
registerCondition(CONDITION_NAME$j, condition$j, {
  name: FILTERS_CONDITIONS_YESTERDAY,
  inputsCount: 0
});

var sortCompare = getComparisonFunction();
function toVisualValue(value, defaultEmptyValue) {
  var visualValue = value;
  if (visualValue === "") {
    visualValue = "(".concat(defaultEmptyValue, ")");
  }
  return visualValue;
}
var SUPPORT_SET_CONSTRUCTOR = new Set([1]).has(1);
var SUPPORT_FAST_DEDUPE = SUPPORT_SET_CONSTRUCTOR && typeof Array.from === "function";
function createArrayAssertion(initialData) {
  var dataset = initialData;
  if (SUPPORT_SET_CONSTRUCTOR) {
    dataset = new Set(dataset);
  }
  return function(value) {
    var result;
    if (SUPPORT_SET_CONSTRUCTOR) {
      result = dataset.has(value);
    } else {
      result = !!~dataset.indexOf(value);
    }
    return result;
  };
}
function toEmptyString(value) {
  return value === null || value === void 0 ? "" : value;
}
function unifyColumnValues(values) {
  var unifiedValues = values;
  if (SUPPORT_FAST_DEDUPE) {
    unifiedValues = Array.from(new Set(unifiedValues));
  } else {
    unifiedValues = arrayUnique(unifiedValues);
  }
  unifiedValues = unifiedValues.sort(function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a - b;
    }
    if (a === b) {
      return 0;
    }
    return a > b ? 1 : -1;
  });
  return unifiedValues;
}
function intersectValues(base, selected, defaultEmptyValue, callback) {
  var result = [];
  var same = base === selected;
  var selectedItemsAssertion;
  if (!same) {
    selectedItemsAssertion = createArrayAssertion(selected);
  }
  arrayEach(base, function(value) {
    var checked = false;
    if (same || selectedItemsAssertion(value)) {
      checked = true;
    }
    var item = {
      checked,
      value,
      visualValue: toVisualValue(value, defaultEmptyValue)
    };
    if (callback) {
      callback(item);
    }
    result.push(item);
  });
  return result;
}

function _slicedToArray$E(arr, i) {
  return _arrayWithHoles$G(arr) || _iterableToArrayLimit$E(arr, i) || _unsupportedIterableToArray$U(arr, i) || _nonIterableRest$G();
}
function _nonIterableRest$G() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$U(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$U(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$U(o, minLen);
}
function _arrayLikeToArray$U(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$E(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$G(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CONDITION_NAME$k = "by_value";
function condition$k(dataRow, _ref) {
  var _ref2 = _slicedToArray$E(_ref, 1), value = _ref2[0];
  return value(dataRow.value);
}
registerCondition(CONDITION_NAME$k, condition$k, {
  name: "By value",
  inputsCount: 0,
  inputValuesDecorator: function inputValuesDecorator(_ref3) {
    var _ref4 = _slicedToArray$E(_ref3, 1), data = _ref4[0];
    return [createArrayAssertion(data)];
  },
  showOperators: false
});

var operations = {};
function getOperationFunc(id) {
  if (!operations[id]) {
    throw Error('Operation with id "'.concat(id, '" does not exist.'));
  }
  var func = operations[id].func;
  return function(conditions, value) {
    return func(conditions, value);
  };
}
function getOperationName(id) {
  return operations[id].name;
}
function registerOperation(id, name, func) {
  operations[id] = {
    name,
    func
  };
}

var OPERATION_ID = "conjunction";
var SHORT_NAME_FOR_COMPONENT = FILTERS_LABELS_CONJUNCTION;
function operationResult(conditions, value) {
  return conditions.every(function(condition) {
    return condition.func(value);
  });
}
registerOperation(OPERATION_ID, SHORT_NAME_FOR_COMPONENT, operationResult);

var OPERATION_ID$1 = "disjunction";
var SHORT_NAME_FOR_COMPONENT$1 = FILTERS_LABELS_DISJUNCTION;
function operationResult$1(conditions, value) {
  return conditions.some(function(condition) {
    return condition.func(value);
  });
}
registerOperation(OPERATION_ID$1, SHORT_NAME_FOR_COMPONENT$1, operationResult$1);

var OPERATION_ID$2 = "disjunctionWithExtraCondition";
var SHORT_NAME_FOR_COMPONENT$2 = FILTERS_LABELS_DISJUNCTION;
function operationResult$2(conditions, value) {
  if (conditions.length < 3) {
    throw Error("Operation doesn't work on less then three conditions.");
  }
  return conditions.slice(0, conditions.length - 1).some(function(condition) {
    return condition.func(value);
  }) && conditions[conditions.length - 1].func(value);
}
registerOperation(OPERATION_ID$2, SHORT_NAME_FOR_COMPONENT$2, operationResult$2);

var _TYPES;
function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var TYPE_NUMERIC = "numeric";
var TYPE_TEXT = "text";
var TYPE_DATE = "date";
var TYPES = (_TYPES = {}, _defineProperty$j(_TYPES, TYPE_NUMERIC, [CONDITION_NAME, KEY, CONDITION_NAME$1, CONDITION_NAME$2, KEY, CONDITION_NAME$3, CONDITION_NAME$4, KEY, CONDITION_NAME$5, CONDITION_NAME$6, CONDITION_NAME$7, CONDITION_NAME$8, CONDITION_NAME$b, CONDITION_NAME$c]), _defineProperty$j(_TYPES, TYPE_TEXT, [CONDITION_NAME, KEY, CONDITION_NAME$1, CONDITION_NAME$2, KEY, CONDITION_NAME$3, CONDITION_NAME$4, KEY, CONDITION_NAME$d, CONDITION_NAME$e, KEY, CONDITION_NAME$f, CONDITION_NAME$g]), _defineProperty$j(_TYPES, TYPE_DATE, [CONDITION_NAME, KEY, CONDITION_NAME$1, CONDITION_NAME$2, KEY, CONDITION_NAME$3, CONDITION_NAME$4, KEY, CONDITION_NAME$a, CONDITION_NAME$9, CONDITION_NAME$b, KEY, CONDITION_NAME$h, CONDITION_NAME$i, CONDITION_NAME$j]), _TYPES);
function getOptionsList(type) {
  var items = [];
  var typeName = type;
  if (!TYPES[typeName]) {
    typeName = TYPE_TEXT;
  }
  arrayEach(TYPES[typeName], function(typeValue) {
    var option;
    if (typeValue === KEY) {
      option = {
        name: KEY
      };
    } else {
      option = clone(getConditionDescriptor(typeValue));
    }
    items.push(option);
  });
  return items;
}

function _classCallCheck$29(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$23(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$23(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$23(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$23(Constructor, staticProps);
  return Constructor;
}
var STATE_BUILT$2 = "built";
var STATE_BUILDING = "building";
var EVENTS_TO_REGISTER = ["click", "input", "keydown", "keypress", "keyup", "focus", "blur", "change"];
var BaseUI$2 = /* @__PURE__ */ function() {
  function BaseUI2(hotInstance, options) {
    _classCallCheck$29(this, BaseUI2);
    this.hot = hotInstance;
    this.eventManager = new EventManager(this);
    this.options = extend(BaseUI2.DEFAULTS, options);
    this._element = this.hot.rootDocument.createElement(this.options.wrapIt ? "div" : this.options.tagName);
    this.buildState = false;
  }
  _createClass$23(BaseUI2, [{
    key: "setValue",
    value: function setValue(value) {
      this.options.value = value;
      this.update();
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
  }, {
    key: "element",
    get: function get() {
      if (this.buildState === STATE_BUILDING) {
        return this._element;
      }
      if (this.buildState === STATE_BUILT$2) {
        this.update();
        return this._element;
      }
      this.buildState = STATE_BUILDING;
      this.build();
      this.buildState = STATE_BUILT$2;
      return this._element;
    }
  }, {
    key: "isBuilt",
    value: function isBuilt() {
      return this.buildState === STATE_BUILT$2;
    }
  }, {
    key: "translateIfPossible",
    value: function translateIfPossible(value) {
      if (typeof value === "string" && value.startsWith(FILTERS_NAMESPACE)) {
        return this.hot.getTranslatedPhrase(value);
      }
      return value;
    }
  }, {
    key: "build",
    value: function build() {
      var _this = this;
      var registerEvent = function registerEvent2(element2, eventName) {
        _this.eventManager.addEventListener(element2, eventName, function(event) {
          return _this.runLocalHooks(eventName, event, _this);
        });
      };
      if (!this.buildState) {
        this.buildState = STATE_BUILDING;
      }
      if (this.options.className) {
        addClass(this._element, this.options.className);
      }
      if (this.options.children.length) {
        arrayEach(this.options.children, function(element2) {
          return _this._element.appendChild(element2.element);
        });
      } else if (this.options.wrapIt) {
        var element = this.hot.rootDocument.createElement(this.options.tagName);
        objectEach(this.options, function(value, key) {
          if (element[key] !== void 0 && key !== "className" && key !== "tagName" && key !== "children") {
            element[key] = _this.translateIfPossible(value);
          }
        });
        this._element.appendChild(element);
        arrayEach(EVENTS_TO_REGISTER, function(eventName) {
          return registerEvent(element, eventName);
        });
      } else {
        arrayEach(EVENTS_TO_REGISTER, function(eventName) {
          return registerEvent(_this._element, eventName);
        });
      }
    }
  }, {
    key: "update",
    value: function update() {
    }
  }, {
    key: "reset",
    value: function reset() {
      this.options.value = "";
      this.update();
    }
  }, {
    key: "show",
    value: function show() {
      this.element.style.display = "";
    }
  }, {
    key: "hide",
    value: function hide() {
      this.element.style.display = "none";
    }
  }, {
    key: "focus",
    value: function focus() {
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.eventManager.destroy();
      this.eventManager = null;
      this.hot = null;
      if (this._element.parentNode) {
        this._element.parentNode.removeChild(this._element);
      }
      this._element = null;
    }
  }], [{
    key: "DEFAULTS",
    get: function get() {
      return clone({
        className: "",
        value: "",
        tagName: "div",
        children: [],
        wrapIt: true
      });
    }
  }]);
  return BaseUI2;
}();
mixin(BaseUI$2, localHooks);

function _typeof$1e(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1e = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1e = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1e(obj);
}
function _classCallCheck$2a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$24(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$24(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$24(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$24(Constructor, staticProps);
  return Constructor;
}
function _get$E(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$E = Reflect.get;
  } else {
    _get$E = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$E(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$E(target, property, receiver || target);
}
function _superPropBase$E(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$12(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$12(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$13(subClass, superClass);
}
function _setPrototypeOf$13(o, p) {
  _setPrototypeOf$13 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$13(o, p);
}
function _createSuper$12(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$13();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$12(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$12(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$12(this, result);
  };
}
function _possibleConstructorReturn$12(self, call) {
  if (call && (_typeof$1e(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$12(self);
}
function _assertThisInitialized$12(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$13() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$12(o) {
  _getPrototypeOf$12 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$12(o);
}
var privatePool$f = new WeakMap();
var InputUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$12(InputUI2, _BaseUI);
  var _super = _createSuper$12(InputUI2);
  function InputUI2(hotInstance, options) {
    var _this;
    _classCallCheck$2a(this, InputUI2);
    _this = _super.call(this, hotInstance, extend(InputUI2.DEFAULTS, options));
    privatePool$f.set(_assertThisInitialized$12(_this), {});
    _this.registerHooks();
    return _this;
  }
  _createClass$24(InputUI2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.addLocalHook("click", function() {
        return _this2.onClick();
      });
      this.addLocalHook("keyup", function(event) {
        return _this2.onKeyup(event);
      });
    }
  }, {
    key: "build",
    value: function build() {
      _get$E(_getPrototypeOf$12(InputUI2.prototype), "build", this).call(this);
      var priv = privatePool$f.get(this);
      var icon = this.hot.rootDocument.createElement("div");
      priv.input = this._element.firstChild;
      addClass(this._element, "htUIInput");
      addClass(icon, "htUIInputIcon");
      this._element.appendChild(icon);
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      var input = privatePool$f.get(this).input;
      input.type = this.options.type;
      input.placeholder = this.translateIfPossible(this.options.placeholder);
      input.value = this.translateIfPossible(this.options.value);
    }
  }, {
    key: "focus",
    value: function focus() {
      if (this.isBuilt()) {
        privatePool$f.get(this).input.focus();
      }
    }
  }, {
    key: "onClick",
    value: function onClick() {
    }
  }, {
    key: "onKeyup",
    value: function onKeyup(event) {
      this.options.value = event.target.value;
    }
  }], [{
    key: "DEFAULTS",
    get: function get() {
      return clone({
        placeholder: "",
        type: "text",
        tagName: "input"
      });
    }
  }]);
  return InputUI2;
}(BaseUI$2);

function _typeof$1f(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1f = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1f = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1f(obj);
}
function _classCallCheck$2b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$25(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$25(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$25(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$25(Constructor, staticProps);
  return Constructor;
}
function _get$F(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$F = Reflect.get;
  } else {
    _get$F = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$F(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$F(target, property, receiver || target);
}
function _superPropBase$F(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$13(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$13(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$14(subClass, superClass);
}
function _setPrototypeOf$14(o, p) {
  _setPrototypeOf$14 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$14(o, p);
}
function _createSuper$13(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$14();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$13(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$13(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$13(this, result);
  };
}
function _possibleConstructorReturn$13(self, call) {
  if (call && (_typeof$1f(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$13(self);
}
function _assertThisInitialized$13(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$14() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$13(o) {
  _getPrototypeOf$13 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$13(o);
}
var privatePool$g = new WeakMap();
var SelectUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$13(SelectUI2, _BaseUI);
  var _super = _createSuper$13(SelectUI2);
  function SelectUI2(hotInstance, options) {
    var _this;
    _classCallCheck$2b(this, SelectUI2);
    _this = _super.call(this, hotInstance, extend(SelectUI2.DEFAULTS, options));
    privatePool$g.set(_assertThisInitialized$13(_this), {});
    _this.menu = null;
    _this.items = [];
    _this.registerHooks();
    return _this;
  }
  _createClass$25(SelectUI2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.addLocalHook("click", function() {
        return _this2.onClick();
      });
    }
  }, {
    key: "setItems",
    value: function setItems(items) {
      this.items = this.translateNames(items);
      if (this.menu) {
        this.menu.setMenuItems(this.items);
      }
    }
  }, {
    key: "translateNames",
    value: function translateNames(items) {
      var _this3 = this;
      arrayEach(items, function(item) {
        item.name = _this3.translateIfPossible(item.name);
      });
      return items;
    }
  }, {
    key: "build",
    value: function build() {
      var _this4 = this;
      _get$F(_getPrototypeOf$13(SelectUI2.prototype), "build", this).call(this);
      this.menu = new Menu(this.hot, {
        className: "htSelectUI htFiltersConditionsMenu",
        keepInViewport: false,
        standalone: true,
        container: this.options.menuContainer
      });
      this.menu.setMenuItems(this.items);
      var caption = new BaseUI$2(this.hot, {
        className: "htUISelectCaption"
      });
      var dropdown = new BaseUI$2(this.hot, {
        className: "htUISelectDropdown"
      });
      var priv = privatePool$g.get(this);
      priv.caption = caption;
      priv.captionElement = caption.element;
      priv.dropdown = dropdown;
      arrayEach([caption, dropdown], function(element) {
        return _this4._element.appendChild(element.element);
      });
      this.menu.addLocalHook("select", function(command) {
        return _this4.onMenuSelect(command);
      });
      this.menu.addLocalHook("afterClose", function() {
        return _this4.onMenuClosed();
      });
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      var conditionName;
      if (this.options.value) {
        conditionName = this.options.value.name;
      } else {
        conditionName = this.menu.hot.getTranslatedPhrase(FILTERS_CONDITIONS_NONE);
      }
      privatePool$g.get(this).captionElement.textContent = conditionName;
      _get$F(_getPrototypeOf$13(SelectUI2.prototype), "update", this).call(this);
    }
  }, {
    key: "openOptions",
    value: function openOptions() {
      var rect = this.element.getBoundingClientRect();
      if (this.menu) {
        this.menu.open();
        this.menu.setPosition({
          left: rect.left - 5,
          top: rect.top - 1,
          width: rect.width,
          height: rect.height
        });
      }
    }
  }, {
    key: "closeOptions",
    value: function closeOptions() {
      if (this.menu) {
        this.menu.close();
      }
    }
  }, {
    key: "onMenuSelect",
    value: function onMenuSelect(command) {
      if (command.name !== KEY) {
        this.options.value = command;
        this.update();
        this.runLocalHooks("select", this.options.value);
      }
    }
  }, {
    key: "onMenuClosed",
    value: function onMenuClosed() {
      this.runLocalHooks("afterClose");
    }
  }, {
    key: "onClick",
    value: function onClick() {
      this.openOptions();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.menu) {
        this.menu.destroy();
        this.menu = null;
      }
      var _privatePool$get = privatePool$g.get(this), caption = _privatePool$get.caption, dropdown = _privatePool$get.dropdown;
      if (caption) {
        caption.destroy();
      }
      if (dropdown) {
        dropdown.destroy();
      }
      _get$F(_getPrototypeOf$13(SelectUI2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "DEFAULTS",
    get: function get() {
      return clone({
        className: "htUISelect",
        wrapIt: false
      });
    }
  }]);
  return SelectUI2;
}(BaseUI$2);

function _typeof$1g(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1g = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1g = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1g(obj);
}
function _toConsumableArray$p(arr) {
  return _arrayWithoutHoles$n(arr) || _iterableToArray$p(arr) || _unsupportedIterableToArray$V(arr) || _nonIterableSpread$n();
}
function _nonIterableSpread$n() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$V(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$V(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$V(o, minLen);
}
function _iterableToArray$p(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$n(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$V(arr);
}
function _arrayLikeToArray$V(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$2c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$26(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$26(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$26(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$26(Constructor, staticProps);
  return Constructor;
}
function _get$G(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$G = Reflect.get;
  } else {
    _get$G = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$G(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$G(target, property, receiver || target);
}
function _superPropBase$G(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$14(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$14(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$15(subClass, superClass);
}
function _setPrototypeOf$15(o, p) {
  _setPrototypeOf$15 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$15(o, p);
}
function _createSuper$14(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$15();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$14(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$14(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$14(this, result);
  };
}
function _possibleConstructorReturn$14(self, call) {
  if (call && (_typeof$1g(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$14(self);
}
function _assertThisInitialized$14(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$15() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$14(o) {
  _getPrototypeOf$14 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$14(o);
}
var ConditionComponent = /* @__PURE__ */ function(_BaseComponent) {
  _inherits$14(ConditionComponent2, _BaseComponent);
  var _super = _createSuper$14(ConditionComponent2);
  function ConditionComponent2(hotInstance, options) {
    var _this;
    _classCallCheck$2c(this, ConditionComponent2);
    _this = _super.call(this, hotInstance, {
      id: options.id,
      stateless: false
    });
    _this.name = options.name;
    _this.addSeparator = options.addSeparator;
    _this.elements.push(new SelectUI(_this.hot, {
      menuContainer: options.menuContainer
    }));
    _this.elements.push(new InputUI(_this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_VALUE
    }));
    _this.elements.push(new InputUI(_this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE
    }));
    _this.registerHooks();
    return _this;
  }
  _createClass$26(ConditionComponent2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.getSelectElement().addLocalHook("select", function(command) {
        return _this2.onConditionSelect(command);
      });
      this.getSelectElement().addLocalHook("afterClose", function() {
        return _this2.onSelectUIClosed();
      });
      arrayEach(this.getInputElements(), function(input) {
        input.addLocalHook("keydown", function(event) {
          return _this2.onInputKeyDown(event);
        });
      });
    }
  }, {
    key: "setState",
    value: function setState(value) {
      var _this3 = this;
      this.reset();
      if (!value) {
        return;
      }
      var copyOfCommand = clone(value.command);
      if (copyOfCommand.name.startsWith(FILTERS_CONDITIONS_NAMESPACE)) {
        copyOfCommand.name = this.hot.getTranslatedPhrase(copyOfCommand.name);
      }
      this.getSelectElement().setValue(copyOfCommand);
      arrayEach(value.args, function(arg, index) {
        if (index > copyOfCommand.inputsCount - 1) {
          return false;
        }
        var element = _this3.getInputElement(index);
        element.setValue(arg);
        element[copyOfCommand.inputsCount > index ? "show" : "hide"]();
        if (!index) {
          setTimeout(function() {
            return element.focus();
          }, 10);
        }
      });
    }
  }, {
    key: "getState",
    value: function getState() {
      var command = this.getSelectElement().getValue() || getConditionDescriptor(CONDITION_NAME);
      var args = [];
      arrayEach(this.getInputElements(), function(element, index) {
        if (command.inputsCount > index) {
          args.push(element.getValue());
        }
      });
      return {
        command,
        args
      };
    }
  }, {
    key: "updateState",
    value: function updateState(condition, column) {
      var command = condition ? getConditionDescriptor(condition.name) : getConditionDescriptor(CONDITION_NAME);
      this.state.setValueAtIndex(column, {
        command,
        args: condition ? condition.args : []
      });
      if (!condition) {
        arrayEach(this.getInputElements(), function(element) {
          return element.setValue(null);
        });
      }
    }
  }, {
    key: "getSelectElement",
    value: function getSelectElement() {
      return this.elements.filter(function(element) {
        return element instanceof SelectUI;
      })[0];
    }
  }, {
    key: "getInputElement",
    value: function getInputElement() {
      var index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return this.getInputElements()[index];
    }
  }, {
    key: "getInputElements",
    value: function getInputElements() {
      return this.elements.filter(function(element) {
        return element instanceof InputUI;
      });
    }
  }, {
    key: "getMenuItemDescriptor",
    value: function getMenuItemDescriptor() {
      var _this4 = this;
      return {
        key: this.id,
        name: this.name,
        isCommand: false,
        disableSelection: true,
        hidden: function hidden() {
          return _this4.isHidden();
        },
        renderer: function renderer(hot, wrapper, row, col, prop, value) {
          addClass(wrapper.parentNode, "htFiltersMenuCondition");
          if (_this4.addSeparator) {
            addClass(wrapper.parentNode, "border");
          }
          var label = _this4.hot.rootDocument.createElement("div");
          addClass(label, "htFiltersMenuLabel");
          label.textContent = value;
          wrapper.appendChild(label);
          if (!wrapper.parentNode.hasAttribute("ghost-table")) {
            arrayEach(_this4.elements, function(ui) {
              return wrapper.appendChild(ui.element);
            });
          }
          return wrapper;
        }
      };
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this$hot;
      var lastSelectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
      var visualIndex = lastSelectedColumn && lastSelectedColumn.visualIndex;
      var columnType = (_this$hot = this.hot).getDataType.apply(_this$hot, _toConsumableArray$p(this.hot.getSelectedLast() || [0, visualIndex]));
      var items = getOptionsList(columnType);
      arrayEach(this.getInputElements(), function(element) {
        return element.hide();
      });
      this.getSelectElement().setItems(items);
      _get$G(_getPrototypeOf$14(ConditionComponent2.prototype), "reset", this).call(this);
      this.getSelectElement().setValue(items[0]);
    }
  }, {
    key: "onConditionSelect",
    value: function onConditionSelect(command) {
      arrayEach(this.getInputElements(), function(element, index) {
        element[command.inputsCount > index ? "show" : "hide"]();
        if (index === 0) {
          setTimeout(function() {
            return element.focus();
          }, 10);
        }
      });
      this.runLocalHooks("change", command);
    }
  }, {
    key: "onSelectUIClosed",
    value: function onSelectUIClosed() {
      this.runLocalHooks("afterClose");
    }
  }, {
    key: "onInputKeyDown",
    value: function onInputKeyDown(event) {
      if (isKey(event.keyCode, "ENTER")) {
        this.runLocalHooks("accept");
        stopImmediatePropagation(event);
      } else if (isKey(event.keyCode, "ESCAPE")) {
        this.runLocalHooks("cancel");
        stopImmediatePropagation(event);
      }
    }
  }]);
  return ConditionComponent2;
}(BaseComponent);

function _typeof$1h(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1h = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1h = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1h(obj);
}
function _classCallCheck$2d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$27(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$27(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$27(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$27(Constructor, staticProps);
  return Constructor;
}
function _get$H(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$H = Reflect.get;
  } else {
    _get$H = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$H(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$H(target, property, receiver || target);
}
function _superPropBase$H(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$15(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$15(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$16(subClass, superClass);
}
function _setPrototypeOf$16(o, p) {
  _setPrototypeOf$16 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$16(o, p);
}
function _createSuper$15(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$16();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$15(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$15(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$15(this, result);
  };
}
function _possibleConstructorReturn$15(self, call) {
  if (call && (_typeof$1h(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$15(self);
}
function _assertThisInitialized$15(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$16() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$15(o) {
  _getPrototypeOf$15 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$15(o);
}
var privatePool$h = new WeakMap();
var RadioInputUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$15(RadioInputUI2, _BaseUI);
  var _super = _createSuper$15(RadioInputUI2);
  function RadioInputUI2(hotInstance, options) {
    var _this;
    _classCallCheck$2d(this, RadioInputUI2);
    _this = _super.call(this, hotInstance, extend(RadioInputUI2.DEFAULTS, options));
    privatePool$h.set(_assertThisInitialized$15(_this), {});
    return _this;
  }
  _createClass$27(RadioInputUI2, [{
    key: "build",
    value: function build() {
      _get$H(_getPrototypeOf$15(RadioInputUI2.prototype), "build", this).call(this);
      var priv = privatePool$h.get(this);
      priv.input = this._element.firstChild;
      var label = this.hot.rootDocument.createElement("label");
      label.textContent = this.translateIfPossible(this.options.label.textContent);
      label.htmlFor = this.translateIfPossible(this.options.label.htmlFor);
      priv.label = label;
      this._element.appendChild(label);
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      var priv = privatePool$h.get(this);
      priv.input.checked = this.options.checked;
      priv.label.textContent = this.translateIfPossible(this.options.label.textContent);
    }
  }, {
    key: "isChecked",
    value: function isChecked() {
      return this.options.checked;
    }
  }, {
    key: "setChecked",
    value: function setChecked() {
      var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.options.checked = value;
      this.update();
    }
  }, {
    key: "focus",
    value: function focus() {
      if (this.isBuilt()) {
        privatePool$h.get(this).input.focus();
      }
    }
  }], [{
    key: "DEFAULTS",
    get: function get() {
      return clone({
        type: "radio",
        tagName: "input",
        className: "htUIRadio",
        label: {}
      });
    }
  }]);
  return RadioInputUI2;
}(BaseUI$2);

function _typeof$1i(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1i = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1i = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1i(obj);
}
var _templateObject$9;
function _taggedTemplateLiteral$9(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _classCallCheck$2e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$28(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$28(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$28(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$28(Constructor, staticProps);
  return Constructor;
}
function _inherits$16(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$17(subClass, superClass);
}
function _setPrototypeOf$17(o, p) {
  _setPrototypeOf$17 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$17(o, p);
}
function _createSuper$16(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$17();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$16(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$16(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$16(this, result);
  };
}
function _possibleConstructorReturn$16(self, call) {
  if (call && (_typeof$1i(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$16(self);
}
function _assertThisInitialized$16(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$17() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$16(o) {
  _getPrototypeOf$16 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$16(o);
}
var SELECTED_AT_START_ELEMENT_INDEX = 0;
var OperatorsComponent = /* @__PURE__ */ function(_BaseComponent) {
  _inherits$16(OperatorsComponent2, _BaseComponent);
  var _super = _createSuper$16(OperatorsComponent2);
  function OperatorsComponent2(hotInstance, options) {
    var _this;
    _classCallCheck$2e(this, OperatorsComponent2);
    _this = _super.call(this, hotInstance, {
      id: options.id,
      stateless: false
    });
    _this.name = options.name;
    _this.buildOperatorsElement();
    return _this;
  }
  _createClass$28(OperatorsComponent2, [{
    key: "getMenuItemDescriptor",
    value: function getMenuItemDescriptor() {
      var _this2 = this;
      return {
        key: this.id,
        name: this.name,
        isCommand: false,
        disableSelection: true,
        hidden: function hidden() {
          return _this2.isHidden();
        },
        renderer: function renderer(hot, wrapper) {
          addClass(wrapper.parentNode, "htFiltersMenuOperators");
          if (!wrapper.parentNode.hasAttribute("ghost-table")) {
            arrayEach(_this2.elements, function(ui) {
              return wrapper.appendChild(ui.element);
            });
          }
          return wrapper;
        }
      };
    }
  }, {
    key: "buildOperatorsElement",
    value: function buildOperatorsElement() {
      var _this3 = this;
      var operationKeys = [OPERATION_ID, OPERATION_ID$1];
      arrayEach(operationKeys, function(operation) {
        var radioInput = new RadioInputUI(_this3.hot, {
          name: "operator",
          label: {
            htmlFor: operation,
            textContent: getOperationName(operation)
          },
          value: operation,
          checked: operation === operationKeys[SELECTED_AT_START_ELEMENT_INDEX],
          id: operation
        });
        radioInput.addLocalHook("change", function(event) {
          return _this3.onRadioInputChange(event);
        });
        _this3.elements.push(radioInput);
      });
    }
  }, {
    key: "setChecked",
    value: function setChecked(searchedIndex) {
      if (this.elements.length < searchedIndex) {
        throw Error(toSingleLine(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteral$9(["Radio button with index ", " doesn't exist."])), searchedIndex));
      }
      arrayEach(this.elements, function(element, index) {
        element.setChecked(index === searchedIndex);
      });
    }
  }, {
    key: "getActiveOperationId",
    value: function getActiveOperationId() {
      var operationElement = this.elements.find(function(element) {
        return element instanceof RadioInputUI && element.isChecked();
      });
      if (operationElement) {
        return operationElement.getValue();
      }
      return OPERATION_ID;
    }
  }, {
    key: "getState",
    value: function getState() {
      return this.getActiveOperationId();
    }
  }, {
    key: "setState",
    value: function setState(value) {
      this.reset();
      if (value && this.getActiveOperationId() !== value) {
        arrayEach(this.elements, function(element) {
          element.setChecked(element.getValue() === value);
        });
      }
    }
  }, {
    key: "updateState",
    value: function updateState() {
      var operationId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OPERATION_ID;
      var column = arguments.length > 1 ? arguments[1] : void 0;
      var selectedOperationId = operationId;
      if (selectedOperationId === OPERATION_ID$2) {
        selectedOperationId = OPERATION_ID$1;
      }
      this.state.setValueAtIndex(column, selectedOperationId);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.setChecked(SELECTED_AT_START_ELEMENT_INDEX);
    }
  }, {
    key: "onRadioInputChange",
    value: function onRadioInputChange(event) {
      this.setState(event.target.value);
    }
  }]);
  return OperatorsComponent2;
}(BaseComponent);

var quot = /"/g;

// `CreateHTML` abstract operation
// https://tc39.es/ecma262/#sec-createhtml
var createHtml = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
var stringHtmlForced = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};

// `String.prototype.link` method
// https://tc39.es/ecma262/#sec-string.prototype.link
_export({ target: 'String', proto: true, forced: stringHtmlForced('link') }, {
  link: function link(url) {
    return createHtml(this, 'a', 'href', url);
  }
});

function _typeof$1j(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1j = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1j = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1j(obj);
}
function _classCallCheck$2f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$29(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$29(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$29(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$29(Constructor, staticProps);
  return Constructor;
}
function _get$I(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$I = Reflect.get;
  } else {
    _get$I = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$I(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$I(target, property, receiver || target);
}
function _superPropBase$I(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$17(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$17(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$18(subClass, superClass);
}
function _setPrototypeOf$18(o, p) {
  _setPrototypeOf$18 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$18(o, p);
}
function _createSuper$17(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$18();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$17(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$17(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$17(this, result);
  };
}
function _possibleConstructorReturn$17(self, call) {
  if (call && (_typeof$1j(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$17(self);
}
function _assertThisInitialized$17(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$18() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$17(o) {
  _getPrototypeOf$17 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$17(o);
}
var privatePool$i = new WeakMap();
var LinkUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$17(LinkUI2, _BaseUI);
  var _super = _createSuper$17(LinkUI2);
  function LinkUI2(hotInstance, options) {
    var _this;
    _classCallCheck$2f(this, LinkUI2);
    _this = _super.call(this, hotInstance, extend(LinkUI2.DEFAULTS, options));
    privatePool$i.set(_assertThisInitialized$17(_this), {});
    return _this;
  }
  _createClass$29(LinkUI2, [{
    key: "build",
    value: function build() {
      _get$I(_getPrototypeOf$17(LinkUI2.prototype), "build", this).call(this);
      var priv = privatePool$i.get(this);
      priv.link = this._element.firstChild;
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      privatePool$i.get(this).link.textContent = this.translateIfPossible(this.options.textContent);
    }
  }], [{
    key: "DEFAULTS",
    get: function get() {
      return clone({
        href: "#",
        tagName: "a"
      });
    }
  }]);
  return LinkUI2;
}(BaseUI$2);

function _typeof$1k(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1k = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1k = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1k(obj);
}
function _toConsumableArray$q(arr) {
  return _arrayWithoutHoles$o(arr) || _iterableToArray$q(arr) || _unsupportedIterableToArray$W(arr) || _nonIterableSpread$o();
}
function _nonIterableSpread$o() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$W(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$W(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$W(o, minLen);
}
function _iterableToArray$q(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$o(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$W(arr);
}
function _arrayLikeToArray$W(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$2g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2a(Constructor, staticProps);
  return Constructor;
}
function _get$J(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$J = Reflect.get;
  } else {
    _get$J = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$J(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$J(target, property, receiver || target);
}
function _superPropBase$J(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$18(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$18(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$19(subClass, superClass);
}
function _setPrototypeOf$19(o, p) {
  _setPrototypeOf$19 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$19(o, p);
}
function _createSuper$18(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$19();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$18(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$18(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$18(this, result);
  };
}
function _possibleConstructorReturn$18(self, call) {
  if (call && (_typeof$1k(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$18(self);
}
function _assertThisInitialized$18(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$19() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$18(o) {
  _getPrototypeOf$18 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$18(o);
}
var privatePool$j = new WeakMap();
var MultipleSelectUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$18(MultipleSelectUI2, _BaseUI);
  var _super = _createSuper$18(MultipleSelectUI2);
  function MultipleSelectUI2(hotInstance, options) {
    var _this;
    _classCallCheck$2g(this, MultipleSelectUI2);
    _this = _super.call(this, hotInstance, extend(MultipleSelectUI2.DEFAULTS, options));
    privatePool$j.set(_assertThisInitialized$18(_this), {});
    _this.searchInput = new InputUI(_this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_SEARCH,
      className: "htUIMultipleSelectSearch"
    });
    _this.selectAllUI = new LinkUI(_this.hot, {
      textContent: FILTERS_BUTTONS_SELECT_ALL,
      className: "htUISelectAll"
    });
    _this.clearAllUI = new LinkUI(_this.hot, {
      textContent: FILTERS_BUTTONS_CLEAR,
      className: "htUIClearAll"
    });
    _this.items = [];
    _this.itemsBox = null;
    _this.registerHooks();
    return _this;
  }
  _createClass$2a(MultipleSelectUI2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.searchInput.addLocalHook("keydown", function(event) {
        return _this2.onInputKeyDown(event);
      });
      this.searchInput.addLocalHook("input", function(event) {
        return _this2.onInput(event);
      });
      this.selectAllUI.addLocalHook("click", function(event) {
        return _this2.onSelectAllClick(event);
      });
      this.clearAllUI.addLocalHook("click", function(event) {
        return _this2.onClearAllClick(event);
      });
    }
  }, {
    key: "setItems",
    value: function setItems(items) {
      this.items = items;
      if (this.itemsBox) {
        this.itemsBox.loadData(this.items);
      }
    }
  }, {
    key: "getItems",
    value: function getItems() {
      return _toConsumableArray$q(this.items);
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return itemsToValue(this.items);
    }
  }, {
    key: "isSelectedAllValues",
    value: function isSelectedAllValues() {
      return this.items.length === this.getValue().length;
    }
  }, {
    key: "build",
    value: function build() {
      var _this3 = this;
      _get$J(_getPrototypeOf$18(MultipleSelectUI2.prototype), "build", this).call(this);
      var rootDocument = this.hot.rootDocument;
      var itemsBoxWrapper = rootDocument.createElement("div");
      var selectionControl = new BaseUI$2(this.hot, {
        className: "htUISelectionControls",
        children: [this.selectAllUI, this.clearAllUI]
      });
      this._element.appendChild(this.searchInput.element);
      this._element.appendChild(selectionControl.element);
      this._element.appendChild(itemsBoxWrapper);
      var hotInitializer = function hotInitializer2(wrapper) {
        if (!_this3._element) {
          return;
        }
        if (_this3.itemsBox) {
          _this3.itemsBox.destroy();
        }
        addClass(wrapper, "htUIMultipleSelectHot");
        _this3.itemsBox = new _this3.hot.constructor(wrapper, {
          data: _this3.items,
          columns: [{
            data: "checked",
            type: "checkbox",
            label: {
              property: "visualValue",
              position: "after"
            }
          }],
          beforeRenderer: function beforeRenderer(TD, row, col, prop, value, cellProperties) {
            TD.title = cellProperties.instance.getDataAtRowProp(row, cellProperties.label.property);
          },
          maxCols: 1,
          autoWrapCol: true,
          height: 110,
          colWidths: function colWidths() {
            return _this3.itemsBox.container.scrollWidth - getScrollbarWidth(rootDocument);
          },
          copyPaste: false,
          disableVisualSelection: "area",
          fillHandle: false,
          fragmentSelection: "cell",
          tabMoves: {
            row: 1,
            col: 0
          },
          beforeKeyDown: function beforeKeyDown(event) {
            return _this3.onItemsBoxBeforeKeyDown(event);
          }
        });
        _this3.itemsBox.init();
      };
      hotInitializer(itemsBoxWrapper);
      setTimeout(function() {
        return hotInitializer(itemsBoxWrapper);
      }, 100);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.searchInput.reset();
      this.selectAllUI.reset();
      this.clearAllUI.reset();
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.isBuilt()) {
        return;
      }
      this.itemsBox.loadData(valueToItems(this.items, this.options.value));
      _get$J(_getPrototypeOf$18(MultipleSelectUI2.prototype), "update", this).call(this);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.itemsBox) {
        this.itemsBox.destroy();
      }
      this.searchInput.destroy();
      this.clearAllUI.destroy();
      this.selectAllUI.destroy();
      this.searchInput = null;
      this.clearAllUI = null;
      this.selectAllUI = null;
      this.itemsBox = null;
      this.items = null;
      _get$J(_getPrototypeOf$18(MultipleSelectUI2.prototype), "destroy", this).call(this);
    }
  }, {
    key: "onInput",
    value: function onInput(event) {
      var value = event.target.value.toLowerCase();
      var filteredItems;
      if (value === "") {
        filteredItems = _toConsumableArray$q(this.items);
      } else {
        filteredItems = arrayFilter(this.items, function(item) {
          return "".concat(item.value).toLowerCase().indexOf(value) >= 0;
        });
      }
      this.itemsBox.loadData(filteredItems);
    }
  }, {
    key: "onInputKeyDown",
    value: function onInputKeyDown(event) {
      this.runLocalHooks("keydown", event, this);
      var isKeyCode = partial(isKey, event.keyCode);
      if (isKeyCode("ARROW_DOWN|TAB") && !this.itemsBox.isListening()) {
        stopImmediatePropagation(event);
        this.itemsBox.listen();
        this.itemsBox.selectCell(0, 0);
      }
    }
  }, {
    key: "onItemsBoxBeforeKeyDown",
    value: function onItemsBoxBeforeKeyDown(event) {
      var isKeyCode = partial(isKey, event.keyCode);
      if (isKeyCode("ESCAPE")) {
        this.runLocalHooks("keydown", event, this);
      }
      if (!isKeyCode("ARROW_UP|ARROW_DOWN|ARROW_LEFT|ARROW_RIGHT|TAB|SPACE|ENTER")) {
        stopImmediatePropagation(event);
        this.itemsBox.unlisten();
        this.itemsBox.deselectCell();
        this.searchInput.focus();
      }
    }
  }, {
    key: "onSelectAllClick",
    value: function onSelectAllClick(event) {
      var changes = [];
      event.preventDefault();
      arrayEach(this.itemsBox.getSourceData(), function(row, rowIndex) {
        row.checked = true;
        changes.push(dataRowToChangesArray(row, rowIndex)[0]);
      });
      this.itemsBox.setSourceDataAtCell(changes);
    }
  }, {
    key: "onClearAllClick",
    value: function onClearAllClick(event) {
      var changes = [];
      event.preventDefault();
      arrayEach(this.itemsBox.getSourceData(), function(row, rowIndex) {
        row.checked = false;
        changes.push(dataRowToChangesArray(row, rowIndex)[0]);
      });
      this.itemsBox.setSourceDataAtCell(changes);
    }
  }], [{
    key: "DEFAULTS",
    get: function get() {
      return clone({
        className: "htUIMultipleSelect",
        value: []
      });
    }
  }]);
  return MultipleSelectUI2;
}(BaseUI$2);
function valueToItems(availableItems, selectedValue) {
  var arrayAssertion = createArrayAssertion(selectedValue);
  return arrayMap(availableItems, function(item) {
    item.checked = arrayAssertion(item.value);
    return item;
  });
}
function itemsToValue(availableItems) {
  var items = [];
  arrayEach(availableItems, function(item) {
    if (item.checked) {
      items.push(item.value);
    }
  });
  return items;
}

function _typeof$1l(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1l = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1l = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1l(obj);
}
function _slicedToArray$F(arr, i) {
  return _arrayWithHoles$H(arr) || _iterableToArrayLimit$F(arr, i) || _unsupportedIterableToArray$X(arr, i) || _nonIterableRest$H();
}
function _nonIterableRest$H() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$X(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$X(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$X(o, minLen);
}
function _arrayLikeToArray$X(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$F(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$H(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$2h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2b(Constructor, staticProps);
  return Constructor;
}
function _get$K(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$K = Reflect.get;
  } else {
    _get$K = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$K(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$K(target, property, receiver || target);
}
function _superPropBase$K(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$19(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$19(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1a(subClass, superClass);
}
function _setPrototypeOf$1a(o, p) {
  _setPrototypeOf$1a = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1a(o, p);
}
function _createSuper$19(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$19(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$19(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$19(this, result);
  };
}
function _possibleConstructorReturn$19(self, call) {
  if (call && (_typeof$1l(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$19(self);
}
function _assertThisInitialized$19(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$19(o) {
  _getPrototypeOf$19 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$19(o);
}
var ValueComponent = /* @__PURE__ */ function(_BaseComponent) {
  _inherits$19(ValueComponent2, _BaseComponent);
  var _super = _createSuper$19(ValueComponent2);
  function ValueComponent2(hotInstance, options) {
    var _this;
    _classCallCheck$2h(this, ValueComponent2);
    _this = _super.call(this, hotInstance, {
      id: options.id,
      stateless: false
    });
    _this.name = options.name;
    _this.elements.push(new MultipleSelectUI(_this.hot));
    _this.registerHooks();
    return _this;
  }
  _createClass$2b(ValueComponent2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      this.getMultipleSelectElement().addLocalHook("keydown", function(event) {
        return _this2.onInputKeyDown(event);
      });
    }
  }, {
    key: "setState",
    value: function setState(value) {
      this.reset();
      if (value && value.command.key === CONDITION_NAME$k) {
        var select = this.getMultipleSelectElement();
        select.setItems(value.itemsSnapshot);
        select.setValue(value.args[0]);
      }
    }
  }, {
    key: "getState",
    value: function getState() {
      var select = this.getMultipleSelectElement();
      var availableItems = select.getItems();
      return {
        command: {
          key: select.isSelectedAllValues() || !availableItems.length ? CONDITION_NAME : CONDITION_NAME$k
        },
        args: [select.getValue()],
        itemsSnapshot: availableItems
      };
    }
  }, {
    key: "updateState",
    value: function updateState(stateInfo) {
      var _this3 = this;
      var updateColumnState = function updateColumnState2(physicalColumn, conditions, conditionArgsChange, filteredRowsFactory, conditionsStack) {
        var _arrayFilter = arrayFilter(conditions, function(condition) {
          return condition.name === CONDITION_NAME$k;
        }), _arrayFilter2 = _slicedToArray$F(_arrayFilter, 1), firstByValueCondition = _arrayFilter2[0];
        var state = {};
        var defaultBlankCellValue = _this3.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);
        if (firstByValueCondition) {
          var rowValues = unifyColumnValues(arrayMap(filteredRowsFactory(physicalColumn, conditionsStack), function(row) {
            return row.value;
          }));
          if (conditionArgsChange) {
            firstByValueCondition.args[0] = conditionArgsChange;
          }
          var selectedValues = [];
          var itemsSnapshot = intersectValues(rowValues, firstByValueCondition.args[0], defaultBlankCellValue, function(item) {
            if (item.checked) {
              selectedValues.push(item.value);
            }
          });
          state.args = [selectedValues];
          state.command = getConditionDescriptor(CONDITION_NAME$k);
          state.itemsSnapshot = itemsSnapshot;
        } else {
          state.args = [];
          state.command = getConditionDescriptor(CONDITION_NAME);
        }
        _this3.state.setValueAtIndex(physicalColumn, state);
      };
      updateColumnState(stateInfo.editedConditionStack.column, stateInfo.editedConditionStack.conditions, stateInfo.conditionArgsChange, stateInfo.filteredRowsFactory);
      if (stateInfo.dependentConditionStacks.length) {
        updateColumnState(stateInfo.dependentConditionStacks[0].column, stateInfo.dependentConditionStacks[0].conditions, stateInfo.conditionArgsChange, stateInfo.filteredRowsFactory, stateInfo.editedConditionStack);
      }
    }
  }, {
    key: "getMultipleSelectElement",
    value: function getMultipleSelectElement() {
      return this.elements.filter(function(element) {
        return element instanceof MultipleSelectUI;
      })[0];
    }
  }, {
    key: "getMenuItemDescriptor",
    value: function getMenuItemDescriptor() {
      var _this4 = this;
      return {
        key: this.id,
        name: this.name,
        isCommand: false,
        disableSelection: true,
        hidden: function hidden() {
          return _this4.isHidden();
        },
        renderer: function renderer(hot, wrapper, row, col, prop, value) {
          addClass(wrapper.parentNode, "htFiltersMenuValue");
          var label = _this4.hot.rootDocument.createElement("div");
          addClass(label, "htFiltersMenuLabel");
          label.textContent = value;
          wrapper.appendChild(label);
          if (!wrapper.parentNode.hasAttribute("ghost-table")) {
            arrayEach(_this4.elements, function(ui) {
              return wrapper.appendChild(ui.element);
            });
          }
          return wrapper;
        }
      };
    }
  }, {
    key: "reset",
    value: function reset() {
      var defaultBlankCellValue = this.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);
      var values = unifyColumnValues(this._getColumnVisibleValues());
      var items = intersectValues(values, values, defaultBlankCellValue);
      this.getMultipleSelectElement().setItems(items);
      _get$K(_getPrototypeOf$19(ValueComponent2.prototype), "reset", this).call(this);
      this.getMultipleSelectElement().setValue(values);
    }
  }, {
    key: "onInputKeyDown",
    value: function onInputKeyDown(event) {
      if (isKey(event.keyCode, "ESCAPE")) {
        this.runLocalHooks("cancel");
        stopImmediatePropagation(event);
      }
    }
  }, {
    key: "_getColumnVisibleValues",
    value: function _getColumnVisibleValues() {
      var lastSelectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
      var visualIndex = lastSelectedColumn && lastSelectedColumn.visualIndex;
      return arrayMap(this.hot.getDataAtCol(visualIndex), function(v) {
        return toEmptyString(v);
      });
    }
  }]);
  return ValueComponent2;
}(BaseComponent);

function _typeof$1m(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1m = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1m = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1m(obj);
}
function _classCallCheck$2i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2c(Constructor, staticProps);
  return Constructor;
}
function _inherits$1a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1b(subClass, superClass);
}
function _setPrototypeOf$1b(o, p) {
  _setPrototypeOf$1b = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1b(o, p);
}
function _createSuper$1a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1a(this, result);
  };
}
function _possibleConstructorReturn$1a(self, call) {
  if (call && (_typeof$1m(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1a(self);
}
function _assertThisInitialized$1a(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1a(o) {
  _getPrototypeOf$1a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1a(o);
}
var ActionBarComponent = /* @__PURE__ */ function(_BaseComponent) {
  _inherits$1a(ActionBarComponent2, _BaseComponent);
  var _super = _createSuper$1a(ActionBarComponent2);
  function ActionBarComponent2(hotInstance, options) {
    var _this;
    _classCallCheck$2i(this, ActionBarComponent2);
    _this = _super.call(this, hotInstance, {
      id: options.id,
      stateless: true
    });
    _this.name = options.name;
    _this.elements.push(new InputUI(_this.hot, {
      type: "button",
      value: FILTERS_BUTTONS_OK,
      className: "htUIButton htUIButtonOK",
      identifier: ActionBarComponent2.BUTTON_OK
    }));
    _this.elements.push(new InputUI(_this.hot, {
      type: "button",
      value: FILTERS_BUTTONS_CANCEL,
      className: "htUIButton htUIButtonCancel",
      identifier: ActionBarComponent2.BUTTON_CANCEL
    }));
    _this.registerHooks();
    return _this;
  }
  _createClass$2c(ActionBarComponent2, [{
    key: "registerHooks",
    value: function registerHooks() {
      var _this2 = this;
      arrayEach(this.elements, function(element) {
        element.addLocalHook("click", function(event, button) {
          return _this2.onButtonClick(event, button);
        });
      });
    }
  }, {
    key: "getMenuItemDescriptor",
    value: function getMenuItemDescriptor() {
      var _this3 = this;
      return {
        key: this.id,
        name: this.name,
        isCommand: false,
        disableSelection: true,
        hidden: function hidden() {
          return _this3.isHidden();
        },
        renderer: function renderer(hot, wrapper) {
          addClass(wrapper.parentNode, "htFiltersMenuActionBar");
          if (!wrapper.parentNode.hasAttribute("ghost-table")) {
            arrayEach(_this3.elements, function(ui) {
              return wrapper.appendChild(ui.element);
            });
          }
          return wrapper;
        }
      };
    }
  }, {
    key: "accept",
    value: function accept() {
      this.runLocalHooks("accept");
    }
  }, {
    key: "cancel",
    value: function cancel() {
      this.runLocalHooks("cancel");
    }
  }, {
    key: "onButtonClick",
    value: function onButtonClick(event, button) {
      if (button.options.identifier === ActionBarComponent2.BUTTON_OK) {
        this.accept();
      } else {
        this.cancel();
      }
    }
  }], [{
    key: "BUTTON_OK",
    get: function get() {
      return "ok";
    }
  }, {
    key: "BUTTON_CANCEL",
    get: function get() {
      return "cancel";
    }
  }]);
  return ActionBarComponent2;
}(BaseComponent);

var _templateObject$a, _templateObject2$2;
function _slicedToArray$G(arr, i) {
  return _arrayWithHoles$I(arr) || _iterableToArrayLimit$G(arr, i) || _unsupportedIterableToArray$Y(arr, i) || _nonIterableRest$I();
}
function _nonIterableRest$I() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$Y(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$Y(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$Y(o, minLen);
}
function _arrayLikeToArray$Y(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$G(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$I(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _taggedTemplateLiteral$a(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _classCallCheck$2j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2d(Constructor, staticProps);
  return Constructor;
}
var MAP_NAME = "ConditionCollection.filteringStates";
var ConditionCollection = /* @__PURE__ */ function() {
  function ConditionCollection2(hot) {
    var isMapRegistrable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    _classCallCheck$2j(this, ConditionCollection2);
    this.hot = hot;
    this.isMapRegistrable = isMapRegistrable;
    this.filteringStates = new LinkedPhysicalIndexToValueMap();
    if (this.isMapRegistrable === true) {
      this.hot.columnIndexMapper.registerMap(MAP_NAME, this.filteringStates);
    } else {
      this.filteringStates.init(this.hot.columnIndexMapper.getNumberOfIndexes());
    }
  }
  _createClass$2d(ConditionCollection2, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.getFilteredColumns().length === 0;
    }
  }, {
    key: "isMatch",
    value: function isMatch(value, column) {
      var _stateForColumn$condi;
      var stateForColumn = this.filteringStates.getValueAtIndex(column);
      var conditions = (_stateForColumn$condi = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.conditions) !== null && _stateForColumn$condi !== void 0 ? _stateForColumn$condi : [];
      var operation = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.operation;
      return this.isMatchInConditions(conditions, value, operation);
    }
  }, {
    key: "isMatchInConditions",
    value: function isMatchInConditions(conditions, value) {
      var operationType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OPERATION_ID;
      if (conditions.length) {
        return getOperationFunc(operationType)(conditions, value);
      }
      return true;
    }
  }, {
    key: "addCondition",
    value: function addCondition(column, conditionDefinition) {
      var operation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OPERATION_ID;
      var position = arguments.length > 3 ? arguments[3] : void 0;
      var args = arrayMap(conditionDefinition.args, function(v) {
        return typeof v === "string" ? v.toLowerCase() : v;
      });
      var name = conditionDefinition.name || conditionDefinition.command.key;
      this.runLocalHooks("beforeAdd", column);
      var columnType = this.getOperation(column);
      if (columnType) {
        if (columnType !== operation) {
          throw Error(toSingleLine(_templateObject$a || (_templateObject$a = _taggedTemplateLiteral$a(["The column of index ", " has been already applied with a `", "` \n        filter operation. Use `removeConditions` to clear the current conditions and then add new ones. \n        Mind that you cannot mix different types of operations (for instance, if you use `conjunction`, \n        use it consequently for a particular column)."], ["The column of index ", " has been already applied with a \\`", "\\`\\x20\n        filter operation. Use \\`removeConditions\\` to clear the current conditions and then add new ones.\\x20\n        Mind that you cannot mix different types of operations (for instance, if you use \\`conjunction\\`,\\x20\n        use it consequently for a particular column)."])), column, columnType));
        }
      } else if (isUndefined$1(operations[operation])) {
        throw new Error(toSingleLine(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral$a(["Unexpected operation named `", "`. Possible ones are \n        `disjunction` and `conjunction`."], ["Unexpected operation named \\`", "\\`. Possible ones are\\x20\n        \\`disjunction\\` and \\`conjunction\\`."])), operation));
      }
      var conditionsForColumn = this.getConditions(column);
      if (conditionsForColumn.length === 0) {
        this.filteringStates.setValueAtIndex(column, {
          operation,
          conditions: [{
            name,
            args,
            func: getCondition(name, args)
          }]
        }, position);
      } else {
        conditionsForColumn.push({
          name,
          args,
          func: getCondition(name, args)
        });
      }
      this.runLocalHooks("afterAdd", column);
    }
  }, {
    key: "getConditions",
    value: function getConditions(column) {
      var _this$filteringStates, _this$filteringStates2;
      return (_this$filteringStates = (_this$filteringStates2 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates2 === void 0 ? void 0 : _this$filteringStates2.conditions) !== null && _this$filteringStates !== void 0 ? _this$filteringStates : [];
    }
  }, {
    key: "getOperation",
    value: function getOperation(column) {
      var _this$filteringStates3;
      return (_this$filteringStates3 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates3 === void 0 ? void 0 : _this$filteringStates3.operation;
    }
  }, {
    key: "getFilteredColumns",
    value: function getFilteredColumns() {
      return this.filteringStates.getEntries().map(function(_ref) {
        var _ref2 = _slicedToArray$G(_ref, 1), physicalColumn = _ref2[0];
        return physicalColumn;
      });
    }
  }, {
    key: "getColumnStackPosition",
    value: function getColumnStackPosition(column) {
      return this.getFilteredColumns().indexOf(column);
    }
  }, {
    key: "exportAllConditions",
    value: function exportAllConditions() {
      return arrayReduce(this.filteringStates.getEntries(), function(allConditions, _ref3) {
        var _ref4 = _slicedToArray$G(_ref3, 2), column = _ref4[0], _ref4$ = _ref4[1], operation = _ref4$.operation, conditions = _ref4$.conditions;
        allConditions.push({
          column,
          operation,
          conditions: arrayMap(conditions, function(_ref5) {
            var name = _ref5.name, args = _ref5.args;
            return {
              name,
              args
            };
          })
        });
        return allConditions;
      }, []);
    }
  }, {
    key: "importAllConditions",
    value: function importAllConditions(conditions) {
      var _this = this;
      this.clean();
      arrayEach(conditions, function(stack) {
        arrayEach(stack.conditions, function(condition) {
          return _this.addCondition(stack.column, condition);
        });
      });
    }
  }, {
    key: "removeConditions",
    value: function removeConditions(column) {
      this.runLocalHooks("beforeRemove", column);
      this.filteringStates.clearValue(column);
      this.runLocalHooks("afterRemove", column);
    }
  }, {
    key: "clean",
    value: function clean() {
      this.runLocalHooks("beforeClean");
      this.filteringStates.clear();
      this.runLocalHooks("afterClean");
    }
  }, {
    key: "hasConditions",
    value: function hasConditions(column, name) {
      var conditions = this.getConditions(column);
      if (name) {
        return conditions.some(function(condition) {
          return condition.name === name;
        });
      }
      return conditions.length > 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.isMapRegistrable) {
        this.hot.columnIndexMapper.unregisterMap(MAP_NAME);
      }
      this.filteringStates = null;
      this.clearLocalHooks();
    }
  }]);
  return ConditionCollection2;
}();
mixin(ConditionCollection, localHooks);

function _classCallCheck$2k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2e(Constructor, staticProps);
  return Constructor;
}
var DataFilter = /* @__PURE__ */ function() {
  function DataFilter2(conditionCollection) {
    var columnDataFactory = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
      return [];
    };
    _classCallCheck$2k(this, DataFilter2);
    this.conditionCollection = conditionCollection;
    this.columnDataFactory = columnDataFactory;
  }
  _createClass$2e(DataFilter2, [{
    key: "filter",
    value: function filter() {
      var _this = this;
      var filteredData = [];
      arrayEach(this.conditionCollection.getFilteredColumns(), function(physicalColumn, index) {
        var columnData = _this.columnDataFactory(physicalColumn);
        if (index) {
          columnData = _this._getIntersectData(columnData, filteredData);
        }
        filteredData = _this.filterByColumn(physicalColumn, columnData);
      });
      return filteredData;
    }
  }, {
    key: "filterByColumn",
    value: function filterByColumn(column) {
      var _this2 = this;
      var dataSource = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var filteredData = [];
      arrayEach(dataSource, function(dataRow) {
        if (dataRow !== void 0 && _this2.conditionCollection.isMatch(dataRow, column)) {
          filteredData.push(dataRow);
        }
      });
      return filteredData;
    }
  }, {
    key: "_getIntersectData",
    value: function _getIntersectData(data, needles) {
      var result = [];
      arrayEach(needles, function(needleRow) {
        var row = needleRow.meta.visualRow;
        if (data[row] !== void 0) {
          result[row] = data[row];
        }
      });
      return result;
    }
  }]);
  return DataFilter2;
}();

function _classCallCheck$2l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2f(Constructor, staticProps);
  return Constructor;
}
var ConditionUpdateObserver = /* @__PURE__ */ function() {
  function ConditionUpdateObserver2(hot, conditionCollection) {
    var _this = this;
    var columnDataFactory = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      return [];
    };
    _classCallCheck$2l(this, ConditionUpdateObserver2);
    this.hot = hot;
    this.conditionCollection = conditionCollection;
    this.columnDataFactory = columnDataFactory;
    this.changes = [];
    this.grouping = false;
    this.latestEditedColumnPosition = -1;
    this.latestOrderStack = [];
    this.conditionCollection.addLocalHook("beforeRemove", function(column) {
      return _this._onConditionBeforeModify(column);
    });
    this.conditionCollection.addLocalHook("afterRemove", function(column) {
      return _this.updateStatesAtColumn(column);
    });
    this.conditionCollection.addLocalHook("afterAdd", function(column) {
      return _this.updateStatesAtColumn(column);
    });
    this.conditionCollection.addLocalHook("beforeClean", function() {
      return _this._onConditionBeforeClean();
    });
    this.conditionCollection.addLocalHook("afterClean", function() {
      return _this._onConditionAfterClean();
    });
  }
  _createClass$2f(ConditionUpdateObserver2, [{
    key: "groupChanges",
    value: function groupChanges() {
      this.grouping = true;
    }
  }, {
    key: "flush",
    value: function flush() {
      var _this2 = this;
      this.grouping = false;
      arrayEach(this.changes, function(column) {
        _this2.updateStatesAtColumn(column);
      });
      this.changes.length = 0;
    }
  }, {
    key: "_onConditionBeforeModify",
    value: function _onConditionBeforeModify(column) {
      this.latestEditedColumnPosition = this.conditionCollection.getColumnStackPosition(column);
    }
  }, {
    key: "updateStatesAtColumn",
    value: function updateStatesAtColumn(column, conditionArgsChange) {
      var _this3 = this;
      if (this.grouping) {
        if (this.changes.indexOf(column) === -1) {
          this.changes.push(column);
        }
        return;
      }
      var allConditions = this.conditionCollection.exportAllConditions();
      var editedColumnPosition = this.conditionCollection.getColumnStackPosition(column);
      if (editedColumnPosition === -1) {
        editedColumnPosition = this.latestEditedColumnPosition;
      }
      var conditionsBefore = allConditions.slice(0, editedColumnPosition);
      var conditionsAfter = allConditions.slice(editedColumnPosition);
      if (conditionsAfter.length && conditionsAfter[0].column === column) {
        conditionsAfter.shift();
      }
      var visibleDataFactory = curry(function(curriedConditionsBefore, curriedColumn) {
        var conditionsStack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        var splitConditionCollection = new ConditionCollection(_this3.hot, false);
        var curriedConditionsBeforeArray = [].concat(curriedConditionsBefore, conditionsStack);
        splitConditionCollection.importAllConditions(curriedConditionsBeforeArray);
        var allRows = _this3.columnDataFactory(curriedColumn);
        var visibleRows;
        if (splitConditionCollection.isEmpty()) {
          visibleRows = allRows;
        } else {
          visibleRows = new DataFilter(splitConditionCollection, function(columnData) {
            return _this3.columnDataFactory(columnData);
          }).filter();
        }
        visibleRows = arrayMap(visibleRows, function(rowData) {
          return rowData.meta.visualRow;
        });
        var visibleRowsAssertion = createArrayAssertion(visibleRows);
        splitConditionCollection.destroy();
        return arrayFilter(allRows, function(rowData) {
          return visibleRowsAssertion(rowData.meta.visualRow);
        });
      })(conditionsBefore);
      var editedConditions = [].concat(this.conditionCollection.getConditions(column));
      this.runLocalHooks("update", {
        editedConditionStack: {
          column,
          conditions: editedConditions
        },
        dependentConditionStacks: conditionsAfter,
        filteredRowsFactory: visibleDataFactory,
        conditionArgsChange
      });
    }
  }, {
    key: "_onConditionBeforeClean",
    value: function _onConditionBeforeClean() {
      this.latestOrderStack = this.conditionCollection.getFilteredColumns();
    }
  }, {
    key: "_onConditionAfterClean",
    value: function _onConditionAfterClean() {
      var _this4 = this;
      arrayEach(this.latestOrderStack, function(column) {
        _this4.updateStatesAtColumn(column);
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this5 = this;
      this.clearLocalHooks();
      objectEach(this, function(value, property) {
        _this5[property] = null;
      });
    }
  }]);
  return ConditionUpdateObserver2;
}();
mixin(ConditionUpdateObserver, localHooks);

function _typeof$1n(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1n = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1n = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1n(obj);
}
var _templateObject$b;
function _taggedTemplateLiteral$b(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _slicedToArray$H(arr, i) {
  return _arrayWithHoles$J(arr) || _iterableToArrayLimit$H(arr, i) || _unsupportedIterableToArray$Z(arr, i) || _nonIterableRest$J();
}
function _nonIterableRest$J() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$Z(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$Z(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$Z(o, minLen);
}
function _arrayLikeToArray$Z(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$H(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$J(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$2m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2g(Constructor, staticProps);
  return Constructor;
}
function _get$L(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$L = Reflect.get;
  } else {
    _get$L = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$L(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$L(target, property, receiver || target);
}
function _superPropBase$L(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1b(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$1b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1c(subClass, superClass);
}
function _setPrototypeOf$1c(o, p) {
  _setPrototypeOf$1c = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1c(o, p);
}
function _createSuper$1b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1b(this, result);
  };
}
function _possibleConstructorReturn$1b(self, call) {
  if (call && (_typeof$1n(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1b(self);
}
function _assertThisInitialized$1b(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1b(o) {
  _getPrototypeOf$1b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1b(o);
}
var PLUGIN_KEY$q = "filters";
var PLUGIN_PRIORITY$o = 250;
var Filters = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$1b(Filters2, _BasePlugin);
  var _super = _createSuper$1b(Filters2);
  function Filters2(hotInstance) {
    var _this;
    _classCallCheck$2m(this, Filters2);
    _this = _super.call(this, hotInstance);
    _this.eventManager = new EventManager(_assertThisInitialized$1b(_this));
    _this.dropdownMenuPlugin = null;
    _this.conditionCollection = null;
    _this.conditionUpdateObserver = null;
    _this.components = new Map([["filter_by_condition", null], ["filter_operators", null], ["filter_by_condition2", null], ["filter_by_value", null], ["filter_action_bar", null]]);
    _this.lastSelectedColumn = null;
    _this.filtersRowsMap = null;
    _this.hot.addHook("afterGetColHeader", function(col, TH) {
      return _this.onAfterGetColHeader(col, TH);
    });
    return _this;
  }
  _createClass$2g(Filters2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$q] ? true : false;
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.filtersRowsMap = this.hot.rowIndexMapper.registerMap(this.pluginName, new TrimmingMap());
      this.dropdownMenuPlugin = this.hot.getPlugin("dropdownMenu");
      var dropdownSettings = this.hot.getSettings().dropdownMenu;
      var menuContainer = dropdownSettings && dropdownSettings.uiContainer || this.hot.rootDocument.body;
      var addConfirmationHooks = function addConfirmationHooks2(component) {
        component.addLocalHook("accept", function() {
          return _this2.onActionBarSubmit("accept");
        });
        component.addLocalHook("cancel", function() {
          return _this2.onActionBarSubmit("cancel");
        });
        component.addLocalHook("change", function(command) {
          return _this2.onComponentChange(component, command);
        });
        return component;
      };
      var filterByConditionLabel = function filterByConditionLabel2() {
        return "".concat(_this2.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_CONDITION), ":");
      };
      var filterValueLabel = function filterValueLabel2() {
        return "".concat(_this2.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_VALUE), ":");
      };
      if (!this.components.get("filter_by_condition")) {
        var conditionComponent = new ConditionComponent(this.hot, {
          id: "filter_by_condition",
          name: filterByConditionLabel,
          addSeparator: false,
          menuContainer
        });
        conditionComponent.addLocalHook("afterClose", function() {
          return _this2.onSelectUIClosed();
        });
        this.components.set("filter_by_condition", addConfirmationHooks(conditionComponent));
      }
      if (!this.components.get("filter_operators")) {
        this.components.set("filter_operators", new OperatorsComponent(this.hot, {
          id: "filter_operators",
          name: "Operators"
        }));
      }
      if (!this.components.get("filter_by_condition2")) {
        var _conditionComponent = new ConditionComponent(this.hot, {
          id: "filter_by_condition2",
          name: "",
          addSeparator: true,
          menuContainer
        });
        _conditionComponent.addLocalHook("afterClose", function() {
          return _this2.onSelectUIClosed();
        });
        this.components.set("filter_by_condition2", addConfirmationHooks(_conditionComponent));
      }
      if (!this.components.get("filter_by_value")) {
        this.components.set("filter_by_value", addConfirmationHooks(new ValueComponent(this.hot, {
          id: "filter_by_value",
          name: filterValueLabel
        })));
      }
      if (!this.components.get("filter_action_bar")) {
        this.components.set("filter_action_bar", addConfirmationHooks(new ActionBarComponent(this.hot, {
          id: "filter_action_bar",
          name: "Action bar"
        })));
      }
      if (!this.conditionCollection) {
        this.conditionCollection = new ConditionCollection(this.hot);
      }
      if (!this.conditionUpdateObserver) {
        this.conditionUpdateObserver = new ConditionUpdateObserver(this.hot, this.conditionCollection, function(physicalColumn) {
          return _this2.getDataMapAtColumn(physicalColumn);
        });
        this.conditionUpdateObserver.addLocalHook("update", function(conditionState) {
          return _this2.updateComponents(conditionState);
        });
      }
      this.components.forEach(function(component) {
        return component.show();
      });
      this.registerEvents();
      this.addHook("beforeDropdownMenuSetItems", function(items) {
        return _this2.onBeforeDropdownMenuSetItems(items);
      });
      this.addHook("afterDropdownMenuDefaultOptions", function(defaultOptions) {
        return _this2.onAfterDropdownMenuDefaultOptions(defaultOptions);
      });
      this.addHook("afterDropdownMenuShow", function() {
        return _this2.onAfterDropdownMenuShow();
      });
      this.addHook("afterDropdownMenuHide", function() {
        return _this2.onAfterDropdownMenuHide();
      });
      this.addHook("afterChange", function(changes) {
        return _this2.onAfterChange(changes);
      });
      if (this.hot.getSettings().dropdownMenu && this.dropdownMenuPlugin) {
        this.dropdownMenuPlugin.disablePlugin();
        this.dropdownMenuPlugin.enablePlugin();
      }
      _get$L(_getPrototypeOf$1b(Filters2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "registerEvents",
    value: function registerEvents() {
      var _this3 = this;
      this.eventManager.addEventListener(this.hot.rootElement, "click", function(event) {
        return _this3.onTableClick(event);
      });
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this4 = this;
      if (this.enabled) {
        var _this$dropdownMenuPlu;
        if ((_this$dropdownMenuPlu = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu !== void 0 && _this$dropdownMenuPlu.enabled) {
          this.dropdownMenuPlugin.menu.clearLocalHooks();
        }
        this.components.forEach(function(component, key) {
          component.destroy();
          _this4.components.set(key, null);
        });
        this.conditionCollection.destroy();
        this.conditionCollection = null;
        this.hot.rowIndexMapper.unregisterMap(this.pluginName);
      }
      _get$L(_getPrototypeOf$1b(Filters2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "addCondition",
    value: function addCondition(column, name, args) {
      var operationId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : OPERATION_ID;
      var physicalColumn = this.hot.toPhysicalColumn(column);
      this.conditionCollection.addCondition(physicalColumn, {
        command: {
          key: name
        },
        args
      }, operationId);
    }
  }, {
    key: "removeConditions",
    value: function removeConditions(column) {
      var physicalColumn = this.hot.toPhysicalColumn(column);
      this.conditionCollection.removeConditions(physicalColumn);
    }
  }, {
    key: "clearConditions",
    value: function clearConditions(column) {
      if (column === void 0) {
        this.conditionCollection.clean();
      } else {
        var physicalColumn = this.hot.toPhysicalColumn(column);
        this.conditionCollection.removeConditions(physicalColumn);
      }
    }
  }, {
    key: "filter",
    value: function filter() {
      var _this5 = this;
      var dataFilter = this._createDataFilter();
      var needToFilter = !this.conditionCollection.isEmpty();
      var visibleVisualRows = [];
      var conditions = this.conditionCollection.exportAllConditions();
      var allowFiltering = this.hot.runHooks("beforeFilter", conditions);
      if (allowFiltering !== false) {
        if (needToFilter) {
          var trimmedRows = [];
          this.hot.batchExecution(function() {
            _this5.filtersRowsMap.clear();
            visibleVisualRows = arrayMap(dataFilter.filter(), function(rowData) {
              return rowData.meta.visualRow;
            });
            var visibleVisualRowsAssertion = createArrayAssertion(visibleVisualRows);
            rangeEach(_this5.hot.countSourceRows() - 1, function(row) {
              if (!visibleVisualRowsAssertion(row)) {
                trimmedRows.push(row);
              }
            });
            arrayEach(trimmedRows, function(physicalRow) {
              _this5.filtersRowsMap.setValueAtIndex(physicalRow, true);
            });
          }, true);
          if (!visibleVisualRows.length) {
            this.hot.deselectCell();
          }
        } else {
          this.filtersRowsMap.clear();
        }
      }
      this.hot.runHooks("afterFilter", conditions);
      this.hot.view.adjustElementsSize(true);
      this.hot.render();
      this.clearColumnSelection();
    }
  }, {
    key: "getSelectedColumn",
    value: function getSelectedColumn() {
      return this.lastSelectedColumn;
    }
  }, {
    key: "clearColumnSelection",
    value: function clearColumnSelection() {
      var _this$hot$getSelected;
      var coords = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.getTopLeftCorner();
      if (coords !== void 0) {
        this.hot.selectCell(coords.row, coords.col);
      }
    }
  }, {
    key: "getDataMapAtColumn",
    value: function getDataMapAtColumn(column) {
      var _this6 = this;
      var visualIndex = this.hot.toVisualColumn(column);
      var data = [];
      arrayEach(this.hot.getSourceDataAtCol(visualIndex), function(value, rowIndex) {
        var _this6$hot$getCellMet = _this6.hot.getCellMeta(rowIndex, visualIndex), row = _this6$hot$getCellMet.row, col = _this6$hot$getCellMet.col, visualCol = _this6$hot$getCellMet.visualCol, visualRow = _this6$hot$getCellMet.visualRow, type = _this6$hot$getCellMet.type, instance = _this6$hot$getCellMet.instance, dateFormat = _this6$hot$getCellMet.dateFormat;
        data.push({
          meta: {
            row,
            col,
            visualCol,
            visualRow,
            type,
            instance,
            dateFormat
          },
          value: toEmptyString(value)
        });
      });
      return data;
    }
  }, {
    key: "onAfterChange",
    value: function onAfterChange(changes) {
      var _this7 = this;
      if (changes) {
        arrayEach(changes, function(change) {
          var _change = _slicedToArray$H(change, 2), prop = _change[1];
          var columnIndex = _this7.hot.propToCol(prop);
          if (_this7.conditionCollection.hasConditions(columnIndex)) {
            _this7.updateValueComponentCondition(columnIndex);
          }
        });
      }
    }
  }, {
    key: "updateValueComponentCondition",
    value: function updateValueComponentCondition(columnIndex) {
      var dataAtCol = this.hot.getDataAtCol(columnIndex);
      var selectedValues = unifyColumnValues(dataAtCol);
      this.conditionUpdateObserver.updateStatesAtColumn(columnIndex, selectedValues);
    }
  }, {
    key: "restoreComponents",
    value: function restoreComponents(components) {
      var _this$getSelectedColu;
      var physicalIndex = (_this$getSelectedColu = this.getSelectedColumn()) === null || _this$getSelectedColu === void 0 ? void 0 : _this$getSelectedColu.physicalIndex;
      components.forEach(function(component) {
        if (component.isHidden()) {
          return;
        }
        component.restoreState(physicalIndex);
      });
      this.updateDependentComponentsVisibility();
    }
  }, {
    key: "onAfterDropdownMenuShow",
    value: function onAfterDropdownMenuShow() {
      this.restoreComponents(Array.from(this.components.values()));
    }
  }, {
    key: "onAfterDropdownMenuHide",
    value: function onAfterDropdownMenuHide() {
      this.components.get("filter_by_condition").getSelectElement().closeOptions();
      this.components.get("filter_by_condition2").getSelectElement().closeOptions();
    }
  }, {
    key: "onBeforeDropdownMenuSetItems",
    value: function onBeforeDropdownMenuSetItems() {
      var _this8 = this;
      if (this.dropdownMenuPlugin) {
        this.dropdownMenuPlugin.menu.addLocalHook("afterOpen", function() {
          _this8.dropdownMenuPlugin.menu.hotMenu.updateSettings({
            hiddenRows: true
          });
        });
      }
    }
  }, {
    key: "onAfterDropdownMenuDefaultOptions",
    value: function onAfterDropdownMenuDefaultOptions(defaultOptions) {
      defaultOptions.items.push({
        name: KEY
      });
      this.components.forEach(function(component) {
        defaultOptions.items.push(component.getMenuItemDescriptor());
      });
    }
  }, {
    key: "getOperationBasedOnArguments",
    value: function getOperationBasedOnArguments(suggestedOperation, byConditionState1, byConditionState2, byValueState) {
      var operation = suggestedOperation;
      if (operation === OPERATION_ID$1 && byConditionState1.command.key !== CONDITION_NAME && byConditionState2.command.key !== CONDITION_NAME && byValueState.command.key !== CONDITION_NAME) {
        operation = OPERATION_ID$2;
      } else if (byValueState.command.key !== CONDITION_NAME) {
        if (byConditionState1.command.key === CONDITION_NAME || byConditionState2.command.key === CONDITION_NAME) {
          operation = OPERATION_ID;
        }
      }
      return operation;
    }
  }, {
    key: "onActionBarSubmit",
    value: function onActionBarSubmit(submitType) {
      if (submitType === "accept") {
        var _this$getSelectedColu2;
        var physicalIndex = (_this$getSelectedColu2 = this.getSelectedColumn()) === null || _this$getSelectedColu2 === void 0 ? void 0 : _this$getSelectedColu2.physicalIndex;
        var byConditionState1 = this.components.get("filter_by_condition").getState();
        var byConditionState2 = this.components.get("filter_by_condition2").getState();
        var byValueState = this.components.get("filter_by_value").getState();
        var operation = this.getOperationBasedOnArguments(this.components.get("filter_operators").getActiveOperationId(), byConditionState1, byConditionState2, byValueState);
        this.conditionUpdateObserver.groupChanges();
        var columnStackPosition = this.conditionCollection.getColumnStackPosition(physicalIndex);
        if (columnStackPosition === -1) {
          columnStackPosition = void 0;
        }
        this.conditionCollection.removeConditions(physicalIndex);
        if (byConditionState1.command.key !== CONDITION_NAME) {
          this.conditionCollection.addCondition(physicalIndex, byConditionState1, operation, columnStackPosition);
          if (byConditionState2.command.key !== CONDITION_NAME) {
            this.conditionCollection.addCondition(physicalIndex, byConditionState2, operation, columnStackPosition);
          }
        }
        if (byValueState.command.key !== CONDITION_NAME) {
          this.conditionCollection.addCondition(physicalIndex, byValueState, operation, columnStackPosition);
        }
        this.conditionUpdateObserver.flush();
        this.components.forEach(function(component) {
          return component.saveState(physicalIndex);
        });
        this.filtersRowsMap.clear();
        this.filter();
      }
      if (this.dropdownMenuPlugin) {
        this.dropdownMenuPlugin.close();
      }
    }
  }, {
    key: "onComponentChange",
    value: function onComponentChange(component, command) {
      this.updateDependentComponentsVisibility();
      if (component.constructor === ConditionComponent && !command.inputsCount) {
        this.setListeningDropdownMenu();
      }
    }
  }, {
    key: "onSelectUIClosed",
    value: function onSelectUIClosed() {
      this.setListeningDropdownMenu();
    }
  }, {
    key: "setListeningDropdownMenu",
    value: function setListeningDropdownMenu() {
      if (this.dropdownMenuPlugin) {
        this.dropdownMenuPlugin.setListening();
      }
    }
  }, {
    key: "updateDependentComponentsVisibility",
    value: function updateDependentComponentsVisibility() {
      var component = this.components.get("filter_by_condition");
      var _component$getState = component.getState(), command = _component$getState.command;
      var componentsToShow = [this.components.get("filter_by_condition2"), this.components.get("filter_operators")];
      if (command.showOperators) {
        this.showComponents.apply(this, componentsToShow);
      } else {
        this.hideComponents.apply(this, componentsToShow);
      }
    }
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(col, TH) {
      var physicalColumn = this.hot.toPhysicalColumn(col);
      if (this.enabled && this.conditionCollection.hasConditions(physicalColumn)) {
        addClass(TH, "htFiltersActive");
      } else {
        removeClass(TH, "htFiltersActive");
      }
    }
  }, {
    key: "onTableClick",
    value: function onTableClick(event) {
      var th = closest(event.target, "TH");
      if (th) {
        var visualIndex = this.hot.getCoords(th).col;
        var physicalIndex = this.hot.toPhysicalColumn(visualIndex);
        this.lastSelectedColumn = {
          visualIndex,
          physicalIndex
        };
      }
    }
  }, {
    key: "_createDataFilter",
    value: function _createDataFilter() {
      var _this9 = this;
      var conditionCollection = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.conditionCollection;
      return new DataFilter(conditionCollection, function(physicalColumn) {
        return _this9.getDataMapAtColumn(physicalColumn);
      });
    }
  }, {
    key: "updateComponents",
    value: function updateComponents(conditionsState) {
      var _this$dropdownMenuPlu2;
      if (!((_this$dropdownMenuPlu2 = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu2 !== void 0 && _this$dropdownMenuPlu2.enabled)) {
        return;
      }
      var _conditionsState$edit = conditionsState.editedConditionStack, conditions = _conditionsState$edit.conditions, column = _conditionsState$edit.column;
      var conditionsByValue = conditions.filter(function(condition) {
        return condition.name === CONDITION_NAME$k;
      });
      var conditionsWithoutByValue = conditions.filter(function(condition) {
        return condition.name !== CONDITION_NAME$k;
      });
      if (conditionsByValue.length >= 2 || conditionsWithoutByValue.length >= 3) {
        warn$1(toSingleLine(_templateObject$b || (_templateObject$b = _taggedTemplateLiteral$b(["The filter conditions have been applied properly, but couldn’t be displayed visually. \n        The overall amount of conditions exceed the capability of the dropdown menu. \n        For more details see the documentation."], ["The filter conditions have been applied properly, but couldn’t be displayed visually.\\x20\n        The overall amount of conditions exceed the capability of the dropdown menu.\\x20\n        For more details see the documentation."]))));
      } else {
        var operationType = this.conditionCollection.getOperation(column);
        this.components.get("filter_by_condition").updateState(conditionsWithoutByValue[0], column);
        this.components.get("filter_by_condition2").updateState(conditionsWithoutByValue[1], column);
        this.components.get("filter_operators").updateState(operationType, column);
        this.components.get("filter_by_value").updateState(conditionsState);
      }
    }
  }, {
    key: "getIndexesOfComponents",
    value: function getIndexesOfComponents() {
      var indexes = [];
      if (!this.dropdownMenuPlugin) {
        return indexes;
      }
      var menu = this.dropdownMenuPlugin.menu;
      for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {
        components[_key] = arguments[_key];
      }
      arrayEach(components, function(component) {
        arrayEach(menu.menuItems, function(item, index) {
          if (item.key === component.getMenuItemDescriptor().key) {
            indexes.push(index);
          }
        });
      });
      return indexes;
    }
  }, {
    key: "changeComponentsVisibility",
    value: function changeComponentsVisibility() {
      var visible = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!this.dropdownMenuPlugin) {
        return;
      }
      var menu = this.dropdownMenuPlugin.menu;
      var hotMenu = menu.hotMenu;
      var hiddenRows = hotMenu.getPlugin("hiddenRows");
      for (var _len2 = arguments.length, components = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        components[_key2 - 1] = arguments[_key2];
      }
      var indexes = this.getIndexesOfComponents.apply(this, components);
      if (visible) {
        hiddenRows.showRows(indexes);
      } else {
        hiddenRows.hideRows(indexes);
      }
      hotMenu.render();
    }
  }, {
    key: "hideComponents",
    value: function hideComponents() {
      for (var _len3 = arguments.length, components = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        components[_key3] = arguments[_key3];
      }
      this.changeComponentsVisibility.apply(this, [false].concat(components));
    }
  }, {
    key: "showComponents",
    value: function showComponents() {
      for (var _len4 = arguments.length, components = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        components[_key4] = arguments[_key4];
      }
      this.changeComponentsVisibility.apply(this, [true].concat(components));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this10 = this;
      if (this.enabled) {
        this.components.forEach(function(component, key) {
          if (component !== null) {
            component.destroy();
            _this10.components.set(key, null);
          }
        });
        this.conditionCollection.destroy();
        this.conditionUpdateObserver.destroy();
        this.hot.rowIndexMapper.unregisterMap(this.pluginName);
      }
      _get$L(_getPrototypeOf$1b(Filters2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$q;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$o;
    }
  }, {
    key: "PLUGIN_DEPS",
    get: function get() {
      return ["plugin:DropdownMenu", "plugin:HiddenRows", "cell-type:checkbox"];
    }
  }]);
  return Filters2;
}(BasePlugin);

var createAutofillHooks = function createAutofillHooks2(pluginInstance) {
  var beforeAutofill = function beforeAutofill2(_, __, target) {
    var width = target.getWidth();
    var height = target.getHeight();
    var row = target.from.row;
    var col = target.from.col;
    if (!pluginInstance.engine.isItPossibleToSetCellContents({
      sheet: pluginInstance.sheetId,
      row,
      col
    }, width, height)) {
      return false;
    }
  };
  var afterAutofill = function afterAutofill2(fillData, source, target, direction, hasFillDataChanged) {
    if (hasFillDataChanged) {
      return;
    }
    var sourceSize = {
      width: source.getWidth(),
      height: source.getHeight()
    };
    var targetSize = {
      width: target.getWidth(),
      height: target.getHeight()
    };
    var operations = [];
    switch (direction) {
      case "right": {
        var pasteRow = source.from.row;
        for (var pasteCol = target.from.col; pasteCol <= target.to.col; pasteCol += sourceSize.width) {
          var remaining = target.to.col - pasteCol + 1;
          var width = Math.min(sourceSize.width, remaining);
          operations.push({
            copy: {
              row: source.from.row,
              col: source.from.col,
              width,
              height: sourceSize.height
            },
            paste: {
              row: pasteRow,
              col: pasteCol
            }
          });
        }
        break;
      }
      case "down": {
        var _pasteCol = source.from.col;
        for (var _pasteRow = target.from.row; _pasteRow <= target.to.row; _pasteRow += sourceSize.height) {
          var _remaining = target.to.row - _pasteRow + 1;
          var height = Math.min(sourceSize.height, _remaining);
          operations.push({
            copy: {
              row: source.from.row,
              col: source.from.col,
              width: sourceSize.width,
              height
            },
            paste: {
              row: _pasteRow,
              col: _pasteCol
            }
          });
        }
        break;
      }
      case "left": {
        var _pasteRow2 = source.from.row;
        for (var _pasteCol2 = target.from.col; _pasteCol2 <= target.to.col; _pasteCol2++) {
          var offset = targetSize.width % sourceSize.width;
          var copyCol = (sourceSize.width - offset + (_pasteCol2 - target.from.col)) % sourceSize.width + source.from.col;
          operations.push({
            copy: {
              row: source.from.row,
              col: copyCol,
              width: 1,
              height: sourceSize.height
            },
            paste: {
              row: _pasteRow2,
              col: _pasteCol2
            }
          });
        }
        break;
      }
      case "up": {
        var _pasteCol3 = source.from.col;
        for (var _pasteRow3 = target.from.row; _pasteRow3 <= target.to.row; _pasteRow3++) {
          var _offset = targetSize.height % sourceSize.height;
          var copyRow = (sourceSize.height - _offset + (_pasteRow3 - target.from.row)) % sourceSize.height + source.from.row;
          operations.push({
            copy: {
              row: copyRow,
              col: source.from.col,
              width: sourceSize.width,
              height: 1
            },
            paste: {
              row: _pasteRow3,
              col: _pasteCol3
            }
          });
        }
        break;
      }
      default: {
        throw new Error("Unexpected direction parameter");
      }
    }
    var sheet = pluginInstance.sheetId;
    operations.reduce(function(previousCopy, operation) {
      if (!isObjectEqual(previousCopy, operation.copy)) {
        pluginInstance.engine.copy({
          sheet,
          row: operation.copy.row,
          col: operation.copy.col
        }, operation.copy.width, operation.copy.height);
      }
      pluginInstance.engine.paste({
        sheet,
        row: operation.paste.row,
        col: operation.paste.col
      });
      return operation.copy;
    }, {});
  };
  return {
    beforeAutofill,
    afterAutofill
  };
};

function ownKeys$a(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$a(Object(source), true).forEach(function(key) {
        _defineProperty$k(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$a(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
var DEFAULT_LICENSE_KEY = "internal-use-in-handsontable";
var DEFAULT_SETTINGS = {
  licenseKey: DEFAULT_LICENSE_KEY,
  binarySearchThreshold: 20,
  matrixDetection: false,
  matrixDetectionThreshold: 100,
  useColumnIndex: false,
  useStats: false,
  evaluateNullToZero: true,
  precisionEpsilon: 1e-13,
  precisionRounding: 14,
  smartRounding: true,
  leapYear1900: true,
  nullDate: {
    year: 1899,
    month: 12,
    day: 31
  },
  nullYear: 30,
  dateFormats: ["DD/MM/YYYY", "DD/MM/YY"],
  timeFormats: ["hh:mm", "hh:mm:ss.sss"],
  matchWholeCell: true,
  useRegularExpressions: false,
  useWildcards: true,
  functionArgSeparator: ",",
  thousandSeparator: "",
  decimalSeparator: ".",
  language: "enGB"
};
function getEngineSettingsOverrides(hotSettings) {
  var _hotSettings$PLUGIN_K, _hotSettings$PLUGIN_K2;
  return {
    maxColumns: hotSettings.maxColumns,
    maxRows: hotSettings.maxRows,
    language: (_hotSettings$PLUGIN_K = hotSettings[PLUGIN_KEY$r]) === null || _hotSettings$PLUGIN_K === void 0 ? void 0 : (_hotSettings$PLUGIN_K2 = _hotSettings$PLUGIN_K.language) === null || _hotSettings$PLUGIN_K2 === void 0 ? void 0 : _hotSettings$PLUGIN_K2.langCode
  };
}
function cleanEngineSettings(pluginSettings) {
  return Object.keys(pluginSettings).reduce(function(obj, key) {
    if (key !== "hyperformula") {
      obj[key] = pluginSettings[key];
    }
    return obj;
  }, {});
}
function getEngineSettingsWithDefaultsAndOverrides(hotSettings) {
  var _pluginSettings$engin;
  var pluginSettings = hotSettings[PLUGIN_KEY$r];
  var userSettings = cleanEngineSettings(pluginSettings !== null && pluginSettings !== void 0 && (_pluginSettings$engin = pluginSettings.engine) !== null && _pluginSettings$engin !== void 0 && _pluginSettings$engin.hyperformula ? pluginSettings.engine : {});
  var overrides = getEngineSettingsOverrides(hotSettings);
  return _objectSpread$a(_objectSpread$a(_objectSpread$a({}, DEFAULT_SETTINGS), userSettings), overrides);
}
function getEngineSettingsWithOverrides(hotSettings) {
  var _pluginSettings$engin2;
  var pluginSettings = hotSettings[PLUGIN_KEY$r];
  var userSettings = cleanEngineSettings(pluginSettings !== null && pluginSettings !== void 0 && (_pluginSettings$engin2 = pluginSettings.engine) !== null && _pluginSettings$engin2 !== void 0 && _pluginSettings$engin2.hyperformula ? pluginSettings.engine : {});
  var overrides = getEngineSettingsOverrides(hotSettings);
  return _objectSpread$a(_objectSpread$a({}, userSettings), overrides);
}

function _typeof$1o(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1o = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1o = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1o(obj);
}
function getEngineRelationshipRegistry() {
  var registryKey = "engine_relationship";
  var pluginStaticRegistry = staticRegister(PLUGIN_KEY$r);
  if (!pluginStaticRegistry.hasItem(registryKey)) {
    pluginStaticRegistry.register(registryKey, new Map());
  }
  return pluginStaticRegistry.getItem(registryKey);
}
function getSharedEngineUsageRegistry() {
  var registryKey = "shared_engine_usage";
  var pluginStaticRegistry = staticRegister(PLUGIN_KEY$r);
  if (!pluginStaticRegistry.hasItem(registryKey)) {
    pluginStaticRegistry.register(registryKey, new Map());
  }
  return pluginStaticRegistry.getItem(registryKey);
}
function setupEngine(hotInstance) {
  var hotSettings = hotInstance.getSettings();
  var pluginSettings = hotSettings[PLUGIN_KEY$r];
  var engineConfigItem = pluginSettings === null || pluginSettings === void 0 ? void 0 : pluginSettings.engine;
  if (pluginSettings === true) {
    return null;
  }
  if (isUndefined$1(engineConfigItem)) {
    return null;
  }
  if (typeof engineConfigItem.hyperformula === "function" || typeof engineConfigItem === "function") {
    var _engineConfigItem$hyp;
    return registerEngine((_engineConfigItem$hyp = engineConfigItem.hyperformula) !== null && _engineConfigItem$hyp !== void 0 ? _engineConfigItem$hyp : engineConfigItem, hotSettings, hotInstance);
  } else if (_typeof$1o(engineConfigItem) === "object" && isUndefined$1(engineConfigItem.hyperformula)) {
    var engineRelationship = getEngineRelationshipRegistry();
    var sharedEngineUsage = getSharedEngineUsageRegistry().get(engineConfigItem);
    if (!engineRelationship.has(engineConfigItem)) {
      engineRelationship.set(engineConfigItem, []);
    }
    engineRelationship.get(engineConfigItem).push(hotInstance);
    if (sharedEngineUsage) {
      sharedEngineUsage.push(hotInstance.guid);
    }
    if (!engineConfigItem.getConfig().licenseKey) {
      engineConfigItem.updateConfig({
        licenseKey: DEFAULT_LICENSE_KEY
      });
    }
    return engineConfigItem;
  }
  return null;
}
function registerEngine(engineClass, hotSettings, hotInstance) {
  var pluginSettings = hotSettings[PLUGIN_KEY$r];
  var engineSettings = getEngineSettingsWithDefaultsAndOverrides(hotSettings);
  var engineRegistry = getEngineRelationshipRegistry();
  var sharedEngineRegistry = getSharedEngineUsageRegistry();
  registerCustomFunctions(engineClass, pluginSettings.functions);
  registerLanguage(engineClass, pluginSettings.language);
  var engineInstance = engineClass.buildEmpty(engineSettings);
  engineRegistry.set(engineInstance, [hotInstance]);
  sharedEngineRegistry.set(engineInstance, [hotInstance.guid]);
  registerNamedExpressions(engineInstance, pluginSettings.namedExpressions);
  engineInstance.on("sheetAdded", function() {
    engineInstance.rebuildAndRecalculate();
  });
  engineInstance.on("sheetRemoved", function() {
    engineInstance.rebuildAndRecalculate();
  });
  return engineInstance;
}
function getRegisteredHotInstances(engine) {
  var _engineRegistry$get;
  var engineRegistry = getEngineRelationshipRegistry();
  var hotInstances = engineRegistry.size === 0 ? [] : Array.from((_engineRegistry$get = engineRegistry.get(engine)) !== null && _engineRegistry$get !== void 0 ? _engineRegistry$get : []);
  return new Map(hotInstances.map(function(hot) {
    return [hot.getPlugin("formulas").sheetId, hot];
  }));
}
function unregisterEngine(engine, hotInstance) {
  if (engine) {
    var engineRegistry = getEngineRelationshipRegistry();
    var engineHotRelationship = engineRegistry.get(engine);
    var sharedEngineRegistry = getSharedEngineUsageRegistry();
    var sharedEngineUsage = sharedEngineRegistry.get(engine);
    if (engineHotRelationship && engineHotRelationship.includes(hotInstance)) {
      engineHotRelationship.splice(engineHotRelationship.indexOf(hotInstance), 1);
      if (engineHotRelationship.length === 0) {
        engineRegistry.delete(engine);
      }
    }
    if (sharedEngineUsage && sharedEngineUsage.includes(hotInstance.guid)) {
      sharedEngineUsage.splice(sharedEngineUsage.indexOf(hotInstance.guid), 1);
      if (sharedEngineUsage.length === 0) {
        sharedEngineRegistry.delete(engine);
        engine.destroy();
      }
    }
  }
}
function registerCustomFunctions(engineClass, customFunctions) {
  if (customFunctions) {
    customFunctions.forEach(function(func) {
      var name = func.name, plugin = func.plugin, translations = func.translations;
      try {
        engineClass.registerFunction(name, plugin, translations);
      } catch (e) {
        warn$1(e.message);
      }
    });
  }
}
function registerLanguage(engineClass, languageSetting) {
  if (languageSetting) {
    var langCode = languageSetting.langCode;
    try {
      engineClass.registerLanguage(langCode, languageSetting);
    } catch (e) {
      warn$1(e.message);
    }
  }
}
function registerNamedExpressions(engineInstance, namedExpressions) {
  if (namedExpressions) {
    engineInstance.suspendEvaluation();
    namedExpressions.forEach(function(namedExp) {
      var name = namedExp.name, expression = namedExp.expression, scope = namedExp.scope, options = namedExp.options;
      try {
        engineInstance.addNamedExpression(name, expression, scope, options);
      } catch (e) {
        warn$1(e.message);
      }
    });
    engineInstance.resumeEvaluation();
  }
}
function setupSheet(engineInstance, sheetName) {
  if (isUndefined$1(sheetName) || !engineInstance.doesSheetExist(sheetName)) {
    sheetName = engineInstance.addSheet(sheetName);
  }
  return sheetName;
}

function isEscapedFormulaExpression(expression) {
  return typeof expression === "string" && expression.charAt(0) === "'" && expression.charAt(1) === "=";
}
function unescapeFormulaExpression(expression) {
  return isEscapedFormulaExpression(expression) ? expression.substr(1) : expression;
}

function _toConsumableArray$r(arr) {
  return _arrayWithoutHoles$p(arr) || _iterableToArray$r(arr) || _unsupportedIterableToArray$_(arr) || _nonIterableSpread$p();
}
function _nonIterableSpread$p() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$r(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$p(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$_(arr);
}
function _typeof$1p(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1p = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1p = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1p(obj);
}
function _slicedToArray$I(arr, i) {
  return _arrayWithHoles$K(arr) || _iterableToArrayLimit$I(arr, i) || _unsupportedIterableToArray$_(arr, i) || _nonIterableRest$K();
}
function _nonIterableRest$K() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$_(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$_(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$_(o, minLen);
}
function _arrayLikeToArray$_(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$I(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$K(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$2n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2h(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2h(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2h(Constructor, staticProps);
  return Constructor;
}
function _get$M(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$M = Reflect.get;
  } else {
    _get$M = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$M(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$M(target, property, receiver || target);
}
function _superPropBase$M(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1c(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$1c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1d(subClass, superClass);
}
function _setPrototypeOf$1d(o, p) {
  _setPrototypeOf$1d = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1d(o, p);
}
function _createSuper$1c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1c(this, result);
  };
}
function _possibleConstructorReturn$1c(self, call) {
  if (call && (_typeof$1p(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1c(self);
}
function _assertThisInitialized$1c(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1c(o) {
  _getPrototypeOf$1c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1c(o);
}
function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classPrivateFieldSet$2(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$2(receiver, privateMap, "set");
  _classApplyDescriptorSet$2(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet$2(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet$2(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$2(receiver, privateMap, "get");
  return _classApplyDescriptorGet$2(receiver, descriptor);
}
function _classExtractFieldDescriptor$2(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet$2(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var PLUGIN_KEY$r = "formulas";
var PLUGIN_PRIORITY$p = 260;
Hooks.getSingleton().register("afterNamedExpressionAdded");
Hooks.getSingleton().register("afterNamedExpressionRemoved");
Hooks.getSingleton().register("afterSheetAdded");
Hooks.getSingleton().register("afterSheetRemoved");
Hooks.getSingleton().register("afterSheetRenamed");
Hooks.getSingleton().register("afterFormulasValuesUpdate");
var _internalOperationPending = /* @__PURE__ */ new WeakMap();
var _hotWasInitializedWithEmptyData = /* @__PURE__ */ new WeakMap();
var _engineListeners = /* @__PURE__ */ new WeakMap();
var Formulas = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$1c(Formulas2, _BasePlugin);
  var _super = _createSuper$1c(Formulas2);
  function Formulas2() {
    var _this;
    _classCallCheck$2n(this, Formulas2);
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(_args));
    _internalOperationPending.set(_assertThisInitialized$1c(_this), {
      writable: true,
      value: false
    });
    _hotWasInitializedWithEmptyData.set(_assertThisInitialized$1c(_this), {
      writable: true,
      value: false
    });
    _engineListeners.set(_assertThisInitialized$1c(_this), {
      writable: true,
      value: [["valuesUpdated", function() {
        var _this2;
        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);
      }], ["namedExpressionAdded", function() {
        var _this3;
        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);
      }], ["namedExpressionRemoved", function() {
        var _this4;
        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);
      }], ["sheetAdded", function() {
        var _this5;
        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);
      }], ["sheetRenamed", function() {
        var _this6;
        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);
      }], ["sheetRemoved", function() {
        var _this7;
        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);
      }]]
    });
    _defineProperty$l(_assertThisInitialized$1c(_this), "staticRegister", staticRegister("formulas"));
    _defineProperty$l(_assertThisInitialized$1c(_this), "engine", null);
    _defineProperty$l(_assertThisInitialized$1c(_this), "sheetName", null);
    return _this;
  }
  _createClass$2h(Formulas2, [{
    key: "sheetId",
    get: function get() {
      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);
    }
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings()[PLUGIN_KEY$r] ? true : false;
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _setupEngine, _this8 = this;
      if (this.enabled) {
        return;
      }
      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;
      if (!this.engine) {
        warn$1("Missing the required `engine` key in the Formulas settings. Please fill it with either an engine class or an engine instance.");
        return;
      }
      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {
        this.sheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());
      }
      this.addHook("beforeLoadData", function() {
        return _this8.onBeforeLoadData.apply(_this8, arguments);
      });
      this.addHook("afterLoadData", function() {
        return _this8.onAfterLoadData.apply(_this8, arguments);
      });
      this.addHook("modifyData", function() {
        return _this8.onModifyData.apply(_this8, arguments);
      });
      this.addHook("modifySourceData", function() {
        return _this8.onModifySourceData.apply(_this8, arguments);
      });
      this.addHook("beforeValidate", function() {
        return _this8.onBeforeValidate.apply(_this8, arguments);
      });
      this.addHook("afterSetSourceDataAtCell", function() {
        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);
      });
      this.addHook("afterSetDataAtCell", function() {
        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);
      });
      this.addHook("afterSetDataAtRowProp", function() {
        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);
      });
      this.addHook("beforeCreateRow", function() {
        return _this8.onBeforeCreateRow.apply(_this8, arguments);
      });
      this.addHook("beforeCreateCol", function() {
        return _this8.onBeforeCreateCol.apply(_this8, arguments);
      });
      this.addHook("afterCreateRow", function() {
        return _this8.onAfterCreateRow.apply(_this8, arguments);
      });
      this.addHook("afterCreateCol", function() {
        return _this8.onAfterCreateCol.apply(_this8, arguments);
      });
      this.addHook("beforeRemoveRow", function() {
        return _this8.onBeforeRemoveRow.apply(_this8, arguments);
      });
      this.addHook("beforeRemoveCol", function() {
        return _this8.onBeforeRemoveCol.apply(_this8, arguments);
      });
      this.addHook("afterRemoveRow", function() {
        return _this8.onAfterRemoveRow.apply(_this8, arguments);
      });
      this.addHook("afterRemoveCol", function() {
        return _this8.onAfterRemoveCol.apply(_this8, arguments);
      });
      var autofillHooks = createAutofillHooks(this);
      this.addHook("beforeAutofill", autofillHooks.beforeAutofill);
      this.addHook("afterAutofill", autofillHooks.afterAutofill);
      _classPrivateFieldGet$2(this, _engineListeners).forEach(function(_ref) {
        var _ref2 = _slicedToArray$I(_ref, 2), eventName = _ref2[0], listener = _ref2[1];
        return _this8.engine.on(eventName, listener);
      });
      _get$M(_getPrototypeOf$1c(Formulas2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this9 = this;
      _classPrivateFieldGet$2(this, _engineListeners).forEach(function(_ref3) {
        var _ref4 = _slicedToArray$I(_ref3, 2), eventName = _ref4[0], listener = _ref4[1];
        return _this9.engine.off(eventName, listener);
      });
      unregisterEngine(this.engine, this.hot);
      _get$M(_getPrototypeOf$1c(Formulas2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin(newSettings) {
      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$r];
      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {
        this.switchSheet(pluginSettings.sheetName);
      }
      if (!newSettings.data && this.sheetName === null) {
        var sheetName = this.hot.getSettings()[PLUGIN_KEY$r].sheetName;
        if (sheetName && this.engine.doesSheetExist(sheetName)) {
          this.switchSheet(this.sheetName);
        } else {
          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());
        }
      }
      _get$M(_getPrototypeOf$1c(Formulas2.prototype), "updatePlugin", this).call(this, newSettings);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this10 = this;
      _classPrivateFieldGet$2(this, _engineListeners).forEach(function(_ref5) {
        var _this10$engine;
        var _ref6 = _slicedToArray$I(_ref5, 2), eventName = _ref6[0], listener = _ref6[1];
        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);
      });
      _classPrivateFieldSet$2(this, _engineListeners, null);
      unregisterEngine(this.engine, this.hot);
      _get$M(_getPrototypeOf$1c(Formulas2.prototype), "destroy", this).call(this);
    }
  }, {
    key: "getPhysicalIndexPosition",
    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {
      if (!contained) {
        if (visualIndex >= entriesCount) {
          return sourceEntriesCount + (visualIndex - entriesCount);
        }
      }
      return physicalIndex;
    }
  }, {
    key: "toPhysicalRowPosition",
    value: function toPhysicalRowPosition(row) {
      var contained = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);
    }
  }, {
    key: "toPhysicalColumnPosition",
    value: function toPhysicalColumnPosition(column) {
      var contained = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);
    }
  }, {
    key: "addSheet",
    value: function addSheet(sheetName, sheetData) {
      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {
        warn$1("The provided data should be an array of arrays.");
        return false;
      }
      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {
        warn$1("Sheet with the provided name already exists.");
        return false;
      }
      try {
        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);
        if (sheetData) {
          this.engine.setSheetContent(actualSheetName, sheetData);
        }
        return actualSheetName;
      } catch (e) {
        warn$1(e.message);
        return false;
      }
    }
  }, {
    key: "switchSheet",
    value: function switchSheet(sheetName) {
      if (!this.engine.doesSheetExist(sheetName)) {
        error("The sheet named `".concat(sheetName, "` does not exist, switch aborted."));
        return;
      }
      this.sheetName = sheetName;
      var serialized = this.engine.getSheetSerialized(this.sheetId);
      if (serialized.length > 0) {
        this.hot.loadData(serialized, "".concat(toUpperCaseFirst(PLUGIN_KEY$r), ".switchSheet"));
      }
    }
  }, {
    key: "getCellType",
    value: function getCellType(row, column) {
      var sheet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.sheetId;
      return this.engine.getCellType({
        sheet,
        row: this.hot.toPhysicalRow(row),
        col: this.hot.toPhysicalColumn(column)
      });
    }
  }, {
    key: "isFormulaCellType",
    value: function isFormulaCellType(row, column) {
      var sheet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.sheetId;
      var cellType = this.getCellType(row, column, sheet);
      return cellType === "FORMULA" || cellType === "MATRIX";
    }
  }, {
    key: "renderDependentSheets",
    value: function renderDependentSheets(dependentCells) {
      var _this11 = this;
      var renderSelf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var affectedSheetIds = new Set();
      dependentCells.forEach(function(change) {
        var _change$address;
        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;
        if (sheetId !== void 0) {
          if (!affectedSheetIds.has(sheetId)) {
            affectedSheetIds.add(sheetId);
          }
        }
      });
      getRegisteredHotInstances(this.engine).forEach(function(relatedHot, sheetId) {
        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {
          var _relatedHot$view;
          relatedHot.render();
          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();
        }
      });
    }
  }, {
    key: "validateDependentCells",
    value: function validateDependentCells(dependentCells) {
      var _this12 = this;
      var changedCells = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var stringifyAddress = function stringifyAddress2(change) {
        var _change$address2;
        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {}, row = _ref7.row, col = _ref7.col, sheet = _ref7.sheet;
        return isDefined(sheet) ? "".concat(sheet, ":").concat(row, "x").concat(col) : "";
      };
      var changedCellsSet = new Set(changedCells.map(function(change) {
        return stringifyAddress(change);
      }));
      dependentCells.forEach(function(change) {
        var _change$address3, _change$address4;
        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {}, row = _ref8.row, col = _ref8.col;
        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;
        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null;
        if (visualRow === null || visualColumn === null) {
          return;
        }
        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;
        var addressId = stringifyAddress(change);
        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {
          var hot = getRegisteredHotInstances(_this12.engine).get(sheetId);
          hot.validateCell(hot.getDataAtCell(visualRow, visualColumn), hot.getCellMeta(visualRow, visualColumn), function() {
          });
        }
      });
    }
  }, {
    key: "syncChangeWithEngine",
    value: function syncChangeWithEngine(row, column, newValue) {
      var address = {
        row: this.toPhysicalRowPosition(row),
        col: this.toPhysicalColumnPosition(column),
        sheet: this.sheetId
      };
      if (!this.engine.isItPossibleToSetCellContents(address)) {
        warn$1("Not possible to set cell data at ".concat(JSON.stringify(address)));
        return;
      }
      return this.engine.setCellContents(address, newValue);
    }
  }, {
    key: "onBeforeValidate",
    value: function onBeforeValidate(value, visualRow, prop) {
      var visualColumn = this.hot.propToCol(prop);
      if (this.isFormulaCellType(visualRow, visualColumn)) {
        var address = {
          row: this.hot.toPhysicalRow(visualRow),
          col: this.hot.toPhysicalColumn(visualColumn),
          sheet: this.sheetId
        };
        var cellValue = this.engine.getCellValue(address);
        return _typeof$1p(cellValue) === "object" && cellValue !== null ? cellValue.value : cellValue;
      }
      return value;
    }
  }, {
    key: "onBeforeLoadData",
    value: function onBeforeLoadData(sourceData, initialLoad) {
      var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      if (source.includes(toUpperCaseFirst(PLUGIN_KEY$r))) {
        return;
      }
      _classPrivateFieldSet$2(this, _hotWasInitializedWithEmptyData, isUndefined$1(this.hot.getSettings().data));
    }
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(sourceData, initialLoad) {
      var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      if (source.includes(toUpperCaseFirst(PLUGIN_KEY$r))) {
        return;
      }
      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY$r].sheetName);
      if (!_classPrivateFieldGet$2(this, _hotWasInitializedWithEmptyData)) {
        var sourceDataArray = this.hot.getSourceDataArray();
        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetName, sourceDataArray)) {
          _classPrivateFieldSet$2(this, _internalOperationPending, true);
          var dependentCells = this.engine.setSheetContent(this.sheetName, this.hot.getSourceDataArray());
          this.renderDependentSheets(dependentCells);
          _classPrivateFieldSet$2(this, _internalOperationPending, false);
        }
      } else {
        this.switchSheet(this.sheetName);
      }
    }
  }, {
    key: "onModifyData",
    value: function onModifyData(row, column, valueHolder, ioMode) {
      if (ioMode !== "get" || _classPrivateFieldGet$2(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {
        return;
      }
      var isFormulaCellType = this.isFormulaCellType(this.hot.toVisualRow(row), column);
      if (!isFormulaCellType) {
        if (isEscapedFormulaExpression(valueHolder.value)) {
          valueHolder.value = unescapeFormulaExpression(valueHolder.value);
        }
        return;
      }
      var address = {
        row,
        col: this.toPhysicalColumnPosition(column),
        sheet: this.sheetId
      };
      var cellValue = this.engine.getCellValue(address);
      var value = _typeof$1p(cellValue) === "object" && cellValue !== null ? cellValue.value : cellValue;
      valueHolder.value = value;
    }
  }, {
    key: "onModifySourceData",
    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {
      if (ioMode !== "get" || _classPrivateFieldGet$2(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {
        return;
      }
      var visualColumn = this.hot.propToCol(columnOrProp);
      var isFormulaCellType = this.isFormulaCellType(this.hot.toVisualRow(row), visualColumn);
      if (!isFormulaCellType) {
        return;
      }
      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));
      if (dimensions.width === 0 && dimensions.height === 0) {
        return;
      }
      var address = {
        row,
        col: this.toPhysicalColumnPosition(visualColumn),
        sheet: this.sheetId
      };
      valueHolder.value = this.engine.getCellSerialized(address);
    }
  }, {
    key: "onAfterSetDataAtCell",
    value: function onAfterSetDataAtCell(changes) {
      var _this13 = this;
      var dependentCells = [];
      var outOfBoundsChanges = [];
      var changedCells = [];
      changes.forEach(function(_ref9) {
        var _ref10 = _slicedToArray$I(_ref9, 4), row = _ref10[0], prop = _ref10[1], newValue = _ref10[3];
        var column = _this13.hot.propToCol(prop);
        var physicalRow = _this13.hot.toPhysicalRow(row);
        var physicalColumn = _this13.hot.toPhysicalColumn(column);
        var address = {
          row: physicalRow,
          col: physicalColumn,
          sheet: _this13.sheetId
        };
        if (physicalRow !== null && physicalColumn !== null) {
          dependentCells.push.apply(dependentCells, _toConsumableArray$r(_this13.syncChangeWithEngine(row, column, newValue)));
        } else {
          outOfBoundsChanges.push([row, column, newValue]);
        }
        changedCells.push({
          address
        });
      });
      if (outOfBoundsChanges.length) {
        this.hot.addHookOnce("afterChange", function() {
          var outOfBoundsDependentCells = [];
          outOfBoundsChanges.forEach(function(_ref11) {
            var _ref12 = _slicedToArray$I(_ref11, 3), row = _ref12[0], column = _ref12[1], newValue = _ref12[2];
            outOfBoundsDependentCells.push.apply(outOfBoundsDependentCells, _toConsumableArray$r(_this13.syncChangeWithEngine(row, column, newValue)));
          });
          _this13.renderDependentSheets(outOfBoundsDependentCells, true);
        });
      }
      this.renderDependentSheets(dependentCells);
      this.validateDependentCells(dependentCells, changedCells);
    }
  }, {
    key: "onAfterSetSourceDataAtCell",
    value: function onAfterSetSourceDataAtCell(changes) {
      var _this14 = this;
      var dependentCells = [];
      var changedCells = [];
      changes.forEach(function(_ref13) {
        var _ref14 = _slicedToArray$I(_ref13, 4), row = _ref14[0], column = _ref14[1], newValue = _ref14[3];
        var address = {
          row,
          col: _this14.toPhysicalColumnPosition(column),
          sheet: _this14.sheetId
        };
        if (!_this14.engine.isItPossibleToSetCellContents(address)) {
          warn$1("Not possible to set source cell data at ".concat(JSON.stringify(address)));
          return;
        }
        changedCells.push({
          address
        });
        dependentCells.push.apply(dependentCells, _toConsumableArray$r(_this14.engine.setCellContents(address, newValue)));
      });
      this.renderDependentSheets(dependentCells);
      this.validateDependentCells(dependentCells, changedCells);
    }
  }, {
    key: "onBeforeCreateRow",
    value: function onBeforeCreateRow(row, amount) {
      if (!this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {
        return false;
      }
    }
  }, {
    key: "onBeforeCreateCol",
    value: function onBeforeCreateCol(col, amount) {
      if (!this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {
        return false;
      }
    }
  }, {
    key: "onBeforeRemoveRow",
    value: function onBeforeRemoveRow(row, amount, physicalRows) {
      var _this15 = this;
      var possible = physicalRows.every(function(physicalRow) {
        return _this15.engine.isItPossibleToRemoveRows(_this15.sheetId, [physicalRow, 1]);
      });
      return possible === false ? false : void 0;
    }
  }, {
    key: "onBeforeRemoveCol",
    value: function onBeforeRemoveCol(col, amount, physicalColumns) {
      var _this16 = this;
      var possible = physicalColumns.every(function(physicalColumn) {
        return _this16.engine.isItPossibleToRemoveColumns(_this16.sheetId, [physicalColumn, 1]);
      });
      return possible === false ? false : void 0;
    }
  }, {
    key: "onAfterCreateRow",
    value: function onAfterCreateRow(row, amount) {
      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);
      this.renderDependentSheets(changes);
    }
  }, {
    key: "onAfterCreateCol",
    value: function onAfterCreateCol(col, amount) {
      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);
      this.renderDependentSheets(changes);
    }
  }, {
    key: "onAfterRemoveRow",
    value: function onAfterRemoveRow(row, amount, physicalRows) {
      var _this17 = this;
      var descendingPhysicalRows = physicalRows.sort().reverse();
      var changes = this.engine.batch(function() {
        descendingPhysicalRows.forEach(function(physicalRow) {
          _this17.engine.removeRows(_this17.sheetId, [physicalRow, 1]);
        });
      });
      this.renderDependentSheets(changes);
    }
  }, {
    key: "onAfterRemoveCol",
    value: function onAfterRemoveCol(col, amount, physicalColumns) {
      var _this18 = this;
      var descendingPhysicalColumns = physicalColumns.sort().reverse();
      var changes = this.engine.batch(function() {
        descendingPhysicalColumns.forEach(function(physicalColumn) {
          _this18.engine.removeColumns(_this18.sheetId, [physicalColumn, 1]);
        });
      });
      this.renderDependentSheets(changes);
    }
  }, {
    key: "onEngineValuesUpdated",
    value: function onEngineValuesUpdated(changes) {
      this.hot.runHooks("afterFormulasValuesUpdate", changes);
    }
  }, {
    key: "onEngineNamedExpressionsAdded",
    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {
      this.hot.runHooks("afterNamedExpressionAdded", namedExpressionName, changes);
    }
  }, {
    key: "onEngineNamedExpressionsRemoved",
    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {
      this.hot.runHooks("afterNamedExpressionRemoved", namedExpressionName, changes);
    }
  }, {
    key: "onEngineSheetAdded",
    value: function onEngineSheetAdded(addedSheetDisplayName) {
      this.hot.runHooks("afterSheetAdded", addedSheetDisplayName);
    }
  }, {
    key: "onEngineSheetRenamed",
    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {
      this.hot.runHooks("afterSheetRenamed", oldDisplayName, newDisplayName);
    }
  }, {
    key: "onEngineSheetRemoved",
    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {
      this.hot.runHooks("afterSheetRemoved", removedSheetDisplayName, changes);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$r;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$p;
    }
  }]);
  return Formulas2;
}(BasePlugin);

function createDefaultHeaderSettings() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$label = _ref.label, label = _ref$label === void 0 ? "" : _ref$label, _ref$colspan = _ref.colspan, colspan = _ref$colspan === void 0 ? 1 : _ref$colspan, _ref$origColspan = _ref.origColspan, origColspan = _ref$origColspan === void 0 ? 1 : _ref$origColspan, _ref$collapsible = _ref.collapsible, collapsible = _ref$collapsible === void 0 ? false : _ref$collapsible, _ref$crossHiddenColum = _ref.crossHiddenColumns, crossHiddenColumns = _ref$crossHiddenColum === void 0 ? [] : _ref$crossHiddenColum, _ref$isCollapsed = _ref.isCollapsed, isCollapsed = _ref$isCollapsed === void 0 ? false : _ref$isCollapsed, _ref$isHidden = _ref.isHidden, isHidden = _ref$isHidden === void 0 ? false : _ref$isHidden, _ref$isRoot = _ref.isRoot, isRoot = _ref$isRoot === void 0 ? false : _ref$isRoot, _ref$isPlaceholder = _ref.isPlaceholder, isPlaceholder = _ref$isPlaceholder === void 0 ? false : _ref$isPlaceholder;
  return {
    label,
    colspan,
    origColspan,
    collapsible,
    isCollapsed,
    crossHiddenColumns,
    isHidden,
    isRoot,
    isPlaceholder
  };
}
function createPlaceholderHeaderSettings() {
  return {
    label: "",
    isPlaceholder: true
  };
}

function _toConsumableArray$s(arr) {
  return _arrayWithoutHoles$q(arr) || _iterableToArray$s(arr) || _unsupportedIterableToArray$$(arr) || _nonIterableSpread$q();
}
function _nonIterableSpread$q() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$$(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$$(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$$(o, minLen);
}
function _iterableToArray$s(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$q(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$$(arr);
}
function _arrayLikeToArray$$(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function normalizeSettings(sourceSettings) {
  var columnsLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
  var normalizedSettings = [];
  if (columnsLimit === 0) {
    return normalizedSettings;
  }
  arrayEach(sourceSettings, function(headersSettings) {
    var columns = [];
    var columnIndex = 0;
    normalizedSettings.push(columns);
    arrayEach(headersSettings, function(sourceHeaderSettings) {
      var headerSettings = createDefaultHeaderSettings();
      if (isObject(sourceHeaderSettings)) {
        var label = sourceHeaderSettings.label, colspan = sourceHeaderSettings.colspan;
        headerSettings.label = stringify(label);
        if (typeof colspan === "number" && colspan > 1) {
          headerSettings.colspan = colspan;
          headerSettings.origColspan = colspan;
        }
      } else {
        headerSettings.label = stringify(sourceHeaderSettings);
      }
      columnIndex += headerSettings.origColspan;
      var cancelProcessing = false;
      if (columnIndex >= columnsLimit) {
        headerSettings.colspan = headerSettings.origColspan - (columnIndex - columnsLimit);
        headerSettings.origColspan = headerSettings.colspan;
        cancelProcessing = true;
      }
      columns.push(headerSettings);
      if (headerSettings.colspan > 1) {
        for (var i = 0; i < headerSettings.colspan - 1; i++) {
          columns.push(createPlaceholderHeaderSettings());
        }
      }
      return !cancelProcessing;
    });
  });
  var columnsLength = Math.max.apply(Math, _toConsumableArray$s(arrayMap(normalizedSettings, function(headersSettings) {
    return headersSettings.length;
  })));
  arrayEach(normalizedSettings, function(headersSettings) {
    if (headersSettings.length < columnsLength) {
      var defaultSettings = arrayMap(new Array(columnsLength - headersSettings.length), function() {
        return createDefaultHeaderSettings();
      });
      headersSettings.splice.apply(headersSettings, [headersSettings.length, 0].concat(_toConsumableArray$s(defaultSettings)));
    }
  });
  return normalizedSettings;
}

var _excluded$6 = ["row", "col"];
function ownKeys$b(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$b(Object(source), true).forEach(function(key) {
        _defineProperty$m(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$b(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$m(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$2o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2i(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2i(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2i(Constructor, staticProps);
  return Constructor;
}
function _classPrivateFieldGet$3(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$3(receiver, privateMap, "get");
  return _classApplyDescriptorGet$3(receiver, descriptor);
}
function _classApplyDescriptorGet$3(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$3(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$3(receiver, privateMap, "set");
  _classApplyDescriptorSet$3(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$3(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$3(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var HEADER_CONFIGURABLE_PROPS = ["label", "collapsible"];
var _data = /* @__PURE__ */ new WeakMap();
var _dataLength = /* @__PURE__ */ new WeakMap();
var _columnsLimit = /* @__PURE__ */ new WeakMap();
var SourceSettings = /* @__PURE__ */ function() {
  function SourceSettings2() {
    _classCallCheck$2o(this, SourceSettings2);
    _data.set(this, {
      writable: true,
      value: []
    });
    _dataLength.set(this, {
      writable: true,
      value: 0
    });
    _columnsLimit.set(this, {
      writable: true,
      value: Infinity
    });
  }
  _createClass$2i(SourceSettings2, [{
    key: "setColumnsLimit",
    value: function setColumnsLimit(columnsCount) {
      _classPrivateFieldSet$3(this, _columnsLimit, columnsCount);
    }
  }, {
    key: "setData",
    value: function setData() {
      var nestedHeadersSettings = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      _classPrivateFieldSet$3(this, _data, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet$3(this, _columnsLimit)));
      _classPrivateFieldSet$3(this, _dataLength, _classPrivateFieldGet$3(this, _data).length);
    }
  }, {
    key: "getData",
    value: function getData() {
      return _classPrivateFieldGet$3(this, _data);
    }
  }, {
    key: "mergeWith",
    value: function mergeWith(additionalSettings) {
      var _this = this;
      arrayEach(additionalSettings, function(_ref) {
        var row = _ref.row, col = _ref.col, rest = _objectWithoutProperties$6(_ref, _excluded$6);
        var headerSettings = _this.getHeaderSettings(row, col);
        if (headerSettings !== null) {
          extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);
        }
      });
    }
  }, {
    key: "map",
    value: function map(callback) {
      arrayEach(_classPrivateFieldGet$3(this, _data), function(header) {
        arrayEach(header, function(headerSettings) {
          var propsToExtend = callback(_objectSpread$b({}, headerSettings));
          if (isObject(propsToExtend)) {
            extend(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);
          }
        });
      });
    }
  }, {
    key: "getHeaderSettings",
    value: function getHeaderSettings(headerLevel, columnIndex) {
      var _headersSettings$colu;
      if (headerLevel >= _classPrivateFieldGet$3(this, _dataLength) || headerLevel < 0) {
        return null;
      }
      var headersSettings = _classPrivateFieldGet$3(this, _data)[headerLevel];
      if (columnIndex >= headersSettings.length) {
        return null;
      }
      return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;
    }
  }, {
    key: "getHeadersSettings",
    value: function getHeadersSettings(headerLevel, columnIndex) {
      var columnsLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var headersSettingsChunks = [];
      if (headerLevel >= _classPrivateFieldGet$3(this, _dataLength) || headerLevel < 0) {
        return headersSettingsChunks;
      }
      var headersSettings = _classPrivateFieldGet$3(this, _data)[headerLevel];
      var currentLength = 0;
      for (var i = columnIndex; i < headersSettings.length; i++) {
        var headerSettings = headersSettings[i];
        if (headerSettings.isPlaceholder) {
          throw new Error("The first column settings cannot overlap the other header layers");
        }
        currentLength += headerSettings.colspan;
        headersSettingsChunks.push(headerSettings);
        if (headerSettings.colspan > 1) {
          i += headerSettings.colspan - 1;
        }
        if (currentLength === columnsLength) {
          break;
        }
        if (currentLength > columnsLength) {
          throw new Error("The last column settings cannot overlap the other header layers");
        }
      }
      return headersSettingsChunks;
    }
  }, {
    key: "getLayersCount",
    value: function getLayersCount() {
      return _classPrivateFieldGet$3(this, _dataLength);
    }
  }, {
    key: "getColumnsCount",
    value: function getColumnsCount() {
      return _classPrivateFieldGet$3(this, _dataLength) > 0 ? _classPrivateFieldGet$3(this, _data)[0].length : 0;
    }
  }, {
    key: "clear",
    value: function clear() {
      _classPrivateFieldSet$3(this, _data, []);
      _classPrivateFieldSet$3(this, _dataLength, 0);
    }
  }]);
  return SourceSettings2;
}();

function ownKeys$c(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$c(Object(source), true).forEach(function(key) {
        _defineProperty$n(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$c(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _classCallCheck$2p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2j(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2j(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2j(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2j(Constructor, staticProps);
  return Constructor;
}
function _defineProperty$n(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toConsumableArray$t(arr) {
  return _arrayWithoutHoles$r(arr) || _iterableToArray$t(arr) || _unsupportedIterableToArray$10(arr) || _nonIterableSpread$r();
}
function _nonIterableSpread$r() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$10(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$10(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$10(o, minLen);
}
function _iterableToArray$t(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$r(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$10(arr);
}
function _arrayLikeToArray$10(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var TRAVERSAL_DF_PRE = "DF-pre-order";
function depthFirstPreOrder(callback, context) {
  var continueTraverse = callback.call(context, this);
  for (var i = 0; i < this.childs.length; i++) {
    if (continueTraverse === false) {
      return false;
    }
    continueTraverse = depthFirstPreOrder.call(this.childs[i], callback, context);
  }
  return continueTraverse;
}
var TRAVERSAL_DF_POST = "DF-post-order";
function depthFirstPostOrder(callback, context) {
  for (var i = 0; i < this.childs.length; i++) {
    var continueTraverse = depthFirstPostOrder.call(this.childs[i], callback, context);
    if (continueTraverse === false) {
      return false;
    }
  }
  return callback.call(context, this);
}
var TRAVERSAL_BF = "BF";
function breadthFirst(callback, context) {
  var queue = [this];
  function process() {
    if (queue.length === 0) {
      return;
    }
    var node = queue.shift();
    queue.push.apply(queue, _toConsumableArray$t(node.childs));
    if (callback.call(context, node) !== false) {
      process();
    }
  }
  process();
}
var DEFAULT_TRAVERSAL_STRATEGY = TRAVERSAL_BF;
var TRAVERSAL_STRATEGIES = new Map([[TRAVERSAL_DF_PRE, depthFirstPreOrder], [TRAVERSAL_DF_POST, depthFirstPostOrder], [TRAVERSAL_BF, breadthFirst]]);
var TreeNode = /* @__PURE__ */ function() {
  function TreeNode2(data) {
    _classCallCheck$2p(this, TreeNode2);
    _defineProperty$n(this, "data", {});
    _defineProperty$n(this, "parent", null);
    _defineProperty$n(this, "childs", []);
    this.data = data;
  }
  _createClass$2j(TreeNode2, [{
    key: "addChild",
    value: function addChild(node) {
      node.parent = this;
      this.childs.push(node);
    }
  }, {
    key: "cloneTree",
    value: function cloneTree() {
      var nodeTree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
      var clonedNode = new TreeNode2(_objectSpread$c({}, nodeTree.data));
      for (var i = 0; i < nodeTree.childs.length; i++) {
        clonedNode.addChild(this.cloneTree(nodeTree.childs[i]));
      }
      return clonedNode;
    }
  }, {
    key: "replaceTreeWith",
    value: function replaceTreeWith(nodeTree) {
      this.data = _objectSpread$c({}, nodeTree.data);
      this.childs = [];
      for (var i = 0; i < nodeTree.childs.length; i++) {
        this.addChild(nodeTree.childs[i]);
      }
    }
  }, {
    key: "walkDown",
    value: function walkDown(callback) {
      var traversalStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_TRAVERSAL_STRATEGY;
      if (!TRAVERSAL_STRATEGIES.has(traversalStrategy)) {
        throw new Error('Traversal strategy "'.concat(traversalStrategy, '" does not exist'));
      }
      TRAVERSAL_STRATEGIES.get(traversalStrategy).call(this, callback, this);
    }
  }, {
    key: "walkUp",
    value: function walkUp(callback) {
      var context = this;
      var process = function process2(node) {
        var continueTraverse = callback.call(context, node);
        if (continueTraverse !== false && node.parent !== null) {
          process2(node.parent);
        }
      };
      process(this);
    }
  }]);
  return TreeNode2;
}();

function ownKeys$d(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$d(Object(source), true).forEach(function(key) {
        _defineProperty$o(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$d(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$o(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$J(arr, i) {
  return _arrayWithHoles$L(arr) || _iterableToArrayLimit$J(arr, i) || _unsupportedIterableToArray$11(arr, i) || _nonIterableRest$L();
}
function _nonIterableRest$L() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$11(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$11(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$11(o, minLen);
}
function _arrayLikeToArray$11(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$J(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$L(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$2q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2k(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2k(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2k(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2k(Constructor, staticProps);
  return Constructor;
}
function _classPrivateFieldGet$4(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$4(receiver, privateMap, "get");
  return _classApplyDescriptorGet$4(receiver, descriptor);
}
function _classApplyDescriptorGet$4(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$4(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$4(receiver, privateMap, "set");
  _classApplyDescriptorSet$4(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$4(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$4(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _rootNodes = /* @__PURE__ */ new WeakMap();
var _rootsIndex = /* @__PURE__ */ new WeakMap();
var _sourceSettings = /* @__PURE__ */ new WeakMap();
var HeadersTree = /* @__PURE__ */ function() {
  function HeadersTree2(sourceSettings) {
    _classCallCheck$2q(this, HeadersTree2);
    _rootNodes.set(this, {
      writable: true,
      value: new Map()
    });
    _rootsIndex.set(this, {
      writable: true,
      value: new Map()
    });
    _sourceSettings.set(this, {
      writable: true,
      value: null
    });
    _classPrivateFieldSet$4(this, _sourceSettings, sourceSettings);
  }
  _createClass$2k(HeadersTree2, [{
    key: "getRoots",
    value: function getRoots() {
      return Array.from(_classPrivateFieldGet$4(this, _rootNodes).values());
    }
  }, {
    key: "getRootByColumn",
    value: function getRootByColumn(columnIndex) {
      var node;
      if (_classPrivateFieldGet$4(this, _rootsIndex).has(columnIndex)) {
        node = _classPrivateFieldGet$4(this, _rootNodes).get(_classPrivateFieldGet$4(this, _rootsIndex).get(columnIndex));
      }
      return node;
    }
  }, {
    key: "getNode",
    value: function getNode(headerLevel, columnIndex) {
      var rootNode = this.getRootByColumn(columnIndex);
      if (!rootNode) {
        return;
      }
      var normColumnIndex = columnIndex - _classPrivateFieldGet$4(this, _rootsIndex).get(columnIndex);
      var columnCursor = 0;
      var treeNode;
      rootNode.walkDown(function(node) {
        var _node$data = node.data, origColspan = _node$data.origColspan, nodeHeaderLevel = _node$data.headerLevel;
        if (headerLevel === nodeHeaderLevel) {
          if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {
            treeNode = node;
            return false;
          }
          columnCursor += origColspan;
        }
      });
      return treeNode;
    }
  }, {
    key: "rebuildTreeIndex",
    value: function rebuildTreeIndex() {
      var _this = this;
      var columnIndex = 0;
      _classPrivateFieldGet$4(this, _rootsIndex).clear();
      arrayEach(_classPrivateFieldGet$4(this, _rootNodes), function(_ref) {
        var _ref2 = _slicedToArray$J(_ref, 2), colspan = _ref2[1].data.colspan;
        for (var i = columnIndex; i < columnIndex + colspan; i++) {
          _classPrivateFieldGet$4(_this, _rootsIndex).set(i, columnIndex);
        }
        columnIndex += colspan;
      });
    }
  }, {
    key: "buildTree",
    value: function buildTree() {
      this.clear();
      var columnsCount = _classPrivateFieldGet$4(this, _sourceSettings).getColumnsCount();
      var columnIndex = 0;
      while (columnIndex < columnsCount) {
        var columnSettings = _classPrivateFieldGet$4(this, _sourceSettings).getHeaderSettings(0, columnIndex);
        var rootNode = new TreeNode();
        _classPrivateFieldGet$4(this, _rootNodes).set(columnIndex, rootNode);
        this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);
        columnIndex += columnSettings.origColspan;
      }
      this.rebuildTreeIndex();
    }
  }, {
    key: "buildLeaves",
    value: function buildLeaves(parentNode, columnIndex, headerLevel) {
      var _this2 = this;
      var extractionLength = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      var columnsSettings = _classPrivateFieldGet$4(this, _sourceSettings).getHeadersSettings(headerLevel, columnIndex, extractionLength);
      headerLevel += 1;
      arrayEach(columnsSettings, function(columnSettings) {
        var nodeData = _objectSpread$d(_objectSpread$d({}, columnSettings), {}, {
          headerLevel: headerLevel - 1,
          columnIndex
        });
        var node;
        if (headerLevel === 1) {
          parentNode.data = nodeData;
          node = parentNode;
        } else {
          node = new TreeNode(nodeData);
          parentNode.addChild(node);
        }
        if (headerLevel < _classPrivateFieldGet$4(_this2, _sourceSettings).getLayersCount()) {
          _this2.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);
        }
        columnIndex += columnSettings.origColspan;
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      _classPrivateFieldGet$4(this, _rootNodes).clear();
      _classPrivateFieldGet$4(this, _rootsIndex).clear();
    }
  }]);
  return HeadersTree2;
}();

function traverseHiddenNodeColumnIndexes(node, callback) {
  node.walkDown(function(_ref) {
    var data = _ref.data, childs = _ref.childs;
    if (!data.isHidden) {
      callback(data.columnIndex);
      if (childs.length === 0) {
        for (var i = 1; i < data.colspan; i++) {
          callback(data.columnIndex + i);
        }
      }
    }
  });
}
function getFirstChildProperty(_ref2, propertyName) {
  var childs = _ref2.childs;
  if (childs.length === 0) {
    return;
  }
  return childs[0].data[propertyName];
}
function isNodeReflectsFirstChildColspan(node) {
  return getFirstChildProperty(node, "origColspan") === node.data.origColspan;
}

function expandNode(nodeToProcess) {
  var nodeData = nodeToProcess.data, nodeChilds = nodeToProcess.childs;
  if (!nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {
    return {
      rollbackModification: function rollbackModification() {
      },
      affectedColumns: [],
      colspanCompensation: 0
    };
  }
  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);
  if (isNodeReflected) {
    return expandNode(nodeChilds[0]);
  }
  nodeData.isCollapsed = false;
  var allLeavesExceptMostLeft = nodeChilds.slice(1);
  var affectedColumns = new Set();
  var colspanCompensation = 0;
  if (allLeavesExceptMostLeft.length > 0) {
    arrayEach(allLeavesExceptMostLeft, function(node) {
      node.replaceTreeWith(node.data.clonedTree);
      node.data.clonedTree = null;
      var leafData = node.data;
      colspanCompensation += leafData.colspan;
      traverseHiddenNodeColumnIndexes(node, function(gridColumnIndex) {
        affectedColumns.add(gridColumnIndex);
      });
    });
  } else {
    var colspan = nodeData.colspan, origColspan = nodeData.origColspan, columnIndex = nodeData.columnIndex;
    colspanCompensation = origColspan - colspan;
    for (var i = 1; i < origColspan; i++) {
      affectedColumns.add(columnIndex + i);
    }
  }
  nodeToProcess.walkUp(function(node) {
    var data = node.data;
    data.colspan += colspanCompensation;
    if (data.colspan >= data.origColspan) {
      data.colspan = data.origColspan;
      data.isCollapsed = false;
    } else if (isNodeReflectsFirstChildColspan(node)) {
      data.isCollapsed = getFirstChildProperty(node, "isCollapsed");
    }
  });
  return {
    rollbackModification: function rollbackModification() {
      return collapseNode(nodeToProcess);
    },
    affectedColumns: Array.from(affectedColumns),
    colspanCompensation
  };
}

function collapseNode(nodeToProcess) {
  var _getFirstChildPropert;
  var nodeData = nodeToProcess.data, nodeChilds = nodeToProcess.childs;
  if (nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {
    return {
      rollbackModification: function rollbackModification() {
      },
      affectedColumns: [],
      colspanCompensation: 0
    };
  }
  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);
  if (isNodeReflected) {
    return collapseNode(nodeChilds[0]);
  }
  nodeData.isCollapsed = true;
  var allLeavesExceptMostLeft = nodeChilds.slice(1);
  var affectedColumns = new Set();
  if (allLeavesExceptMostLeft.length > 0) {
    arrayEach(allLeavesExceptMostLeft, function(node) {
      traverseHiddenNodeColumnIndexes(node, function(gridColumnIndex2) {
        affectedColumns.add(gridColumnIndex2);
      });
      node.data.clonedTree = node.cloneTree();
      node.walkDown(function(_ref) {
        var data = _ref.data;
        data.isHidden = true;
      });
    });
  } else {
    var origColspan = nodeData.origColspan, columnIndex = nodeData.columnIndex;
    for (var i = 1; i < origColspan; i++) {
      var gridColumnIndex = columnIndex + i;
      affectedColumns.add(gridColumnIndex);
    }
  }
  var colspanCompensation = nodeData.colspan - ((_getFirstChildPropert = getFirstChildProperty(nodeToProcess, "colspan")) !== null && _getFirstChildPropert !== void 0 ? _getFirstChildPropert : 1);
  nodeToProcess.walkUp(function(node) {
    var data = node.data;
    data.colspan -= colspanCompensation;
    if (data.colspan <= 1) {
      data.colspan = 1;
      data.isCollapsed = true;
    } else if (isNodeReflectsFirstChildColspan(node)) {
      data.isCollapsed = getFirstChildProperty(node, "isCollapsed");
    }
  });
  return {
    rollbackModification: function rollbackModification() {
      return expandNode(nodeToProcess);
    },
    affectedColumns: Array.from(affectedColumns),
    colspanCompensation
  };
}

var _templateObject$c;
function _taggedTemplateLiteral$c(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function hideColumn(nodeToProcess, gridColumnIndex) {
  if (!Number.isInteger(gridColumnIndex)) {
    throw new Error("The passed gridColumnIndex argument has invalid type.");
  }
  if (nodeToProcess.childs.length > 0) {
    throw new Error(toSingleLine(_templateObject$c || (_templateObject$c = _taggedTemplateLiteral$c(["The passed node is not the last node on the tree. Only for \nthe last node, the hide column modification can be applied."], ["The passed node is not the last node on the tree. Only for\\x20\nthe last node, the hide column modification can be applied."]))));
  }
  var crossHiddenColumns = nodeToProcess.data.crossHiddenColumns;
  if (crossHiddenColumns.includes(gridColumnIndex)) {
    return;
  }
  var isCollapsibleNode = false;
  nodeToProcess.walkUp(function(node) {
    var collapsible = node.data.collapsible;
    if (collapsible) {
      isCollapsibleNode = true;
      return false;
    }
  });
  if (isCollapsibleNode) {
    return;
  }
  nodeToProcess.walkUp(function(node) {
    var data = node.data;
    data.crossHiddenColumns.push(gridColumnIndex);
    if (data.colspan > 1) {
      data.colspan -= 1;
    } else {
      data.isHidden = true;
    }
  });
}

var _templateObject$d;
function _taggedTemplateLiteral$d(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function showColumn(nodeToProcess, gridColumnIndex) {
  if (!Number.isInteger(gridColumnIndex)) {
    throw new Error("The passed gridColumnIndex argument has invalid type.");
  }
  if (nodeToProcess.childs.length > 0) {
    throw new Error(toSingleLine(_templateObject$d || (_templateObject$d = _taggedTemplateLiteral$d(["The passed node is not the last node on the tree. Only for \nthe last node, the show column modification can be applied."], ["The passed node is not the last node on the tree. Only for\\x20\nthe last node, the show column modification can be applied."]))));
  }
  var crossHiddenColumns = nodeToProcess.data.crossHiddenColumns;
  if (!crossHiddenColumns.includes(gridColumnIndex)) {
    return;
  }
  var isCollapsibleNode = false;
  nodeToProcess.walkUp(function(node) {
    var collapsible = node.data.collapsible;
    if (collapsible) {
      isCollapsibleNode = true;
      return false;
    }
  });
  if (isCollapsibleNode) {
    return;
  }
  nodeToProcess.walkUp(function(node) {
    var data = node.data;
    data.crossHiddenColumns.splice(data.crossHiddenColumns.indexOf(gridColumnIndex), 1);
    if (!data.isHidden && data.colspan < data.origColspan) {
      data.colspan += 1;
    }
    data.isHidden = false;
  });
}

var availableModifiers = new Map([["collapse", collapseNode], ["expand", expandNode], ["hide-column", hideColumn], ["show-column", showColumn]]);
function triggerNodeModification(actionName, nodeToProcess, gridColumnIndex) {
  if (!availableModifiers.has(actionName)) {
    throw new Error('The node modifier action ("'.concat(actionName, '") does not exist.'));
  }
  return availableModifiers.get(actionName)(nodeToProcess, gridColumnIndex);
}

var _excluded$7 = ["crossHiddenColumns"];
function _objectWithoutProperties$7(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function generateMatrix(headerRoots) {
  var matrix = [];
  arrayEach(headerRoots, function(rootNode) {
    rootNode.walkDown(function(node) {
      var nodeData = node.data;
      var origColspan = nodeData.origColspan, columnIndex = nodeData.columnIndex, headerLevel = nodeData.headerLevel, crossHiddenColumns = nodeData.crossHiddenColumns;
      var colspanHeaderLayer = createNestedArrayIfNecessary(matrix, headerLevel);
      var isRootSettingsFound = false;
      for (var i = columnIndex; i < columnIndex + origColspan; i++) {
        var isColumnHidden = crossHiddenColumns.includes(i);
        if (isColumnHidden || isRootSettingsFound) {
          colspanHeaderLayer.push(createPlaceholderHeaderSettings());
        } else {
          var headerRootSettings = createHeaderSettings(nodeData);
          headerRootSettings.isRoot = true;
          colspanHeaderLayer.push(headerRootSettings);
          isRootSettingsFound = true;
        }
      }
    });
  });
  return matrix;
}
function createHeaderSettings(nodeData) {
  var _createDefaultHeaderS = createDefaultHeaderSettings(nodeData), headerRootSettings = _objectWithoutProperties$7(_createDefaultHeaderS, _excluded$7);
  return headerRootSettings;
}
function createNestedArrayIfNecessary(array, index) {
  var subArray;
  if (Array.isArray(array[index])) {
    subArray = array[index];
  } else {
    subArray = [];
    array[index] = subArray;
  }
  return subArray;
}

var _excluded$8 = ["row"];
function ownKeys$e(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$e(Object(source), true).forEach(function(key) {
        _defineProperty$p(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$e(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$p(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$8(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$8(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$2r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2l(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2l(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2l(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2l(Constructor, staticProps);
  return Constructor;
}
function _classPrivateFieldSet$5(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$5(receiver, privateMap, "set");
  _classApplyDescriptorSet$5(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet$5(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet$5(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$5(receiver, privateMap, "get");
  return _classApplyDescriptorGet$5(receiver, descriptor);
}
function _classExtractFieldDescriptor$5(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet$5(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var _sourceSettings$1 = /* @__PURE__ */ new WeakMap();
var _headersTree = /* @__PURE__ */ new WeakMap();
var _stateMatrix = /* @__PURE__ */ new WeakMap();
var StateManager = /* @__PURE__ */ function() {
  function StateManager2() {
    _classCallCheck$2r(this, StateManager2);
    _sourceSettings$1.set(this, {
      writable: true,
      value: new SourceSettings()
    });
    _headersTree.set(this, {
      writable: true,
      value: new HeadersTree(_classPrivateFieldGet$5(this, _sourceSettings$1))
    });
    _stateMatrix.set(this, {
      writable: true,
      value: [[]]
    });
  }
  _createClass$2l(StateManager2, [{
    key: "setState",
    value: function setState(nestedHeadersSettings) {
      _classPrivateFieldGet$5(this, _sourceSettings$1).setData(nestedHeadersSettings);
      var hasError = false;
      try {
        _classPrivateFieldGet$5(this, _headersTree).buildTree();
      } catch (ex) {
        _classPrivateFieldGet$5(this, _headersTree).clear();
        _classPrivateFieldGet$5(this, _sourceSettings$1).clear();
        hasError = true;
      }
      _classPrivateFieldSet$5(this, _stateMatrix, generateMatrix(_classPrivateFieldGet$5(this, _headersTree).getRoots()));
      return hasError;
    }
  }, {
    key: "setColumnsLimit",
    value: function setColumnsLimit(columnsCount) {
      _classPrivateFieldGet$5(this, _sourceSettings$1).setColumnsLimit(columnsCount);
    }
  }, {
    key: "mergeStateWith",
    value: function mergeStateWith(settings) {
      var _this = this;
      var transformedSettings = arrayMap(settings, function(_ref) {
        var row = _ref.row, rest = _objectWithoutProperties$8(_ref, _excluded$8);
        return _objectSpread$e({
          row: row < 0 ? _this.rowCoordsToLevel(row) : row
        }, rest);
      });
      _classPrivateFieldGet$5(this, _sourceSettings$1).mergeWith(transformedSettings);
      _classPrivateFieldGet$5(this, _headersTree).buildTree();
      _classPrivateFieldSet$5(this, _stateMatrix, generateMatrix(_classPrivateFieldGet$5(this, _headersTree).getRoots()));
    }
  }, {
    key: "mapState",
    value: function mapState(callback) {
      _classPrivateFieldGet$5(this, _sourceSettings$1).map(callback);
      _classPrivateFieldGet$5(this, _headersTree).buildTree();
      _classPrivateFieldSet$5(this, _stateMatrix, generateMatrix(_classPrivateFieldGet$5(this, _headersTree).getRoots()));
    }
  }, {
    key: "mapNodes",
    value: function mapNodes(callback) {
      return arrayReduce(_classPrivateFieldGet$5(this, _headersTree).getRoots(), function(acc, rootNode) {
        rootNode.walkDown(function(node) {
          var result = callback(node.data);
          if (result !== void 0) {
            acc.push(result);
          }
        });
        return acc;
      }, []);
    }
  }, {
    key: "triggerNodeModification",
    value: function triggerNodeModification$1(action, headerLevel, columnIndex) {
      if (headerLevel < 0) {
        headerLevel = this.rowCoordsToLevel(headerLevel);
      }
      var nodeToProcess = _classPrivateFieldGet$5(this, _headersTree).getNode(headerLevel, columnIndex);
      var actionResult;
      if (nodeToProcess) {
        actionResult = triggerNodeModification(action, nodeToProcess, columnIndex);
        _classPrivateFieldSet$5(this, _stateMatrix, generateMatrix(_classPrivateFieldGet$5(this, _headersTree).getRoots()));
      }
      return actionResult;
    }
  }, {
    key: "triggerColumnModification",
    value: function triggerColumnModification(action, columnIndex) {
      return this.triggerNodeModification(action, -1, columnIndex);
    }
  }, {
    key: "rowCoordsToLevel",
    value: function rowCoordsToLevel(rowIndex) {
      var layersCount = Math.max(this.getLayersCount(), 1);
      var highestPossibleLevel = layersCount - 1;
      var lowestPossibleLevel = 0;
      return Math.min(Math.max(rowIndex + layersCount, lowestPossibleLevel), highestPossibleLevel);
    }
  }, {
    key: "levelToRowCoords",
    value: function levelToRowCoords(headerLevel) {
      var layersCount = Math.max(this.getLayersCount(), 1);
      var highestPossibleRow = -1;
      var lowestPossibleRow = -layersCount;
      return Math.min(Math.max(headerLevel - layersCount, lowestPossibleRow), highestPossibleRow);
    }
  }, {
    key: "getHeaderSettings",
    value: function getHeaderSettings(headerLevel, columnIndex) {
      var _classPrivateFieldGet2, _classPrivateFieldGet3;
      if (headerLevel < 0) {
        headerLevel = this.rowCoordsToLevel(headerLevel);
      }
      if (headerLevel >= this.getLayersCount()) {
        return null;
      }
      return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet$5(this, _stateMatrix)[headerLevel]) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3[columnIndex]) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;
    }
  }, {
    key: "getHeaderTreeNodeData",
    value: function getHeaderTreeNodeData(headerLevel, columnIndex) {
      if (headerLevel < 0) {
        headerLevel = this.rowCoordsToLevel(headerLevel);
      }
      var node = _classPrivateFieldGet$5(this, _headersTree).getNode(headerLevel, columnIndex);
      if (!node) {
        return null;
      }
      return _objectSpread$e({}, node.data);
    }
  }, {
    key: "findLeftMostColumnIndex",
    value: function findLeftMostColumnIndex(headerLevel, columnIndex) {
      var _this$getHeaderSettin;
      var _ref2 = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {
        isRoot: true
      }, isRoot = _ref2.isRoot;
      if (isRoot) {
        return columnIndex;
      }
      var stepBackColumn = columnIndex - 1;
      do {
        var _this$getHeaderSettin2;
        var _ref3 = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {
          isRoot: true
        }, isRootNode = _ref3.isRoot;
        if (isRootNode) {
          break;
        }
        stepBackColumn -= 1;
      } while (columnIndex >= 0);
      return stepBackColumn;
    }
  }, {
    key: "getLayersCount",
    value: function getLayersCount() {
      return _classPrivateFieldGet$5(this, _sourceSettings$1).getLayersCount();
    }
  }, {
    key: "getColumnsCount",
    value: function getColumnsCount() {
      return _classPrivateFieldGet$5(this, _sourceSettings$1).getColumnsCount();
    }
  }, {
    key: "clear",
    value: function clear() {
      _classPrivateFieldSet$5(this, _stateMatrix, []);
      _classPrivateFieldGet$5(this, _sourceSettings$1).clear();
      _classPrivateFieldGet$5(this, _headersTree).clear();
    }
  }]);
  return StateManager2;
}();

function _classCallCheck$2s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2m(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2m(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2m(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2m(Constructor, staticProps);
  return Constructor;
}
var GhostTable$1 = /* @__PURE__ */ function() {
  function GhostTable2(plugin) {
    _classCallCheck$2s(this, GhostTable2);
    this.nestedHeaders = plugin;
    this.container = void 0;
    this.widthsCache = [];
  }
  _createClass$2m(GhostTable2, [{
    key: "buildWidthsMapper",
    value: function buildWidthsMapper() {
      this.container = this.nestedHeaders.hot.rootDocument.createElement("div");
      this.buildGhostTable(this.container);
      this.nestedHeaders.hot.rootElement.appendChild(this.container);
      var columns = this.container.querySelectorAll("tr:last-of-type th");
      var maxColumns = columns.length;
      this.widthsCache.length = 0;
      for (var i = 0; i < maxColumns; i++) {
        this.widthsCache.push(columns[i].offsetWidth);
      }
      this.container.parentNode.removeChild(this.container);
      this.container = null;
      this.nestedHeaders.hot.render();
    }
  }, {
    key: "buildGhostTable",
    value: function buildGhostTable(container) {
      var rootDocument = this.nestedHeaders.hot.rootDocument;
      var fragment = rootDocument.createDocumentFragment();
      var table = rootDocument.createElement("table");
      var lastRowColspan = false;
      var isDropdownEnabled = !!this.nestedHeaders.hot.getSettings().dropdownMenu;
      var maxRows = this.nestedHeaders.getLayersCount();
      var maxCols = this.nestedHeaders.hot.countCols();
      var lastRowIndex = maxRows - 1;
      for (var row = 0; row < maxRows; row++) {
        var tr = rootDocument.createElement("tr");
        lastRowColspan = false;
        for (var col = 0; col < maxCols; col++) {
          var td = rootDocument.createElement("th");
          var headerObj = clone(this.nestedHeaders.getHeaderSettings(row, col));
          if (headerObj && !headerObj.isHidden) {
            if (row === lastRowIndex) {
              if (headerObj.colspan > 1) {
                lastRowColspan = true;
              }
              if (isDropdownEnabled) {
                headerObj.label += '<button class="changeType"></button>';
              }
            }
            fastInnerHTML(td, headerObj.label);
            td.colSpan = headerObj.colspan;
            tr.appendChild(td);
          }
        }
        table.appendChild(tr);
      }
      if (lastRowColspan) {
        {
          var _tr = rootDocument.createElement("tr");
          for (var _col = 0; _col < maxCols; _col++) {
            var _td = rootDocument.createElement("th");
            _tr.appendChild(_td);
          }
          table.appendChild(_tr);
        }
      }
      fragment.appendChild(table);
      container.appendChild(fragment);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.container = null;
      this.widthsCache.length = 0;
    }
  }]);
  return GhostTable2;
}();

function _typeof$1q(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1q = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1q = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1q(obj);
}
var _templateObject$e, _templateObject2$3;
function _taggedTemplateLiteral$e(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _classCallCheck$2t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2n(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2n(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2n(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2n(Constructor, staticProps);
  return Constructor;
}
function _get$N(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$N = Reflect.get;
  } else {
    _get$N = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$N(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$N(target, property, receiver || target);
}
function _superPropBase$N(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1d(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$1d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1e(subClass, superClass);
}
function _setPrototypeOf$1e(o, p) {
  _setPrototypeOf$1e = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1e(o, p);
}
function _createSuper$1d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1d(this, result);
  };
}
function _possibleConstructorReturn$1d(self, call) {
  if (call && (_typeof$1q(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1d(self);
}
function _assertThisInitialized$1d(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1d(o) {
  _getPrototypeOf$1d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1d(o);
}
function _defineProperty$q(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classPrivateFieldSet$6(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$6(receiver, privateMap, "set");
  _classApplyDescriptorSet$6(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet$6(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet$6(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$6(receiver, privateMap, "get");
  return _classApplyDescriptorGet$6(receiver, descriptor);
}
function _classExtractFieldDescriptor$6(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet$6(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var PLUGIN_KEY$s = "nestedHeaders";
var PLUGIN_PRIORITY$q = 280;
var _stateManager = /* @__PURE__ */ new WeakMap();
var _hidingIndexMapObserver = /* @__PURE__ */ new WeakMap();
var NestedHeaders = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$1d(NestedHeaders2, _BasePlugin);
  var _super = _createSuper$1d(NestedHeaders2);
  function NestedHeaders2() {
    var _this;
    _classCallCheck$2t(this, NestedHeaders2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _stateManager.set(_assertThisInitialized$1d(_this), {
      writable: true,
      value: new StateManager()
    });
    _hidingIndexMapObserver.set(_assertThisInitialized$1d(_this), {
      writable: true,
      value: null
    });
    _defineProperty$q(_assertThisInitialized$1d(_this), "ghostTable", new GhostTable$1(_assertThisInitialized$1d(_this)));
    _defineProperty$q(_assertThisInitialized$1d(_this), "detectedOverlappedHeaders", false);
    return _this;
  }
  _createClass$2n(NestedHeaders2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$s];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var _this$hot$getSettings = this.hot.getSettings(), nestedHeaders = _this$hot$getSettings.nestedHeaders;
      if (!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {
        warn$1(toSingleLine(_templateObject$e || (_templateObject$e = _taggedTemplateLiteral$e(["Your Nested Headers plugin configuration is invalid. The settings has to be \n                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]"], ["Your Nested Headers plugin configuration is invalid. The settings has to be\\x20\n                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]"]))));
      }
      this.addHook("init", function() {
        return _this2.onInit();
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData.apply(_this2, arguments);
      });
      this.addHook("beforeOnCellMouseDown", function() {
        return _this2.onBeforeOnCellMouseDown.apply(_this2, arguments);
      });
      this.addHook("afterOnCellMouseDown", function() {
        return _this2.onAfterOnCellMouseDown.apply(_this2, arguments);
      });
      this.addHook("beforeOnCellMouseOver", function() {
        return _this2.onBeforeOnCellMouseOver.apply(_this2, arguments);
      });
      this.addHook("afterGetColumnHeaderRenderers", function(array) {
        return _this2.onAfterGetColumnHeaderRenderers(array);
      });
      this.addHook("modifyColWidth", function() {
        return _this2.onModifyColWidth.apply(_this2, arguments);
      });
      this.addHook("beforeHighlightingColumnHeader", function() {
        return _this2.onBeforeHighlightingColumnHeader.apply(_this2, arguments);
      });
      this.addHook("afterViewportColumnCalculatorOverride", function() {
        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);
      });
      _get$N(_getPrototypeOf$1d(NestedHeaders2.prototype), "enablePlugin", this).call(this);
      this.updatePlugin();
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var _this3 = this;
      if (!this.hot.view) {
        return;
      }
      var _this$hot$getSettings2 = this.hot.getSettings(), nestedHeaders = _this$hot$getSettings2.nestedHeaders;
      _classPrivateFieldGet$6(this, _stateManager).setColumnsLimit(this.hot.countSourceCols());
      if (Array.isArray(nestedHeaders)) {
        this.detectedOverlappedHeaders = _classPrivateFieldGet$6(this, _stateManager).setState(nestedHeaders);
      }
      if (this.detectedOverlappedHeaders) {
        warn$1(toSingleLine(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteral$e(["Your Nested Headers plugin setup contains overlapping headers. This kind of configuration \n                        is currently not supported."], ["Your Nested Headers plugin setup contains overlapping headers. This kind of configuration\\x20\n                        is currently not supported."]))));
      }
      if (this.enabled) {
        this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach(function(isColumnHidden, physicalColumnIndex) {
          var actionName = isColumnHidden === true ? "hide-column" : "show-column";
          _classPrivateFieldGet$6(_this3, _stateManager).triggerColumnModification(actionName, physicalColumnIndex);
        });
      }
      if (!_classPrivateFieldGet$6(this, _hidingIndexMapObserver) && this.enabled) {
        _classPrivateFieldSet$6(this, _hidingIndexMapObserver, this.hot.columnIndexMapper.createChangesObserver("hiding").subscribe(function(changes) {
          changes.forEach(function(_ref) {
            var op = _ref.op, columnIndex = _ref.index, newValue = _ref.newValue;
            if (op === "replace") {
              var actionName = newValue === true ? "hide-column" : "show-column";
              _classPrivateFieldGet$6(_this3, _stateManager).triggerColumnModification(actionName, columnIndex);
            }
          });
        }));
      }
      this.ghostTable.buildWidthsMapper();
      _get$N(_getPrototypeOf$1d(NestedHeaders2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.clearColspans();
      _classPrivateFieldGet$6(this, _stateManager).clear();
      _classPrivateFieldGet$6(this, _hidingIndexMapObserver).unsubscribe();
      _classPrivateFieldSet$6(this, _hidingIndexMapObserver, null);
      this.ghostTable.clear();
      _get$N(_getPrototypeOf$1d(NestedHeaders2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "getStateManager",
    value: function getStateManager() {
      return _classPrivateFieldGet$6(this, _stateManager);
    }
  }, {
    key: "getLayersCount",
    value: function getLayersCount() {
      return _classPrivateFieldGet$6(this, _stateManager).getLayersCount();
    }
  }, {
    key: "getHeaderSettings",
    value: function getHeaderSettings(headerLevel, columnIndex) {
      return _classPrivateFieldGet$6(this, _stateManager).getHeaderSettings(headerLevel, columnIndex);
    }
  }, {
    key: "clearColspans",
    value: function clearColspans() {
      if (!this.hot.view) {
        return;
      }
      var wt = this.hot.view.wt;
      var headerLevels = wt.getSetting("columnHeaders").length;
      var mainHeaders = wt.wtTable.THEAD;
      var topHeaders = wt.wtOverlays.topOverlay.clone.wtTable.THEAD;
      var topLeftCornerHeaders = wt.wtOverlays.topLeftCornerOverlay ? wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.THEAD : null;
      for (var i = 0; i < headerLevels; i++) {
        var masterLevel = mainHeaders.childNodes[i];
        if (!masterLevel) {
          break;
        }
        var topLevel = topHeaders.childNodes[i];
        var topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;
        for (var j = 0, masterNodes = masterLevel.childNodes.length; j < masterNodes; j++) {
          masterLevel.childNodes[j].removeAttribute("colspan");
          removeClass(masterLevel.childNodes[j], "hiddenHeader");
          if (topLevel && topLevel.childNodes[j]) {
            topLevel.childNodes[j].removeAttribute("colspan");
            removeClass(topLevel.childNodes[j], "hiddenHeader");
          }
          if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {
            topLeftCornerLevel.childNodes[j].removeAttribute("colspan");
            removeClass(topLeftCornerLevel.childNodes[j], "hiddenHeader");
          }
        }
      }
    }
  }, {
    key: "headerRendererFactory",
    value: function headerRendererFactory(headerLevel) {
      var _this4 = this;
      var fixedColumnsLeft = this.hot.view.wt.getSetting("fixedColumnsLeft");
      return function(renderedColumnIndex, TH) {
        var _classPrivateFieldGet2;
        var _this4$hot = _this4.hot, rootDocument = _this4$hot.rootDocument, columnIndexMapper = _this4$hot.columnIndexMapper, view = _this4$hot.view;
        var visualColumnsIndex = columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
        if (visualColumnsIndex === null) {
          visualColumnsIndex = renderedColumnIndex;
        }
        TH.removeAttribute("colspan");
        removeClass(TH, "hiddenHeader");
        var _ref2 = (_classPrivateFieldGet2 = _classPrivateFieldGet$6(_this4, _stateManager).getHeaderSettings(headerLevel, visualColumnsIndex)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : {
          label: ""
        }, colspan = _ref2.colspan, label = _ref2.label, isHidden = _ref2.isHidden, isPlaceholder = _ref2.isPlaceholder;
        if (isPlaceholder || isHidden) {
          addClass(TH, "hiddenHeader");
        } else if (colspan > 1) {
          var _view$wt$wtOverlays$t, _view$wt$wtOverlays$l;
          var isTopLeftOverlay = (_view$wt$wtOverlays$t = view.wt.wtOverlays.topLeftCornerOverlay) === null || _view$wt$wtOverlays$t === void 0 ? void 0 : _view$wt$wtOverlays$t.clone.wtTable.THEAD.contains(TH);
          var isLeftOverlay = (_view$wt$wtOverlays$l = view.wt.wtOverlays.leftOverlay) === null || _view$wt$wtOverlays$l === void 0 ? void 0 : _view$wt$wtOverlays$l.clone.wtTable.THEAD.contains(TH);
          var correctedColspan = isTopLeftOverlay || isLeftOverlay ? Math.min(colspan, fixedColumnsLeft - renderedColumnIndex) : colspan;
          if (correctedColspan > 1) {
            TH.setAttribute("colspan", correctedColspan);
          }
        }
        var divEl = rootDocument.createElement("div");
        var spanEl = rootDocument.createElement("span");
        addClass(divEl, "relative");
        addClass(spanEl, "colHeader");
        fastInnerHTML(spanEl, label);
        divEl.appendChild(spanEl);
        empty(TH);
        TH.appendChild(divEl);
        _this4.hot.runHooks("afterGetColHeader", visualColumnsIndex, TH);
      };
    }
  }, {
    key: "onBeforeHighlightingColumnHeader",
    value: function onBeforeHighlightingColumnHeader(visualColumn, headerLevel, highlightMeta) {
      var headerNodeData = _classPrivateFieldGet$6(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumn);
      if (!headerNodeData) {
        return visualColumn;
      }
      var classNames = highlightMeta.classNames, columnCursor = highlightMeta.columnCursor, selectionType = highlightMeta.selectionType, selectionWidth = highlightMeta.selectionWidth;
      var _classPrivateFieldGet3 = _classPrivateFieldGet$6(this, _stateManager).getHeaderSettings(headerLevel, visualColumn), isRoot = _classPrivateFieldGet3.isRoot, colspan = _classPrivateFieldGet3.colspan;
      if (selectionType === HEADER_TYPE) {
        if (!isRoot) {
          return headerNodeData.columnIndex;
        }
      } else if (selectionType === ACTIVE_HEADER_TYPE) {
        if (colspan > selectionWidth - columnCursor || !isRoot) {
          classNames.length = 0;
        }
      }
      return visualColumn;
    }
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event, coords, TD, blockCalculations) {
      var headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
      if (headerNodeData) {
        blockCalculations.column = true;
      }
    }
  }, {
    key: "onAfterOnCellMouseDown",
    value: function onAfterOnCellMouseDown(event, coords) {
      var headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
      if (!headerNodeData) {
        return;
      }
      var selection = this.hot.selection;
      var currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;
      var columnsToSelect = [];
      var columnIndex = headerNodeData.columnIndex, origColspan = headerNodeData.origColspan;
      var allowRightClickSelection = !selection.inInSelection(coords);
      if (event.shiftKey && currentSelection) {
        if (coords.col < currentSelection.from.col) {
          columnsToSelect.push(currentSelection.getTopRightCorner().col, columnIndex, coords.row);
        } else if (coords.col > currentSelection.from.col) {
          columnsToSelect.push(currentSelection.getTopLeftCorner().col, columnIndex + origColspan - 1, coords.row);
        } else {
          columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);
        }
      } else if (isLeftClick(event) || isRightClick(event) && allowRightClickSelection) {
        columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);
      }
      selection.selectColumns.apply(selection, columnsToSelect);
    }
  }, {
    key: "onBeforeOnCellMouseOver",
    value: function onBeforeOnCellMouseOver(event, coords, TD, blockCalculations) {
      var _this$hot;
      if (!this.hot.view.isMouseDown()) {
        return;
      }
      var headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
      if (!headerNodeData) {
        return;
      }
      var columnIndex = headerNodeData.columnIndex, origColspan = headerNodeData.origColspan;
      var selectedRange = this.hot.getSelectedRangeLast();
      var topLeftCoords = selectedRange.getTopLeftCorner();
      var bottomRightCoords = selectedRange.getBottomRightCorner();
      var from = selectedRange.from;
      blockCalculations.column = true;
      blockCalculations.cell = true;
      var columnsToSelect = [];
      if (coords.col < from.col) {
        columnsToSelect.push(bottomRightCoords.col, columnIndex);
      } else if (coords.col > from.col) {
        columnsToSelect.push(topLeftCoords.col, columnIndex + origColspan - 1);
      } else {
        columnsToSelect.push(columnIndex, columnIndex + origColspan - 1);
      }
      (_this$hot = this.hot).selectColumns.apply(_this$hot, columnsToSelect);
    }
  }, {
    key: "onAfterGetColumnHeaderRenderers",
    value: function onAfterGetColumnHeaderRenderers(renderersArray) {
      if (renderersArray) {
        renderersArray.length = 0;
        for (var headerLayer = 0; headerLayer < _classPrivateFieldGet$6(this, _stateManager).getLayersCount(); headerLayer++) {
          renderersArray.push(this.headerRendererFactory(headerLayer));
        }
      }
    }
  }, {
    key: "onAfterViewportColumnCalculatorOverride",
    value: function onAfterViewportColumnCalculatorOverride(calc) {
      var newStartColumn = calc.startColumn;
      for (var headerLayer = 0; headerLayer < _classPrivateFieldGet$6(this, _stateManager).getLayersCount(); headerLayer++) {
        var startColumn = _classPrivateFieldGet$6(this, _stateManager).findLeftMostColumnIndex(headerLayer, calc.startColumn);
        var renderedStartColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);
        if (renderedStartColumn < calc.startColumn) {
          newStartColumn = renderedStartColumn;
          break;
        }
      }
      calc.startColumn = newStartColumn;
    }
  }, {
    key: "onModifyColWidth",
    value: function onModifyColWidth(width, column) {
      var cachedWidth = this.ghostTable.widthsCache[column];
      return width > cachedWidth ? width : cachedWidth;
    }
  }, {
    key: "onInit",
    value: function onInit() {
      this.updatePlugin();
    }
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(sourceData, initialLoad) {
      if (!initialLoad) {
        this.updatePlugin();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldSet$6(this, _stateManager, null);
      if (_classPrivateFieldGet$6(this, _hidingIndexMapObserver) !== null) {
        _classPrivateFieldGet$6(this, _hidingIndexMapObserver).unsubscribe();
        _classPrivateFieldSet$6(this, _hidingIndexMapObserver, null);
      }
      _get$N(_getPrototypeOf$1d(NestedHeaders2.prototype), "destroy", this).call(this);
    }
  }, {
    key: "_getHeaderTreeNodeDataByCoords",
    value: function _getHeaderTreeNodeDataByCoords(coords) {
      if (coords.row >= 0 || coords.col < 0) {
        return;
      }
      return _classPrivateFieldGet$6(this, _stateManager).getHeaderTreeNodeData(coords.row, coords.col);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$s;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$q;
    }
  }]);
  return NestedHeaders2;
}(BasePlugin);

function _typeof$1r(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1r = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1r = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1r(obj);
}
function _toConsumableArray$u(arr) {
  return _arrayWithoutHoles$s(arr) || _iterableToArray$u(arr) || _unsupportedIterableToArray$12(arr) || _nonIterableSpread$s();
}
function _nonIterableSpread$s() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$12(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$12(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$12(o, minLen);
}
function _iterableToArray$u(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$s(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$12(arr);
}
function _arrayLikeToArray$12(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$2u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2o(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2o(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2o(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2o(Constructor, staticProps);
  return Constructor;
}
function _get$O(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$O = Reflect.get;
  } else {
    _get$O = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$O(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$O(target, property, receiver || target);
}
function _superPropBase$O(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1e(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$1e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1f(subClass, superClass);
}
function _setPrototypeOf$1f(o, p) {
  _setPrototypeOf$1f = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1f(o, p);
}
function _createSuper$1e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1e(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1e(this, result);
  };
}
function _possibleConstructorReturn$1e(self, call) {
  if (call && (_typeof$1r(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1e(self);
}
function _assertThisInitialized$1e(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1e(o) {
  _getPrototypeOf$1e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1e(o);
}
function _defineProperty$r(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classPrivateFieldGet$7(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$7(receiver, privateMap, "get");
  return _classApplyDescriptorGet$7(receiver, descriptor);
}
function _classApplyDescriptorGet$7(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$7(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$7(receiver, privateMap, "set");
  _classApplyDescriptorSet$7(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$7(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$7(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var PLUGIN_KEY$t = "collapsibleColumns";
var PLUGIN_PRIORITY$r = 290;
var actionDictionary = new Map([["collapse", {
  hideColumn: true,
  beforeHook: "beforeColumnCollapse",
  afterHook: "afterColumnCollapse"
}], ["expand", {
  hideColumn: false,
  beforeHook: "beforeColumnExpand",
  afterHook: "afterColumnExpand"
}]]);
var _collapsedColumnsMap = /* @__PURE__ */ new WeakMap();
var CollapsibleColumns = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$1e(CollapsibleColumns2, _BasePlugin);
  var _super = _createSuper$1e(CollapsibleColumns2);
  function CollapsibleColumns2() {
    var _this;
    _classCallCheck$2u(this, CollapsibleColumns2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$r(_assertThisInitialized$1e(_this), "nestedHeadersPlugin", null);
    _defineProperty$r(_assertThisInitialized$1e(_this), "eventManager", new EventManager(_assertThisInitialized$1e(_this)));
    _defineProperty$r(_assertThisInitialized$1e(_this), "headerStateManager", null);
    _collapsedColumnsMap.set(_assertThisInitialized$1e(_this), {
      writable: true,
      value: null
    });
    return _this;
  }
  _createClass$2o(CollapsibleColumns2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$t];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var _this$hot$getSettings = this.hot.getSettings(), nestedHeaders = _this$hot$getSettings.nestedHeaders;
      if (!nestedHeaders) {
        warn$1("You need to configure the Nested Headers plugin in order to use collapsible headers.");
      }
      _classPrivateFieldSet$7(this, _collapsedColumnsMap, this.hot.columnIndexMapper.createAndRegisterIndexMap(this.pluginName, "hiding"));
      this.nestedHeadersPlugin = this.hot.getPlugin("nestedHeaders");
      this.headerStateManager = this.nestedHeadersPlugin.getStateManager();
      this.addHook("init", function() {
        return _this2.onInit();
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData.apply(_this2, arguments);
      });
      this.addHook("afterGetColHeader", function(col, TH) {
        return _this2.onAfterGetColHeader(col, TH);
      });
      this.addHook("beforeOnCellMouseDown", function(event, coords, TD) {
        return _this2.onBeforeOnCellMouseDown(event, coords, TD);
      });
      _get$O(_getPrototypeOf$1e(CollapsibleColumns2.prototype), "enablePlugin", this).call(this);
      this.updatePlugin();
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      if (!this.hot.view) {
        return;
      }
      if (!this.nestedHeadersPlugin.detectedOverlappedHeaders) {
        var _this$hot$getSettings2 = this.hot.getSettings(), collapsibleColumns = _this$hot$getSettings2.collapsibleColumns;
        if (typeof collapsibleColumns === "boolean") {
          this.headerStateManager.mapState(function(headerSettings) {
            return {
              collapsible: headerSettings.origColspan > 1
            };
          });
        } else if (Array.isArray(collapsibleColumns)) {
          this.headerStateManager.mergeStateWith(collapsibleColumns);
        }
      }
      _get$O(_getPrototypeOf$1e(CollapsibleColumns2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.columnIndexMapper.unregisterMap(this.pluginName);
      _classPrivateFieldSet$7(this, _collapsedColumnsMap, null);
      this.nestedHeadersPlugin = null;
      this.clearButtons();
      _get$O(_getPrototypeOf$1e(CollapsibleColumns2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "clearButtons",
    value: function clearButtons() {
      if (!this.hot.view) {
        return;
      }
      var headerLevels = this.hot.view.wt.getSetting("columnHeaders").length;
      var mainHeaders = this.hot.view.wt.wtTable.THEAD;
      var topHeaders = this.hot.view.wt.wtOverlays.topOverlay.clone.wtTable.THEAD;
      var topLeftCornerHeaders = this.hot.view.wt.wtOverlays.topLeftCornerOverlay ? this.hot.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.THEAD : null;
      var removeButton = function removeButton2(button) {
        if (button) {
          button.parentNode.removeChild(button);
        }
      };
      rangeEach(0, headerLevels - 1, function(i) {
        var masterLevel = mainHeaders.childNodes[i];
        var topLevel = topHeaders.childNodes[i];
        var topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;
        rangeEach(0, masterLevel.childNodes.length - 1, function(j) {
          var button = masterLevel.childNodes[j].querySelector(".collapsibleIndicator");
          removeButton(button);
          if (topLevel && topLevel.childNodes[j]) {
            button = topLevel.childNodes[j].querySelector(".collapsibleIndicator");
            removeButton(button);
          }
          if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {
            button = topLeftCornerLevel.childNodes[j].querySelector(".collapsibleIndicator");
            removeButton(button);
          }
        });
      });
    }
  }, {
    key: "expandSection",
    value: function expandSection(coords) {
      this.toggleCollapsibleSection([coords], "expand");
    }
  }, {
    key: "collapseSection",
    value: function collapseSection(coords) {
      this.toggleCollapsibleSection([coords], "collapse");
    }
  }, {
    key: "toggleAllCollapsibleSections",
    value: function toggleAllCollapsibleSections(action) {
      var _this3 = this;
      var coords = this.headerStateManager.mapNodes(function(_ref) {
        var collapsible = _ref.collapsible, origColspan = _ref.origColspan, headerLevel = _ref.headerLevel, columnIndex = _ref.columnIndex;
        if (collapsible === true && origColspan > 1) {
          return {
            row: _this3.headerStateManager.levelToRowCoords(headerLevel),
            col: columnIndex
          };
        }
      });
      this.toggleCollapsibleSection(coords, action);
    }
  }, {
    key: "collapseAll",
    value: function collapseAll() {
      this.toggleAllCollapsibleSections("collapse");
    }
  }, {
    key: "expandAll",
    value: function expandAll() {
      this.toggleAllCollapsibleSections("expand");
    }
  }, {
    key: "toggleCollapsibleSection",
    value: function toggleCollapsibleSection(coords, action) {
      var _this4 = this;
      if (!actionDictionary.has(action)) {
        throw new Error("Unsupported action is passed (".concat(action, ")."));
      }
      if (!Array.isArray(coords)) {
        return;
      }
      var filteredCoords = arrayFilter(coords, function(_ref2) {
        var row = _ref2.row;
        return row < 0;
      });
      var isActionPossible = filteredCoords.length > 0;
      arrayEach(filteredCoords, function(_ref3) {
        var _this4$headerStateMan;
        var row = _ref3.row, column = _ref3.col;
        var _ref4 = (_this4$headerStateMan = _this4.headerStateManager.getHeaderSettings(row, column)) !== null && _this4$headerStateMan !== void 0 ? _this4$headerStateMan : {}, collapsible = _ref4.collapsible, isCollapsed = _ref4.isCollapsed;
        if (!collapsible || isCollapsed && action === "collapse" || !isCollapsed && action === "expand") {
          isActionPossible = false;
          return false;
        }
      });
      var nodeModRollbacks = [];
      var affectedColumnsIndexes = [];
      if (isActionPossible) {
        arrayEach(filteredCoords, function(_ref5) {
          var row = _ref5.row, column = _ref5.col;
          var _this4$headerStateMan2 = _this4.headerStateManager.triggerNodeModification(action, row, column), colspanCompensation = _this4$headerStateMan2.colspanCompensation, affectedColumns = _this4$headerStateMan2.affectedColumns, rollbackModification = _this4$headerStateMan2.rollbackModification;
          if (colspanCompensation > 0) {
            affectedColumnsIndexes.push.apply(affectedColumnsIndexes, _toConsumableArray$u(affectedColumns));
            nodeModRollbacks.push(rollbackModification);
          }
        });
      }
      var currentCollapsedColumns = this.getCollapsedColumns();
      var destinationCollapsedColumns = [];
      if (action === "collapse") {
        destinationCollapsedColumns = arrayUnique([].concat(_toConsumableArray$u(currentCollapsedColumns), affectedColumnsIndexes));
      } else if (action === "expand") {
        destinationCollapsedColumns = arrayFilter(currentCollapsedColumns, function(index) {
          return !affectedColumnsIndexes.includes(index);
        });
      }
      var actionTranslator = actionDictionary.get(action);
      var isActionAllowed = this.hot.runHooks(actionTranslator.beforeHook, currentCollapsedColumns, destinationCollapsedColumns, isActionPossible);
      if (isActionAllowed === false) {
        arrayEach(nodeModRollbacks, function(nodeModRollback) {
          nodeModRollback();
        });
        return;
      }
      this.hot.batchExecution(function() {
        arrayEach(affectedColumnsIndexes, function(visualColumn) {
          _classPrivateFieldGet$7(_this4, _collapsedColumnsMap).setValueAtIndex(_this4.hot.toPhysicalColumn(visualColumn), actionTranslator.hideColumn);
        });
      }, true);
      var isActionPerformed = this.getCollapsedColumns().length !== currentCollapsedColumns.length;
      this.hot.runHooks(actionTranslator.afterHook, currentCollapsedColumns, destinationCollapsedColumns, isActionPossible, isActionPerformed);
      this.hot.render();
      this.hot.view.adjustElementsSize(true);
    }
  }, {
    key: "getCollapsedColumns",
    value: function getCollapsedColumns() {
      return _classPrivateFieldGet$7(this, _collapsedColumnsMap).getHiddenIndexes();
    }
  }, {
    key: "generateIndicator",
    value: function generateIndicator(row, column) {
      var divEl = this.hot.rootDocument.createElement("div");
      var columnSettings = this.headerStateManager.getHeaderSettings(row, column);
      addClass(divEl, "collapsibleIndicator");
      if (columnSettings.isCollapsed) {
        addClass(divEl, "collapsed");
        fastInnerText(divEl, "+");
      } else {
        addClass(divEl, "expanded");
        fastInnerText(divEl, "-");
      }
      return divEl;
    }
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(column, TH) {
      var _this$headerStateMana;
      var TR = TH.parentNode;
      var THEAD = TR.parentNode;
      var row = -1 * THEAD.childNodes.length + Array.prototype.indexOf.call(THEAD.childNodes, TR);
      var _ref6 = (_this$headerStateMana = this.headerStateManager.getHeaderSettings(row, column)) !== null && _this$headerStateMana !== void 0 ? _this$headerStateMana : {}, collapsible = _ref6.collapsible, origColspan = _ref6.origColspan;
      if (collapsible && origColspan > 1 && column >= this.hot.getSettings().fixedColumnsLeft) {
        var button = this.generateIndicator(row, column);
        TH.querySelector("div:first-child").appendChild(button);
      }
    }
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event, coords) {
      if (hasClass(event.target, "collapsibleIndicator")) {
        if (hasClass(event.target, "expanded")) {
          this.eventManager.fireEvent(event.target, "mouseup");
          this.toggleCollapsibleSection([coords], "collapse");
        } else if (hasClass(event.target, "collapsed")) {
          this.eventManager.fireEvent(event.target, "mouseup");
          this.toggleCollapsibleSection([coords], "expand");
        }
        stopImmediatePropagation(event);
      }
    }
  }, {
    key: "onInit",
    value: function onInit() {
      this.updatePlugin();
    }
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(sourceData, initialLoad) {
      if (!initialLoad) {
        this.updatePlugin();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldSet$7(this, _collapsedColumnsMap, null);
      _get$O(_getPrototypeOf$1e(CollapsibleColumns2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$t;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$r;
    }
  }, {
    key: "PLUGIN_DEPS",
    get: function get() {
      return ["plugin:NestedHeaders"];
    }
  }]);
  return CollapsibleColumns2;
}(BasePlugin);

function _toConsumableArray$v(arr) {
  return _arrayWithoutHoles$t(arr) || _iterableToArray$v(arr) || _unsupportedIterableToArray$13(arr) || _nonIterableSpread$t();
}
function _nonIterableSpread$t() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$13(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$13(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$13(o, minLen);
}
function _iterableToArray$v(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$t(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$13(arr);
}
function _arrayLikeToArray$13(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _typeof$1s(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1s = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1s = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1s(obj);
}
function _classCallCheck$2v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2p(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2p(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2p(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2p(Constructor, staticProps);
  return Constructor;
}
var DataManager = /* @__PURE__ */ function() {
  function DataManager2(nestedRowsPlugin, hotInstance) {
    _classCallCheck$2v(this, DataManager2);
    this.hot = hotInstance;
    this.data = null;
    this.plugin = nestedRowsPlugin;
    this.parentReference = new WeakMap();
    this.cache = {
      levels: [],
      levelCount: 0,
      rows: [],
      nodeInfo: new WeakMap()
    };
  }
  _createClass$2p(DataManager2, [{
    key: "setData",
    value: function setData(data) {
      this.data = data;
    }
  }, {
    key: "getData",
    value: function getData() {
      return this.data;
    }
  }, {
    key: "getRawSourceData",
    value: function getRawSourceData() {
      var rawSourceData = null;
      this.plugin.disableCoreAPIModifiers();
      rawSourceData = this.hot.getSourceData();
      this.plugin.enableCoreAPIModifiers();
      return rawSourceData;
    }
  }, {
    key: "updateWithData",
    value: function updateWithData(data) {
      this.setData(data);
      this.rewriteCache();
    }
  }, {
    key: "rewriteCache",
    value: function rewriteCache() {
      var _this = this;
      this.cache = {
        levels: [],
        levelCount: 0,
        rows: [],
        nodeInfo: new WeakMap()
      };
      rangeEach(0, this.data.length - 1, function(i) {
        _this.cacheNode(_this.data[i], 0, null);
      });
    }
  }, {
    key: "cacheNode",
    value: function cacheNode(node, level, parent) {
      var _this2 = this;
      if (!this.cache.levels[level]) {
        this.cache.levels[level] = [];
        this.cache.levelCount += 1;
      }
      this.cache.levels[level].push(node);
      this.cache.rows.push(node);
      this.cache.nodeInfo.set(node, {
        parent,
        row: this.cache.rows.length - 1,
        level
      });
      if (this.hasChildren(node)) {
        arrayEach(node.__children, function(elem) {
          _this2.cacheNode(elem, level + 1, node);
        });
      }
    }
  }, {
    key: "getDataObject",
    value: function getDataObject(row) {
      return row === null || row === void 0 ? null : this.cache.rows[row];
    }
  }, {
    key: "readTreeNodes",
    value: function readTreeNodes(parent, readCount, neededIndex, neededObject) {
      var _this3 = this;
      var rootLevel = false;
      var readNodesCount = readCount;
      if (isNaN(readNodesCount) && readNodesCount.end) {
        return readNodesCount;
      }
      var parentObj = parent;
      if (!parentObj) {
        parentObj = {
          __children: this.data
        };
        rootLevel = true;
        readNodesCount -= 1;
      }
      if (neededIndex !== null && neededIndex !== void 0 && readNodesCount === neededIndex) {
        return {
          result: parentObj,
          end: true
        };
      }
      if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {
        return {
          result: readNodesCount,
          end: true
        };
      }
      readNodesCount += 1;
      if (parentObj.__children) {
        arrayEach(parentObj.__children, function(val) {
          _this3.parentReference.set(val, rootLevel ? null : parentObj);
          readNodesCount = _this3.readTreeNodes(val, readNodesCount, neededIndex, neededObject);
          if (isNaN(readNodesCount) && readNodesCount.end) {
            return false;
          }
        });
      }
      return readNodesCount;
    }
  }, {
    key: "mockParent",
    value: function mockParent() {
      var fakeParent = this.mockNode();
      fakeParent.__children = this.data;
      return fakeParent;
    }
  }, {
    key: "mockNode",
    value: function mockNode() {
      var fakeNode = {};
      objectEach(this.data[0], function(val, key) {
        fakeNode[key] = null;
      });
      return fakeNode;
    }
  }, {
    key: "getRowIndex",
    value: function getRowIndex(rowObj) {
      return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;
    }
  }, {
    key: "getRowIndexWithinParent",
    value: function getRowIndexWithinParent(row) {
      var rowObj = null;
      if (isNaN(row)) {
        rowObj = row;
      } else {
        rowObj = this.getDataObject(row);
      }
      var parent = this.getRowParent(row);
      if (parent === null || parent === void 0) {
        return this.data.indexOf(rowObj);
      }
      return parent.__children.indexOf(rowObj);
    }
  }, {
    key: "countAllRows",
    value: function countAllRows() {
      var rootNodeMock = {
        __children: this.data
      };
      return this.countChildren(rootNodeMock);
    }
  }, {
    key: "countChildren",
    value: function countChildren(parent) {
      var _this4 = this;
      var rowCount = 0;
      var parentNode = parent;
      if (!isNaN(parentNode)) {
        parentNode = this.getDataObject(parentNode);
      }
      if (!parentNode || !parentNode.__children) {
        return 0;
      }
      arrayEach(parentNode.__children, function(elem) {
        rowCount += 1;
        if (elem.__children) {
          rowCount += _this4.countChildren(elem);
        }
      });
      return rowCount;
    }
  }, {
    key: "getRowParent",
    value: function getRowParent(row) {
      var rowObject;
      if (isNaN(row)) {
        rowObject = row;
      } else {
        rowObject = this.getDataObject(row);
      }
      return this.getRowObjectParent(rowObject);
    }
  }, {
    key: "getRowObjectParent",
    value: function getRowObjectParent(rowObject) {
      if (!rowObject || _typeof$1s(rowObject) !== "object") {
        return null;
      }
      return this.cache.nodeInfo.get(rowObject).parent;
    }
  }, {
    key: "getRowLevel",
    value: function getRowLevel(row) {
      var rowObject = null;
      if (isNaN(row)) {
        rowObject = row;
      } else {
        rowObject = this.getDataObject(row);
      }
      return rowObject ? this.getRowObjectLevel(rowObject) : null;
    }
  }, {
    key: "getRowObjectLevel",
    value: function getRowObjectLevel(rowObject) {
      return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;
    }
  }, {
    key: "hasChildren",
    value: function hasChildren(row) {
      var rowObj = row;
      if (!isNaN(rowObj)) {
        rowObj = this.getDataObject(rowObj);
      }
      return !!(rowObj.__children && rowObj.__children.length);
    }
  }, {
    key: "isChild",
    value: function isChild(index) {
      return this.getRowParent(index) !== null;
    }
  }, {
    key: "isRowHighestLevel",
    value: function isRowHighestLevel(index) {
      return !this.isChild(index);
    }
  }, {
    key: "isParent",
    value: function isParent(row) {
      var _rowObj$__children;
      var rowObj = row;
      if (!isNaN(rowObj)) {
        rowObj = this.getDataObject(rowObj);
      }
      return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;
    }
  }, {
    key: "addChild",
    value: function addChild(parent, element) {
      var childElement = element;
      this.hot.runHooks("beforeAddChild", parent, childElement);
      var parentIndex = null;
      if (parent) {
        parentIndex = this.getRowIndex(parent);
      }
      this.hot.runHooks("beforeCreateRow", parentIndex + this.countChildren(parent) + 1, 1);
      var functionalParent = parent;
      if (!parent) {
        functionalParent = this.mockParent();
      }
      if (!functionalParent.__children) {
        functionalParent.__children = [];
      }
      if (!childElement) {
        childElement = this.mockNode();
      }
      functionalParent.__children.push(childElement);
      this.rewriteCache();
      var newRowIndex = this.getRowIndex(childElement);
      this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);
      this.hot.runHooks("afterCreateRow", newRowIndex, 1);
      this.hot.runHooks("afterAddChild", parent, childElement);
    }
  }, {
    key: "addChildAtIndex",
    value: function addChildAtIndex(parent, index, element) {
      var childElement = element;
      if (!childElement) {
        childElement = this.mockNode();
      }
      this.hot.runHooks("beforeAddChild", parent, childElement, index);
      if (parent) {
        this.hot.runHooks("beforeCreateRow", index, 1);
        parent.__children.splice(index, null, childElement);
        this.plugin.disableCoreAPIModifiers();
        this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), "__children", parent.__children, "NestedRows.addChildAtIndex");
        this.plugin.enableCoreAPIModifiers();
        this.hot.runHooks("afterCreateRow", index, 1);
      } else {
        this.plugin.disableCoreAPIModifiers();
        this.hot.alter("insert_row", index, 1, "NestedRows.addChildAtIndex");
        this.plugin.enableCoreAPIModifiers();
      }
      this.updateWithData(this.getRawSourceData());
      childElement = this.getDataObject(index);
      this.hot.runHooks("afterAddChild", parent, childElement, index);
    }
  }, {
    key: "addSibling",
    value: function addSibling(index) {
      var where = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "below";
      var translatedIndex = this.translateTrimmedRow(index);
      var parent = this.getRowParent(translatedIndex);
      var indexWithinParent = this.getRowIndexWithinParent(translatedIndex);
      switch (where) {
        case "below":
          this.addChildAtIndex(parent, indexWithinParent + 1, null);
          break;
        case "above":
          this.addChildAtIndex(parent, indexWithinParent, null);
          break;
      }
    }
  }, {
    key: "detachFromParent",
    value: function detachFromParent(elements) {
      var _this5 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var element = null;
      var rowObjects = [];
      if (Array.isArray(elements)) {
        rangeEach(elements[0], elements[2], function(i) {
          var translatedIndex = _this5.translateTrimmedRow(i);
          rowObjects.push(_this5.getDataObject(translatedIndex));
        });
        rangeEach(0, rowObjects.length - 2, function(i) {
          _this5.detachFromParent(rowObjects[i], false);
        });
        element = rowObjects[rowObjects.length - 1];
      } else {
        element = elements;
      }
      var childRowIndex = this.getRowIndex(element);
      var indexWithinParent = this.getRowIndexWithinParent(element);
      var parent = this.getRowParent(element);
      var grandparent = this.getRowParent(parent);
      var grandparentRowIndex = this.getRowIndex(grandparent);
      var movedElementRowIndex = null;
      this.hot.runHooks("beforeDetachChild", parent, element);
      if (indexWithinParent !== null && indexWithinParent !== void 0) {
        this.hot.runHooks("beforeRemoveRow", childRowIndex, 1, [childRowIndex], this.plugin.pluginName);
        parent.__children.splice(indexWithinParent, 1);
        this.rewriteCache();
        this.hot.runHooks("afterRemoveRow", childRowIndex, 1, [childRowIndex], this.plugin.pluginName);
        if (grandparent) {
          movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);
          this.hot.runHooks("beforeCreateRow", movedElementRowIndex, 1, this.plugin.pluginName);
          grandparent.__children.push(element);
        } else {
          movedElementRowIndex = this.hot.countRows() + 1;
          this.hot.runHooks("beforeCreateRow", movedElementRowIndex, 1, this.plugin.pluginName);
          this.data.push(element);
        }
      }
      this.rewriteCache();
      this.hot.runHooks("afterCreateRow", movedElementRowIndex, 1, this.plugin.pluginName);
      this.hot.runHooks("afterDetachChild", parent, element);
      if (forceRender) {
        this.hot.render();
      }
    }
  }, {
    key: "filterData",
    value: function filterData(index, amount, logicRows) {
      var _this6 = this;
      var elementsToRemove = [];
      arrayEach(logicRows, function(elem) {
        elementsToRemove.push(_this6.getDataObject(elem));
      });
      arrayEach(elementsToRemove, function(elem) {
        var indexWithinParent = _this6.getRowIndexWithinParent(elem);
        var tempParent = _this6.getRowParent(elem);
        if (tempParent === null) {
          _this6.data.splice(indexWithinParent, 1);
        } else {
          tempParent.__children.splice(indexWithinParent, 1);
        }
      });
      this.rewriteCache();
    }
  }, {
    key: "spliceData",
    value: function spliceData(index, amount, elements) {
      var previousElement = this.getDataObject(index - 1);
      var newRowParent = null;
      var indexWithinParent = index;
      if (previousElement && previousElement.__children && previousElement.__children.length === 0) {
        newRowParent = previousElement;
        indexWithinParent = 0;
      } else if (index < this.countAllRows()) {
        newRowParent = this.getRowParent(index);
        indexWithinParent = this.getRowIndexWithinParent(index);
      }
      if (newRowParent) {
        if (elements) {
          var _newRowParent$__child;
          (_newRowParent$__child = newRowParent.__children).splice.apply(_newRowParent$__child, [indexWithinParent, amount].concat(_toConsumableArray$v(elements)));
        } else {
          newRowParent.__children.splice(indexWithinParent, amount);
        }
      } else if (elements) {
        var _this$data;
        (_this$data = this.data).splice.apply(_this$data, [indexWithinParent, amount].concat(_toConsumableArray$v(elements)));
      } else {
        this.data.splice(indexWithinParent, amount);
      }
      this.rewriteCache();
    }
  }, {
    key: "syncRowWithRawSource",
    value: function syncRowWithRawSource(rowElement) {
      var upmostParent = rowElement;
      var tempParent = null;
      do {
        tempParent = this.getRowParent(tempParent);
        if (tempParent !== null) {
          upmostParent = tempParent;
        }
      } while (tempParent !== null);
      this.plugin.disableCoreAPIModifiers();
      this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), "__children", upmostParent.__children, "NestedRows.syncRowWithRawSource");
      this.plugin.enableCoreAPIModifiers();
    }
  }, {
    key: "moveRow",
    value: function moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {
      var moveToLastRow = toIndex === this.hot.countRows();
      var fromParent = this.getRowParent(fromIndex);
      var indexInFromParent = this.getRowIndexWithinParent(fromIndex);
      var elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);
      var movingUp = fromIndex > toIndex;
      var toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);
      if (toParent === null || toParent === void 0) {
        toParent = this.getRowParent(toIndex - 1);
      }
      if (toParent === null || toParent === void 0) {
        toParent = this.getDataObject(toIndex - 1);
      }
      if (!toParent) {
        toParent = this.getDataObject(toIndex);
        toParent.__children = [];
      } else if (!toParent.__children) {
        toParent.__children = [];
      }
      var indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);
      var sameParent = fromParent === toParent;
      toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);
      fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);
      this.syncRowWithRawSource(fromParent);
      if (!sameParent) {
        this.syncRowWithRawSource(toParent);
      }
    }
  }, {
    key: "translateTrimmedRow",
    value: function translateTrimmedRow(row) {
      if (this.plugin.collapsingUI) {
        return this.plugin.collapsingUI.translateTrimmedRow(row);
      }
      return row;
    }
  }, {
    key: "untranslateTrimmedRow",
    value: function untranslateTrimmedRow(row) {
      if (this.plugin.collapsingUI) {
        return this.plugin.collapsingUI.untranslateTrimmedRow(row);
      }
      return row;
    }
  }]);
  return DataManager2;
}();

function _classCallCheck$2w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var BaseUI$3 = function BaseUI2(pluginInstance, hotInstance) {
  _classCallCheck$2w(this, BaseUI2);
  this.hot = hotInstance;
  this.plugin = pluginInstance;
};

function _typeof$1t(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1t = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1t = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1t(obj);
}
function _classCallCheck$2x(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2q(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2q(Constructor, staticProps);
  return Constructor;
}
function _inherits$1f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1g(subClass, superClass);
}
function _setPrototypeOf$1g(o, p) {
  _setPrototypeOf$1g = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1g(o, p);
}
function _createSuper$1f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1f(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1f(this, result);
  };
}
function _possibleConstructorReturn$1f(self, call) {
  if (call && (_typeof$1t(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1f(self);
}
function _assertThisInitialized$1f(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1f(o) {
  _getPrototypeOf$1f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1f(o);
}
var HeadersUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$1f(HeadersUI2, _BaseUI);
  var _super = _createSuper$1f(HeadersUI2);
  function HeadersUI2(nestedRowsPlugin, hotInstance) {
    var _this;
    _classCallCheck$2x(this, HeadersUI2);
    _this = _super.call(this, nestedRowsPlugin, hotInstance);
    _this.dataManager = _this.plugin.dataManager;
    _this.collapsingUI = _this.plugin.collapsingUI;
    _this.rowHeaderWidthCache = null;
    return _this;
  }
  _createClass$2q(HeadersUI2, [{
    key: "appendLevelIndicators",
    value: function appendLevelIndicators(row, TH) {
      var rowIndex = this.hot.toPhysicalRow(row);
      var rowLevel = this.dataManager.getRowLevel(rowIndex);
      var rowObject = this.dataManager.getDataObject(rowIndex);
      var innerDiv = TH.getElementsByTagName("DIV")[0];
      var innerSpan = innerDiv.querySelector("span.rowHeader");
      var previousIndicators = innerDiv.querySelectorAll('[class^="ht_nesting"]');
      arrayEach(previousIndicators, function(elem) {
        if (elem) {
          innerDiv.removeChild(elem);
        }
      });
      addClass(TH, HeadersUI2.CSS_CLASSES.indicatorContainer);
      if (rowLevel) {
        var rootDocument = this.hot.rootDocument;
        var initialContent = innerSpan.cloneNode(true);
        innerDiv.innerHTML = "";
        rangeEach(0, rowLevel - 1, function() {
          var levelIndicator = rootDocument.createElement("SPAN");
          addClass(levelIndicator, HeadersUI2.CSS_CLASSES.emptyIndicator);
          innerDiv.appendChild(levelIndicator);
        });
        innerDiv.appendChild(initialContent);
      }
      if (this.dataManager.hasChildren(rowObject)) {
        var buttonsContainer = this.hot.rootDocument.createElement("DIV");
        addClass(TH, HeadersUI2.CSS_CLASSES.parent);
        if (this.collapsingUI.areChildrenCollapsed(rowIndex)) {
          addClass(buttonsContainer, "".concat(HeadersUI2.CSS_CLASSES.button, " ").concat(HeadersUI2.CSS_CLASSES.expandButton));
        } else {
          addClass(buttonsContainer, "".concat(HeadersUI2.CSS_CLASSES.button, " ").concat(HeadersUI2.CSS_CLASSES.collapseButton));
        }
        innerDiv.appendChild(buttonsContainer);
      }
    }
  }, {
    key: "updateRowHeaderWidth",
    value: function updateRowHeaderWidth(deepestLevel) {
      var deepestLevelIndex = deepestLevel;
      if (!deepestLevelIndex) {
        deepestLevelIndex = this.dataManager.cache.levelCount;
      }
      this.rowHeaderWidthCache = Math.max(50, 11 + 10 * deepestLevelIndex + 25);
      this.hot.render();
    }
  }], [{
    key: "CSS_CLASSES",
    get: function get() {
      return {
        indicatorContainer: "ht_nestingLevels",
        parent: "ht_nestingParent",
        indicator: "ht_nestingLevel",
        emptyIndicator: "ht_nestingLevel_empty",
        button: "ht_nestingButton",
        expandButton: "ht_nestingExpand",
        collapseButton: "ht_nestingCollapse"
      };
    }
  }]);
  return HeadersUI2;
}(BaseUI$3);

function _typeof$1u(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1u = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1u = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1u(obj);
}
function _toConsumableArray$w(arr) {
  return _arrayWithoutHoles$u(arr) || _iterableToArray$w(arr) || _unsupportedIterableToArray$14(arr) || _nonIterableSpread$u();
}
function _nonIterableSpread$u() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$14(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$14(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$14(o, minLen);
}
function _iterableToArray$w(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$u(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$14(arr);
}
function _arrayLikeToArray$14(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$2y(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2r(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2r(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2r(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2r(Constructor, staticProps);
  return Constructor;
}
function _inherits$1g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1h(subClass, superClass);
}
function _setPrototypeOf$1h(o, p) {
  _setPrototypeOf$1h = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1h(o, p);
}
function _createSuper$1g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1g(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1g(this, result);
  };
}
function _possibleConstructorReturn$1g(self, call) {
  if (call && (_typeof$1u(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1g(self);
}
function _assertThisInitialized$1g(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1g(o) {
  _getPrototypeOf$1g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1g(o);
}
var CollapsingUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$1g(CollapsingUI2, _BaseUI);
  var _super = _createSuper$1g(CollapsingUI2);
  function CollapsingUI2(nestedRowsPlugin, hotInstance) {
    var _this;
    _classCallCheck$2y(this, CollapsingUI2);
    _this = _super.call(this, nestedRowsPlugin, hotInstance);
    _this.dataManager = _this.plugin.dataManager;
    _this.collapsedRows = [];
    _this.collapsedRowsStash = {
      stash: function stash() {
        var forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        _this.lastCollapsedRows = _this.collapsedRows.slice(0);
        _this.expandMultipleChildren(_this.lastCollapsedRows, forceRender);
      },
      shiftStash: function shiftStash(baseIndex, targetIndex) {
        var delta = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        if (targetIndex === null || targetIndex === void 0) {
          targetIndex = Infinity;
        }
        arrayEach(_this.lastCollapsedRows, function(elem, i) {
          if (elem >= baseIndex && elem < targetIndex) {
            _this.lastCollapsedRows[i] = elem + delta;
          }
        });
      },
      applyStash: function applyStash() {
        var forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        _this.collapseMultipleChildren(_this.lastCollapsedRows, forceRender);
        _this.lastCollapsedRows = void 0;
      },
      trimStash: function trimStash(realElementIndex, amount) {
        rangeEach(realElementIndex, realElementIndex + amount - 1, function(i) {
          var indexOfElement = _this.lastCollapsedRows.indexOf(i);
          if (indexOfElement > -1) {
            _this.lastCollapsedRows.splice(indexOfElement, 1);
          }
        });
      }
    };
    return _this;
  }
  _createClass$2r(CollapsingUI2, [{
    key: "collapseChildren",
    value: function collapseChildren(row) {
      var _this2 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var rowsToCollapse = [];
      var rowObject = null;
      var rowIndex = null;
      var rowsToTrim = null;
      if (isNaN(row)) {
        rowObject = row;
        rowIndex = this.dataManager.getRowIndex(rowObject);
      } else {
        rowObject = this.dataManager.getDataObject(row);
        rowIndex = row;
      }
      if (this.dataManager.hasChildren(rowObject)) {
        arrayEach(rowObject.__children, function(elem) {
          rowsToCollapse.push(_this2.dataManager.getRowIndex(elem));
        });
      }
      rowsToTrim = this.collapseRows(rowsToCollapse, true, false);
      if (doTrimming) {
        this.trimRows(rowsToTrim);
      }
      if (forceRender) {
        this.renderAndAdjust();
      }
      if (this.collapsedRows.indexOf(rowIndex) === -1) {
        this.collapsedRows.push(rowIndex);
      }
      return rowsToTrim;
    }
  }, {
    key: "collapseMultipleChildren",
    value: function collapseMultipleChildren(rows) {
      var _this3 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var rowsToTrim = [];
      arrayEach(rows, function(elem) {
        rowsToTrim.push.apply(rowsToTrim, _toConsumableArray$w(_this3.collapseChildren(elem, false, false)));
      });
      if (doTrimming) {
        this.trimRows(rowsToTrim);
      }
      if (forceRender) {
        this.renderAndAdjust();
      }
    }
  }, {
    key: "collapseRow",
    value: function collapseRow(rowIndex) {
      var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      this.collapseRows([rowIndex], recursive);
    }
  }, {
    key: "collapseRows",
    value: function collapseRows(rowIndexes) {
      var _this4 = this;
      var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var rowsToTrim = [];
      arrayEach(rowIndexes, function(elem) {
        rowsToTrim.push(elem);
        if (recursive) {
          _this4.collapseChildRows(elem, rowsToTrim);
        }
      });
      if (doTrimming) {
        this.trimRows(rowsToTrim);
      }
      return rowsToTrim;
    }
  }, {
    key: "collapseChildRows",
    value: function collapseChildRows(parentIndex) {
      var _this5 = this;
      var rowsToTrim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var doTrimming = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (this.dataManager.hasChildren(parentIndex)) {
        var parentObject = this.dataManager.getDataObject(parentIndex);
        arrayEach(parentObject.__children, function(elem) {
          var elemIndex = _this5.dataManager.getRowIndex(elem);
          rowsToTrim.push(elemIndex);
          _this5.collapseChildRows(elemIndex, rowsToTrim);
        });
      }
      if (doTrimming) {
        this.trimRows(rowsToTrim);
      }
    }
  }, {
    key: "expandRow",
    value: function expandRow(rowIndex) {
      var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      this.expandRows([rowIndex], recursive);
    }
  }, {
    key: "expandRows",
    value: function expandRows(rowIndexes) {
      var _this6 = this;
      var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var rowsToUntrim = [];
      arrayEach(rowIndexes, function(elem) {
        rowsToUntrim.push(elem);
        if (recursive) {
          _this6.expandChildRows(elem, rowsToUntrim);
        }
      });
      if (doTrimming) {
        this.untrimRows(rowsToUntrim);
      }
      return rowsToUntrim;
    }
  }, {
    key: "expandChildRows",
    value: function expandChildRows(parentIndex) {
      var _this7 = this;
      var rowsToUntrim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var doTrimming = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (this.dataManager.hasChildren(parentIndex)) {
        var parentObject = this.dataManager.getDataObject(parentIndex);
        arrayEach(parentObject.__children, function(elem) {
          if (!_this7.isAnyParentCollapsed(elem)) {
            var elemIndex = _this7.dataManager.getRowIndex(elem);
            rowsToUntrim.push(elemIndex);
            _this7.expandChildRows(elemIndex, rowsToUntrim);
          }
        });
      }
      if (doTrimming) {
        this.untrimRows(rowsToUntrim);
      }
    }
  }, {
    key: "expandChildren",
    value: function expandChildren(row) {
      var _this8 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var rowsToExpand = [];
      var rowObject = null;
      var rowIndex = null;
      var rowsToUntrim = null;
      if (isNaN(row)) {
        rowObject = row;
        rowIndex = this.dataManager.getRowIndex(row);
      } else {
        rowObject = this.dataManager.getDataObject(row);
        rowIndex = row;
      }
      this.collapsedRows.splice(this.collapsedRows.indexOf(rowIndex), 1);
      if (this.dataManager.hasChildren(rowObject)) {
        arrayEach(rowObject.__children, function(elem) {
          var childIndex = _this8.dataManager.getRowIndex(elem);
          rowsToExpand.push(childIndex);
        });
      }
      rowsToUntrim = this.expandRows(rowsToExpand, true, false);
      if (doTrimming) {
        this.untrimRows(rowsToUntrim);
      }
      if (forceRender) {
        this.renderAndAdjust();
      }
      return rowsToUntrim;
    }
  }, {
    key: "expandMultipleChildren",
    value: function expandMultipleChildren(rows) {
      var _this9 = this;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var rowsToUntrim = [];
      arrayEach(rows, function(elem) {
        rowsToUntrim.push.apply(rowsToUntrim, _toConsumableArray$w(_this9.expandChildren(elem, false, false)));
      });
      if (doTrimming) {
        this.untrimRows(rowsToUntrim);
      }
      if (forceRender) {
        this.renderAndAdjust();
      }
    }
  }, {
    key: "collapseAll",
    value: function collapseAll() {
      var _this10 = this;
      var data = this.dataManager.getData();
      var parentsToCollapse = [];
      arrayEach(data, function(elem) {
        if (_this10.dataManager.hasChildren(elem)) {
          parentsToCollapse.push(elem);
        }
      });
      this.collapseMultipleChildren(parentsToCollapse);
      this.renderAndAdjust();
    }
  }, {
    key: "expandAll",
    value: function expandAll() {
      var _this11 = this;
      var data = this.dataManager.getData();
      var parentsToExpand = [];
      arrayEach(data, function(elem) {
        if (_this11.dataManager.hasChildren(elem)) {
          parentsToExpand.push(elem);
        }
      });
      this.expandMultipleChildren(parentsToExpand);
      this.renderAndAdjust();
    }
  }, {
    key: "trimRows",
    value: function trimRows(rows) {
      var _this12 = this;
      this.hot.batchExecution(function() {
        arrayEach(rows, function(physicalRow) {
          _this12.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, true);
        });
      }, true);
    }
  }, {
    key: "untrimRows",
    value: function untrimRows(rows) {
      var _this13 = this;
      this.hot.batchExecution(function() {
        arrayEach(rows, function(physicalRow) {
          _this13.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, false);
        });
      }, true);
    }
  }, {
    key: "areChildrenCollapsed",
    value: function areChildrenCollapsed(row) {
      var _this14 = this;
      var rowObj = isNaN(row) ? row : this.dataManager.getDataObject(row);
      var allCollapsed = true;
      if (rowObj === null) {
        rowObj = {
          __children: this.dataManager.data
        };
      }
      if (this.dataManager.hasChildren(rowObj)) {
        arrayEach(rowObj.__children, function(elem) {
          var rowIndex = _this14.dataManager.getRowIndex(elem);
          if (!_this14.plugin.collapsedRowsMap.getValueAtIndex(rowIndex)) {
            allCollapsed = false;
            return false;
          }
        });
      }
      return allCollapsed;
    }
  }, {
    key: "isAnyParentCollapsed",
    value: function isAnyParentCollapsed(rowObj) {
      var parent = rowObj;
      while (parent !== null) {
        parent = this.dataManager.getRowParent(parent);
        var parentIndex = this.dataManager.getRowIndex(parent);
        if (this.collapsedRows.indexOf(parentIndex) > -1) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "toggleState",
    value: function toggleState(event, coords) {
      if (coords.col >= 0) {
        return;
      }
      var row = this.translateTrimmedRow(coords.row);
      if (hasClass(event.target, HeadersUI.CSS_CLASSES.button)) {
        if (this.areChildrenCollapsed(row)) {
          this.expandChildren(row);
        } else {
          this.collapseChildren(row);
        }
        stopImmediatePropagation(event);
      }
    }
  }, {
    key: "translateTrimmedRow",
    value: function translateTrimmedRow(row) {
      return this.hot.toPhysicalRow(row);
    }
  }, {
    key: "untranslateTrimmedRow",
    value: function untranslateTrimmedRow(row) {
      return this.hot.toVisualRow(row);
    }
  }, {
    key: "renderAndAdjust",
    value: function renderAndAdjust() {
      this.hot.render();
      this.hot.view.adjustElementsSize();
    }
  }]);
  return CollapsingUI2;
}(BaseUI$3);

function _typeof$1v(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1v = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1v = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1v(obj);
}
function _classCallCheck$2z(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2s(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2s(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2s(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2s(Constructor, staticProps);
  return Constructor;
}
function _inherits$1h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1i(subClass, superClass);
}
function _setPrototypeOf$1i(o, p) {
  _setPrototypeOf$1i = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1i(o, p);
}
function _createSuper$1h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1h(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1h(this, result);
  };
}
function _possibleConstructorReturn$1h(self, call) {
  if (call && (_typeof$1v(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1h(self);
}
function _assertThisInitialized$1h(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1h(o) {
  _getPrototypeOf$1h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1h(o);
}
var privatePool$k = new WeakMap();
var ContextMenuUI = /* @__PURE__ */ function(_BaseUI) {
  _inherits$1h(ContextMenuUI2, _BaseUI);
  var _super = _createSuper$1h(ContextMenuUI2);
  function ContextMenuUI2(nestedRowsPlugin, hotInstance) {
    var _this;
    _classCallCheck$2z(this, ContextMenuUI2);
    _this = _super.call(this, nestedRowsPlugin, hotInstance);
    privatePool$k.set(_assertThisInitialized$1h(_this), {
      row_above: function row_above(key, selection) {
        var lastSelection = selection[selection.length - 1];
        _this.dataManager.addSibling(lastSelection.start.row, "above");
      },
      row_below: function row_below(key, selection) {
        var lastSelection = selection[selection.length - 1];
        _this.dataManager.addSibling(lastSelection.start.row, "below");
      }
    });
    _this.dataManager = _this.plugin.dataManager;
    return _this;
  }
  _createClass$2s(ContextMenuUI2, [{
    key: "appendOptions",
    value: function appendOptions(defaultOptions) {
      var _this2 = this;
      var newEntries = [{
        key: "add_child",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD);
        },
        callback: function callback() {
          var translatedRowIndex = _this2.dataManager.translateTrimmedRow(_this2.hot.getSelectedLast()[0]);
          var parent = _this2.dataManager.getDataObject(translatedRowIndex);
          _this2.dataManager.addChild(parent);
        },
        disabled: function disabled() {
          var selected = _this2.hot.getSelectedLast();
          return !selected || selected[0] < 0 || _this2.hot.selection.isSelectedByColumnHeader() || _this2.hot.countRows() >= _this2.hot.getSettings().maxRows;
        }
      }, {
        key: "detach_from_parent",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD);
        },
        callback: function callback() {
          _this2.dataManager.detachFromParent(_this2.hot.getSelectedLast());
        },
        disabled: function disabled() {
          var selected = _this2.hot.getSelectedLast();
          var translatedRowIndex = _this2.dataManager.translateTrimmedRow(selected[0]);
          var parent = _this2.dataManager.getRowParent(translatedRowIndex);
          return !parent || !selected || selected[0] < 0 || _this2.hot.selection.isSelectedByColumnHeader() || _this2.hot.countRows() >= _this2.hot.getSettings().maxRows;
        }
      }, {
        name: "---------"
      }];
      rangeEach(0, defaultOptions.items.length - 1, function(i) {
        if (i === 0) {
          arrayEach(newEntries, function(val, j) {
            defaultOptions.items.splice(i + j, 0, val);
          });
          return false;
        }
      });
      return this.modifyRowInsertingOptions(defaultOptions);
    }
  }, {
    key: "modifyRowInsertingOptions",
    value: function modifyRowInsertingOptions(defaultOptions) {
      var priv = privatePool$k.get(this);
      rangeEach(0, defaultOptions.items.length - 1, function(i) {
        var option = priv[defaultOptions.items[i].key];
        if (option !== null && option !== void 0) {
          defaultOptions.items[i].callback = option;
        }
      });
      return defaultOptions;
    }
  }]);
  return ContextMenuUI2;
}(BaseUI$3);

var _templateObject$f;
function _toConsumableArray$x(arr) {
  return _arrayWithoutHoles$v(arr) || _iterableToArray$x(arr) || _unsupportedIterableToArray$15(arr) || _nonIterableSpread$v();
}
function _nonIterableSpread$v() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$15(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$15(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$15(o, minLen);
}
function _iterableToArray$x(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$v(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$15(arr);
}
function _arrayLikeToArray$15(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _taggedTemplateLiteral$f(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
}
function _classCallCheck$2A(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2t(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2t(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2t(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2t(Constructor, staticProps);
  return Constructor;
}
var RowMoveController = /* @__PURE__ */ function() {
  function RowMoveController2(plugin) {
    _classCallCheck$2A(this, RowMoveController2);
    this.plugin = plugin;
    this.hot = plugin.hot;
    this.dataManager = plugin.dataManager;
    this.collapsingUI = plugin.collapsingUI;
  }
  _createClass$2t(RowMoveController2, [{
    key: "onBeforeRowMove",
    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {
      var _this = this;
      var improperUsage = this.displayAPICompatibilityWarning({
        rows,
        finalIndex,
        dropIndex,
        movePossible
      });
      if (improperUsage) {
        return false;
      }
      this.movedToCollapsed = false;
      var dropToLastRow = dropIndex === this.hot.countRows();
      var physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);
      var allowMove = true;
      var physicalStartIndexes = rows.map(function(rowIndex) {
        if (!allowMove) {
          return false;
        }
        var physicalRowIndex = _this.dataManager.translateTrimmedRow(rowIndex);
        allowMove = _this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);
        return physicalRowIndex;
      });
      var willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;
      if (!allowMove || !willDataChange) {
        return false;
      }
      var baseParent = this.getBaseParent(physicalStartIndexes);
      var targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);
      var sameParent = baseParent === targetParent;
      this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent);
      this.collapsingUI.collapsedRowsStash.stash();
      this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);
      this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);
      this.dataManager.updateWithData(this.dataManager.getRawSourceData());
      this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);
      this.collapsingUI.collapsedRowsStash.applyStash(false);
      this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));
      this.hot.render();
      this.selectCells(rows, dropIndex);
      return false;
    }
  }, {
    key: "displayAPICompatibilityWarning",
    value: function displayAPICompatibilityWarning(beforeMoveRowHookArgs) {
      var rows = beforeMoveRowHookArgs.rows, finalIndex = beforeMoveRowHookArgs.finalIndex, dropIndex = beforeMoveRowHookArgs.dropIndex, movePossible = beforeMoveRowHookArgs.movePossible;
      var shouldTerminate = false;
      if (isUndefined$1(dropIndex)) {
        warn$1(toSingleLine(_templateObject$f || (_templateObject$f = _taggedTemplateLiteral$f(["Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows \n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead."], ["Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\x20\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead."]))));
        this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, false);
        shouldTerminate = true;
      }
      return shouldTerminate;
    }
  }, {
    key: "shouldAllowMoving",
    value: function shouldAllowMoving(physicalRowIndex, physicalDropIndex) {
      return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);
    }
  }, {
    key: "getBaseParent",
    value: function getBaseParent(physicalStartIndexes) {
      return this.dataManager.getRowParent(physicalStartIndexes[0]);
    }
  }, {
    key: "getTargetParent",
    value: function getTargetParent(dropToLastRow, physicalDropIndex) {
      var targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex);
      if (targetParent === null || targetParent === void 0) {
        targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);
      }
      return targetParent;
    }
  }, {
    key: "shiftCollapsibleParentsLocations",
    value: function shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {
      if (!sameParent) {
        if (Math.max.apply(Math, _toConsumableArray$x(physicalStartIndexes)) <= physicalDropIndex) {
          this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);
        } else {
          this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);
        }
      }
    }
  }, {
    key: "moveRows",
    value: function moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {
      var _this2 = this;
      var moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;
      this.hot.batchRender(function() {
        physicalStartIndexes.forEach(function(physicalStartIndex) {
          _this2.dataManager.moveRow(physicalStartIndex, physicalDropIndex, _this2.movedToCollapsed, moveToLastChild);
        });
      });
    }
  }, {
    key: "moveCellsMeta",
    value: function moveCellsMeta(baseIndexes, targetIndex) {
      var _this3 = this, _this$hot;
      var rowsOfMeta = [];
      var movingDown = Math.max.apply(Math, _toConsumableArray$x(baseIndexes)) < targetIndex;
      baseIndexes.forEach(function(baseIndex) {
        rowsOfMeta.push(_this3.hot.getCellMetaAtRow(baseIndex));
      });
      this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);
      (_this$hot = this.hot).spliceCellsMeta.apply(_this$hot, [targetIndex - (movingDown ? rowsOfMeta.length : 0), 0].concat(rowsOfMeta));
    }
  }, {
    key: "selectCells",
    value: function selectCells(rows, dropIndex) {
      var rowsLen = rows.length;
      var startRow = 0;
      var endRow = 0;
      var selection = null;
      var lastColIndex = null;
      if (this.movedToCollapsed) {
        var physicalDropIndex = null;
        if (rows[rowsLen - 1] < dropIndex) {
          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);
        } else {
          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);
        }
        var parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);
        var parentIndex = this.dataManager.getRowIndex(parentObject);
        startRow = this.dataManager.untranslateTrimmedRow(parentIndex);
        endRow = startRow;
      } else if (rows[rowsLen - 1] < dropIndex) {
        endRow = dropIndex - 1;
        startRow = endRow - rowsLen + 1;
      } else {
        startRow = dropIndex;
        endRow = startRow + rowsLen - 1;
      }
      selection = this.hot.selection;
      lastColIndex = this.hot.countCols() - 1;
      selection.setRangeStart(new CellCoords(startRow, 0));
      selection.setRangeEnd(new CellCoords(endRow, lastColIndex), true);
    }
  }, {
    key: "isRowOrderChanged",
    value: function isRowOrderChanged(movedRows, finalIndex) {
      return movedRows.some(function(row, nrOfMovedElement) {
        return row - nrOfMovedElement !== finalIndex;
      });
    }
  }]);
  return RowMoveController2;
}();

function _typeof$1w(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1w = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1w = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1w(obj);
}
function _toConsumableArray$y(arr) {
  return _arrayWithoutHoles$w(arr) || _iterableToArray$y(arr) || _unsupportedIterableToArray$16(arr) || _nonIterableSpread$w();
}
function _nonIterableSpread$w() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$16(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$16(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$16(o, minLen);
}
function _iterableToArray$y(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$w(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$16(arr);
}
function _arrayLikeToArray$16(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$2B(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2u(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2u(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2u(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2u(Constructor, staticProps);
  return Constructor;
}
function _get$P(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$P = Reflect.get;
  } else {
    _get$P = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$P(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$P(target, property, receiver || target);
}
function _superPropBase$P(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1i(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$1i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1j(subClass, superClass);
}
function _setPrototypeOf$1j(o, p) {
  _setPrototypeOf$1j = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1j(o, p);
}
function _createSuper$1i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1i(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1i(this, result);
  };
}
function _possibleConstructorReturn$1i(self, call) {
  if (call && (_typeof$1w(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1i(self);
}
function _assertThisInitialized$1i(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1i(o) {
  _getPrototypeOf$1i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1i(o);
}
var PLUGIN_KEY$u = "nestedRows";
var PLUGIN_PRIORITY$s = 300;
var privatePool$l = new WeakMap();
var NestedRows = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$1i(NestedRows2, _BasePlugin);
  var _super = _createSuper$1i(NestedRows2);
  function NestedRows2(hotInstance) {
    var _this;
    _classCallCheck$2B(this, NestedRows2);
    _this = _super.call(this, hotInstance);
    _this.dataManager = null;
    _this.headersUI = null;
    _this.collapsedRowsMap = null;
    privatePool$l.set(_assertThisInitialized$1i(_this), {
      movedToCollapsed: false,
      skipRender: null,
      skipCoreAPIModifiers: false
    });
    return _this;
  }
  _createClass$2u(NestedRows2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$u];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.collapsedRowsMap = this.hot.rowIndexMapper.registerMap("nestedRows", new TrimmingMap());
      this.dataManager = new DataManager(this, this.hot);
      this.collapsingUI = new CollapsingUI(this, this.hot);
      this.headersUI = new HeadersUI(this, this.hot);
      this.contextMenuUI = new ContextMenuUI(this, this.hot);
      this.rowMoveController = new RowMoveController(this);
      this.addHook("afterInit", function() {
        return _this2.onAfterInit.apply(_this2, arguments);
      });
      this.addHook("beforeRender", function() {
        return _this2.onBeforeRender.apply(_this2, arguments);
      });
      this.addHook("modifyRowData", function() {
        return _this2.onModifyRowData.apply(_this2, arguments);
      });
      this.addHook("modifySourceLength", function() {
        return _this2.onModifySourceLength.apply(_this2, arguments);
      });
      this.addHook("beforeDataSplice", function() {
        return _this2.onBeforeDataSplice.apply(_this2, arguments);
      });
      this.addHook("beforeDataFilter", function() {
        return _this2.onBeforeDataFilter.apply(_this2, arguments);
      });
      this.addHook("afterContextMenuDefaultOptions", function() {
        return _this2.onAfterContextMenuDefaultOptions.apply(_this2, arguments);
      });
      this.addHook("afterGetRowHeader", function() {
        return _this2.onAfterGetRowHeader.apply(_this2, arguments);
      });
      this.addHook("beforeOnCellMouseDown", function() {
        return _this2.onBeforeOnCellMouseDown.apply(_this2, arguments);
      });
      this.addHook("beforeRemoveRow", function() {
        return _this2.onBeforeRemoveRow.apply(_this2, arguments);
      });
      this.addHook("afterRemoveRow", function() {
        return _this2.onAfterRemoveRow.apply(_this2, arguments);
      });
      this.addHook("beforeAddChild", function() {
        return _this2.onBeforeAddChild.apply(_this2, arguments);
      });
      this.addHook("afterAddChild", function() {
        return _this2.onAfterAddChild.apply(_this2, arguments);
      });
      this.addHook("beforeDetachChild", function() {
        return _this2.onBeforeDetachChild.apply(_this2, arguments);
      });
      this.addHook("afterDetachChild", function() {
        return _this2.onAfterDetachChild.apply(_this2, arguments);
      });
      this.addHook("modifyRowHeaderWidth", function() {
        return _this2.onModifyRowHeaderWidth.apply(_this2, arguments);
      });
      this.addHook("afterCreateRow", function() {
        return _this2.onAfterCreateRow.apply(_this2, arguments);
      });
      this.addHook("beforeRowMove", function() {
        return _this2.onBeforeRowMove.apply(_this2, arguments);
      });
      this.addHook("beforeLoadData", function(data) {
        return _this2.onBeforeLoadData(data);
      });
      _get$P(_getPrototypeOf$1i(NestedRows2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.rowIndexMapper.unregisterMap("nestedRows");
      _get$P(_getPrototypeOf$1i(NestedRows2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      var vanillaSourceData = this.hot.getSourceData();
      this.enablePlugin();
      this.dataManager.updateWithData(vanillaSourceData);
      _get$P(_getPrototypeOf$1i(NestedRows2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "onBeforeRowMove",
    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {
      return this.rowMoveController.onBeforeRowMove(rows, finalIndex, dropIndex, movePossible);
    }
  }, {
    key: "disableCoreAPIModifiers",
    value: function disableCoreAPIModifiers() {
      var priv = privatePool$l.get(this);
      priv.skipCoreAPIModifiers = true;
    }
  }, {
    key: "enableCoreAPIModifiers",
    value: function enableCoreAPIModifiers() {
      var priv = privatePool$l.get(this);
      priv.skipCoreAPIModifiers = false;
    }
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event, coords, TD) {
      this.collapsingUI.toggleState(event, coords, TD);
    }
  }, {
    key: "onModifyRowData",
    value: function onModifyRowData(row) {
      var priv = privatePool$l.get(this);
      if (priv.skipCoreAPIModifiers) {
        return;
      }
      return this.dataManager.getDataObject(row);
    }
  }, {
    key: "onModifySourceLength",
    value: function onModifySourceLength() {
      var priv = privatePool$l.get(this);
      if (priv.skipCoreAPIModifiers) {
        return;
      }
      return this.dataManager.countAllRows();
    }
  }, {
    key: "onBeforeDataSplice",
    value: function onBeforeDataSplice(index, amount, element) {
      var priv = privatePool$l.get(this);
      if (priv.skipCoreAPIModifiers || this.dataManager.isRowHighestLevel(index)) {
        return true;
      }
      this.dataManager.spliceData(index, amount, element);
      return false;
    }
  }, {
    key: "onBeforeDataFilter",
    value: function onBeforeDataFilter(index, amount, physicalRows) {
      var priv = privatePool$l.get(this);
      this.collapsingUI.collapsedRowsStash.stash();
      this.collapsingUI.collapsedRowsStash.trimStash(physicalRows[0], amount);
      this.collapsingUI.collapsedRowsStash.shiftStash(physicalRows[0], null, -1 * amount);
      this.dataManager.filterData(index, amount, physicalRows);
      priv.skipRender = true;
      return false;
    }
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(defaultOptions) {
      return this.contextMenuUI.appendOptions(defaultOptions);
    }
  }, {
    key: "onAfterGetRowHeader",
    value: function onAfterGetRowHeader(row, TH) {
      this.headersUI.appendLevelIndicators(row, TH);
    }
  }, {
    key: "onModifyRowHeaderWidth",
    value: function onModifyRowHeaderWidth(rowHeaderWidth) {
      return this.headersUI.rowHeaderWidthCache || rowHeaderWidth;
    }
  }, {
    key: "onAfterRemoveRow",
    value: function onAfterRemoveRow(index, amount, logicRows, source) {
      var _this3 = this;
      if (source === this.pluginName) {
        return;
      }
      var priv = privatePool$l.get(this);
      setTimeout(function() {
        priv.skipRender = null;
        _this3.headersUI.updateRowHeaderWidth();
        _this3.collapsingUI.collapsedRowsStash.applyStash();
      }, 0);
    }
  }, {
    key: "onBeforeRemoveRow",
    value: function onBeforeRemoveRow(index, amount, physicalRows) {
      var _this4 = this;
      var modifiedPhysicalRows = Array.from(physicalRows.reduce(function(removedRows, physicalIndex) {
        if (_this4.dataManager.isParent(physicalIndex)) {
          var children = _this4.dataManager.getDataObject(physicalIndex).__children;
          removedRows.add(physicalIndex);
          if (Array.isArray(children)) {
            children.forEach(function(child) {
              return removedRows.add(_this4.dataManager.getRowIndex(child));
            });
          }
          return removedRows;
        }
        return removedRows.add(physicalIndex);
      }, new Set()));
      physicalRows.length = 0;
      physicalRows.push.apply(physicalRows, _toConsumableArray$y(modifiedPhysicalRows));
    }
  }, {
    key: "onBeforeAddChild",
    value: function onBeforeAddChild() {
      this.collapsingUI.collapsedRowsStash.stash();
    }
  }, {
    key: "onAfterAddChild",
    value: function onAfterAddChild(parent, element) {
      this.collapsingUI.collapsedRowsStash.shiftStash(this.dataManager.getRowIndex(element));
      this.collapsingUI.collapsedRowsStash.applyStash();
      this.headersUI.updateRowHeaderWidth();
    }
  }, {
    key: "onBeforeDetachChild",
    value: function onBeforeDetachChild() {
      this.collapsingUI.collapsedRowsStash.stash();
    }
  }, {
    key: "onAfterDetachChild",
    value: function onAfterDetachChild(parent, element) {
      this.collapsingUI.collapsedRowsStash.shiftStash(this.dataManager.getRowIndex(element), null, -1);
      this.collapsingUI.collapsedRowsStash.applyStash();
      this.headersUI.updateRowHeaderWidth();
    }
  }, {
    key: "onAfterCreateRow",
    value: function onAfterCreateRow(index, amount, source) {
      if (source === this.pluginName) {
        return;
      }
      this.dataManager.updateWithData(this.dataManager.getRawSourceData());
    }
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      var deepestLevel = Math.max.apply(Math, _toConsumableArray$y(this.dataManager.cache.levels));
      if (deepestLevel > 0) {
        this.headersUI.updateRowHeaderWidth(deepestLevel);
      }
    }
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender(force, skipRender) {
      var priv = privatePool$l.get(this);
      if (priv.skipRender) {
        skipRender.skipRender = true;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$P(_getPrototypeOf$1i(NestedRows2.prototype), "destroy", this).call(this);
    }
  }, {
    key: "onBeforeLoadData",
    value: function onBeforeLoadData(data) {
      this.dataManager.setData(data);
      this.dataManager.rewriteCache();
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$u;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$s;
    }
  }]);
  return NestedRows2;
}(BasePlugin);

function _slicedToArray$K(arr, i) {
  return _arrayWithHoles$M(arr) || _iterableToArrayLimit$K(arr, i) || _unsupportedIterableToArray$17(arr, i) || _nonIterableRest$M();
}
function _nonIterableRest$M() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$17(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$17(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$17(o, minLen);
}
function _arrayLikeToArray$17(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$K(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$M(arr) {
  if (Array.isArray(arr))
    return arr;
}
function hideColumnItem(hiddenColumnsPlugin) {
  return {
    key: "hidden_columns_hide",
    name: function name() {
      var selection = this.getSelectedLast();
      var pluralForm = 0;
      if (Array.isArray(selection)) {
        var _selection = _slicedToArray$K(selection, 4), fromColumn = _selection[1], toColumn = _selection[3];
        if (fromColumn - toColumn !== 0) {
          pluralForm = 1;
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_COLUMN, pluralForm);
    },
    callback: function callback() {
      var _this$getSelectedRang = this.getSelectedRangeLast(), from = _this$getSelectedRang.from, to = _this$getSelectedRang.to;
      var start = Math.max(Math.min(from.col, to.col), 0);
      var end = Math.max(from.col, to.col);
      var columnsToHide = [];
      for (var visualColumn = start; visualColumn <= end; visualColumn += 1) {
        columnsToHide.push(visualColumn);
      }
      var firstHiddenColumn = columnsToHide[0];
      var lastHiddenColumn = columnsToHide[columnsToHide.length - 1];
      var columnToSelect = this.columnIndexMapper.getFirstNotHiddenIndex(lastHiddenColumn + 1, 1, true, firstHiddenColumn - 1);
      hiddenColumnsPlugin.hideColumns(columnsToHide);
      if (Number.isInteger(columnToSelect) && columnToSelect >= 0) {
        this.selectColumns(columnToSelect);
      } else {
        this.deselectCell();
      }
      this.render();
      this.view.adjustElementsSize(true);
    },
    disabled: false,
    hidden: function hidden() {
      return !(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner());
    }
  };
}

function _toConsumableArray$z(arr) {
  return _arrayWithoutHoles$x(arr) || _iterableToArray$z(arr) || _unsupportedIterableToArray$18(arr) || _nonIterableSpread$x();
}
function _nonIterableSpread$x() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$18(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$18(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$18(o, minLen);
}
function _iterableToArray$z(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$x(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$18(arr);
}
function _arrayLikeToArray$18(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function showColumnItem(hiddenColumnsPlugin) {
  var columns = [];
  return {
    key: "hidden_columns_show",
    name: function name() {
      var pluralForm = columns.length > 1 ? 1 : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_COLUMN, pluralForm);
    },
    callback: function callback() {
      var _this$columnIndexMapp, _this$columnIndexMapp2;
      if (columns.length === 0) {
        return;
      }
      var startVisualColumn = columns[0];
      var endVisualColumn = columns[columns.length - 1];
      startVisualColumn = (_this$columnIndexMapp = this.columnIndexMapper.getFirstNotHiddenIndex(startVisualColumn - 1, -1)) !== null && _this$columnIndexMapp !== void 0 ? _this$columnIndexMapp : 0;
      endVisualColumn = (_this$columnIndexMapp2 = this.columnIndexMapper.getFirstNotHiddenIndex(endVisualColumn + 1, 1)) !== null && _this$columnIndexMapp2 !== void 0 ? _this$columnIndexMapp2 : this.countCols() - 1;
      hiddenColumnsPlugin.showColumns(columns);
      this.render();
      this.view.adjustElementsSize(true);
      var allColumnsSelected = endVisualColumn - startVisualColumn + 1 === this.countCols();
      if (!allColumnsSelected) {
        this.selectColumns(startVisualColumn, endVisualColumn);
      }
    },
    disabled: false,
    hidden: function hidden() {
      var _this = this;
      var hiddenPhysicalColumns = arrayMap(hiddenColumnsPlugin.getHiddenColumns(), function(visualColumnIndex) {
        return _this.toPhysicalColumn(visualColumnIndex);
      });
      if (!(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalColumns.length < 1) {
        return true;
      }
      columns.length = 0;
      var selectedRangeLast = this.getSelectedRangeLast();
      var visualStartColumn = selectedRangeLast.getTopLeftCorner().col;
      var visualEndColumn = selectedRangeLast.getBottomRightCorner().col;
      var columnIndexMapper = this.columnIndexMapper;
      var renderableStartColumn = columnIndexMapper.getRenderableFromVisualIndex(visualStartColumn);
      var renderableEndColumn = columnIndexMapper.getRenderableFromVisualIndex(visualEndColumn);
      var notTrimmedColumnIndexes = columnIndexMapper.getNotTrimmedIndexes();
      var physicalColumnIndexes = [];
      if (visualStartColumn !== visualEndColumn) {
        var visualColumnsInRange = visualEndColumn - visualStartColumn + 1;
        var renderedColumnsInRange = renderableEndColumn - renderableStartColumn + 1;
        if (visualColumnsInRange > renderedColumnsInRange) {
          var physicalIndexesInRange = notTrimmedColumnIndexes.slice(visualStartColumn, visualEndColumn + 1);
          physicalColumnIndexes.push.apply(physicalColumnIndexes, _toConsumableArray$z(physicalIndexesInRange.filter(function(physicalIndex) {
            return hiddenPhysicalColumns.includes(physicalIndex);
          })));
        }
      } else if (renderableStartColumn === 0 && renderableStartColumn < visualStartColumn) {
        physicalColumnIndexes.push.apply(physicalColumnIndexes, _toConsumableArray$z(notTrimmedColumnIndexes.slice(0, visualStartColumn)));
      } else if (renderableStartColumn === null) {
        physicalColumnIndexes.push.apply(physicalColumnIndexes, _toConsumableArray$z(notTrimmedColumnIndexes.slice(0, this.countCols())));
      } else {
        var lastVisualIndex = this.countCols() - 1;
        var lastRenderableIndex = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getFirstNotHiddenIndex(lastVisualIndex, -1));
        if (renderableEndColumn === lastRenderableIndex && lastVisualIndex > visualEndColumn) {
          physicalColumnIndexes.push.apply(physicalColumnIndexes, _toConsumableArray$z(notTrimmedColumnIndexes.slice(visualEndColumn + 1)));
        }
      }
      arrayEach(physicalColumnIndexes, function(physicalColumnIndex) {
        columns.push(_this.toVisualColumn(physicalColumnIndex));
      });
      return columns.length === 0;
    }
  };
}

function _typeof$1x(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1x = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1x = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1x(obj);
}
function _classCallCheck$2C(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2v(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2v(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2v(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2v(Constructor, staticProps);
  return Constructor;
}
function _get$Q(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$Q = Reflect.get;
  } else {
    _get$Q = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$Q(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$Q(target, property, receiver || target);
}
function _superPropBase$Q(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1j(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$1j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1k(subClass, superClass);
}
function _setPrototypeOf$1k(o, p) {
  _setPrototypeOf$1k = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1k(o, p);
}
function _createSuper$1j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1j(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1j(this, result);
  };
}
function _possibleConstructorReturn$1j(self, call) {
  if (call && (_typeof$1x(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1j(self);
}
function _assertThisInitialized$1j(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1k() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1j(o) {
  _getPrototypeOf$1j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1j(o);
}
function _classPrivateFieldGet$8(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$8(receiver, privateMap, "get");
  return _classApplyDescriptorGet$8(receiver, descriptor);
}
function _classApplyDescriptorGet$8(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$8(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$8(receiver, privateMap, "set");
  _classApplyDescriptorSet$8(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$8(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$8(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
Hooks.getSingleton().register("beforeHideColumns");
Hooks.getSingleton().register("afterHideColumns");
Hooks.getSingleton().register("beforeUnhideColumns");
Hooks.getSingleton().register("afterUnhideColumns");
var PLUGIN_KEY$v = "hiddenColumns";
var PLUGIN_PRIORITY$t = 310;
var _settings = /* @__PURE__ */ new WeakMap();
var _hiddenColumnsMap = /* @__PURE__ */ new WeakMap();
var HiddenColumns = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$1j(HiddenColumns2, _BasePlugin);
  var _super = _createSuper$1j(HiddenColumns2);
  function HiddenColumns2() {
    var _this;
    _classCallCheck$2C(this, HiddenColumns2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _settings.set(_assertThisInitialized$1j(_this), {
      writable: true,
      value: {}
    });
    _hiddenColumnsMap.set(_assertThisInitialized$1j(_this), {
      writable: true,
      value: null
    });
    return _this;
  }
  _createClass$2v(HiddenColumns2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$v];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$v];
      if (isObject(pluginSettings)) {
        _classPrivateFieldSet$8(this, _settings, pluginSettings);
        if (isUndefined$1(pluginSettings.copyPasteEnabled)) {
          pluginSettings.copyPasteEnabled = true;
        }
      }
      _classPrivateFieldSet$8(this, _hiddenColumnsMap, new HidingMap());
      _classPrivateFieldGet$8(this, _hiddenColumnsMap).addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      this.hot.columnIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet$8(this, _hiddenColumnsMap));
      this.addHook("afterContextMenuDefaultOptions", function() {
        return _this2.onAfterContextMenuDefaultOptions.apply(_this2, arguments);
      });
      this.addHook("afterGetCellMeta", function(row, col, cellProperties) {
        return _this2.onAfterGetCellMeta(row, col, cellProperties);
      });
      this.addHook("modifyColWidth", function(width, col) {
        return _this2.onModifyColWidth(width, col);
      });
      this.addHook("afterGetColHeader", function() {
        return _this2.onAfterGetColHeader.apply(_this2, arguments);
      });
      this.addHook("modifyCopyableRange", function(ranges) {
        return _this2.onModifyCopyableRange(ranges);
      });
      _get$Q(_getPrototypeOf$1j(HiddenColumns2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$Q(_getPrototypeOf$1j(HiddenColumns2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.columnIndexMapper.unregisterMap(this.pluginName);
      _classPrivateFieldSet$8(this, _settings, {});
      _get$Q(_getPrototypeOf$1j(HiddenColumns2.prototype), "disablePlugin", this).call(this);
      this.resetCellsMeta();
    }
  }, {
    key: "showColumns",
    value: function showColumns(columns) {
      var _this3 = this;
      var currentHideConfig = this.getHiddenColumns();
      var isValidConfig = this.isValidConfig(columns);
      var destinationHideConfig = currentHideConfig;
      var hidingMapValues = _classPrivateFieldGet$8(this, _hiddenColumnsMap).getValues().slice();
      var isAnyColumnShowed = columns.length > 0;
      if (isValidConfig && isAnyColumnShowed) {
        var physicalColumns = columns.map(function(visualColumn) {
          return _this3.hot.toPhysicalColumn(visualColumn);
        });
        arrayEach(physicalColumns, function(physicalColumn) {
          hidingMapValues[physicalColumn] = false;
        });
        destinationHideConfig = arrayReduce(hidingMapValues, function(hiddenIndexes, isHidden, physicalIndex) {
          if (isHidden) {
            hiddenIndexes.push(_this3.hot.toVisualColumn(physicalIndex));
          }
          return hiddenIndexes;
        }, []);
      }
      var continueHiding = this.hot.runHooks("beforeUnhideColumns", currentHideConfig, destinationHideConfig, isValidConfig && isAnyColumnShowed);
      if (continueHiding === false) {
        return;
      }
      if (isValidConfig && isAnyColumnShowed) {
        _classPrivateFieldGet$8(this, _hiddenColumnsMap).setValues(hidingMapValues);
      }
      this.hot.view.adjustElementsSize();
      this.hot.runHooks("afterUnhideColumns", currentHideConfig, destinationHideConfig, isValidConfig && isAnyColumnShowed, isValidConfig && destinationHideConfig.length < currentHideConfig.length);
    }
  }, {
    key: "showColumn",
    value: function showColumn() {
      for (var _len2 = arguments.length, column = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        column[_key2] = arguments[_key2];
      }
      this.showColumns(column);
    }
  }, {
    key: "hideColumns",
    value: function hideColumns(columns) {
      var _this4 = this;
      var currentHideConfig = this.getHiddenColumns();
      var isConfigValid = this.isValidConfig(columns);
      var destinationHideConfig = currentHideConfig;
      if (isConfigValid) {
        destinationHideConfig = Array.from(new Set(currentHideConfig.concat(columns)));
      }
      var continueHiding = this.hot.runHooks("beforeHideColumns", currentHideConfig, destinationHideConfig, isConfigValid);
      if (continueHiding === false) {
        return;
      }
      if (isConfigValid) {
        this.hot.batchExecution(function() {
          arrayEach(columns, function(visualColumn) {
            _classPrivateFieldGet$8(_this4, _hiddenColumnsMap).setValueAtIndex(_this4.hot.toPhysicalColumn(visualColumn), true);
          });
        }, true);
      }
      this.hot.runHooks("afterHideColumns", currentHideConfig, destinationHideConfig, isConfigValid, isConfigValid && destinationHideConfig.length > currentHideConfig.length);
    }
  }, {
    key: "hideColumn",
    value: function hideColumn() {
      for (var _len3 = arguments.length, column = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        column[_key3] = arguments[_key3];
      }
      this.hideColumns(column);
    }
  }, {
    key: "getHiddenColumns",
    value: function getHiddenColumns() {
      var _this5 = this;
      return arrayMap(_classPrivateFieldGet$8(this, _hiddenColumnsMap).getHiddenIndexes(), function(physicalColumnIndex) {
        return _this5.hot.toVisualColumn(physicalColumnIndex);
      });
    }
  }, {
    key: "isHidden",
    value: function isHidden(column) {
      return _classPrivateFieldGet$8(this, _hiddenColumnsMap).getValueAtIndex(this.hot.toPhysicalColumn(column)) || false;
    }
  }, {
    key: "isValidConfig",
    value: function isValidConfig(hiddenColumns) {
      var nrOfColumns = this.hot.countCols();
      if (Array.isArray(hiddenColumns) && hiddenColumns.length > 0) {
        return hiddenColumns.every(function(visualColumn) {
          return Number.isInteger(visualColumn) && visualColumn >= 0 && visualColumn < nrOfColumns;
        });
      }
      return false;
    }
  }, {
    key: "resetCellsMeta",
    value: function resetCellsMeta() {
      arrayEach(this.hot.getCellsMeta(), function(meta) {
        if (meta) {
          meta.skipColumnOnPaste = false;
        }
      });
    }
  }, {
    key: "onModifyColWidth",
    value: function onModifyColWidth(width, column) {
      if (this.isHidden(column)) {
        return 0;
      }
      if (_classPrivateFieldGet$8(this, _settings).indicators && (this.isHidden(column + 1) || this.isHidden(column - 1))) {
        if (typeof width === "number" && this.hot.hasColHeaders()) {
          return width + 15;
        }
      }
    }
  }, {
    key: "onAfterGetCellMeta",
    value: function onAfterGetCellMeta(row, column, cellProperties) {
      if (_classPrivateFieldGet$8(this, _settings).copyPasteEnabled === false && this.isHidden(column)) {
        cellProperties.skipColumnOnPaste = true;
      }
      if (this.isHidden(column - 1)) {
        cellProperties.className = cellProperties.className || "";
        if (cellProperties.className.indexOf("afterHiddenColumn") === -1) {
          cellProperties.className += " afterHiddenColumn";
        }
      } else if (cellProperties.className) {
        var classArr = cellProperties.className.split(" ");
        if (classArr.length > 0) {
          var containAfterHiddenColumn = classArr.indexOf("afterHiddenColumn");
          if (containAfterHiddenColumn > -1) {
            classArr.splice(containAfterHiddenColumn, 1);
          }
          cellProperties.className = classArr.join(" ");
        }
      }
    }
  }, {
    key: "onModifyCopyableRange",
    value: function onModifyCopyableRange(ranges) {
      var _this6 = this;
      if (_classPrivateFieldGet$8(this, _settings).copyPasteEnabled) {
        return ranges;
      }
      var newRanges = [];
      var pushRange = function pushRange2(startRow, endRow, startCol, endCol) {
        newRanges.push({
          startRow,
          endRow,
          startCol,
          endCol
        });
      };
      arrayEach(ranges, function(range) {
        var isHidden = true;
        var rangeStart = 0;
        rangeEach(range.startCol, range.endCol, function(visualColumn) {
          if (_this6.isHidden(visualColumn)) {
            if (!isHidden) {
              pushRange(range.startRow, range.endRow, rangeStart, visualColumn - 1);
            }
            isHidden = true;
          } else {
            if (isHidden) {
              rangeStart = visualColumn;
            }
            if (visualColumn === range.endCol) {
              pushRange(range.startRow, range.endRow, rangeStart, visualColumn);
            }
            isHidden = false;
          }
        });
      });
      return newRanges;
    }
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(column, TH) {
      if (!_classPrivateFieldGet$8(this, _settings).indicators || column < 0) {
        return;
      }
      var classList = [];
      if (column >= 1 && this.isHidden(column - 1)) {
        classList.push("afterHiddenColumn");
      }
      if (column < this.hot.countCols() - 1 && this.isHidden(column + 1)) {
        classList.push("beforeHiddenColumn");
      }
      addClass(TH, classList);
    }
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(options) {
      options.items.push({
        name: KEY
      }, hideColumnItem(this), showColumnItem(this));
    }
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      if (Array.isArray(_classPrivateFieldGet$8(this, _settings).columns)) {
        this.hideColumns(_classPrivateFieldGet$8(this, _settings).columns);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldSet$8(this, _settings, null);
      _classPrivateFieldSet$8(this, _hiddenColumnsMap, null);
      _get$Q(_getPrototypeOf$1j(HiddenColumns2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$v;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$t;
    }
  }]);
  return HiddenColumns2;
}(BasePlugin);

function _slicedToArray$L(arr, i) {
  return _arrayWithHoles$N(arr) || _iterableToArrayLimit$L(arr, i) || _unsupportedIterableToArray$19(arr, i) || _nonIterableRest$N();
}
function _nonIterableRest$N() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$19(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$19(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$19(o, minLen);
}
function _arrayLikeToArray$19(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$L(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$N(arr) {
  if (Array.isArray(arr))
    return arr;
}
function hideRowItem(hiddenRowsPlugin) {
  return {
    key: "hidden_rows_hide",
    name: function name() {
      var selection = this.getSelectedLast();
      var pluralForm = 0;
      if (Array.isArray(selection)) {
        var _selection = _slicedToArray$L(selection, 3), fromRow = _selection[0], toRow = _selection[2];
        if (fromRow - toRow !== 0) {
          pluralForm = 1;
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_ROW, pluralForm);
    },
    callback: function callback() {
      var _this$getSelectedRang = this.getSelectedRangeLast(), from = _this$getSelectedRang.from, to = _this$getSelectedRang.to;
      var start = Math.max(Math.min(from.row, to.row), 0);
      var end = Math.max(from.row, to.row);
      var rowsToHide = [];
      for (var visualRow = start; visualRow <= end; visualRow += 1) {
        rowsToHide.push(visualRow);
      }
      var firstHiddenRow = rowsToHide[0];
      var lastHiddenRow = rowsToHide[rowsToHide.length - 1];
      var rowToSelect = this.rowIndexMapper.getFirstNotHiddenIndex(lastHiddenRow + 1, 1, true, firstHiddenRow - 1);
      hiddenRowsPlugin.hideRows(rowsToHide);
      if (Number.isInteger(rowToSelect) && rowToSelect >= 0) {
        this.selectRows(rowToSelect);
      } else {
        this.deselectCell();
      }
      this.render();
      this.view.adjustElementsSize(true);
    },
    disabled: false,
    hidden: function hidden() {
      return !(this.selection.isSelectedByRowHeader() || this.selection.isSelectedByCorner());
    }
  };
}

function _toConsumableArray$A(arr) {
  return _arrayWithoutHoles$y(arr) || _iterableToArray$A(arr) || _unsupportedIterableToArray$1a(arr) || _nonIterableSpread$y();
}
function _nonIterableSpread$y() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1a(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1a(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1a(o, minLen);
}
function _iterableToArray$A(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$y(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1a(arr);
}
function _arrayLikeToArray$1a(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function showRowItem(hiddenRowsPlugin) {
  var rows = [];
  return {
    key: "hidden_rows_show",
    name: function name() {
      var pluralForm = rows.length > 1 ? 1 : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_ROW, pluralForm);
    },
    callback: function callback() {
      var _this$rowIndexMapper$, _this$rowIndexMapper$2;
      if (rows.length === 0) {
        return;
      }
      var startVisualRow = rows[0];
      var endVisualRow = rows[rows.length - 1];
      startVisualRow = (_this$rowIndexMapper$ = this.rowIndexMapper.getFirstNotHiddenIndex(startVisualRow - 1, -1)) !== null && _this$rowIndexMapper$ !== void 0 ? _this$rowIndexMapper$ : 0;
      endVisualRow = (_this$rowIndexMapper$2 = this.rowIndexMapper.getFirstNotHiddenIndex(endVisualRow + 1, 1)) !== null && _this$rowIndexMapper$2 !== void 0 ? _this$rowIndexMapper$2 : this.countRows() - 1;
      hiddenRowsPlugin.showRows(rows);
      this.render();
      this.view.adjustElementsSize(true);
      var allRowsSelected = endVisualRow - startVisualRow + 1 === this.countRows();
      if (!allRowsSelected) {
        this.selectRows(startVisualRow, endVisualRow);
      }
    },
    disabled: false,
    hidden: function hidden() {
      var _this = this;
      var hiddenPhysicalRows = arrayMap(hiddenRowsPlugin.getHiddenRows(), function(visualRowIndex) {
        return _this.toPhysicalRow(visualRowIndex);
      });
      if (!(this.selection.isSelectedByRowHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalRows.length < 1) {
        return true;
      }
      rows.length = 0;
      var selectedRangeLast = this.getSelectedRangeLast();
      var visualStartRow = selectedRangeLast.getTopLeftCorner().row;
      var visualEndRow = selectedRangeLast.getBottomRightCorner().row;
      var rowIndexMapper = this.rowIndexMapper;
      var renderableStartRow = rowIndexMapper.getRenderableFromVisualIndex(visualStartRow);
      var renderableEndRow = rowIndexMapper.getRenderableFromVisualIndex(visualEndRow);
      var notTrimmedRowIndexes = rowIndexMapper.getNotTrimmedIndexes();
      var physicalRowIndexes = [];
      if (visualStartRow !== visualEndRow) {
        var visualRowsInRange = visualEndRow - visualStartRow + 1;
        var renderedRowsInRange = renderableEndRow - renderableStartRow + 1;
        if (visualRowsInRange > renderedRowsInRange) {
          var physicalIndexesInRange = notTrimmedRowIndexes.slice(visualStartRow, visualEndRow + 1);
          physicalRowIndexes.push.apply(physicalRowIndexes, _toConsumableArray$A(physicalIndexesInRange.filter(function(physicalIndex) {
            return hiddenPhysicalRows.includes(physicalIndex);
          })));
        }
      } else if (renderableStartRow === 0 && renderableStartRow < visualStartRow) {
        physicalRowIndexes.push.apply(physicalRowIndexes, _toConsumableArray$A(notTrimmedRowIndexes.slice(0, visualStartRow)));
      } else if (renderableStartRow === null) {
        physicalRowIndexes.push.apply(physicalRowIndexes, _toConsumableArray$A(notTrimmedRowIndexes.slice(0, this.countRows())));
      } else {
        var lastVisualIndex = this.countRows() - 1;
        var lastRenderableIndex = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getFirstNotHiddenIndex(lastVisualIndex, -1));
        if (renderableEndRow === lastRenderableIndex && lastVisualIndex > visualEndRow) {
          physicalRowIndexes.push.apply(physicalRowIndexes, _toConsumableArray$A(notTrimmedRowIndexes.slice(visualEndRow + 1)));
        }
      }
      arrayEach(physicalRowIndexes, function(physicalRowIndex) {
        rows.push(_this.toVisualRow(physicalRowIndex));
      });
      return rows.length === 0;
    }
  };
}

function _typeof$1y(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1y = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1y = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1y(obj);
}
function _classCallCheck$2D(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2w(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2w(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2w(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2w(Constructor, staticProps);
  return Constructor;
}
function _get$R(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$R = Reflect.get;
  } else {
    _get$R = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$R(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$R(target, property, receiver || target);
}
function _superPropBase$R(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1k(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$1k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1l(subClass, superClass);
}
function _setPrototypeOf$1l(o, p) {
  _setPrototypeOf$1l = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1l(o, p);
}
function _createSuper$1k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1k(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1k(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1k(this, result);
  };
}
function _possibleConstructorReturn$1k(self, call) {
  if (call && (_typeof$1y(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1k(self);
}
function _assertThisInitialized$1k(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1l() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1k(o) {
  _getPrototypeOf$1k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1k(o);
}
function _classPrivateFieldGet$9(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$9(receiver, privateMap, "get");
  return _classApplyDescriptorGet$9(receiver, descriptor);
}
function _classApplyDescriptorGet$9(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet$9(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$9(receiver, privateMap, "set");
  _classApplyDescriptorSet$9(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor$9(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet$9(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
Hooks.getSingleton().register("beforeHideRows");
Hooks.getSingleton().register("afterHideRows");
Hooks.getSingleton().register("beforeUnhideRows");
Hooks.getSingleton().register("afterUnhideRows");
var PLUGIN_KEY$w = "hiddenRows";
var PLUGIN_PRIORITY$u = 320;
var _settings$1 = /* @__PURE__ */ new WeakMap();
var _hiddenRowsMap = /* @__PURE__ */ new WeakMap();
var HiddenRows = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$1k(HiddenRows2, _BasePlugin);
  var _super = _createSuper$1k(HiddenRows2);
  function HiddenRows2() {
    var _this;
    _classCallCheck$2D(this, HiddenRows2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _settings$1.set(_assertThisInitialized$1k(_this), {
      writable: true,
      value: {}
    });
    _hiddenRowsMap.set(_assertThisInitialized$1k(_this), {
      writable: true,
      value: null
    });
    return _this;
  }
  _createClass$2w(HiddenRows2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$w];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY$w];
      if (isObject(pluginSettings)) {
        _classPrivateFieldSet$9(this, _settings$1, pluginSettings);
        if (isUndefined$1(pluginSettings.copyPasteEnabled)) {
          pluginSettings.copyPasteEnabled = true;
        }
      }
      _classPrivateFieldSet$9(this, _hiddenRowsMap, new HidingMap());
      _classPrivateFieldGet$9(this, _hiddenRowsMap).addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      this.hot.rowIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet$9(this, _hiddenRowsMap));
      this.addHook("afterContextMenuDefaultOptions", function() {
        return _this2.onAfterContextMenuDefaultOptions.apply(_this2, arguments);
      });
      this.addHook("afterGetCellMeta", function(row, col, cellProperties) {
        return _this2.onAfterGetCellMeta(row, col, cellProperties);
      });
      this.addHook("modifyRowHeight", function(height, row) {
        return _this2.onModifyRowHeight(height, row);
      });
      this.addHook("afterGetRowHeader", function() {
        return _this2.onAfterGetRowHeader.apply(_this2, arguments);
      });
      this.addHook("modifyCopyableRange", function(ranges) {
        return _this2.onModifyCopyableRange(ranges);
      });
      _get$R(_getPrototypeOf$1k(HiddenRows2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get$R(_getPrototypeOf$1k(HiddenRows2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.rowIndexMapper.unregisterMap(this.pluginName);
      _classPrivateFieldSet$9(this, _settings$1, {});
      _get$R(_getPrototypeOf$1k(HiddenRows2.prototype), "disablePlugin", this).call(this);
      this.resetCellsMeta();
    }
  }, {
    key: "showRows",
    value: function showRows(rows) {
      var _this3 = this;
      var currentHideConfig = this.getHiddenRows();
      var isValidConfig = this.isValidConfig(rows);
      var destinationHideConfig = currentHideConfig;
      var hidingMapValues = _classPrivateFieldGet$9(this, _hiddenRowsMap).getValues().slice();
      var isAnyRowShowed = rows.length > 0;
      if (isValidConfig && isAnyRowShowed) {
        var physicalRows = rows.map(function(visualRow) {
          return _this3.hot.toPhysicalRow(visualRow);
        });
        arrayEach(physicalRows, function(physicalRow) {
          hidingMapValues[physicalRow] = false;
        });
        destinationHideConfig = arrayReduce(hidingMapValues, function(hiddenIndexes, isHidden, physicalIndex) {
          if (isHidden) {
            hiddenIndexes.push(_this3.hot.toVisualRow(physicalIndex));
          }
          return hiddenIndexes;
        }, []);
      }
      var continueHiding = this.hot.runHooks("beforeUnhideRows", currentHideConfig, destinationHideConfig, isValidConfig && isAnyRowShowed);
      if (continueHiding === false) {
        return;
      }
      if (isValidConfig && isAnyRowShowed) {
        _classPrivateFieldGet$9(this, _hiddenRowsMap).setValues(hidingMapValues);
      }
      this.hot.runHooks("afterUnhideRows", currentHideConfig, destinationHideConfig, isValidConfig && isAnyRowShowed, isValidConfig && destinationHideConfig.length < currentHideConfig.length);
    }
  }, {
    key: "showRow",
    value: function showRow() {
      for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        row[_key2] = arguments[_key2];
      }
      this.showRows(row);
    }
  }, {
    key: "hideRows",
    value: function hideRows(rows) {
      var _this4 = this;
      var currentHideConfig = this.getHiddenRows();
      var isConfigValid = this.isValidConfig(rows);
      var destinationHideConfig = currentHideConfig;
      if (isConfigValid) {
        destinationHideConfig = Array.from(new Set(currentHideConfig.concat(rows)));
      }
      var continueHiding = this.hot.runHooks("beforeHideRows", currentHideConfig, destinationHideConfig, isConfigValid);
      if (continueHiding === false) {
        return;
      }
      if (isConfigValid) {
        this.hot.batchExecution(function() {
          arrayEach(rows, function(visualRow) {
            _classPrivateFieldGet$9(_this4, _hiddenRowsMap).setValueAtIndex(_this4.hot.toPhysicalRow(visualRow), true);
          });
        }, true);
      }
      this.hot.runHooks("afterHideRows", currentHideConfig, destinationHideConfig, isConfigValid, isConfigValid && destinationHideConfig.length > currentHideConfig.length);
    }
  }, {
    key: "hideRow",
    value: function hideRow() {
      for (var _len3 = arguments.length, row = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        row[_key3] = arguments[_key3];
      }
      this.hideRows(row);
    }
  }, {
    key: "getHiddenRows",
    value: function getHiddenRows() {
      var _this5 = this;
      return arrayMap(_classPrivateFieldGet$9(this, _hiddenRowsMap).getHiddenIndexes(), function(physicalRowIndex) {
        return _this5.hot.toVisualRow(physicalRowIndex);
      });
    }
  }, {
    key: "isHidden",
    value: function isHidden(row) {
      return _classPrivateFieldGet$9(this, _hiddenRowsMap).getValueAtIndex(this.hot.toPhysicalRow(row)) || false;
    }
  }, {
    key: "isValidConfig",
    value: function isValidConfig(hiddenRows) {
      var nrOfRows = this.hot.countRows();
      if (Array.isArray(hiddenRows) && hiddenRows.length > 0) {
        return hiddenRows.every(function(visualRow) {
          return Number.isInteger(visualRow) && visualRow >= 0 && visualRow < nrOfRows;
        });
      }
      return false;
    }
  }, {
    key: "resetCellsMeta",
    value: function resetCellsMeta() {
      arrayEach(this.hot.getCellsMeta(), function(meta) {
        if (meta) {
          meta.skipRowOnPaste = false;
        }
      });
    }
  }, {
    key: "onModifyRowHeight",
    value: function onModifyRowHeight(height, row) {
      if (this.isHidden(row)) {
        return 0;
      }
      return height;
    }
  }, {
    key: "onAfterGetCellMeta",
    value: function onAfterGetCellMeta(row, column, cellProperties) {
      if (_classPrivateFieldGet$9(this, _settings$1).copyPasteEnabled === false && this.isHidden(row)) {
        cellProperties.skipRowOnPaste = true;
      }
      if (this.isHidden(row - 1)) {
        cellProperties.className = cellProperties.className || "";
        if (cellProperties.className.indexOf("afterHiddenRow") === -1) {
          cellProperties.className += " afterHiddenRow";
        }
      } else if (cellProperties.className) {
        var classArr = cellProperties.className.split(" ");
        if (classArr.length > 0) {
          var containAfterHiddenRow = classArr.indexOf("afterHiddenRow");
          if (containAfterHiddenRow > -1) {
            classArr.splice(containAfterHiddenRow, 1);
          }
          cellProperties.className = classArr.join(" ");
        }
      }
    }
  }, {
    key: "onModifyCopyableRange",
    value: function onModifyCopyableRange(ranges) {
      var _this6 = this;
      if (_classPrivateFieldGet$9(this, _settings$1).copyPasteEnabled) {
        return ranges;
      }
      var newRanges = [];
      var pushRange = function pushRange2(startRow, endRow, startCol, endCol) {
        newRanges.push({
          startRow,
          endRow,
          startCol,
          endCol
        });
      };
      arrayEach(ranges, function(range) {
        var isHidden = true;
        var rangeStart = 0;
        rangeEach(range.startRow, range.endRow, function(visualRow) {
          if (_this6.isHidden(visualRow)) {
            if (!isHidden) {
              pushRange(rangeStart, visualRow - 1, range.startCol, range.endCol);
            }
            isHidden = true;
          } else {
            if (isHidden) {
              rangeStart = visualRow;
            }
            if (visualRow === range.endRow) {
              pushRange(rangeStart, visualRow, range.startCol, range.endCol);
            }
            isHidden = false;
          }
        });
      });
      return newRanges;
    }
  }, {
    key: "onAfterGetRowHeader",
    value: function onAfterGetRowHeader(row, TH) {
      if (!_classPrivateFieldGet$9(this, _settings$1).indicators || row < 0) {
        return;
      }
      var classList = [];
      if (row >= 1 && this.isHidden(row - 1)) {
        classList.push("afterHiddenRow");
      }
      if (row < this.hot.countRows() - 1 && this.isHidden(row + 1)) {
        classList.push("beforeHiddenRow");
      }
      addClass(TH, classList);
    }
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(options) {
      options.items.push({
        name: KEY
      }, hideRowItem(this), showRowItem(this));
    }
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      if (Array.isArray(_classPrivateFieldGet$9(this, _settings$1).rows)) {
        this.hideRows(_classPrivateFieldGet$9(this, _settings$1).rows);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldSet$9(this, _settings$1, null);
      _classPrivateFieldSet$9(this, _hiddenRowsMap, null);
      _get$R(_getPrototypeOf$1k(HiddenRows2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$w;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$u;
    }
  }]);
  return HiddenRows2;
}(BasePlugin);

function _typeof$1z(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1z = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1z = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1z(obj);
}
function _classCallCheck$2E(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2x(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2x(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2x(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2x(Constructor, staticProps);
  return Constructor;
}
function _get$S(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$S = Reflect.get;
  } else {
    _get$S = function _get2(target2, property2, receiver2) {
      var base = _superPropBase$S(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get$S(target, property, receiver || target);
}
function _superPropBase$S(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1l(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits$1l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
  if (superClass)
    _setPrototypeOf$1m(subClass, superClass);
}
function _setPrototypeOf$1m(o, p) {
  _setPrototypeOf$1m = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1m(o, p);
}
function _createSuper$1l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1l(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1l(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1l(this, result);
  };
}
function _possibleConstructorReturn$1l(self, call) {
  if (call && (_typeof$1z(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1l(self);
}
function _assertThisInitialized$1l(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct$1m() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1l(o) {
  _getPrototypeOf$1l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1l(o);
}
var PLUGIN_KEY$x = "trimRows";
var PLUGIN_PRIORITY$v = 330;
var TrimRows = /* @__PURE__ */ function(_BasePlugin) {
  _inherits$1l(TrimRows2, _BasePlugin);
  var _super = _createSuper$1l(TrimRows2);
  function TrimRows2(hotInstance) {
    var _this;
    _classCallCheck$2E(this, TrimRows2);
    _this = _super.call(this, hotInstance);
    _this.trimmedRowsMap = null;
    return _this;
  }
  _createClass$2x(TrimRows2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[PLUGIN_KEY$x];
    }
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.trimmedRowsMap = this.hot.rowIndexMapper.registerMap("trimRows", new TrimmingMap());
      this.trimmedRowsMap.addLocalHook("init", function() {
        return _this2.onMapInit();
      });
      _get$S(_getPrototypeOf$1l(TrimRows2.prototype), "enablePlugin", this).call(this);
    }
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var _this3 = this;
      var trimmedRows = this.hot.getSettings()[PLUGIN_KEY$x];
      if (Array.isArray(trimmedRows)) {
        this.hot.batchExecution(function() {
          _this3.trimmedRowsMap.clear();
          arrayEach(trimmedRows, function(physicalRow) {
            _this3.trimmedRowsMap.setValueAtIndex(physicalRow, true);
          });
        }, true);
      }
      _get$S(_getPrototypeOf$1l(TrimRows2.prototype), "updatePlugin", this).call(this);
    }
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hot.rowIndexMapper.unregisterMap("trimRows");
      _get$S(_getPrototypeOf$1l(TrimRows2.prototype), "disablePlugin", this).call(this);
    }
  }, {
    key: "getTrimmedRows",
    value: function getTrimmedRows() {
      return this.trimmedRowsMap.getTrimmedIndexes();
    }
  }, {
    key: "trimRows",
    value: function trimRows(rows) {
      var _this4 = this;
      var currentTrimConfig = this.getTrimmedRows();
      var isValidConfig = this.isValidConfig(rows);
      var destinationTrimConfig = currentTrimConfig;
      if (isValidConfig) {
        destinationTrimConfig = Array.from(new Set(currentTrimConfig.concat(rows)));
      }
      var allowTrimRow = this.hot.runHooks("beforeTrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig);
      if (allowTrimRow === false) {
        return;
      }
      if (isValidConfig) {
        this.hot.batchExecution(function() {
          arrayEach(rows, function(physicalRow) {
            _this4.trimmedRowsMap.setValueAtIndex(physicalRow, true);
          });
        }, true);
      }
      this.hot.runHooks("afterTrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig, isValidConfig && destinationTrimConfig.length > currentTrimConfig.length);
    }
  }, {
    key: "trimRow",
    value: function trimRow() {
      for (var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {
        row[_key] = arguments[_key];
      }
      this.trimRows(row);
    }
  }, {
    key: "untrimRows",
    value: function untrimRows(rows) {
      var currentTrimConfig = this.getTrimmedRows();
      var isValidConfig = this.isValidConfig(rows);
      var destinationTrimConfig = currentTrimConfig;
      var trimmingMapValues = this.trimmedRowsMap.getValues().slice();
      var isAnyRowUntrimmed = rows.length > 0;
      if (isValidConfig && isAnyRowUntrimmed) {
        arrayEach(rows, function(physicalRow) {
          trimmingMapValues[physicalRow] = false;
        });
        destinationTrimConfig = arrayReduce(trimmingMapValues, function(trimmedIndexes, isTrimmed, physicalIndex) {
          if (isTrimmed) {
            trimmedIndexes.push(physicalIndex);
          }
          return trimmedIndexes;
        }, []);
      }
      var allowUntrimRow = this.hot.runHooks("beforeUntrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed);
      if (allowUntrimRow === false) {
        return;
      }
      if (isValidConfig && isAnyRowUntrimmed) {
        this.trimmedRowsMap.setValues(trimmingMapValues);
      }
      this.hot.runHooks("afterUntrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed, isValidConfig && destinationTrimConfig.length < currentTrimConfig.length);
    }
  }, {
    key: "untrimRow",
    value: function untrimRow() {
      for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        row[_key2] = arguments[_key2];
      }
      this.untrimRows(row);
    }
  }, {
    key: "isTrimmed",
    value: function isTrimmed(physicalRow) {
      return this.trimmedRowsMap.getValueAtIndex(physicalRow) || false;
    }
  }, {
    key: "untrimAll",
    value: function untrimAll() {
      this.untrimRows(this.getTrimmedRows());
    }
  }, {
    key: "isValidConfig",
    value: function isValidConfig(trimmedRows) {
      var sourceRows = this.hot.countSourceRows();
      return trimmedRows.every(function(trimmedRow) {
        return Number.isInteger(trimmedRow) && trimmedRow >= 0 && trimmedRow < sourceRows;
      });
    }
  }, {
    key: "onMapInit",
    value: function onMapInit() {
      var _this5 = this;
      var trimmedRows = this.hot.getSettings()[PLUGIN_KEY$x];
      if (Array.isArray(trimmedRows)) {
        this.hot.batchExecution(function() {
          arrayEach(trimmedRows, function(physicalRow) {
            _this5.trimmedRowsMap.setValueAtIndex(physicalRow, true);
          });
        }, true);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get$S(_getPrototypeOf$1l(TrimRows2.prototype), "destroy", this).call(this);
    }
  }], [{
    key: "PLUGIN_KEY",
    get: function get() {
      return PLUGIN_KEY$x;
    }
  }, {
    key: "PLUGIN_PRIORITY",
    get: function get() {
      return PLUGIN_PRIORITY$v;
    }
  }]);
  return TrimRows2;
}(BasePlugin);

_register(BaseEditor);
_register(AutocompleteEditor);
_register(CheckboxEditor);
_register(DateEditor);
_register(DropdownEditor);
_register(HandsontableEditor);
_register(NumericEditor);
_register(PasswordEditor);
_register(SelectEditor);
_register(TextEditor);
_register$1(baseRenderer);
_register$1(autocompleteRenderer);
_register$1(checkboxRenderer);
_register$1(htmlRenderer);
_register$1(numericRenderer);
_register$1(passwordRenderer);
_register$1(textRenderer);
_register$2(autocompleteValidator);
_register$2(dateValidator);
_register$2(numericValidator);
_register$2(timeValidator);
_register$3(AutocompleteCellType);
_register$3(CheckboxCellType);
_register$3(DateCellType);
_register$3(DropdownCellType);
_register$3(HandsontableCellType);
_register$3(NumericCellType);
_register$3(PasswordCellType);
_register$3(TimeCellType);
_register$3(TextCellType);
jQueryWrapper(Handsontable);
registerPlugin(AutoColumnSize);
registerPlugin(Autofill);
registerPlugin(AutoRowSize);
registerPlugin(BindRowsWithHeaders);
registerPlugin(CollapsibleColumns);
registerPlugin(ColumnSorting);
registerPlugin(ColumnSummary);
registerPlugin(Comments);
registerPlugin(ContextMenu);
registerPlugin(CopyPaste);
registerPlugin(CustomBorders);
registerPlugin(DragToScroll);
registerPlugin(DropdownMenu);
registerPlugin(ExportFile);
registerPlugin(Filters);
registerPlugin(Formulas);
registerPlugin(HiddenColumns);
registerPlugin(HiddenRows);
registerPlugin(ManualColumnFreeze);
registerPlugin(ManualColumnMove);
registerPlugin(ManualColumnResize);
registerPlugin(ManualRowMove);
registerPlugin(ManualRowResize);
registerPlugin(MergeCells);
registerPlugin(MultiColumnSorting);
registerPlugin(MultipleSelectionHandles);
registerPlugin(NestedHeaders);
registerPlugin(NestedRows);
registerPlugin(PersistentState);
registerPlugin(Search);
registerPlugin(TouchScroll);
registerPlugin(TrimRows);
registerPlugin(UndoRedo);
Handsontable.__GhostTable = GhostTable;
Handsontable._getListenersCounter = getListenersCounter;
Handsontable._getRegisteredMapsCounter = getRegisteredMapsCounter;
Handsontable.DefaultSettings = metaSchemaFactory();
Handsontable.EventManager = EventManager;
Handsontable.hooks = Hooks.getSingleton();
var HELPERS = [arrayHelpers, browserHelpers, dataHelpers, dateHelpers, featureHelpers, functionHelpers, mixedHelpers, numberHelpers, objectHelpers, stringHelpers, unicodeHelpers, parseTableHelpers];
var DOM = [domHelpers, domEventHelpers];
Handsontable.helper = {};
Handsontable.dom = {};
arrayEach(HELPERS, function(helper) {
  arrayEach(Object.getOwnPropertyNames(helper), function(key) {
    if (key.charAt(0) !== "_") {
      Handsontable.helper[key] = helper[key];
    }
  });
});
arrayEach(DOM, function(helper) {
  arrayEach(Object.getOwnPropertyNames(helper), function(key) {
    if (key.charAt(0) !== "_") {
      Handsontable.dom[key] = helper[key];
    }
  });
});
Handsontable.cellTypes = {};
arrayEach(getNames$3(), function(cellTypeName) {
  Handsontable.cellTypes[cellTypeName] = _getItem$3(cellTypeName);
});
Handsontable.cellTypes.registerCellType = _register$3;
Handsontable.cellTypes.getCellType = _getItem$3;
Handsontable.editors = {};
arrayEach(getNames(), function(editorName) {
  Handsontable.editors["".concat(toUpperCaseFirst(editorName), "Editor")] = _getItem(editorName);
});
Handsontable.editors.registerEditor = _register;
Handsontable.editors.getEditor = _getItem;
Handsontable.renderers = {};
arrayEach(getNames$1(), function(rendererName) {
  var renderer = _getItem$1(rendererName);
  if (rendererName === "base") {
    Handsontable.renderers.cellDecorator = renderer;
  }
  Handsontable.renderers["".concat(toUpperCaseFirst(rendererName), "Renderer")] = renderer;
});
Handsontable.renderers.registerRenderer = _register$1;
Handsontable.renderers.getRenderer = _getItem$1;
Handsontable.validators = {};
arrayEach(getNames$2(), function(validatorName) {
  Handsontable.validators["".concat(toUpperCaseFirst(validatorName), "Validator")] = _getItem$2(validatorName);
});
Handsontable.validators.registerValidator = _register$2;
Handsontable.validators.getValidator = _getItem$2;
Handsontable.plugins = {};
arrayEach(getPluginsNames(), function(pluginName) {
  Handsontable.plugins[pluginName] = getPlugin(pluginName);
});
Handsontable.plugins["".concat(toUpperCaseFirst(BasePlugin.PLUGIN_KEY), "Plugin")] = BasePlugin;
Handsontable.plugins.registerPlugin = registerPlugin;
Handsontable.plugins.getPlugin = getPlugin;

function ownKeys$f(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$f(Object(source), true).forEach(function (key) {
        _defineProperty$s(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$f(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof$1A(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1A = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$1A = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1A(obj);
}

function _classCallCheck$2F(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$2y(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$2y(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2y(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$2y(Constructor, staticProps);
  return Constructor;
}

function _defineProperty$s(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits$1m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$1n(subClass, superClass);
}

function _getPrototypeOf$1m(o) {
  _getPrototypeOf$1m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$1m(o);
}

function _setPrototypeOf$1n(o, p) {
  _setPrototypeOf$1n = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$1n(o, p);
}

function _isNativeReflectConstruct$1n() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized$1m(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$1m(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized$1m(self);
}

function _createSuper$1m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1n();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1m(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1m(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$1m(this, result);
  };
}

var bulkComponentContainer = null;
/**
 * Warning message for the `autoRowSize`/`autoColumnSize` compatibility check.
 */

var AUTOSIZE_WARNING = 'Your `HotTable` configuration includes `autoRowSize`/`autoColumnSize` options, which are not compatible with ' + ' the component-based renderers`. Disable `autoRowSize` and `autoColumnSize` to prevent row and column misalignment.';
/**
 * Default classname given to the wrapper container.
 */

var DEFAULT_CLASSNAME = 'hot-wrapper-editor-container';
/**
 * Logs warn to the console if the `console` object is exposed.
 *
 * @param {...*} args Values which will be logged.
 */

function warn$2() {
  if (typeof console !== 'undefined') {
    var _console;

    (_console = console).warn.apply(_console, arguments);
  }
}
/**
 * Filter out and return elements of the provided `type` from the `HotColumn` component's children.
 *
 * @param {React.ReactNode} children HotTable children array.
 * @param {String} type Either `'hot-renderer'` or `'hot-editor'`.
 * @returns {Object|null} A child (React node) or `null`, if no child of that type was found.
 */

function getChildElementByType(children, type) {
  var childrenArray = react.Children.toArray(children);
  var childrenCount = react.Children.count(children);
  var wantedChild = null;

  if (childrenCount !== 0) {
    if (childrenCount === 1 && childrenArray[0].props[type]) {
      wantedChild = childrenArray[0];
    } else {
      wantedChild = childrenArray.find(function (child) {
        return child.props[type] !== void 0;
      });
    }
  }

  return wantedChild || null;
}
/**
 * Get the reference to the original editor class.
 *
 * @param {React.ReactElement} editorElement React element of the editor class.
 * @returns {Function} Original class of the editor component.
 */

function getOriginalEditorClass(editorElement) {
  if (!editorElement) {
    return null;
  }

  return editorElement.type.WrappedComponent ? editorElement.type.WrappedComponent : editorElement.type;
}
/**
 * Remove editor containers from DOM.
 *
 * @param {Document} [doc] Document to be used.
 * @param {Map} editorCache The editor cache reference.
 */

function removeEditorContainers() {
  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  doc.querySelectorAll("[class^=\"".concat(DEFAULT_CLASSNAME, "\"]")).forEach(function (domNode) {
    if (domNode.parentNode) {
      domNode.parentNode.removeChild(domNode);
    }
  });
}
/**
 * Create an editor portal.
 *
 * @param {Document} [doc] Document to be used.
 * @param {React.ReactElement} editorElement Editor's element.
 * @param {Map} editorCache The editor cache reference.
 * @returns {React.ReactPortal} The portal for the editor.
 */

function createEditorPortal() {
  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  var editorElement = arguments.length > 1 ? arguments[1] : undefined;

  if (editorElement === null) {
    return;
  }

  var editorContainer = doc.createElement('DIV');

  var _getContainerAttribut = getContainerAttributesProps(editorElement.props, false),
      id = _getContainerAttribut.id,
      className = _getContainerAttribut.className,
      style = _getContainerAttribut.style;

  if (id) {
    editorContainer.id = id;
  }

  editorContainer.className = [DEFAULT_CLASSNAME, className].join(' ');

  if (style) {
    Object.assign(editorContainer.style, style);
  }

  doc.body.appendChild(editorContainer);
  return reactDom.createPortal(editorElement, editorContainer);
}
/**
 * Get an editor element extended with a instance-emitting method.
 *
 * @param {React.ReactNode} children Component children.
 * @param {Map} editorCache Component's editor cache.
 * @returns {React.ReactElement} An editor element containing the additional methods.
 */

function getExtendedEditorElement(children, editorCache) {
  var editorElement = getChildElementByType(children, 'hot-editor');
  var editorClass = getOriginalEditorClass(editorElement);

  if (!editorElement) {
    return null;
  }

  return react.cloneElement(editorElement, {
    emitEditorInstance: function emitEditorInstance(editorInstance) {
      editorCache.set(editorClass, editorInstance);
    },
    isEditor: true
  });
}
/**
 * Create a react component and render it to an external DOM done.
 *
 * @param {React.ReactElement} rElement React element to be used as a base for the component.
 * @param {Object} props Props to be passed to the cloned element.
 * @param {Function} callback Callback to be called after the component has been mounted.
 * @param {Document} [ownerDocument] The owner document to set the portal up into.
 * @returns {{portal: React.ReactPortal, portalContainer: HTMLElement}} An object containing the portal and its container.
 */

function createPortal(rElement, props, callback) {
  var ownerDocument = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : document;

  if (!ownerDocument) {
    ownerDocument = document;
  }

  if (!bulkComponentContainer) {
    bulkComponentContainer = ownerDocument.createDocumentFragment();
  }

  var portalContainer = ownerDocument.createElement('DIV');
  bulkComponentContainer.appendChild(portalContainer);
  var extendedRendererElement = react.cloneElement(rElement, _objectSpread2({
    key: "".concat(props.row, "-").concat(props.col)
  }, props));
  return {
    portal: reactDom.createPortal(extendedRendererElement, portalContainer, "".concat(props.row, "-").concat(props.col, "-").concat(Math.random())),
    portalContainer: portalContainer
  };
}
/**
 * Get an object containing the `id`, `className` and `style` keys, representing the corresponding props passed to the
 * component.
 *
 * @param {Object} props Object containing the react element props.
 * @param {Boolean} randomizeId If set to `true`, the function will randomize the `id` property when no `id` was present in the `prop` object.
 * @returns An object containing the `id`, `className` and `style` keys, representing the corresponding props passed to the
 * component.
 */

function getContainerAttributesProps(props) {
  var randomizeId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return {
    id: props.id || (randomizeId ? 'hot-' + Math.random().toString(36).substring(5) : void 0),
    className: props.className || '',
    style: props.style || {}
  };
}
/**
 * Add the `UNSAFE_` prefixes to the deprecated lifecycle methods for React >= 16.3.
 *
 * @param {Object} instance Instance to have the methods renamed.
 */

function addUnsafePrefixes(instance) {
  var reactSemverArray = react.version.split('.').map(function (v) {
    return parseInt(v);
  });
  var shouldPrefix = reactSemverArray[0] >= 16 && reactSemverArray[1] >= 3;

  if (shouldPrefix) {
    instance.UNSAFE_componentWillUpdate = instance.componentWillUpdate;
    instance.componentWillUpdate = void 0;
    instance.UNSAFE_componentWillMount = instance.componentWillMount;
    instance.componentWillMount = void 0;
  }
}

var SettingsMapper = /*#__PURE__*/function () {
  function SettingsMapper() {
    _classCallCheck$2F(this, SettingsMapper);
  }

  _createClass$2y(SettingsMapper, null, [{
    key: "getSettings",
    value:
    /**
     * Parse component settings into Handosntable-compatible settings.
     *
     * @param {Object} properties Object containing properties from the HotTable object.
     * @returns {Object} Handsontable-compatible settings object.
     */
    function getSettings(properties) {
      var newSettings = {};

      if (properties.settings) {
        var settings = properties.settings;

        for (var key in settings) {
          if (settings.hasOwnProperty(key)) {
            newSettings[key] = settings[key];
          }
        }
      }

      for (var _key in properties) {
        if (_key !== 'settings' && _key !== 'children' && properties.hasOwnProperty(_key)) {
          newSettings[_key] = properties[_key];
        }
      }

      return newSettings;
    }
  }]);

  return SettingsMapper;
}();

var HotColumn = /*#__PURE__*/function (_React$Component) {
  _inherits$1m(HotColumn, _React$Component);

  var _super = _createSuper$1m(HotColumn);

  /**
   * HotColumn class constructor.
   *
   * @param {HotColumnProps} props Component props.
   * @param {*} [context] Component context.
   */
  function HotColumn(props, context) {
    var _this;

    _classCallCheck$2F(this, HotColumn);

    _this = _super.call(this, props, context);
    /**
     * Local editor portal cache.
     *
     * @private
     * @type {ReactPortal}
     */

    _this.localEditorPortal = null;
    addUnsafePrefixes(_assertThisInitialized$1m(_this));
    return _this;
  }
  /**
   * Get the local editor portal cache property.
   *
   * @return {ReactPortal} Local editor portal.
   */


  _createClass$2y(HotColumn, [{
    key: "getLocalEditorPortal",
    value: function getLocalEditorPortal() {
      return this.localEditorPortal;
    }
    /**
     * Set the local editor portal cache property.
     *
     * @param {ReactPortal} portal Local editor portal.
     */

  }, {
    key: "setLocalEditorPortal",
    value: function setLocalEditorPortal(portal) {
      this.localEditorPortal = portal;
    }
    /**
     * Filter out all the internal properties and return an object with just the Handsontable-related props.
     *
     * @returns {Object}
     */

  }, {
    key: "getSettingsProps",
    value: function getSettingsProps() {
      var _this2 = this;

      this.internalProps = ['__componentRendererColumns', '_emitColumnSettings', '_columnIndex', '_getChildElementByType', '_getRendererWrapper', '_getEditorClass', '_getEditorCache', '_getOwnerDocument', 'hot-renderer', 'hot-editor', 'children'];
      return Object.keys(this.props).filter(function (key) {
        return !_this2.internalProps.includes(key);
      }).reduce(function (obj, key) {
        obj[key] = _this2.props[key];
        return obj;
      }, {});
    }
    /**
     * Check whether the HotColumn component contains a provided prop.
     *
     * @param {String} propName Property name.
     * @returns {Boolean}
     */

  }, {
    key: "hasProp",
    value: function hasProp(propName) {
      return !!this.props[propName];
    }
    /**
     * Get the editor element for the current column.
     *
     * @returns {React.ReactElement} React editor component element.
     */

  }, {
    key: "getLocalEditorElement",
    value: function getLocalEditorElement() {
      return getExtendedEditorElement(this.props.children, this.props._getEditorCache());
    }
    /**
     * Create the column settings based on the data provided to the `HotColumn` component and it's child components.
     */

  }, {
    key: "createColumnSettings",
    value: function createColumnSettings() {
      var rendererElement = this.props._getChildElementByType(this.props.children, 'hot-renderer');

      var editorElement = this.getLocalEditorElement();
      this.columnSettings = SettingsMapper.getSettings(this.getSettingsProps());

      if (rendererElement !== null) {
        this.columnSettings.renderer = this.props._getRendererWrapper(rendererElement);

        this.props._componentRendererColumns.set(this.props._columnIndex, true);
      } else if (this.hasProp('renderer')) {
        this.columnSettings.renderer = this.props.renderer;
      } else {
        this.columnSettings.renderer = void 0;
      }

      if (editorElement !== null) {
        this.columnSettings.editor = this.props._getEditorClass(editorElement);
      } else if (this.hasProp('editor')) {
        this.columnSettings.editor = this.props.editor;
      } else {
        this.columnSettings.editor = void 0;
      }
    }
    /**
     * Create the local editor portal and its destination HTML element if needed.
     *
     * @param {React.ReactNode} [children] Children of the HotTable instance. Defaults to `this.props.children`.
     */

  }, {
    key: "createLocalEditorPortal",
    value: function createLocalEditorPortal() {
      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.children;

      var editorCache = this.props._getEditorCache();

      var localEditorElement = getExtendedEditorElement(children, editorCache);

      if (localEditorElement) {
        this.setLocalEditorPortal(createEditorPortal(this.props._getOwnerDocument(), localEditorElement, editorCache));
      }
    }
    /**
     * Emit the column settings to the parent using a prop passed from the parent.
     */

  }, {
    key: "emitColumnSettings",
    value: function emitColumnSettings() {
      this.props._emitColumnSettings(this.columnSettings, this.props._columnIndex);
    }
    /*
    ---------------------------------------
    ------- React lifecycle methods -------
    ---------------------------------------
    */

    /**
     * Logic performed before the mounting of the HotColumn component.
     */

  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      this.createLocalEditorPortal();
    }
    /**
     * Logic performed after the mounting of the HotColumn component.
     */

  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.createColumnSettings();
      this.emitColumnSettings();
    }
    /**
     * Logic performed before the updating of the HotColumn component.
     */

  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps, nextState, nextContext) {
      this.createLocalEditorPortal(nextProps.children);
    }
    /**
     * Logic performed after the updating of the HotColumn component.
     */

  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.createColumnSettings();
      this.emitColumnSettings();
    }
    /**
     * Render the portals of the editors, if there are any.
     *
     * @returns {React.ReactElement}
     */

  }, {
    key: "render",
    value: function render() {
      return react.createElement(react.Fragment, null, this.getLocalEditorPortal());
    }
  }]);

  return HotColumn;
}(react.Component);

/**
 * Component class used to manage the renderer component portals.
 */

var PortalManager = /*#__PURE__*/function (_React$Component) {
  _inherits$1m(PortalManager, _React$Component);

  var _super = _createSuper$1m(PortalManager);

  function PortalManager(props) {
    var _this;

    _classCallCheck$2F(this, PortalManager);

    _this = _super.call(this, props);
    _this.state = {
      portals: []
    };
    return _this;
  }

  _createClass$2y(PortalManager, [{
    key: "render",
    value: function render() {
      return react.createElement(react.Fragment, null, this.state.portals);
    }
  }]);

  return PortalManager;
}(react.Component);

var version="9.0.1";

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol["for"],
    c = b ? Symbol["for"]("react.element") : 60103,
    d = b ? Symbol["for"]("react.portal") : 60106,
    e = b ? Symbol["for"]("react.fragment") : 60107,
    f = b ? Symbol["for"]("react.strict_mode") : 60108,
    g = b ? Symbol["for"]("react.profiler") : 60114,
    h = b ? Symbol["for"]("react.provider") : 60109,
    k = b ? Symbol["for"]("react.context") : 60110,
    l = b ? Symbol["for"]("react.async_mode") : 60111,
    m = b ? Symbol["for"]("react.concurrent_mode") : 60111,
    n = b ? Symbol["for"]("react.forward_ref") : 60112,
    p = b ? Symbol["for"]("react.suspense") : 60113,
    q = b ? Symbol["for"]("react.suspense_list") : 60120,
    r = b ? Symbol["for"]("react.memo") : 60115,
    t = b ? Symbol["for"]("react.lazy") : 60116,
    v = b ? Symbol["for"]("react.block") : 60121,
    w = b ? Symbol["for"]("react.fundamental") : 60117,
    x$1 = b ? Symbol["for"]("react.responder") : 60118,
    y = b ? Symbol["for"]("react.scope") : 60119;

function z(a) {
  if ("object" === _typeof$1A(a) && null !== a) {
    var u = a.$$typeof;

    switch (u) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;

              default:
                return u;
            }

        }

      case d:
        return u;
    }
  }
}

function A(a) {
  return z(a) === m;
}

var AsyncMode = l;
var ConcurrentMode = m;
var ContextConsumer = k;
var ContextProvider = h;
var Element = c;
var ForwardRef = n;
var Fragment = e;
var Lazy = t;
var Memo = r;
var Portal = d;
var Profiler = g;
var StrictMode = f;
var Suspense = p;

var isAsyncMode = function isAsyncMode(a) {
  return A(a) || z(a) === l;
};

var isConcurrentMode = A;

var isContextConsumer = function isContextConsumer(a) {
  return z(a) === k;
};

var isContextProvider = function isContextProvider(a) {
  return z(a) === h;
};

var isElement = function isElement(a) {
  return "object" === _typeof$1A(a) && null !== a && a.$$typeof === c;
};

var isForwardRef = function isForwardRef(a) {
  return z(a) === n;
};

var isFragment = function isFragment(a) {
  return z(a) === e;
};

var isLazy = function isLazy(a) {
  return z(a) === t;
};

var isMemo = function isMemo(a) {
  return z(a) === r;
};

var isPortal = function isPortal(a) {
  return z(a) === d;
};

var isProfiler = function isProfiler(a) {
  return z(a) === g;
};

var isStrictMode = function isStrictMode(a) {
  return z(a) === f;
};

var isSuspense = function isSuspense(a) {
  return z(a) === p;
};

var isValidElementType = function isValidElementType(a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === _typeof$1A(a) && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x$1 || a.$$typeof === y || a.$$typeof === v);
};

var typeOf = z;
var reactIs_production_min = {
  AsyncMode: AsyncMode,
  ConcurrentMode: ConcurrentMode,
  ContextConsumer: ContextConsumer,
  ContextProvider: ContextProvider,
  Element: Element,
  ForwardRef: ForwardRef,
  Fragment: Fragment,
  Lazy: Lazy,
  Memo: Memo,
  Portal: Portal,
  Profiler: Profiler,
  StrictMode: StrictMode,
  Suspense: Suspense,
  isAsyncMode: isAsyncMode,
  isConcurrentMode: isConcurrentMode,
  isContextConsumer: isContextConsumer,
  isContextProvider: isContextProvider,
  isElement: isElement,
  isForwardRef: isForwardRef,
  isFragment: isFragment,
  isLazy: isLazy,
  isMemo: isMemo,
  isPortal: isPortal,
  isProfiler: isProfiler,
  isStrictMode: isStrictMode,
  isSuspense: isSuspense,
  isValidElementType: isValidElementType,
  typeOf: typeOf
};

var reactIs_development = createCommonjsModule(function (module, exports) {
});
reactIs_development.AsyncMode;
reactIs_development.ConcurrentMode;
reactIs_development.ContextConsumer;
reactIs_development.ContextProvider;
reactIs_development.Element;
reactIs_development.ForwardRef;
reactIs_development.Fragment;
reactIs_development.Lazy;
reactIs_development.Memo;
reactIs_development.Portal;
reactIs_development.Profiler;
reactIs_development.StrictMode;
reactIs_development.Suspense;
reactIs_development.isAsyncMode;
reactIs_development.isConcurrentMode;
reactIs_development.isContextConsumer;
reactIs_development.isContextProvider;
reactIs_development.isElement;
reactIs_development.isForwardRef;
reactIs_development.isFragment;
reactIs_development.isLazy;
reactIs_development.isMemo;
reactIs_development.isPortal;
reactIs_development.isProfiler;
reactIs_development.isStrictMode;
reactIs_development.isSuspense;
reactIs_development.isValidElementType;
reactIs_development.typeOf;

var reactIs = createCommonjsModule(function (module) {

  {
    module.exports = reactIs_production_min;
  }
});

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject$1(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject$1(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty$2.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

var has = Function.call.bind(Object.prototype.hasOwnProperty);

function emptyFunction() {}

function emptyFunctionWithReset() {}

emptyFunctionWithReset.resetWarningCache = emptyFunction;

var factoryWithThrowingShims = function factoryWithThrowingShims() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      // It is still safe when called from React.
      return;
    }

    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  }
  shim.isRequired = shim;

  function getShim() {
    return shim;
  }
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

var propTypes = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    // By explicitly using `prop-types` you are opting into new production behavior.
    // http://fb.me/prop-types-in-prod
    module.exports = factoryWithThrowingShims();
  }
});

/**
 * A Handsontable-ReactJS wrapper.
 *
 * To implement, use the `HotTable` tag with properties corresponding to Handsontable options.
 * For example:
 *
 * ```js
 * <HotTable id="hot" data={dataObject} contextMenu={true} colHeaders={true} width={600} height={300} stretchH="all" />
 *
 * // is analogous to
 * let hot = new Handsontable(document.getElementById('hot'), {
 *    data: dataObject,
 *    contextMenu: true,
 *    colHeaders: true,
 *    width: 600
 *    height: 300
 * });
 *
 * ```
 *
 * @class HotTable
 */

var HotTable = /*#__PURE__*/function (_React$Component) {
  _inherits$1m(HotTable, _React$Component);

  var _super = _createSuper$1m(HotTable);

  /**
   * HotTable class constructor.
   *
   * @param {HotTableProps} props Component props.
   * @param {*} [context] Component context.
   */
  function HotTable(props, context) {
    var _this;

    _classCallCheck$2F(this, HotTable);

    _this = _super.call(this, props, context);
    /**
     * The `id` of the main Handsontable DOM element.
     *
     * @type {String}
     */

    _this.id = null;
    /**
     * Reference to the Handsontable instance.
     *
     * @type {Object}
     */

    _this.hotInstance = null;
    /**
     * Reference to the main Handsontable DOM element.
     *
     * @type {HTMLElement}
     */

    _this.hotElementRef = null;
    /**
     * Array of object containing the column settings.
     *
     * @type {Array}
     */

    _this.columnSettings = [];
    /**
     * Component used to manage the renderer portals.
     *
     * @type {React.Component}
     */

    _this.portalManager = null;
    /**
     * Array containing the portals cashed to be rendered in bulk after Handsontable's render cycle.
     */

    _this.portalCacheArray = [];
    /**
     * Global editor portal cache.
     *
     * @private
     * @type {React.ReactPortal}
     */

    _this.globalEditorPortal = null;
    /**
     * The rendered cells cache.
     *
     * @private
     * @type {Map}
     */

    _this.renderedCellCache = new Map();
    /**
     * Editor cache.
     *
     * @private
     * @type {Map}
     */

    _this.editorCache = new Map();
    /**
     * Map with column indexes (or a string = 'global') as keys, and booleans as values. Each key represents a component-based editor
     * declared for the used column index, or a global one, if the key is the `global` string.
     *
     * @private
     * @type {Map}
     */

    _this.componentRendererColumns = new Map();
    addUnsafePrefixes(_assertThisInitialized$1m(_this));
    return _this;
  }
  /**
   * Package version getter.
   *
   * @returns The version number of the package.
   */


  _createClass$2y(HotTable, [{
    key: "getRenderedCellCache",
    value:
    /**
     * Get the rendered table cell cache.
     *
     * @returns {Map}
     */
    function getRenderedCellCache() {
      return this.renderedCellCache;
    }
    /**
     * Get the editor cache and return it.
     *
     * @returns {Map}
     */

  }, {
    key: "getEditorCache",
    value: function getEditorCache() {
      return this.editorCache;
    }
    /**
     * Get the global editor portal property.
     *
     * @return {React.ReactPortal} The global editor portal.
     */

  }, {
    key: "getGlobalEditorPortal",
    value: function getGlobalEditorPortal() {
      return this.globalEditorPortal;
    }
    /**
     * Set the private editor portal cache property.
     *
     * @param {React.ReactPortal} portal Global editor portal.
     */

  }, {
    key: "setGlobalEditorPortal",
    value: function setGlobalEditorPortal(portal) {
      this.globalEditorPortal = portal;
    }
    /**
     * Clear both the editor and the renderer cache.
     */

  }, {
    key: "clearCache",
    value: function clearCache() {
      var renderedCellCache = this.getRenderedCellCache();
      this.setGlobalEditorPortal(null);
      removeEditorContainers(this.getOwnerDocument());
      this.getEditorCache().clear();
      renderedCellCache.clear();
      this.componentRendererColumns.clear();
    }
    /**
     * Get the `Document` object corresponding to the main component element.
     *
     * @returns The `Document` object used by the component.
     */

  }, {
    key: "getOwnerDocument",
    value: function getOwnerDocument() {
      return this.hotElementRef ? this.hotElementRef.ownerDocument : document;
    }
    /**
     * Set the reference to the main Handsontable DOM element.
     *
     * @param {HTMLElement} element The main Handsontable DOM element.
     */

  }, {
    key: "setHotElementRef",
    value: function setHotElementRef(element) {
      this.hotElementRef = element;
    }
    /**
     * Return a renderer wrapper function for the provided renderer component.
     *
     * @param {React.ReactElement} rendererElement React renderer component.
     * @returns {Handsontable.renderers.Base} The Handsontable rendering function.
     */

  }, {
    key: "getRendererWrapper",
    value: function getRendererWrapper(rendererElement) {
      var hotTableComponent = this;
      return function (instance, TD, row, col, prop, value, cellProperties) {
        var renderedCellCache = hotTableComponent.getRenderedCellCache();

        if (renderedCellCache.has("".concat(row, "-").concat(col))) {
          TD.innerHTML = renderedCellCache.get("".concat(row, "-").concat(col)).innerHTML;
        }

        if (TD && !TD.getAttribute('ghost-table')) {
          var _createPortal = createPortal(rendererElement, {
            TD: TD,
            row: row,
            col: col,
            prop: prop,
            value: value,
            cellProperties: cellProperties,
            isRenderer: true
          }, function () {}, TD.ownerDocument),
              portal = _createPortal.portal,
              portalContainer = _createPortal.portalContainer;

          while (TD.firstChild) {
            TD.removeChild(TD.firstChild);
          }

          TD.appendChild(portalContainer);
          hotTableComponent.portalCacheArray.push(portal);
        }

        renderedCellCache.set("".concat(row, "-").concat(col), TD);
        return TD;
      };
    }
    /**
     * Create a fresh class to be used as an editor, based on the provided editor React element.
     *
     * @param {React.ReactElement} editorElement React editor component.
     * @returns {Function} A class to be passed to the Handsontable editor settings.
     */

  }, {
    key: "getEditorClass",
    value: function getEditorClass(editorElement) {
      var editorClass = getOriginalEditorClass(editorElement);
      var editorCache = this.getEditorCache();
      var cachedComponent = editorCache.get(editorClass);
      return this.makeEditorClass(cachedComponent);
    }
    /**
     * Create a class to be passed to the Handsontable's settings.
     *
     * @param {React.ReactElement} editorComponent React editor component.
     * @returns {Function} A class to be passed to the Handsontable editor settings.
     */

  }, {
    key: "makeEditorClass",
    value: function makeEditorClass(editorComponent) {
      var customEditorClass = /*#__PURE__*/function (_Handsontable$editors) {
        _inherits$1m(CustomEditor, _Handsontable$editors);

        var _super2 = _createSuper$1m(CustomEditor);

        function CustomEditor(hotInstance, row, col, prop, TD, cellProperties) {
          var _this2;

          _classCallCheck$2F(this, CustomEditor);

          _this2 = _super2.call(this, hotInstance, row, col, prop, TD, cellProperties);
          editorComponent.hotCustomEditorInstance = _assertThisInitialized$1m(_this2);
          _this2.editorComponent = editorComponent;
          return _this2;
        }

        _createClass$2y(CustomEditor, [{
          key: "focus",
          value: function focus() {}
        }, {
          key: "getValue",
          value: function getValue() {}
        }, {
          key: "setValue",
          value: function setValue() {}
        }, {
          key: "open",
          value: function open() {}
        }, {
          key: "close",
          value: function close() {}
        }]);

        return CustomEditor;
      }(Handsontable.editors.BaseEditor); // Fill with the rest of the BaseEditor methods


      Object.getOwnPropertyNames(Handsontable.editors.BaseEditor.prototype).forEach(function (propName) {
        if (propName === 'constructor') {
          return;
        }

        customEditorClass.prototype[propName] = function () {
          var _editorComponent$prop;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return (_editorComponent$prop = editorComponent[propName]).call.apply(_editorComponent$prop, [editorComponent].concat(args));
        };
      });
      return customEditorClass;
    }
    /**
     * Get the renderer element for the entire HotTable instance.
     *
     * @returns {React.ReactElement} React renderer component element.
     */

  }, {
    key: "getGlobalRendererElement",
    value: function getGlobalRendererElement() {
      var hotTableSlots = this.props.children;
      return getChildElementByType(hotTableSlots, 'hot-renderer');
    }
    /**
     * Get the editor element for the entire HotTable instance.
     *
     * @param {React.ReactNode} [children] Children of the HotTable instance. Defaults to `this.props.children`.
     * @returns {React.ReactElement} React editor component element.
     */

  }, {
    key: "getGlobalEditorElement",
    value: function getGlobalEditorElement() {
      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.children;
      return getExtendedEditorElement(children, this.getEditorCache());
    }
    /**
     * Create the global editor portal and its destination HTML element if needed.
     *
     * @param {React.ReactNode} [children] Children of the HotTable instance. Defaults to `this.props.children`.
     */

  }, {
    key: "createGlobalEditorPortal",
    value: function createGlobalEditorPortal() {
      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.children;
      var globalEditorElement = this.getGlobalEditorElement(children);

      if (globalEditorElement) {
        this.setGlobalEditorPortal(createEditorPortal(this.getOwnerDocument(), globalEditorElement, this.getEditorCache()));
      }
    }
    /**
     * Create a new settings object containing the column settings and global editors and renderers.
     *
     * @returns {Handsontable.GridSettings} New global set of settings for Handsontable.
     */

  }, {
    key: "createNewGlobalSettings",
    value: function createNewGlobalSettings() {
      var newSettings = SettingsMapper.getSettings(this.props);
      var globalRendererNode = this.getGlobalRendererElement();
      var globalEditorNode = this.getGlobalEditorElement();
      newSettings.columns = this.columnSettings.length ? this.columnSettings : newSettings.columns;

      if (globalEditorNode) {
        newSettings.editor = this.getEditorClass(globalEditorNode);
      } else {
        newSettings.editor = this.props.editor || (this.props.settings ? this.props.settings.editor : void 0);
      }

      if (globalRendererNode) {
        newSettings.renderer = this.getRendererWrapper(globalRendererNode);
        this.componentRendererColumns.set('global', true);
      } else {
        newSettings.renderer = this.props.renderer || (this.props.settings ? this.props.settings.renderer : void 0);
      }

      return newSettings;
    }
    /**
     * Detect if `autoRowSize` or `autoColumnSize` is defined, and if so, throw an incompatibility warning.
     *
     * @param {Handsontable.GridSettings} newGlobalSettings New global settings passed as Handsontable config.
     */

  }, {
    key: "displayAutoSizeWarning",
    value: function displayAutoSizeWarning(newGlobalSettings) {
      if (this.hotInstance.getPlugin('autoRowSize').enabled || this.hotInstance.getPlugin('autoColumnSize').enabled) {
        if (this.componentRendererColumns.size > 0) {
          warn$2(AUTOSIZE_WARNING);
        }
      }
    }
    /**
     * Sets the column settings based on information received from HotColumn.
     *
     * @param {HotTableProps} columnSettings Column settings object.
     * @param {Number} columnIndex Column index.
     */

  }, {
    key: "setHotColumnSettings",
    value: function setHotColumnSettings(columnSettings, columnIndex) {
      this.columnSettings[columnIndex] = columnSettings;
    }
    /**
     * Handsontable's `beforeRender` hook callback.
     */

  }, {
    key: "handsontableBeforeRender",
    value: function handsontableBeforeRender() {
      this.getRenderedCellCache().clear();
    }
    /**
     * Handsontable's `afterRender` hook callback.
     */

  }, {
    key: "handsontableAfterRender",
    value: function handsontableAfterRender() {
      var _this3 = this;

      this.portalManager.setState(function () {
        return Object.assign({}, {
          portals: _this3.portalCacheArray
        });
      }, function () {
        _this3.portalCacheArray.length = 0;
      });
    }
    /**
     * Call the `updateSettings` method for the Handsontable instance.
     *
     * @param {Object} newSettings The settings object.
     */

  }, {
    key: "updateHot",
    value: function updateHot(newSettings) {
      this.hotInstance.updateSettings(newSettings, false);
    }
    /**
     * Set the portal manager ref.
     *
     * @param {React.ReactComponent} pmComponent The PortalManager component.
     */

  }, {
    key: "setPortalManagerRef",
    value: function setPortalManagerRef(pmComponent) {
      this.portalManager = pmComponent;
    }
    /*
    ---------------------------------------
    ------- React lifecycle methods -------
    ---------------------------------------
    */

    /**
     * Logic performed before the mounting of the component.
     */

  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      this.clearCache();
      this.createGlobalEditorPortal();
    }
    /**
     * Initialize Handsontable after the component has mounted.
     */

  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var hotTableComponent = this;
      var newGlobalSettings = this.createNewGlobalSettings();
      this.hotInstance = new Handsontable.Core(this.hotElementRef, newGlobalSettings);
      this.hotInstance.addHook('beforeRender', function (isForced) {
        hotTableComponent.handsontableBeforeRender();
      });
      this.hotInstance.addHook('afterRender', function () {
        hotTableComponent.handsontableAfterRender();
      }); // `init` missing in Handsontable's type definitions.

      this.hotInstance.init();
      this.displayAutoSizeWarning(newGlobalSettings);
    }
    /**
     * Logic performed before the component update.
     */

  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps, nextState, nextContext) {
      this.clearCache();
      removeEditorContainers(this.getOwnerDocument());
      this.createGlobalEditorPortal(nextProps.children);
    }
    /**
     * Logic performed after the component update.
     */

  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var newGlobalSettings = this.createNewGlobalSettings();
      this.updateHot(newGlobalSettings);
      this.displayAutoSizeWarning(newGlobalSettings);
    }
    /**
     * Destroy the Handsontable instance when the parent component unmounts.
     */

  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.hotInstance.destroy();
      removeEditorContainers(this.getOwnerDocument());
    }
    /**
     * Render the component.
     */

  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _getContainerAttribut = getContainerAttributesProps(this.props),
          id = _getContainerAttribut.id,
          className = _getContainerAttribut.className,
          style = _getContainerAttribut.style;

      var isHotColumn = function isHotColumn(childNode) {
        return childNode.type === HotColumn;
      };

      var children = react.Children.toArray(this.props.children); // filter out anything that's not a HotColumn

      children = children.filter(function (childNode) {
        return isHotColumn(childNode);
      }); // clone the HotColumn nodes and extend them with the callbacks

      var childClones = children.map(function (childNode, columnIndex) {
        return react.cloneElement(childNode, {
          _componentRendererColumns: _this4.componentRendererColumns,
          _emitColumnSettings: _this4.setHotColumnSettings.bind(_this4),
          _columnIndex: columnIndex,
          _getChildElementByType: getChildElementByType.bind(_this4),
          _getRendererWrapper: _this4.getRendererWrapper.bind(_this4),
          _getEditorClass: _this4.getEditorClass.bind(_this4),
          _getOwnerDocument: _this4.getOwnerDocument.bind(_this4),
          _getEditorCache: _this4.getEditorCache.bind(_this4),
          children: childNode.props.children
        });
      }); // add the global editor to the list of children

      childClones.push(this.getGlobalEditorPortal());
      return react.createElement(react.Fragment, null, react.createElement("div", {
        ref: this.setHotElementRef.bind(this),
        id: id,
        className: className,
        style: style
      }, childClones), react.createElement(PortalManager, {
        ref: this.setPortalManagerRef.bind(this)
      }));
    }
  }], [{
    key: "version",
    get: function get() {
      return version;
    }
  }]);

  return HotTable;
}(react.Component);
/**
 * Prop types to be checked at runtime.
 */


HotTable.propTypes = {
  style: propTypes.object,
  id: propTypes.string,
  className: propTypes.string
};

var BaseEditorComponent = /*#__PURE__*/function (_React$Component) {
  _inherits$1m(BaseEditorComponent, _React$Component);

  var _super = _createSuper$1m(BaseEditorComponent);

  function BaseEditorComponent(props) {
    var _this;

    _classCallCheck$2F(this, BaseEditorComponent);

    _this = _super.call(this, props);
    _this.name = 'BaseEditorComponent';
    _this.instance = null;
    _this.row = null;
    _this.col = null;
    _this.prop = null;
    _this.TD = null;
    _this.originalValue = null;
    _this.cellProperties = null;
    _this.state = null;
    _this.hotInstance = null;
    _this.hotCustomEditorInstance = null;
    _this.hot = null;

    if (props.emitEditorInstance) {
      props.emitEditorInstance(_assertThisInitialized$1m(_this));
    }

    return _this;
  } // BaseEditor methods:


  _createClass$2y(BaseEditorComponent, [{
    key: "_fireCallbacks",
    value: function _fireCallbacks() {
      var _Handsontable$editors;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_Handsontable$editors = Handsontable.editors.BaseEditor.prototype._fireCallbacks).call.apply(_Handsontable$editors, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "beginEditing",
    value: function beginEditing() {
      var _Handsontable$editors2;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return (_Handsontable$editors2 = Handsontable.editors.BaseEditor.prototype.beginEditing).call.apply(_Handsontable$editors2, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "cancelChanges",
    value: function cancelChanges() {
      var _Handsontable$editors3;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return (_Handsontable$editors3 = Handsontable.editors.BaseEditor.prototype.cancelChanges).call.apply(_Handsontable$editors3, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "checkEditorSection",
    value: function checkEditorSection() {
      var _Handsontable$editors4;

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return (_Handsontable$editors4 = Handsontable.editors.BaseEditor.prototype.checkEditorSection).call.apply(_Handsontable$editors4, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "close",
    value: function close() {
      var _Handsontable$editors5;

      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return (_Handsontable$editors5 = Handsontable.editors.BaseEditor.prototype.close).call.apply(_Handsontable$editors5, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "discardEditor",
    value: function discardEditor() {
      var _Handsontable$editors6;

      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return (_Handsontable$editors6 = Handsontable.editors.BaseEditor.prototype.discardEditor).call.apply(_Handsontable$editors6, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "enableFullEditMode",
    value: function enableFullEditMode() {
      var _Handsontable$editors7;

      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return (_Handsontable$editors7 = Handsontable.editors.BaseEditor.prototype.enableFullEditMode).call.apply(_Handsontable$editors7, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "extend",
    value: function extend() {
      var _Handsontable$editors8;

      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      return (_Handsontable$editors8 = Handsontable.editors.BaseEditor.prototype.extend).call.apply(_Handsontable$editors8, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "finishEditing",
    value: function finishEditing() {
      var _Handsontable$editors9;

      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      return (_Handsontable$editors9 = Handsontable.editors.BaseEditor.prototype.finishEditing).call.apply(_Handsontable$editors9, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "focus",
    value: function focus() {
      var _Handsontable$editors10;

      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }

      return (_Handsontable$editors10 = Handsontable.editors.BaseEditor.prototype.focus).call.apply(_Handsontable$editors10, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "getValue",
    value: function getValue() {
      var _Handsontable$editors11;

      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }

      return (_Handsontable$editors11 = Handsontable.editors.BaseEditor.prototype.getValue).call.apply(_Handsontable$editors11, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "init",
    value: function init() {
      var _Handsontable$editors12;

      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }

      return (_Handsontable$editors12 = Handsontable.editors.BaseEditor.prototype.init).call.apply(_Handsontable$editors12, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "isInFullEditMode",
    value: function isInFullEditMode() {
      var _Handsontable$editors13;

      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }

      return (_Handsontable$editors13 = Handsontable.editors.BaseEditor.prototype.isInFullEditMode).call.apply(_Handsontable$editors13, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "isOpened",
    value: function isOpened() {
      var _Handsontable$editors14;

      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }

      return (_Handsontable$editors14 = Handsontable.editors.BaseEditor.prototype.isOpened).call.apply(_Handsontable$editors14, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "isWaiting",
    value: function isWaiting() {
      var _Handsontable$editors15;

      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }

      return (_Handsontable$editors15 = Handsontable.editors.BaseEditor.prototype.isWaiting).call.apply(_Handsontable$editors15, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "open",
    value: function open() {
      var _Handsontable$editors16;

      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }

      return (_Handsontable$editors16 = Handsontable.editors.BaseEditor.prototype.open).call.apply(_Handsontable$editors16, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, TD, originalValue, cellProperties) {
      this.hotInstance = cellProperties.instance;
      this.row = row;
      this.col = col;
      this.prop = prop;
      this.TD = TD;
      this.originalValue = originalValue;
      this.cellProperties = cellProperties;
      return Handsontable.editors.BaseEditor.prototype.prepare.call(this.hotCustomEditorInstance, row, col, prop, TD, originalValue, cellProperties);
    }
  }, {
    key: "saveValue",
    value: function saveValue() {
      var _Handsontable$editors17;

      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
        args[_key17] = arguments[_key17];
      }

      return (_Handsontable$editors17 = Handsontable.editors.BaseEditor.prototype.saveValue).call.apply(_Handsontable$editors17, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "setValue",
    value: function setValue() {
      var _Handsontable$editors18;

      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
        args[_key18] = arguments[_key18];
      }

      return (_Handsontable$editors18 = Handsontable.editors.BaseEditor.prototype.setValue).call.apply(_Handsontable$editors18, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "addHook",
    value: function addHook() {
      var _Handsontable$editors19;

      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
        args[_key19] = arguments[_key19];
      }

      return (_Handsontable$editors19 = Handsontable.editors.BaseEditor.prototype.addHook).call.apply(_Handsontable$editors19, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "removeHooksByKey",
    value: function removeHooksByKey() {
      var _Handsontable$editors20;

      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
        args[_key20] = arguments[_key20];
      }

      return (_Handsontable$editors20 = Handsontable.editors.BaseEditor.prototype.removeHooksByKey).call.apply(_Handsontable$editors20, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "clearHooks",
    value: function clearHooks() {
      var _Handsontable$editors21;

      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
        args[_key21] = arguments[_key21];
      }

      return (_Handsontable$editors21 = Handsontable.editors.BaseEditor.prototype.clearHooks).call.apply(_Handsontable$editors21, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "getEditedCell",
    value: function getEditedCell() {
      var _Handsontable$editors22;

      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }

      return (_Handsontable$editors22 = Handsontable.editors.BaseEditor.prototype.getEditedCell).call.apply(_Handsontable$editors22, [this.hotCustomEditorInstance].concat(args));
    }
  }, {
    key: "getEditedCellsZIndex",
    value: function getEditedCellsZIndex() {
      var _Handsontable$editors23;

      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
        args[_key23] = arguments[_key23];
      }

      return (_Handsontable$editors23 = Handsontable.editors.BaseEditor.prototype.getEditedCellsZIndex).call.apply(_Handsontable$editors23, [this.hotCustomEditorInstance].concat(args));
    }
  }]);

  return BaseEditorComponent;
}(react.Component);

export { HotTable };
