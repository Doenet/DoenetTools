<title>Macros</title>

<p>Macros are substitutions that take strings and turn them
into copies of components.  Macros begin with one or 
two dollar signs and followed by an identifier and 
optionally additional parameters.</p>

<p>Note: macros are based only on string matching and 
do not take into account the types of components
that are matched by the identifiers.</p>

<p>List of proposed macros in order of expected usage,
 most common first.</p>

<ol>
<li newNamespace><p><em>Value macro.</em>  &dollar;a becomes 
<c>&lt;copy tname="a" prop="value" /&gt;</c>.
  </p>
  
  <p>Comments:  The most common use case and 
  likely to show in mathematical calculations, 
  hence the shortest macro.  
  Copy the "value" prop so that it works with mathinputs 
  as well as maths.  
Also works with textinputs and texts.</p>

  <p>Example</p>

<p>Let <m>a=</m> <mathinput name="a" prefill="3" />, 
<m>b=</m> <mathinput name="b" prefill="4" />.  
Then <m>a + b = <math simplify>$a+$b</math></m>.
  </p>

  </li>

<li newNamespace><p><em>Function evaluation.</em>
 &dollar;&dollar;f(3) becomes 
  <c>&lt;evaluate&gt;&lt;copy tname="f"/&gt;&lt;input&gt;3&lt;/input&gt;&lt;/evaluate&gt;</c>.
  </p>

<p>Comments: function evaluation requires that 
the identifier is followed immediately by the argument
in parenthesis (not counting whitespace).  
We require the second dollar sign to invoke function 
evaluation so that one doesn't get unintended function
evaluations when using the value macro with multiplications
such as 
 &dollar;x(&dollar;y+&dollar;z).</p>

  <p>Numeric example </p>

<p>Let <m>f(x) = <function name="f">x^2</function></m>. 
If <m>a = </m> <mathinput name="a" prefill="-5" />, 
then <m>f(a) = f(<math simplify>$a</math>) = $$f($a)</m>.</p>

<p>$a</p>
<p><math simplify>$a</math></p>

  <p>Symbolic example</p>

<p>If <m>g(x) =</m> 
<mathinput name="gformula" prefill="sin(x)" /> 
and <m>b = </m><mathinput name="b" prefill="z^2" />,
 then <m>g(b) = g($b) = $$g($b)</m>.</p>

  <function hide name="g" symbolic><formula>$gformula</formula></function>

  </li>

<li newNamespace><p><em>Copying entire object.</em>  
&dollar;&dollar;h becomes <c>&lt;copy tname="h"/&gt;</c> 
as long as it is not immediately followed by 
an argument in parentheses (ignoring whitespace).</p>

  <p>Function graph example</p>

<p>The graph of <m>f(x) =</m> 
<mathinput name="fformula" prefill="1/x" /> 
is shown below.</p>

  <p hide><function name="f"><formula>$fformula</formula></function></p>

  <graph xlabel="x" ylabel="f">$$f</graph>

<p>We can repeat the entire graph with
 &dollar;&dollar;_graph1.</p>

  $$_graph1

  </li>

<li><p><em>Multiword identifiers.</em>  
Use optional parentheses to copy multiword identifiers. 
&dollar;(a+b) becomes
<c>&lt;copy tname="a+b" prop="value" /&gt;</c>; 
&dollar;&dollar;(a+b) becomes  <c>&lt;copy tname="a+b" /&gt;</c> 
(if not followed by argument in parentheses).
  </p>

<p>Note: without parentheses &dollar;a+b becomes 
 <c>&lt;copy tname="a" prop="value" /&gt;+b</c>.</p>

  </li>

<li newNamespace><p><em>Adding attributes.</em> 
When using the form with parenthesis, 
adding arguments inside curly braces {} 
immediately after the identifier adds those attributes
to the copy 
(and replaces the default prop="value" attribute 
for the single dollar sign verion.)
&dollar;(a{prop="x"}) becomes 
<c>&lt;copy tname="a" prop="x" /&gt;</c>; 
&dollar;&dollar;(a{prop="x"}) also becomes 
<c>&lt;copy tname="a" prop="x" /&gt;</c> 
(if not followed by argument in parentheses)</p>

<p>As this macro is based on strings,
the string inside the {} is copied verbatim into the copy
tag, and then the resulting string is reparsed as
DoenetML, i.e., &dollar;(a{foo bar}) becomes 
<c>&lt;copy tname="a" foo bar /&gt;</c>.
Macros do not verify proper syntax.</p>

<p>Note that the single and double dollar signs versions 
become identical when including attributes, 
except that the double dollar sign version 
will turn into an evaluate if followed 
by an argument in parentheses.</p>

  <p>Example</p>
  
  <graph>
    <point name="p" label="x=$(p{prop='x'})">(3,4)</point>
  </graph>

  </li>

</ol>

<subsection>
  <title>Question</title>

  <ol>

<li><p>&dollar;a includes more (i.e., implicit prop="value") 
than &dollar;&dollar;a, but the markup is smaller. 
 Is that OK?
  </p></li>

<li><p>&dollar;&dollar;a and &dollar;a 
have two differences 
(inclusion of prop="value" and function evaluation). 
It makes it strange to just get a regular
&lt;copy tname="a" /&gt;.  
Is it too convoluted?</p>
<p>The are two alternative ways to get &lt;copy tname="a" /&gt;.</p>
    <ol>
    <li>Use &dollar;&dollar;a, 
    and make sure that it isn't followed 
    by an argument in parentheses.
    </li>
    <li>Use &dollar;(a{}), 
    where the {} cancels the prop="value" 
    from the single dollar sign version. 
    In this case, one can follow it by parentheses.
      </li>
    </ol>
  </li>

<li><p>Adding the {} attributes to the macros make them 
ugly and hard to read.  
It also makes it seems like a programming language.  
The only reason we added that feature was to allow 
references to props other than "value" inside attributes 
(which are strings and cannot include XML tags.)  
Is the syntax too confusing?</p>

<p>In the following example, the macro inside the label attribute 
is the only way to copy the label from another point.  
The macro inside the x-coordinate is probably better written as
 an XML tag, as done for the y-coordinate.</p>


  <graph>
    <point name="p" label="A">(1,2)</point>
    <point name="q" label="$(p{prop='label'})'">
      <x>$(p{prop="x"})+1</x>
      <y><copy tname="p" prop="y"/> +2</y>
    </point>
    </graph>


  </li>
</ol>

</subsection>
